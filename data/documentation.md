# ERC-20 • Stylus by Example | Arbitrum Docs

## ERC-20

Any contract that follows the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20) is an ERC-20 token.

ERC-20 tokens provide functionalities to

*   transfer tokens
*   allow others to transfer tokens on behalf of the token holder

Here is the interface for ERC-20.

```rust
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount)
        external
        returns (bool);
}
```

Example implementation of an ERC-20 token contract written in Rust.

### src/erc20.rs[​](#srcerc20rs "Direct link to src/erc20.rs")

note

This code has yet to be audited. Please use at your own risk.

```rust
//! Implementation of the ERC-20 standard
//!
//! The eponymous [`Erc20`] type provides all the standard methods,
//! and is intended to be inherited by other contract types.
//!
//! You can configure the behavior of [`Erc20`] via the [`Erc20Params`] trait,
//! which allows specifying the name, symbol, and decimals of the token.
//!
//! Note that this code is unaudited and not fit for production use.

// Imported packages
use alloc::string::String;
use alloy_primitives::{Address, U256};
use alloy_sol_types::sol;
use core::marker::PhantomData;
use stylus_sdk::{
    evm,
    msg,
    prelude::*,
};

pub trait Erc20Params {
    /// Immutable token name
    const NAME: &'static str;

    /// Immutable token symbol
    const SYMBOL: &'static str;

    /// Immutable token decimals
    const DECIMALS: u8;
}

sol_storage! {
    /// Erc20 implements all ERC-20 methods.
    pub struct Erc20<T> {
        /// Maps users to balances
        mapping(address => uint256) balances;
        /// Maps users to a mapping of each spender's allowance
        mapping(address => mapping(address => uint256)) allowances;
        /// The total supply of the token
        uint256 total_supply;
        /// Used to allow [`Erc20Params`]
        PhantomData<T> phantom;
    }
}

// Declare events and Solidity error types
sol! {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    error InsufficientBalance(address from, uint256 have, uint256 want);
    error InsufficientAllowance(address owner, address spender, uint256 have, uint256 want);
}

/// Represents the ways methods may fail.
#[derive(SolidityError)]
pub enum Erc20Error {
    InsufficientBalance(InsufficientBalance),
    InsufficientAllowance(InsufficientAllowance),
}

// These methods aren't exposed to other contracts
// Methods marked as "pub" here are usable outside of the erc20 module (i.e. they're callable from lib.rs)
// Note: modifying storage will become much prettier soon
impl<T: Erc20Params> Erc20<T> {
    /// Movement of funds between 2 accounts
    /// (invoked by the external transfer() and transfer_from() functions )
    pub fn _transfer(
        &mut self,
        from: Address,
        to: Address,
        value: U256,
    ) -> Result<(), Erc20Error> {
        // Decreasing sender balance
        let mut sender_balance = self.balances.setter(from);
        let old_sender_balance = sender_balance.get();
        if old_sender_balance < value {
            return Err(Erc20Error::InsufficientBalance(InsufficientBalance {
                from,
                have: old_sender_balance,
                want: value,
            }));
        }
        sender_balance.set(old_sender_balance - value);

        // Increasing receiver balance
        let mut to_balance = self.balances.setter(to);
        let new_to_balance = to_balance.get() + value;
        to_balance.set(new_to_balance);

        // Emitting the transfer event
        evm::log(Transfer { from, to, value });
        Ok(())
    }

    /// Mints `value` tokens to `address`
    pub fn mint(&mut self, address: Address, value: U256) -> Result<(), Erc20Error> {
        // Increasing balance
        let mut balance = self.balances.setter(address);
        let new_balance = balance.get() + value;
        balance.set(new_balance);

        // Increasing total supply
        self.total_supply.set(self.total_supply.get() + value);

        // Emitting the transfer event
        evm::log(Transfer {
            from: Address::ZERO,
            to: address,
            value,
        });

        Ok(())
    }

    /// Burns `value` tokens from `address`
    pub fn burn(&mut self, address: Address, value: U256) -> Result<(), Erc20Error> {
        // Decreasing balance
        let mut balance = self.balances.setter(address);
        let old_balance = balance.get();
        if old_balance < value {
            return Err(Erc20Error::InsufficientBalance(InsufficientBalance {
                from: address,
                have: old_balance,
                want: value,
            }));
        }
        balance.set(old_balance - value);

        // Decreasing the total supply
        self.total_supply.set(self.total_supply.get() - value);

        // Emitting the transfer event
        evm::log(Transfer {
            from: address,
            to: Address::ZERO,
            value,
        });

        Ok(())
    }
}

// These methods are external to other contracts
// Note: modifying storage will become much prettier soon
#[public]
impl<T: Erc20Params> Erc20<T> {
    /// Immutable token name
    pub fn name() -> String {
        T::NAME.into()
    }

    /// Immutable token symbol
    pub fn symbol() -> String {
        T::SYMBOL.into()
    }

    /// Immutable token decimals
    pub fn decimals() -> u8 {
        T::DECIMALS
    }

    /// Total supply of tokens
    pub fn total_supply(&self) -> U256 {
        self.total_supply.get()
    }

    /// Balance of `address`
    pub fn balance_of(&self, owner: Address) -> U256 {
        self.balances.get(owner)
    }

    /// Transfers `value` tokens from msg::sender() to `to`
    pub fn transfer(&mut self, to: Address, value: U256) -> Result<bool, Erc20Error> {
        self._transfer(msg::sender(), to, value)?;
        Ok(true)
    }

    /// Transfers `value` tokens from `from` to `to`
    /// (msg::sender() must be able to spend at least `value` tokens from `from`)
    pub fn transfer_from(
        &mut self,
        from: Address,
        to: Address,
        value: U256,
    ) -> Result<bool, Erc20Error> {
        // Check msg::sender() allowance
        let mut sender_allowances = self.allowances.setter(from);
        let mut allowance = sender_allowances.setter(msg::sender());
        let old_allowance = allowance.get();
        if old_allowance < value {
            return Err(Erc20Error::InsufficientAllowance(InsufficientAllowance {
                owner: from,
                spender: msg::sender(),
                have: old_allowance,
                want: value,
            }));
        }

        // Decreases allowance
        allowance.set(old_allowance - value);

        // Calls the internal transfer function
        self._transfer(from, to, value)?;

        Ok(true)
    }

    /// Approves the spenditure of `value` tokens of msg::sender() to `spender`
    pub fn approve(&mut self, spender: Address, value: U256) -> bool {
        self.allowances.setter(msg::sender()).insert(spender, value);
        evm::log(Approval {
            owner: msg::sender(),
            spender,
            value,
        });
        true
    }

    /// Returns the allowance of `spender` on `owner`'s tokens
    pub fn allowance(&self, owner: Address, spender: Address) -> U256 {
        self.allowances.getter(owner).get(spender)
    }
}
```

### lib.rs[​](#librs "Direct link to lib.rs")

```rust
// Only run this as a WASM if the export-abi feature is not set.
#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;

// Modules and imports
mod erc20;

use alloy_primitives::{Address, U256};
use stylus_sdk::{
    msg,
    prelude::*
};
use crate::erc20::{Erc20, Erc20Params, Erc20Error};

/// Immutable definitions
struct StylusTokenParams;
impl Erc20Params for StylusTokenParams {
    const NAME: &'static str = "StylusToken";
    const SYMBOL: &'static str = "STK";
    const DECIMALS: u8 = 18;
}

// Define the entrypoint as a Solidity storage object. The sol_storage! macro
// will generate Rust-equivalent structs with all fields mapped to Solidity-equivalent
// storage slots and types.
sol_storage! {
    #[entrypoint]
    struct StylusToken {
        // Allows erc20 to access StylusToken's storage and make calls
        #[borrow]
        Erc20<StylusTokenParams> erc20;
    }
}

#[public]
#[inherit(Erc20<StylusTokenParams>)]
impl StylusToken {
    /// Mints tokens
    pub fn mint(&mut self, value: U256) -> Result<(), Erc20Error> {
        self.erc20.mint(msg::sender(), value)?;
        Ok(())
    }

    /// Mints tokens to another address
    pub fn mint_to(&mut self, to: Address, value: U256) -> Result<(), Erc20Error> {
        self.erc20.mint(to, value)?;
        Ok(())
    }

    /// Burns tokens
    pub fn burn(&mut self, value: U256) -> Result<(), Erc20Error> {
        self.erc20.burn(msg::sender(), value)?;
        Ok(())
    }
}

```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus_erc20_example"
version = "0.1.7"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"

```

---

# ERC-721 • Stylus by Example | Arbitrum Docs

## ERC-721

Any contract that follows the [ERC-721 standard](https://eips.ethereum.org/EIPS/eip-721) is an ERC-721 token.

Here is the interface for ERC-721.

```rust
interface ERC721 {
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    function balanceOf(address _owner) external view returns (uint256);
    function ownerOf(uint256 _tokenId) external view returns (address);
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
    function approve(address _approved, uint256 _tokenId) external payable;
    function setApprovalForAll(address _operator, bool _approved) external;
    function getApproved(uint256 _tokenId) external view returns (address);
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
}
```

Example implementation of an ERC-721 token contract written in Rust.

### src/erc721.rs[​](#srcerc721rs "Direct link to src/erc721.rs")

note

This code has yet to be audited. Please use at your own risk.

```rust
//! Implementation of the ERC-721 standard
//!
//! The eponymous [`Erc721`] type provides all the standard methods,
//! and is intended to be inherited by other contract types.
//!
//! You can configure the behavior of [`Erc721`] via the [`Erc721Params`] trait,
//! which allows specifying the name, symbol, and token uri.
//!
//! Note that this code is unaudited and not fit for production use.

use alloc::{string::String, vec, vec::Vec};
use alloy_primitives::{Address, U256, FixedBytes};
use alloy_sol_types::sol;
use core::{borrow::BorrowMut, marker::PhantomData};
use stylus_sdk::{
    abi::Bytes,
    evm,
    msg,
    prelude::*
};

pub trait Erc721Params {
    /// Immutable NFT name.
    const NAME: &'static str;

    /// Immutable NFT symbol.
    const SYMBOL: &'static str;

    /// The NFT's Uniform Resource Identifier.
    fn token_uri(token_id: U256) -> String;
}

sol_storage! {
    /// Erc721 implements all ERC-721 methods
    pub struct Erc721<T: Erc721Params> {
        /// Token id to owner map
        mapping(uint256 => address) owners;
        /// User to balance map
        mapping(address => uint256) balances;
        /// Token id to approved user map
        mapping(uint256 => address) token_approvals;
        /// User to operator map (the operator can manage all NFTs of the owner)
        mapping(address => mapping(address => bool)) operator_approvals;
        /// Total supply
        uint256 total_supply;
        /// Used to allow [`Erc721Params`]
        PhantomData<T> phantom;
    }
}

// Declare events and Solidity error types
sol! {
    event Transfer(address indexed from, address indexed to, uint256 indexed token_id);
    event Approval(address indexed owner, address indexed approved, uint256 indexed token_id);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    // Token id has not been minted, or it has been burned
    error InvalidTokenId(uint256 token_id);
    // The specified address is not the owner of the specified token id
    error NotOwner(address from, uint256 token_id, address real_owner);
    // The specified address does not have allowance to spend the specified token id
    error NotApproved(address owner, address spender, uint256 token_id);
    // Attempt to transfer token id to the Zero address
    error TransferToZero(uint256 token_id);
    // The receiver address refused to receive the specified token id
    error ReceiverRefused(address receiver, uint256 token_id, bytes4 returned);
}

/// Represents the ways methods may fail.
#[derive(SolidityError)]
pub enum Erc721Error {
    InvalidTokenId(InvalidTokenId),
    NotOwner(NotOwner),
    NotApproved(NotApproved),
    TransferToZero(TransferToZero),
    ReceiverRefused(ReceiverRefused),
}

// External interfaces
sol_interface! {
    /// Allows calls to the `onERC721Received` method of other contracts implementing `IERC721TokenReceiver`.
    interface IERC721TokenReceiver {
        function onERC721Received(address operator, address from, uint256 token_id, bytes data) external returns(bytes4);
    }
}

/// Selector for `onERC721Received`, which is returned by contracts implementing `IERC721TokenReceiver`.
const ERC721_TOKEN_RECEIVER_ID: u32 = 0x150b7a02;

// These methods aren't external, but are helpers used by external methods.
// Methods marked as "pub" here are usable outside of the erc721 module (i.e. they're callable from lib.rs).
impl<T: Erc721Params> Erc721<T> {
    /// Requires that msg::sender() is authorized to spend a given token
    fn require_authorized_to_spend(&self, from: Address, token_id: U256) -> Result<(), Erc721Error> {
        // `from` must be the owner of the token_id
        let owner = self.owner_of(token_id)?;
        if from != owner {
            return Err(Erc721Error::NotOwner(NotOwner {
                from,
                token_id,
                real_owner: owner,
            }));
        }

        // caller is the owner
        if msg::sender() == owner {
            return Ok(());
        }

        // caller is an operator for the owner (can manage their tokens)
        if self.operator_approvals.getter(owner).get(msg::sender()) {
            return Ok(());
        }

        // caller is approved to manage this token_id
        if msg::sender() == self.token_approvals.get(token_id) {
            return Ok(());
        }

        // otherwise, caller is not allowed to manage this token_id
        Err(Erc721Error::NotApproved(NotApproved {
            owner,
            spender: msg::sender(),
            token_id,
        }))
    }

    /// Transfers `token_id` from `from` to `to`.
    /// This function does check that `from` is the owner of the token, but it does not check
    /// that `to` is not the zero address, as this function is usable for burning.
    pub fn transfer(&mut self, token_id: U256, from: Address, to: Address) -> Result<(), Erc721Error> {
        let mut owner = self.owners.setter(token_id);
        let previous_owner = owner.get();
        if previous_owner != from {
            return Err(Erc721Error::NotOwner(NotOwner {
                from,
                token_id,
                real_owner: previous_owner,
            }));
        }
        owner.set(to);

        // right now working with storage can be verbose, but this will change upcoming version of the Stylus SDK
        let mut from_balance = self.balances.setter(from);
        let balance = from_balance.get() - U256::from(1);
        from_balance.set(balance);

        let mut to_balance = self.balances.setter(to);
        let balance = to_balance.get() + U256::from(1);
        to_balance.set(balance);

        // cleaning app the approved mapping for this token
        self.token_approvals.delete(token_id);
        
        evm::log(Transfer { from, to, token_id });
        Ok(())
    }

    /// Calls `onERC721Received` on the `to` address if it is a contract.
    /// Otherwise it does nothing
    fn call_receiver<S: TopLevelStorage>(
        storage: &mut S,
        token_id: U256,
        from: Address,
        to: Address,
        data: Vec<u8>,
    ) -> Result<(), Erc721Error> {
        if to.has_code() {
            let receiver = IERC721TokenReceiver::new(to);
            let received = receiver
                .on_erc_721_received(&mut *storage, msg::sender(), from, token_id, data.into())
                .map_err(|_e| Erc721Error::ReceiverRefused(ReceiverRefused {
                    receiver: receiver.address,
                    token_id,
                    returned: alloy_primitives::FixedBytes(0_u32.to_be_bytes()),
                }))?
                .0;

            if u32::from_be_bytes(received) != ERC721_TOKEN_RECEIVER_ID {
                return Err(Erc721Error::ReceiverRefused(ReceiverRefused {
                    receiver: receiver.address,
                    token_id,
                    returned: alloy_primitives::FixedBytes(received),
                }));
            }
        }
        Ok(())
    }

    /// Transfers and calls `onERC721Received`
    pub fn safe_transfer<S: TopLevelStorage + BorrowMut<Self>>(
        storage: &mut S,
        token_id: U256,
        from: Address,
        to: Address,
        data: Vec<u8>,
    ) -> Result<(), Erc721Error> {
        storage.borrow_mut().transfer(token_id, from, to)?;
        Self::call_receiver(storage, token_id, from, to, data)
    }

    /// Mints a new token and transfers it to `to`
    pub fn mint(&mut self, to: Address) -> Result<(), Erc721Error> {
        let new_token_id = self.total_supply.get();
        self.total_supply.set(new_token_id + U256::from(1u8));
        self.transfer(new_token_id, Address::default(), to)?;
        Ok(())
    }

    /// Burns the token `token_id` from `from`
    /// Note that total_supply is not reduced since it's used to calculate the next token_id to mint
    pub fn burn(&mut self, from: Address, token_id: U256) -> Result<(), Erc721Error> {
        self.transfer(token_id, from, Address::default())?;
        Ok(())
    }
}

// these methods are external to other contracts
#[public]
impl<T: Erc721Params> Erc721<T> {
    /// Immutable NFT name.
    pub fn name() -> Result<String, Erc721Error> {
        Ok(T::NAME.into())
    }

    /// Immutable NFT symbol.
    pub fn symbol() -> Result<String, Erc721Error> {
        Ok(T::SYMBOL.into())
    }

    /// The NFT's Uniform Resource Identifier.
    #[selector(name = "tokenURI")]
    pub fn token_uri(&self, token_id: U256) -> Result<String, Erc721Error> {
        self.owner_of(token_id)?; // require NFT exist
        Ok(T::token_uri(token_id))
    }

    /// Gets the number of NFTs owned by an account.
    pub fn balance_of(&self, owner: Address) -> Result<U256, Erc721Error> {
        Ok(self.balances.get(owner))
    }

    /// Gets the owner of the NFT, if it exists.
    pub fn owner_of(&self, token_id: U256) -> Result<Address, Erc721Error> {
        let owner = self.owners.get(token_id);
        if owner.is_zero() {
            return Err(Erc721Error::InvalidTokenId(InvalidTokenId { token_id }));
        }
        Ok(owner)
    }

    /// Transfers an NFT, but only after checking the `to` address can receive the NFT.
    /// It includes additional data for the receiver.
    #[selector(name = "safeTransferFrom")]
    pub fn safe_transfer_from_with_data<S: TopLevelStorage + BorrowMut<Self>>(
        storage: &mut S,
        from: Address,
        to: Address,
        token_id: U256,
        data: Bytes,
    ) -> Result<(), Erc721Error> {
        if to.is_zero() {
            return Err(Erc721Error::TransferToZero(TransferToZero { token_id }));
        }
        storage
            .borrow_mut()
            .require_authorized_to_spend(from, token_id)?;

        Self::safe_transfer(storage, token_id, from, to, data.0)
    }

    /// Equivalent to [`safe_transfer_from_with_data`], but without the additional data.
    ///
    /// Note: because Rust doesn't allow multiple methods with the same name,
    /// we use the `#[selector]` macro attribute to simulate solidity overloading.
    #[selector(name = "safeTransferFrom")]
    pub fn safe_transfer_from<S: TopLevelStorage + BorrowMut<Self>>(
        storage: &mut S,
        from: Address,
        to: Address,
        token_id: U256,
    ) -> Result<(), Erc721Error> {
        Self::safe_transfer_from_with_data(storage, from, to, token_id, Bytes(vec![]))
    }

    /// Transfers the NFT.
    pub fn transfer_from(&mut self, from: Address, to: Address, token_id: U256) -> Result<(), Erc721Error> {
        if to.is_zero() {
            return Err(Erc721Error::TransferToZero(TransferToZero { token_id }));
        }
        self.require_authorized_to_spend(from, token_id)?;
        self.transfer(token_id, from, to)?;
        Ok(())
    }

    /// Grants an account the ability to manage the sender's NFT.
    pub fn approve(&mut self, approved: Address, token_id: U256) -> Result<(), Erc721Error> {
        let owner = self.owner_of(token_id)?;

        // require authorization
        if msg::sender() != owner && !self.operator_approvals.getter(owner).get(msg::sender()) {
            return Err(Erc721Error::NotApproved(NotApproved {
                owner,
                spender: msg::sender(),
                token_id,
            }));
        }
        self.token_approvals.insert(token_id, approved);

        evm::log(Approval {
            approved,
            owner,
            token_id,
        });
        Ok(())
    }

    /// Grants an account the ability to manage all of the sender's NFTs.
    pub fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<(), Erc721Error> {
        let owner = msg::sender();
        self.operator_approvals
            .setter(owner)
            .insert(operator, approved);

        evm::log(ApprovalForAll {
            owner,
            operator,
            approved,
        });
        Ok(())
    }

    /// Gets the account managing an NFT, or zero if unmanaged.
    pub fn get_approved(&mut self, token_id: U256) -> Result<Address, Erc721Error> {
        Ok(self.token_approvals.get(token_id))
    }

    /// Determines if an account has been authorized to managing all of a user's NFTs.
    pub fn is_approved_for_all(&mut self, owner: Address, operator: Address) -> Result<bool, Erc721Error> {
        Ok(self.operator_approvals.getter(owner).get(operator))
    }

    /// Whether the NFT supports a given standard.
    pub fn supports_interface(interface: FixedBytes<4>) -> Result<bool, Erc721Error> {
        let interface_slice_array: [u8; 4] = interface.as_slice().try_into().unwrap();

        if u32::from_be_bytes(interface_slice_array) == 0xffffffff {
            // special cased in the ERC165 standard
            return Ok(false);
        }

        const IERC165: u32 = 0x01ffc9a7;
        const IERC721: u32 = 0x80ac58cd;
        const IERC721_METADATA: u32 = 0x5b5e139f;

        Ok(matches!(u32::from_be_bytes(interface_slice_array), IERC165 | IERC721 | IERC721_METADATA))
    }
}
```

### lib.rs[​](#librs "Direct link to lib.rs")

```rust
// Only run this as a WASM if the export-abi feature is not set.
#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;

// Modules and imports
mod erc721;

use alloy_primitives::{U256, Address};
/// Import the Stylus SDK along with alloy primitive types for use in our program.
use stylus_sdk::{
    msg, prelude::*
};
use crate::erc721::{Erc721, Erc721Params, Erc721Error};

/// Immutable definitions
struct StylusNFTParams;
impl Erc721Params for StylusNFTParams {
    const NAME: &'static str = "StylusNFT";
    const SYMBOL: &'static str = "SNFT";

    fn token_uri(token_id: U256) -> String {
        format!("{}{}{}", "https://my-nft-metadata.com/", token_id, ".json")
    }
}

// Define the entrypoint as a Solidity storage object. The sol_storage! macro
// will generate Rust-equivalent structs with all fields mapped to Solidity-equivalent
// storage slots and types.
sol_storage! {
    #[entrypoint]
    struct StylusNFT {
        #[borrow] // Allows erc721 to access StylusNFT's storage and make calls
        Erc721<StylusNFTParams> erc721;
    }
}

#[public]
#[inherit(Erc721<StylusNFTParams>)]
impl StylusNFT {
    /// Mints an NFT
    pub fn mint(&mut self) -> Result<(), Erc721Error> {
        let minter = msg::sender();
        self.erc721.mint(minter)?;
        Ok(())
    }

    /// Mints an NFT to another address
    pub fn mint_to(&mut self, to: Address) -> Result<(), Erc721Error> {
        self.erc721.mint(to)?;
        Ok(())
    }

    /// Burns an NFT
    pub fn burn(&mut self, token_id: U256) -> Result<(), Erc721Error> {
        // This function checks that msg::sender() owns the specified token_id
        self.erc721.burn(msg::sender(), token_id)?;
        Ok(())
    }

    /// Total supply
    pub fn total_supply(&mut self) -> Result<U256, Erc721Error> {
        Ok(self.erc721.total_supply.get())
    }
}
```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus_erc721_example"
version = "0.1.7"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"
```

---

# Multi Call • Stylus by Example | Arbitrum Docs

## Multicall

An Arbitrum Stylus version implementation of [Solidity Multi Call contract](https://solidity-by-example.org/app/multi-call/) that aggregates multiple queries using a for loop and RawCall.

Example implementation of a Multi Call contract written in Rust: Here is the interface for TimeLock.

```rust
/**
 * This file was automatically generated by Stylus and represents a Rust program.
 * For more information, please see [The Stylus SDK](https://github.com/OffchainLabs/stylus-sdk-rs).
 */

// SPDX-License-Identifier: MIT-OR-APACHE-2.0
pragma solidity ^0.8.23;

interface IMultiCall {
    function multicall(address[] memory addresses, bytes[] memory data) external view returns (bytes[] memory);

    error ArraySizeNotMatch();

    error CallFailed(uint256);
}
```

### src/lib.rs[​](#srclibrs "Direct link to src/lib.rs")

note

This code has yet to be audited. Please use at your own risk.

```rust
#![cfg_attr(not(feature = "export-abi"), no_main)]
extern crate alloc;

#[global_allocator]
static ALLOC: mini_alloc::MiniAlloc = mini_alloc::MiniAlloc::INIT;

use alloy_primitives::U256;
use alloy_sol_types::sol;
use stylus_sdk::{abi::Bytes, alloy_primitives::Address, call::RawCall, prelude::*};

#[solidity_storage]
#[entrypoint]
pub struct MultiCall;

// Declare events and Solidity error types
sol! {
    error ArraySizeNotMatch();
    error CallFailed(uint256 call_index);
}

#[derive(SolidityError)]
pub enum MultiCallErrors {
    ArraySizeNotMatch(ArraySizeNotMatch),
    CallFailed(CallFailed),
}

#[external]
impl MultiCall {
    pub fn multicall(
        &self,
        addresses: Vec<Address>,
        data: Vec<Bytes>,
    ) -> Result<Vec<Bytes>, MultiCallErrors> {
        let addr_len = addresses.len();
        let data_len = data.len();
        let mut results: Vec<Bytes> = Vec::new();
        if addr_len != data_len {
            return Err(MultiCallErrors::ArraySizeNotMatch(ArraySizeNotMatch {}));
        }
        for i in 0..addr_len {
            let result = RawCall::new().call(addresses[i], data[i].to_vec().as_slice())
                .map_err(|_| MultiCallErrors::CallFailed(CallFailed { call_index: U256::from(i) }))?;
            results.push(result.into());
}
        Ok(results)
    }
}

```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus-multi-call-contract"
version = "0.1.5"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]
description = "Stylus multi call example"

[dependencies]
alloy-primitives = "0.3.1"
alloy-sol-types = "0.3.1"
mini-alloc = "0.4.2"
stylus-sdk = "0.5.0"
hex = "0.4.3"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[[bin]]
name = "stylus-multi-call"
path = "src/main.rs"

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"
```

---

# Vending Machine • Stylus by Example | Arbitrum Docs

## Vending Machine

An example project for writing Arbitrum Stylus programs in Rust using the [stylus-sdk](https://github.com/OffchainLabs/stylus-sdk-rs). It includes a Rust implementation of a vending machine Ethereum smart contract.

*   distribute Cupcakes to any given address
*   count Cupcakes balance of any given address

Here is the interface for Vending Machine.

```rust
interface IVendingMachine {
    // Function to distribute a cupcake to a user
    function giveCupcakeTo(address userAddress) external returns (bool);

    // Getter function for the cupcake balance of a user
    function getCupcakeBalanceFor(address userAddress) external view returns (uint);
}
```

Example implementation of the Vending Machine contract written in Rust.

### src/lib.rs[​](#srclibrs "Direct link to src/lib.rs")

note

This code has yet to be audited. Please use at your own risk.

```rust
//!
//! Stylus Cupcake Example
//!
//! The program is ABI-equivalent with Solidity, which means you can call it from both Solidity and Rust.
//! To do this, run `cargo stylus export-abi`.
//!
//! Note: this code is a template-only and has not been audited.
//!

// Allow `cargo stylus export-abi` to generate a main function if the "export-abi" feature is enabled.
#![cfg_attr(not(feature = "export-abi"), no_main)]
extern crate alloc;

use alloy_primitives::{Address, Uint};
// Import items from the SDK. The prelude contains common traits and macros.
use stylus_sdk::alloy_primitives::U256;
use stylus_sdk::prelude::*;
use stylus_sdk::{block, console};

// Define persistent storage using the Solidity ABI.
// `VendingMachine` will be the entrypoint for the contract.
sol_storage! {
    #[entrypoint]
    pub struct VendingMachine {
        // Mapping from user addresses to their cupcake balances.
        mapping(address => uint256) cupcake_balances;
        // Mapping from user addresses to the last time they received a cupcake.
        mapping(address => uint256) cupcake_distribution_times;
    }
}

// Declare that `VendingMachine` is a contract with the following external methods.
#[public]
impl VendingMachine {
    // Give a cupcake to the specified user if they are eligible (i.e., if at least 5 seconds have passed since their last cupcake).
    pub fn give_cupcake_to(&mut self, user_address: Address) -> bool {
        // Get the last distribution time for the user.
        let last_distribution = self.cupcake_distribution_times.get(user_address);
        // Calculate the earliest next time the user can receive a cupcake.
        let five_seconds_from_last_distribution = last_distribution + U256::from(5);

        // Get the current block timestamp.
        let current_time = block::timestamp();
        // Check if the user can receive a cupcake.
        let user_can_receive_cupcake =
            five_seconds_from_last_distribution <= Uint::<256, 4>::from(current_time);

        if user_can_receive_cupcake {
            // Increment the user's cupcake balance.
            let mut balance_accessor = self.cupcake_balances.setter(user_address);
            let balance = balance_accessor.get() + U256::from(1);
            balance_accessor.set(balance);

            // Update the distribution time to the current time.
            let mut time_accessor = self.cupcake_distribution_times.setter(user_address);
            let new_distribution_time = block::timestamp();
            time_accessor.set(Uint::<256, 4>::from(new_distribution_time));
            return true;
        } else {
            // User must wait before receiving another cupcake.
            console!(
                "HTTP 429: Too Many Cupcakes (you must wait at least 5 seconds between cupcakes)"
            );
            return false;
        }
    }

    // Get the cupcake balance for the specified user.
    pub fn get_cupcake_balance_for(&self, user_address: Address) -> Uint<256, 4> {
        // Return the user's cupcake balance from storage.
        return self.cupcake_balances.get(user_address);
    }
}
```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus_cupcake_example"
version = "0.1.7"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"
```

---

# ABI Encode • Stylus by Example | Arbitrum Docs

## ABI Decode

The `decode` can not be used for `encode_packed` data because it ignores padding when encode. (For more information you can refer to [ABI Encode](/stylus-by-example/basic_examples/abi_encode))

So here we show an example for using `decode` on data encoded with `abi_encode_sequence`:

note

This code has yet to be audited. Please use at your own risk.

```rust
// This should always return true
pub fn encode_and_decode(
    &self, 
    target: Address,
    value: U256,
    func: String,
    data: Bytes,
    timestamp: U256
) -> Result<bool, HasherError> {
    // define sol types tuple
    type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
    // because the abi_encode_sequence will return alloy_primitives::Bytes rather than stylus_sdk::bytes, so we need to make sure the input and return types are the same
    let primative_data = alloy_primitives::Bytes::copy_from_slice(&data);
    // set the tuple
    let tx_hash_data = (target, value, func, primative_data, timestamp);
    // encode the tuple
    let tx_hash_data_encode = TxIdHashType::abi_encode_sequence(&tx_hash_data);

    let validate = true;
    
    // Check the result
    match TxIdHashType::abi_decode_sequence(&tx_hash_data_encode, validate) {
        Ok(res) => Ok(res == tx_hash_data),
        Err(_) => {
            return Err(HasherError::DecodedFailed(DecodedFailed{}));
        },
    }   
}
```

Full Example code:
==================

### src/lib.rs[​](#srclibrs "Direct link to src/lib.rs")

```rust

#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;


/// Import items from the SDK. The prelude contains common traits and macros.
use stylus_sdk::{alloy_primitives::{U256, Address}, prelude::*};
// Because the naming of `alloy_primitives` and `alloy_sol_types` is the same, we need to rename the types in `alloy_sol_types`.
use alloy_sol_types::{sol_data::{Address as SOLAddress, *}, SolType, sol};


// Define error
sol! {
    error DecodedFailed();
}

// Error types for the MultiSig contract
#[derive(SolidityError)]
pub enum DecoderError{
    DecodedFailed(DecodedFailed)
}

#[storage]
#[entrypoint]
pub struct Decoder;


/// Declare that `Decoder` is a contract with the following external methods.
#[public]
impl Decoder {
    // This should always return true
    pub fn encode_and_decode(
        &self, 
        address: Address, 
        amount: U256
    ) -> Result<bool, DecoderError> {
        // define sol types tuple
        type TxIdHashType = (SOLAddress, Uint<256>);
        // set the tuple
        let tx_hash_data = (address, amount);
        // encode the tuple
        let tx_hash_data_encode = TxIdHashType::abi_encode_params(&tx_hash_data);

        let validate = true;
        
        // Check the result
        match TxIdHashType::abi_decode_params(&tx_hash_data_encode, validate) {
            Ok(res) => Ok(res == tx_hash_data),
            Err(_) => {
                return Err(DecoderError::DecodedFailed(DecodedFailed{}));
            },
        }   
    }

}
```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus-decode-hashing"
version = "0.1.0"
edition = "2021"

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.5.1"

[features]
export-abi = ["stylus-sdk/export-abi"]
debug = ["stylus-sdk/debug"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"

```

---

# ABI Decode • Stylus by Example | Arbitrum Docs

## ABI Encode

The `ABI Encode` has 2 types which are [`encode`](https://docs.soliditylang.org/en/latest/abi-spec.html#strict-encoding-mode) and [`encode_packed`](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).

*   `encode` will concatenate all values and add padding to fit into 32 bytes for each values.
*   `encode_packed` will concatenate all values in the exact byte representations without padding. (For example, `encode_packed("a", "bc") == encode_packed("ab", "c")`)

Suppose we have a tuple of values: `(target, value, func, data, timestamp)` to encode, and their `alloy primitives type` are `(Address, U256, String, Bytes, U256)`.

Firstly we need to import those types we need from `alloy_primitives`, `stylus_sdk::abi` and `alloc::string`:

note

This code has yet to be audited. Please use at your own risk.

```rust
// Import items from the SDK. The prelude contains common traits and macros.
use stylus_sdk::{alloy_primitives::{U256, Address, FixedBytes}, abi::Bytes, prelude::*};
// Import String from alloc
use alloc::string::String;
```

Secondly because we will use the method [`abi_encode_sequence`](https://docs.rs/alloy-sol-types/latest/alloy_sol_types/trait.SolValue.html#method.abi_encode_sequence) and [`abi_encode_packed`](https://docs.rs/alloy-sol-types/latest/alloy_sol_types/trait.SolValue.html#method.abi_encode_packed) under `alloy_sol_types` to encode data, we also need to import the types from `alloy_sol_types`:

```rust
// Becauce the naming of alloy_primitives and alloy_sol_types is the same, so we need to re-name the types in alloy_sol_types
use alloy_sol_types::{sol_data::{Address as SOLAddress, String as SOLString, Bytes as SOLBytes, *}, SolType};
```

encode[​](#encode "Direct link to encode")
------------------------------------------

Then `encode` them:

```rust
// define sol types tuple
type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
// set the tuple
let tx_hash_data = (target, value, func, data, timestamp);
// encode the tuple
let tx_hash_bytes = TxIdHashType::abi_encode_sequence(&tx_hash_data);
```

encode\_packed[​](#encode_packed "Direct link to encode_packed")
----------------------------------------------------------------

There are 2 methods to `encode_packed` data:

1.  `encode_packed` them:

```rust
// define sol types tuple
type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
// set the tuple
let tx_hash_data = (target, value, func, data, timestamp);
// encode the tuple
let tx_hash_data_encode_packed = TxIdHashType::abi_encode_packed(&tx_hash_data);
```

2.  We can also use the following method to `encode_packed` them:

```rust
let tx_hash_data_encode_packed = [&target.to_vec(), &value.to_be_bytes_vec(), func.as_bytes(), &data.to_vec(), &timestamp.to_be_bytes_vec()].concat();
```

Full Example code:
==================

### src/main.rs[​](#srcmainrs "Direct link to src/main.rs")

```rust
// Allow `cargo stylus export-abi` to generate a main function.
#![cfg_attr(not(feature = "export-abi"), no_main)]
extern crate alloc;


/// Import items from the SDK. The prelude contains common traits and macros.
use stylus_sdk::{alloy_primitives::{U256, Address, FixedBytes}, abi::Bytes, prelude::*};
use alloc::string::String;
// Becauce the naming of alloy_primitives and alloy_sol_types is the same, so we need to re-name the types in alloy_sol_types
use alloy_sol_types::{sol_data::{Address as SOLAddress, String as SOLString, Bytes as SOLBytes, *}, SolType};
use sha3::{Digest, Keccak256};

// Define some persistent storage using the Solidity ABI.
// `Encoder` will be the entrypoint.
#[storage]
#[entrypoint]
pub struct Encoder;

impl Encoder {
    fn keccak256(&self, data: Bytes) -> FixedBytes<32> {
        // prepare hasher
        let mut hasher = Keccak256::new();
        // populate the data
        hasher.update(data);
        // hashing with keccack256
        let result = hasher.finalize();
        // convert the result hash to FixedBytes<32>
        let result_vec = result.to_vec();
        FixedBytes::<32>::from_slice(&result_vec)   
    }
}

/// Declare that `Encoder` is a contract with the following external methods.
#[public]
impl Encoder {

     // Encode the data and hash it
     pub fn encode(
        &self, 
        target: Address,
        value: U256,
        func: String,
        data: Bytes,
        timestamp: U256
    ) -> Vec<u8> {
        // define sol types tuple
        type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
        // set the tuple
        let tx_hash_data = (target, value, func, data, timestamp);
        // encode the tuple
        let tx_hash_data_encode = TxIdHashType::abi_encode_params(&tx_hash_data);
        tx_hash_data_encode
    }

    // Packed encode the data and hash it, the same result with the following one
    pub fn packed_encode(
        &self, 
        target: Address,
        value: U256,
        func: String,
        data: Bytes,
        timestamp: U256
    )-> Vec<u8> {
        // define sol types tuple
        type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
        // set the tuple
        let tx_hash_data = (target, value, func, data, timestamp);
        // encode the tuple
        let tx_hash_data_encode_packed = TxIdHashType::abi_encode_packed(&tx_hash_data);
        tx_hash_data_encode_packed
    }

    // Packed encode the data and hash it, the same result with the above one
    pub fn packed_encode_2(
        &self, 
        target: Address,
        value: U256,
        func: String,
        data: Bytes,
        timestamp: U256
    )-> Vec<u8> {
        // set the data to arrary and concat it directly
        let tx_hash_data_encode_packed = [&target.to_vec(), &value.to_be_bytes_vec(), func.as_bytes(), &data.to_vec(), &timestamp.to_be_bytes_vec()].concat();
        tx_hash_data_encode_packed
    }


    // The func example: "transfer(address,uint256)"
    pub fn encode_with_signature(
        &self, 
        func: String, 
        address: Address, 
        amount: U256
    ) -> Vec<u8> {
        type TransferType = (SOLAddress, Uint<256>);
        let tx_data = (address, amount);
        let data = TransferType::abi_encode_params(&tx_data);
        // Get function selector
        let hashed_function_selector = self.keccak256(func.as_bytes().to_vec().into());
        // Combine function selector and input data (use abi_packed way)
        let calldata = [&hashed_function_selector[..4], &data].concat();
        calldata
    }

}
```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus-encode-hashing"
version = "0.1.7"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"
sha3 = "0.10"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"
```

---

# Bytes In, Bytes Out • Stylus by Example | Arbitrum Docs

## Bytes In, Bytes Out

This is a simple bytes in, bytes out contract that shows a minimal `entrypoint` function (denoted by the `#[entrypoint]` proc macro). If your smart contract just has one primary function, like computing a cryptographic hash, this can be a great model because it strips out the SDK and acts like a pure function or Unix-style app.

### src/main.rs[​](#srcmainrs "Direct link to src/main.rs")

note

This code has yet to be audited. Please use at your own risk.

```rust
#![cfg_attr(not(feature = "export-abi"), no_main)]

extern crate alloc;
use alloc::vec::Vec;

use stylus_sdk::stylus_proc::entrypoint;

#[entrypoint]
fn user_main(input: Vec<u8>) -> Result<Vec<u8>, Vec<u8>> {
    Ok(input)
}
```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "bytes_in_bytes_out"
version = "0.1.7"
edition = "2021"

[dependencies]
stylus-sdk = "0.6.0"

[features]
export-abi = ["stylus-sdk/export-abi"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"

[workspace]
```

---

# Constants • Stylus by Example | Arbitrum Docs

## Constants

Constants are values that are bound to a name and cannot change. They are always immutable. In Rust, constants are declared with the `const` keyword. Unlike variables declared with the `let` keyword, constants _must_ be annotated with their type.

Constants are valid for the entire length of the transaction. They are essentially _inlined_ wherever they are used, meaning that their value is copied directly into whatever context invokes them.

Since their value is hardcoded, they can save on gas cost as their value does not need to be fetched from storage.

Learn More[​](#learn-more "Direct link to Learn More")
------------------------------------------------------

*   [Rust docs - Constant items](https://doc.rust-lang.org/reference/items/constant-items.html)
*   [Solidity docs - Constant variables](https://docs.soliditylang.org/en/v0.8.19/contracts.html#constant)

### src/lib.rs[​](#srclibrs "Direct link to src/lib.rs")

note

This code has yet to be audited. Please use at your own risk.

```rust
// Only run this as a WASM if the export-abi feature is not set.
#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;

use alloc::vec;
use alloc::vec::Vec;

use stylus_sdk::alloy_primitives::Address;
use stylus_sdk::prelude::*;
use stylus_sdk::storage::StorageAddress;

const OWNER: &str = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";

#[storage]
#[entrypoint]
pub struct Contract {
    owner: StorageAddress,
}

#[public]
impl Contract {
    pub fn init(&mut self) -> Result<(), Vec<u8>> {
        // Parse the const &str as a local Address variable
        let owner_address = Address::parse_checksummed(OWNER, None).expect("Invalid address");

        // Save the result as the owner
        self.owner.set(owner_address);

        Ok(())
    }
    pub fn owner(&self) -> Result<Address, Vec<u8>> {
        let owner_address = self.owner.get();

        Ok(owner_address)
    }
}

```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus_constants_example"
version = "0.1.7"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"

```

---

# Errors • Stylus by Example | Arbitrum Docs

## Errors

In Rust Stylus contracts, error handling is a crucial aspect of writing robust and reliable smart contracts. Rust differentiates between recoverable and unrecoverable errors. Recoverable errors are represented using the `Result` type, which can either be `Ok`, indicating success, or `Err`, indicating failure. This allows developers to manage errors gracefully and maintain control over the flow of execution. Unrecoverable errors are handled with the `panic!` macro, which stops execution, unwinds the stack, and returns a dataless error.

In Stylus contracts, error types are often explicitly defined, providing clear and structured ways to handle different failure scenarios. This structured approach promotes better error management, ensuring that contracts are secure, maintainable, and behave predictably under various conditions. Similar to Solidity and EVM, errors in Stylus will undo all changes made to the state during a transaction by reverting the transaction. Thus, there are two main types of errors in Rust Stylus contracts:

*   **Recoverable Errors**: The Stylus SDK provides features that make using recoverable errors in Rust Stylus contracts convenient. This type of error handling is strongly recommended for Stylus contracts.
*   **Unrecoverable Errors**: These can be defined similarly to Rust code but are not recommended for smart contracts if recoverable errors can be used instead.

Learn More[​](#learn-more "Direct link to Learn More")
------------------------------------------------------

*   [Solidity docs: Expressions and Control Structures](https://docs.soliditylang.org/en/latest/control-structures.html)
*   [`#[derive(SolidityError)]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/derive.SolidityError.html)
*   [`alloy_sol_types::SolError`](https://docs.rs/alloy-sol-types/latest/alloy_sol_types/trait.SolError.html)
*   [`Error handling: Rust book`](https://doc.rust-lang.org/book/ch09-00-error-handling.html)

Recoverable Errors[​](#recoverable-errors "Direct link to Recoverable Errors")
------------------------------------------------------------------------------

Recoverable errors are represented using the `Result` type, which can either be `Ok`, indicating success, or `Err`, indicating failure. The Stylus SDK provides tools to define custom error types and manage recoverable errors effectively.

#### Example: Recoverable Errors[​](#example-recoverable-errors "Direct link to Example: Recoverable Errors")

Here's a simplified Rust Stylus contract demonstrating how to define and handle recoverable errors:

note

This code has yet to be audited. Please use at your own risk.

```rust
#![cfg_attr(not(feature = "export-abi"), no_main)]
extern crate alloc;


use alloy_sol_types::sol;
use stylus_sdk::{abi::Bytes, alloy_primitives::{Address, U256}, call::RawCall, prelude::*};

#[storage]
#[entrypoint]
pub struct MultiCall;

// Declare events and Solidity error types
sol! {
    error ArraySizeNotMatch();
    error CallFailed(uint256 call_index);
}

#[derive(SolidityError)]
pub enum MultiCallErrors {
    ArraySizeNotMatch(ArraySizeNotMatch),
    CallFailed(CallFailed),
}

#[public]
impl MultiCall {
    pub fn multicall(
        &self,
        addresses: Vec<Address>,
        data: Vec<Bytes>,
    ) -> Result<Vec<Bytes>, MultiCallErrors> {
        let addr_len = addresses.len();
        let data_len = data.len();
        let mut results: Vec<Bytes> = Vec::new();
        if addr_len != data_len {
            return Err(MultiCallErrors::ArraySizeNotMatch(ArraySizeNotMatch {}));
        }
        for i in 0..addr_len {
            let result: Result<Vec<u8>, Vec<u8>> =
                RawCall::new().call(addresses[i], data[i].to_vec().as_slice());
            let data = match result {
                Ok(data) => data,
                Err(_data) => return Err(MultiCallErrors::CallFailed(CallFailed { call_index: U256::from(i) })),
            };
            results.push(data.into())
        }
        Ok(results)
    }
}
```

*   **Using `SolidityError` Derive Macro**: The `#[derive(SolidityError)]` attribute is used for the `MultiCallErrors` enum, automatically implementing the necessary traits for error handling.
*   **Defining Errors**: Custom errors `ArraySizeNotMatch` and `CallFailed` is declared in `MultiCallErrors` enum. `CallFailed` error includes a `call_index` parameter to indicate which call failed.
*   **ArraySizeNotMatch Error Handling**: The `multicall` function returns `ArraySizeNotMatch` if the size of addresses and data vectors are not equal.
*   **CallFailed Error Handling**: The `multicall` function returns a `CallFailed` error with the index of the failed call if any call fails. Note that we're using match to check if the result of the call is an error or a return data. We'll describe match pattern in the further sections.

Unrecoverable Errors[​](#unrecoverable-errors "Direct link to Unrecoverable Errors")
------------------------------------------------------------------------------------

Here are various ways to handle such errors in the `multicall` function, which calls multiple addresses and panics in different scenarios:

### Using `panic!`[​](#using-panic "Direct link to using-panic")

Directly panics if the call fails, including the index of the failed call.

```rust
        for i in 0..addr_len {
            let result = RawCall::new().call(addresses[i], data[i].to_vec().as_slice());
            let data = match result {
                Ok(data) => data,
                Err(_data) => panic!("Call to address {:?} failed at index {}", addresses[i], i),
            };
            results.push(data.into());
}
```

Handling Call Failure with `panic!`: The function panics if any call fails and the transaction will be reverted without any data.

### Using `unwrap`[​](#using-unwrap "Direct link to using-unwrap")

Uses `unwrap` to handle the result, panicking if the call fails.

```rust
        for i in 0..addr_len {
            let result = RawCall::new().call(addresses[i], data[i].to_vec().as_slice()).unwrap();
            results.push(result.into());
}
```

Handling Call Failure with `unwrap`: The function uses `unwrap` to panic if any call fails, including the index of the failed call.

### Using `match`[​](#using-match "Direct link to using-match")

Uses a `match` statement to handle the result of `call`, panicking if the call fails.

```rust
        for i in 0..addr_len {
            let result = RawCall::new().call(addresses[i], data[i].to_vec().as_slice());
            let data = match result {
                Ok(data) => data,
                Err(_data) => return Err(MultiCallErrors::CallFailed(CallFailed { call_index: U256::from(i) })),
            };
            results.push(data.into());
}
```

Handling Call Failure with `match`: The function uses a `match` statement to handle the result of `call`, returning error if any call fails.

### Using the `?` Operator[​](#using-the--operator "Direct link to using-the--operator")

Uses the `?` operator to propagate the error if the call fails, including the index of the failed call.

```rust
        for i in 0..addr_len {
            let result = RawCall::new().call(addresses[i], data[i].to_vec().as_slice())
                .map_err(|_| MultiCallErrors::CallFailed(CallFailed { call_index: U256::from(i) }))?;
            results.push(result.into());
}
```

Handling Call Failure with `?` Operator: The function uses the `?` operator to propagate the error if any call fails, including the index of the failed call.

Each method demonstrates a different way to handle unrecoverable errors in the `multicall` function of a Rust Stylus contract, providing a comprehensive approach to error management.

**Note** that as mentioned above, it is strongly recommended to use custom error handling instead of unrecoverable error handling.

Boilerplate[​](#boilerplate "Direct link to Boilerplate")
---------------------------------------------------------

### src/lib.rs[​](#srclibrs "Direct link to src/lib.rs")

The lib.rs code can be found at the top of the page in the recoverable error example section.

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus-multicall-contract"
version = "0.1.7"
edition = "2021"

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
stylus-sdk = "0.6.0"
hex = "0.4.3"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[[bin]]
name = "stylus-multicall-contract"
path = "src/main.rs"

[lib]
crate-type = ["lib", "cdylib"]

```

---

# Events • Stylus by Example | Arbitrum Docs

## Events

Events allow for data to be logged publicly to the blockchain. Log entries provide the contract's address, a series of up to four topics, and some arbitrary length binary data. The Stylus Rust SDK provides a few ways to publish event logs described below.

Learn More[​](#learn-more "Direct link to Learn More")
------------------------------------------------------

*   [Solidity docs: Events](https://docs.soliditylang.org/en/v0.8.19/abi-spec.html#events)
*   [`stylus_sdk::evm::log`](https://docs.rs/stylus-sdk/latest/stylus_sdk/evm/fn.log.html)
*   [`alloy_sol_types::SolEvent`](https://docs.rs/alloy-sol-types/0.3.1/alloy_sol_types/trait.SolEvent.html)

Log[​](#log "Direct link to Log")
---------------------------------

Using the `evm::log` function in the Stylus SDK is the preferred way to log events. It ensures that an event will be logged in a Solidity ABI-compatible format. The `log` function takes any type that implements Alloy `SolEvent` trait. It's not recommended to attempt to implement this trait on your own. Instead, make use of the provided `sol!` macro to declare your Events and their schema using Solidity-style syntax to declare the parameter types. Alloy will create ABI-compatible Rust types which you can instantiate and pass to the `evm::log` function.

### Log Usage[​](#log-usage "Direct link to Log Usage")

note

This code has yet to be audited. Please use at your own risk.

```rust
// sol! macro event declaration
// Up to 3 parameters can be indexed.
// Indexed parameters helps you filter the logs efficiently
sol! {
    event Log(address indexed sender, string message);
    event AnotherLog();
}

#[storage]
#[entrypoint]
pub struct Events {}

#[public]
impl Events {
fn user_main(_input: Vec<u8>) -> ArbResult {
    // emits a 'Log' event, defined above in the sol! macro
    evm::log(Log {
        sender: Address::from([0x11; 20]),
        message: "Hello world!".to_string(),
    });

    // no data, but 'AnotherLog' event will still emit to the chain
    evm::log(AnotherLog {});

    Ok(vec![])
}
}
```

Raw Log[​](#raw-log "Direct link to Raw Log")
---------------------------------------------

The `evm::raw_log` affordance offers the ability to send anonymous events that do not necessarily conform to the Solidity ABI. Instead, up to four raw 32-byte indexed topics are published along with any arbitrary bytes appended as data.

**NOTE**: It's still possible to achieve Solidity ABI compatibility using this construct. To do so you'll have to manually compute the ABI signature for the event, [following the equation set in the Solidity docs](https://docs.soliditylang.org/en/v0.8.19/abi-spec.html#events). The result of that should be assigned to `TOPIC_0`, the first topic in the slice passed to `raw_log`.

### Raw Log Usage[​](#raw-log-usage "Direct link to Raw Log Usage")

```rust
// set up local variables
let user = Address::from([0x22; 20]);
let balance = U256::from(10_000_000);

// declare up to 4 topics
// topics must be of type FixedBytes<32>
let topics = &[user.into_word()];

// store non-indexed data in a byte Vec
let mut data: Vec<u8> = vec![];
// to_be_bytes means 'to big endian bytes'
data.extend_from_slice(balance.to_be_bytes::<32>().to_vec().as_slice());

// unwrap() here 'consumes' the Result
evm::raw_log(topics.as_slice(), data.as_ref()).unwrap();
```

Result[​](#result "Direct link to Result")
------------------------------------------

Combining the above examples into the boiler plate provided below this section, deploying to a Stylus chain and then invoking the deployed contract will result in the following three events logged to the chain:

### logs[​](#logs "Direct link to logs")

```rust
[
  {
    "address": "0x6cf4a18ac8efd6b0b99d3200c4fb9609dd60d4b3",
    "topics": [
      "0x0738f4da267a110d810e6e89fc59e46be6de0c37b1d5cd559b267dc3688e74e0",
      "0x0000000000000000000000001111111111111111111111111111111111111111"
    ],
    "data": "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000c48656c6c6f20776f726c64210000000000000000000000000000000000000000",
    "blockHash": "0xfef880025dc87b5ab4695a0e1a6955dd7603166ecba79ce0f503a568b2ec8940",
    "blockNumber": "0x94",
    "transactionHash": "0xc7318dae2164eb441fb80f5b869f844e3e97ae83c24a4639d46ec4d915a30818",
    "transactionIndex": "0x1",
    "logIndex": "0x0",
    "removed": false
  },
  {
    "address": "0x6cf4a18ac8efd6b0b99d3200c4fb9609dd60d4b3",
    "topics": ["0xfe1a3ad11e425db4b8e6af35d11c50118826a496df73006fc724cb27f2b99946"],
    "data": "0x",
    "blockHash": "0xfef880025dc87b5ab4695a0e1a6955dd7603166ecba79ce0f503a568b2ec8940",
    "blockNumber": "0x94",
    "transactionHash": "0xc7318dae2164eb441fb80f5b869f844e3e97ae83c24a4639d46ec4d915a30818",
    "transactionIndex": "0x1",
    "logIndex": "0x1",
    "removed": false
  },
  {
    "address": "0x6cf4a18ac8efd6b0b99d3200c4fb9609dd60d4b3",
    "topics": ["0x0000000000000000000000002222222222222222222222222222222222222222"],
    "data": "0x0000000000000000000000000000000000000000000000000000000000989680",
    "blockHash": "0xfef880025dc87b5ab4695a0e1a6955dd7603166ecba79ce0f503a568b2ec8940",
    "blockNumber": "0x94",
    "transactionHash": "0xc7318dae2164eb441fb80f5b869f844e3e97ae83c24a4639d46ec4d915a30818",
    "transactionIndex": "0x1",
    "logIndex": "0x2",
    "removed": false
  }
]
```

Boilerplate[​](#boilerplate "Direct link to Boilerplate")
---------------------------------------------------------

### src/lib.rs[​](#srclibrs "Direct link to src/lib.rs")

```rust
// Only run this as a WASM if the export-abi feature is not set.
#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;

use alloc::vec::Vec;
use alloc::{string::ToString, vec};

use stylus_sdk::alloy_primitives::U256;
use stylus_sdk::{alloy_primitives::Address, alloy_sol_types::sol, evm, prelude::*, ArbResult};

// sol! macro event declaration
// Up to 3 parameters can be indexed.
// Indexed parameters helps you filter the logs by the indexed parameter
sol! {
    event Log(address indexed sender, string message);
    event AnotherLog();
}

#[storage]
#[entrypoint]
pub struct Events {}

#[public]
impl Events {
fn user_main(_input: Vec<u8>) -> ArbResult {
    // emits a 'Log' event, defined above in the sol! macro
    evm::log(Log {
        sender: Address::from([0x11; 20]),
        message: "Hello world!".to_string(),
    });

    // no data, but event will still log to the chain
    evm::log(AnotherLog {});

    // set up local variables
    let user = Address::from([0x22; 20]);
    let balance = U256::from(10_000_000);

    // declare up to 4 topics
    // topics must be of type FixedBytes<32>
    let topics = &[user.into_word()];

    // store non-indexed data in a byte Vec
    let mut data: Vec<u8> = vec![];
    // to_be_bytes means 'to big endian bytes'
    data.extend_from_slice(balance.to_be_bytes::<32>().to_vec().as_slice());

    // unwrap() here 'consumes' the Result
    evm::raw_log(topics.as_slice(), data.as_ref()).unwrap();

    Ok(Vec::new())
}
}
```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus_events_example"
version = "0.1.7"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"
```

---

# Function • Stylus by Example | Arbitrum Docs

## Functions

Functions are a fundamental part of any programming language, including Stylus, enabling you to encapsulate logic into reusable components.

This guide covers the syntax and usage of functions, including internal and external functions, and how to return multiple values.

Learn More[​](#learn-more "Direct link to Learn More")
------------------------------------------------------

*   [Rust docs - Functions](https://doc.rust-lang.org/reference/items/functions.html)
*   [Solidity docs - Functions](https://solidity-by-example.org/function/)

Overview[​](#overview "Direct link to Overview")
------------------------------------------------

A function in Stylus consists of a name, a set of parameters, an optional return type, and a body.

Just as with storage, Stylus methods are Solidity ABI equivalent. This means that contracts written in different programming languages are fully interoperable.

Functions are declared with the `fn` keyword. Parameters allow the function to accept inputs, and the return type specifies the output of the function. If no return type is specified, the function returns `void`.

Following is an example of a function `add` that takes two `uint256` values and returns their sum.

note

This code has yet to be audited. Please use at your own risk.

```rust
fn add(a: uint256, b: uint256) -> uint256 {
    return a + b;
}
```

Function Parameters[​](#function-parameters "Direct link to Function Parameters")
---------------------------------------------------------------------------------

Function parameters are the inputs to a function. They are specified as a list of `IDENTIFIER: Type` pairs, separated by commas.

In this example, the function `add_numbers` takes two `u32` parameters, `a` and `b` and returns the sum of the two numbers.

```rust
fn add_numbers(a: u32, b: u32) -> u32 {
    a + b
}
```

Return Types[​](#return-types "Direct link to Return Types")
------------------------------------------------------------

Return types in functions are an essential part of defining the behavior and expected outcomes of your smart contract methods.

Here, we explain the syntax and usage of return types in Stylus with general examples.

### Basic Syntax[​](#basic-syntax "Direct link to Basic Syntax")

A function with a return type in Stylus follows this basic structure. The return type is specified after the `->` arrow. Values are returned using the `return` keyword or implicitly as the last expression of the function. In Rust and Stylus, the last expression in a function is implicitly returned, so the `return` keyword is often omitted.

```rust
pub fn function_name(&self) -> ReturnType {
    // Function body
}
```

Examples[​](#examples "Direct link to Examples")
------------------------------------------------

**Function returning a String:** This `get_greeting` function returns a `String`. The return type is specified as `String` after the `->` arrow.

```rust
pub fn get_greeting() -> String {
    "Hello, Stylus!".into()
}
```

**Function returning an Integer:** This `get_number` function returns an unsigned 32-bit integer (`u32`).

```rust
pub fn get_number() -> u32 {
    42
}
```

**Function returning a Result with `Ok` and `Err` variants:** The `perform_operation` function returns a `Result<u32, CustomError>`. The `Result` type is used for functions that can return either a success value (`Ok`) or an error (`Err`). In this case, it returns `Ok(value)` on success and an error variant of `CustomError` on failure.

```rust
pub enum CustomError {
    ErrorVariant,
}

pub fn perform_operation(value: u32) -> Result<u32, CustomError> {
    if value > 0 {
        Ok(value)
    } else {
        Err(CustomError::ErrorVariant)
    }
}
```

Public Functions[​](#public-functions "Direct link to Public Functions")
------------------------------------------------------------------------

Public functions are those that can be called by other contracts.

To define a public function in a Stylus contract, you use the `#[public]` macro. This macro ensures that the function is accessible from outside the contract.

Previously, all public methods were required to return a `Result` type with `Vec<u8>` as the error type. This is now optional. Specifically, if a method is "infallible" (i.e., it cannot produce an error), it does not need to return a Result type. Here's what this means:

*   Infallible methods: Methods that are guaranteed not to fail (no errors possible) do not need to use the `Result` type. They can return their result directly without wrapping it in `Result`.
    
*   Optional error handling: The `Result` type with `Vec<u8>` as the error type is now optional for methods that cannot produce an error.
    

In the following example, `owner` is a public function that returns the contract owner's address. Since this function is infallible (i.e., it cannot produce an error), it does not need to return a `Result` type.

```rust
#[external]
impl Contract {
    // Define an external function to get the owner of the contract
    pub fn owner(&self) -> Address {
        self.owner.get()
    }
}
```

Internal Functions[​](#internal-functions "Direct link to Internal Functions")
------------------------------------------------------------------------------

Internal functions are those that can only be called within the contract itself. These functions are not exposed to external calls.

To define an internal function, you simply include it within your contract's implementation without the `#[public]` macro.

The choice between public and internal functions depends on the desired level of accessibility and interaction within and across contracts.

In the followinge example, `set_owner` is an internal function that sets a new owner for the contract. It is only callable within the contract itself.

```rust
impl Contract {
    // Define an internal function to set a new owner
    pub fn set_owner(&mut self, new_owner: Address) {
        self.owner.set(new_owner);
    }
}
```

To mix public and internal functions within the same contract, you should use two separate `impl` blocks with the same contract name. Public functions are defined within an `impl` block annotated with the `#[public]` attribute, signifying that these functions are part of the contract's public interface and can be invoked from outside the contract. In contrast, internal functions are placed within a separate `impl` block that does not have the `#[public]` attribute, making them internal to the contract and inaccessible to external entities.

### src/lib.rs[​](#srclibrs "Direct link to src/lib.rs")

```rust
// Only run this as a WASM if the export-abi feature is not set.
#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;

use alloc::vec;
use stylus_sdk::alloy_primitives::Address;
use stylus_sdk::prelude::*;
use stylus_sdk::storage::StorageAddress;

use stylus_sdk::alloy_primitives::U256;
use stylus_sdk::storage::StorageU256;
use stylus_sdk::console;


#[storage]
#[entrypoint]
pub struct ExampleContract {
    owner: StorageAddress,
    data: StorageU256,
}

#[public]
impl ExampleContract {
    // External function to set the data
    pub fn set_data(&mut self, value: U256) {
        self.data.set(value);
    }

    // External function to get the data
    pub fn get_data(&self) -> U256 {
        self.data.get()
    }

    // External function to get the contract owner
    pub fn get_owner(&self) -> Address {
        self.owner.get()
    }
}

impl ExampleContract {
    // Internal function to set a new owner
    pub fn set_owner(&mut self, new_owner: Address) {
        self.owner.set(new_owner);
    }

    // Internal function to log data
    pub fn log_data(&self) {
        let _data = self.data.get();
        console!("Current data is: {:?}", _data);
    }
}
```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus-functions"
version = "0.1.0"
edition = "2021"

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"
sha3 = "0.10.8"

[features]
export-abi = ["stylus-sdk/export-abi"]
debug = ["stylus-sdk/debug"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"
```

---

# Function selector • Stylus by Example | Arbitrum Docs

## Function selector

When a smart contract is called, the first 4 bytes of the calldata sent as part of the request are called the "function selector", and identify which function of the smart contract to call.

You can compute a specific function selector by using the `function_selector!` macro.

Here's an example that computes the selector of a function named `foo`:

note

This code has yet to be audited. Please use at your own risk.

```rust
function_selector!("foo") // returns 0xc2985578
```

Functions usually take a number of arguments that you need to pass in order for the call to be successful. For example, here's the signature of a function that takes 2 arguments, an address and a uint256:

```rust
function transfer(address recipient, uint256 amount) external returns (bool);
```

To compute the selector for this function, pass the types of the arguments to the `function_selector` macro:

```rust
function_selector!("transfer", Address, U256) // returns 0xa9059cbb
```

`function_selector` will return a byte array containing the encoded function selector.

Learn More[​](#learn-more "Direct link to Learn More")
------------------------------------------------------

*   [`stylus_sdk::function_selector`](https://docs.rs/stylus-sdk/latest/stylus_sdk/macro.function_selector.html)

---

# Hasing with keccak256 • Stylus by Example | Arbitrum Docs

## Hasing with keccak256 • Stylus by Example

Hashing with keccak256[​](#hashing-with-keccak256 "Direct link to Hashing with keccak256")
------------------------------------------------------------------------------------------

Keccak256 is a cryptographic hash function that takes an input of an arbitrary length and produces a fixed-length output of 256 bits.

Keccak256 is a member of the [SHA-3](https://en.wikipedia.org/wiki/SHA-3) family of hash functions.

keccak256 computes the Keccak-256 hash of the input.

Some use cases are:

*   Creating a deterministic unique ID from a input
*   Commit-Reveal scheme
*   Compact cryptographic signature (by signing the hash instead of a larger input)

Here we will use [`stylus-sdk::crypto::keccak`](https://docs.rs/stylus-sdk/latest/stylus_sdk/crypto/fn.keccak.html) to calculate the keccak256 hash of the input data:

note

This code has yet to be audited. Please use at your own risk.

```rust
pub fn keccak<T: AsRef<[u8]>>(bytes: T) -> B256
```

Full Example code:
==================

### src/main.rs[​](#srcmainrs "Direct link to src/main.rs")

```rust
// Only run this as a WASM if the export-abi feature is not set.
#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;

/// Import items from the SDK. The prelude contains common traits and macros.
use stylus_sdk::{alloy_primitives::{U256, Address, FixedBytes}, abi::Bytes, prelude::*, crypto::keccak};
use alloc::string::String;
use alloc::vec::Vec;
// Becauce the naming of alloy_primitives and alloy_sol_types is the same, so we need to re-name the types in alloy_sol_types
use alloy_sol_types::{sol_data::{Address as SOLAddress, String as SOLString, Bytes as SOLBytes, *}, SolType};
use alloy_sol_types::sol;

// Define error
sol! {
    error DecodedFailed();
}

// Error types for the MultiSig contract
#[derive(SolidityError)]
pub enum HasherError{
    DecodedFailed(DecodedFailed)
}

#[solidity_storage]
#[entrypoint]
pub struct Hasher {
}
/// Declare that `Hasher` is a contract with the following external methods.
#[public]
impl Hasher {
    
    // Encode the data and hash it
    pub fn encode_and_hash(
        &self, 
        target: Address,
        value: U256,
        func: String,
        data: Bytes,
        timestamp: U256
    ) -> FixedBytes<32> {
        // define sol types tuple
        type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
        // set the tuple
        let tx_hash_data = (target, value, func, data, timestamp);
        // encode the tuple
        let tx_hash_data_encode = TxIdHashType::abi_encode_sequence(&tx_hash_data);
        // hash the encoded data
        keccak(tx_hash_data_encode).into()
    }

    // This should always return true
    pub fn encode_and_decode(
        &self, 
        address: Address, 
        amount: U256
    ) -> Result<bool, HasherError> {
        // define sol types tuple
        type TxIdHashType = (SOLAddress, Uint<256>);
        // set the tuple
        let tx_hash_data = (address, amount);
        // encode the tuple
        let tx_hash_data_encode = TxIdHashType::abi_encode_sequence(&tx_hash_data);

        let validate = true;
        
        // Check the result
        match TxIdHashType::abi_decode_sequence(&tx_hash_data_encode, validate) {
            Ok(res) => Ok(res == tx_hash_data),
            Err(_) => {
                return Err(HasherError::DecodedFailed(DecodedFailed{}));
            },
        }   
    }
        
    // Packed encode the data and hash it, the same result with the following one
    pub fn packed_encode_and_hash_1(
        &self, 
        target: Address,
        value: U256,
        func: String,
        data: Bytes,
        timestamp: U256
    )-> FixedBytes<32> {
        // define sol types tuple
        type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
        // set the tuple
        let tx_hash_data = (target, value, func, data, timestamp);
        // encode the tuple
        let tx_hash_data_encode_packed = TxIdHashType::abi_encode_packed(&tx_hash_data);
        // hash the encoded data
        keccak(tx_hash_data_encode_packed).into()
    }

    // Packed encode the data and hash it, the same result with the above one
    pub fn packed_encode_and_hash_2(
        &self, 
        target: Address,
        value: U256,
        func: String,
        data: Bytes,
        timestamp: U256
    )-> FixedBytes<32> {
        // set the data to arrary and concat it directly
        let tx_hash_data_encode_packed = [&target.to_vec(), &value.to_be_bytes_vec(), func.as_bytes(), &data.to_vec(), &timestamp.to_be_bytes_vec()].concat();
        // hash the encoded data
        keccak(tx_hash_data_encode_packed).into()
    }


    // The func example: "transfer(address,uint256)"
    pub fn encode_with_signature(
        &self, 
        func: String, 
        address: Address, 
        amount: U256
    ) -> Vec<u8> {
        type TransferType = (SOLAddress, Uint<256>);
        let tx_data = (address, amount);
        let data = TransferType::abi_encode_sequence(&tx_data);
        // Get function selector
        let hashed_function_selector: FixedBytes<32> = keccak(func.as_bytes().to_vec()).into();
        // Combine function selector and input data (use abi_packed way)
        let calldata = [&hashed_function_selector[..4], &data].concat();
        calldata
    }

    // The func example: "transfer(address,uint256)"
    pub fn encode_with_signature_and_hash(
        &self, 
        func: String, 
        address: Address, 
        amount: U256
    ) -> FixedBytes<32> {
        type TransferType = (SOLAddress, Uint<256>);
        let tx_data = (address, amount);
        let data = TransferType::abi_encode_sequence(&tx_data);
        // Get function selector
        let hashed_function_selector: FixedBytes<32> = keccak(func.as_bytes().to_vec()).into();
        // Combine function selector and input data (use abi_packed way)
        let calldata = [&hashed_function_selector[..4], &data].concat();
        keccak(calldata).into()
    }
}
```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus-encode-hashing"
version = "0.1.0"
edition = "2021"

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"
sha3 = "0.10.8"

[features]
export-abi = ["stylus-sdk/export-abi"]
debug = ["stylus-sdk/debug"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"
```

---

# Hello World • Stylus by Example | Arbitrum Docs

## Hello World

Using the `console!` macro from the `stylus_sdk` allows you to print output to the terminal for debugging purposes. To view the output, you'll need to run a local Stylus dev node as described in the [Arbitrum docs](https://docs.arbitrum.io/stylus/how-tos/local-stylus-dev-node) and **_set the debug feature flag_** as shown in line 7 of the `Cargo.toml` file below.

The `console!` macro works similar to the built-in `println!` macro that comes with Rust.

### Examples[​](#examples "Direct link to Examples")

note

This code has yet to be audited. Please use at your own risk.

```rust
// Out: Stylus says: 'hello there!'
console!("hello there!");
// Out: Stylus says: 'format some arguments'
console!("format {} arguments", "some");

let local_variable = "Stylus";
// Out: Stylus says: 'Stylus is awesome!'
console!("{local_variable} is awesome!");
// Out: Stylus says: 'When will you try out Stylus?'
console!("When will you try out {}?", local_variable);
```

### src/main.rs[​](#srcmainrs "Direct link to src/main.rs")

```rust
#![cfg_attr(not(feature = "export-abi"), no_main)]

extern crate alloc;


use stylus_sdk::{console, prelude::*, stylus_proc::entrypoint, ArbResult};

#[storage]
#[entrypoint]
pub struct Hello;


#[public]
impl Hello {
    fn user_main(_input: Vec<u8>) -> ArbResult {
        // Will print 'Stylus says: Hello Stylus!' on your local dev node
        // Be sure to add "debug" feature flag to your Cargo.toml file as
        // shown below.
        console!("Hello Stylus!");
        Ok(Vec::new())
    }
}
```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus_hello_world"
version = "0.1.7"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = { version = "0.6.0", features = ["debug"] }
hex = "0.4.3"
sha3 = "0.10"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"
```

---

# Inheritance • Stylus by Example | Arbitrum Docs

## Inheritance

The Stylus Rust SDK replicates the composition pattern of Solidity. The `#[public]` macro provides the [Router](https://docs.rs/stylus-sdk/latest/stylus_sdk/abi/trait.Router.html) trait, which can be used to connect types via inheritance, via the `#[inherit]` macro.

**Please note:** Stylus doesn't support contract multi-inheritance yet.

Let's see an example:

note

This code has yet to be audited. Please use at your own risk.

```rust
#[public]
#[inherit(Erc20)]
impl Token {
    pub fn mint(&mut self, amount: U256) -> Result<(), Vec<u8>> {
        ...
    }
}

#[public]
impl Erc20 {
    pub fn balance_of() -> Result<U256> {
        ...
    }
}
```

In the above code, we can see how `Token` inherits from `Erc20`, meaning that it will inherit the public methods available in `Erc20`. If someone called the `Token` contract on the function `balanceOf`, the function `Erc20.balance_of()` would be executed.

Additionally, the inheriting type must implement the [Borrow](https://doc.rust-lang.org/core/borrow/trait.Borrow.html) trait for borrowing data from the inherited type. In the case above, `Token` should implement `Borrow<Erc20>`. For simplicity, `#[storage]` and `sol_storage!` provide a `#[borrow]` annotation that can be used instead of manually implementing the trait:

```rust
sol_storage! {
    #[entrypoint]
    pub struct Token {
        #[borrow]
        Erc20 erc20;
        ...
    }

    pub struct Erc20 {
        ...
    }
}
```

Methods search order[​](#methods-search-order "Direct link to Methods search order")
------------------------------------------------------------------------------------

A type can inherit multiple other types (as long as they use the `#[public]` macro). Since execution begins in the type that uses the `#[entrypoint]` macro, that type will be first checked when searching a specific method. If the method is not found in that type, the search will continue in the inherited types, in order of inheritance. If the method is not found in any of the inherited methods, the call will revert.

Let's see an example:

```rust
#[public]
#[inherit(B, C)]
impl A {
    pub fn foo() -> Result<(), Vec<u8>> {
        ...
    }
}

#[public]
impl B {
    pub fn bar() -> Result<(), Vec<u8>> {
        ...
    }
}

#[public]
impl C {
    pub fn bar() -> Result<(), Vec<u8>> {
        ...
    }

    pub fn baz() -> Result<(), Vec<u8>> {
        ...
    }
}
```

In the code above:

*   calling `foo()` will search the method in `A`, find it, and execute `A.foo()`
*   calling `bar()` will search the method in `A` first, then in `B`, find it, and execute `B.bar()`
*   calling `baz()` will search the method in `A`, `B` and finally `C`, so it will execute `C.baz()`

Notice that `C.bar()` won't ever be reached, since the inheritance goes through `B` first, which has a method named `bar()` too.

Finally, since the inherited types can also inherit other types themselves, keep in mind that method resolution finds the first matching method by [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search).

Overriding methods[​](#overriding-methods "Direct link to Overriding methods")
------------------------------------------------------------------------------

Because methods are checked in the inherited order, if two types implement the same method, the one in the higher level in the hierarchy will override the one in the lower levels, which won’t be callable. This allows for patterns where the developer imports a crate implementing a standard, like ERC-20, and then adds or overrides just the methods they want to without modifying the imported ERC-20 type.

**Important warning**: The Stylus Rust SDK does not currently contain explicit `override` or `virtual` keywords for explicitly marking override functions. It is important, therefore, to carefully ensure that contracts are only overriding the functions.

Let's see an example:

```rust
#[public]
#[inherit(B, C)]
impl A {
    pub fn foo() -> Result<(), Vec<u8>> {
        ...
    }
}

#[public]
impl B {
    pub fn foo() -> Result<(), Vec<u8>> {
        ...
    }

    pub fn bar() -> Result<(), Vec<u8>> {
        ...
    }
}
```

In the example above, even though `B` has an implementation for `foo()`, calling `foo()` will execute `A.foo()` since the method is searched first in `A`.

Learn more[​](#learn-more "Direct link to Learn more")
------------------------------------------------------

*   [`Arbitrum documentation`](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#inheritance-inherit-and-borrow)
*   [`inheritance, #[inherit] and #[borrow]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.public.html#inheritance-inherit-and-borrow)
*   [`Router trait`](https://docs.rs/stylus-sdk/latest/stylus_sdk/abi/trait.Router.html)
*   [`Borrow trait`](https://doc.rust-lang.org/core/borrow/trait.Borrow.html)
*   [`BorrowMut trait`](https://doc.rust-lang.org/core/borrow/trait.BorrowMut.html)

---

# Primitive Data Types • Stylus by Example | Arbitrum Docs

## Primitive Data Types

The **Stylus SDK** makes use of the popular **Alloy** library (from the developers of **ethers-rs** and **Foundry**) to represent various native Solidity types as Rust types and to seamlessly convert between them when needed. These are needed since there are a number of custom types (like address) and large integers that are not natively supported in Rust.

In this section, we'll focus on the following types:

*   `U256`
*   `I256`
*   `Address`
*   `Boolean`
*   `Bytes`

More in-depth documentation about the available methods and types in the Alloy library can be found in their docs. It also helps to cross-reference with Solidity docs if you don't already have a solid understanding of those types.

Learn More[​](#learn-more "Direct link to Learn More")
------------------------------------------------------

*   [Alloy docs (v0.7.6)](https://docs.rs/alloy-primitives/0.7.6/alloy_primitives/index.html)
    *   [`Address`](https://docs.rs/alloy-primitives/0.7.6/alloy_primitives/struct.Address.html)
    *   [`Signed`](https://docs.rs/alloy-primitives/0.7.6/alloy_primitives/struct.Signed.html)
    *   [`Uint`](https://docs.rs/ruint/1.10.1/ruint/struct.Uint.html)
*   [Stylus Rust SDK](https://docs.rs/stylus-sdk/latest/stylus_sdk/index.html)
    *   [`Bytes`](https://docs.rs/stylus-sdk/latest/stylus_sdk/abi/struct.Bytes.html)
*   [Solidity docs (v0.8.19)](https://docs.soliditylang.org/en/v0.8.19/types.html)

Integers[​](#integers "Direct link to Integers")
------------------------------------------------

Alloy defines a set of convenient Rust types to represent the typically sized integers used in Solidity. The type `U256` represents a 256-bit _unsigned_ integer, meaning it cannot be negative. The range for a `U256` number is 0 to 2^256 - 1.

Negative numbers are allowed for I types, such as `I256`. These represent signed integers.

*   `U256` maps to `uint256` ... `I256` maps to `int256`
*   `U128` maps to `uint128` ... `I128` maps to `int128`
*   ...
*   `U8` maps to `uint8` ... `I8` maps to `int8`

### Integer Usage[​](#integer-usage "Direct link to Integer Usage")

note

This code has yet to be audited. Please use at your own risk.

```rust
// Unsigned
let eight_bit: U8 = U8::from(1);
let two_fifty_six_bit: U256 = U256::from(0xff_u64);

// Out: Stylus says: '8-bit: 1 | 256-bit: 255'
console!("8-bit: {} | 256-bit: {}", eight_bit, two_fifty_six_bit);

// Signed
let eight_bit: I8 = I8::unchecked_from(-1);
let two_fifty_six_bit: I256 = I256::unchecked_from(0xff_u64);

// Out: Stylus says: '8-bit: -1 | 256-bit: 255'
console!("8-bit: {} | 256-bit: {}", eight_bit, two_fifty_six_bit);
```

### Expanded Integer Usage[​](#expanded-integer-usage "Direct link to Expanded Integer Usage")

```rust
// Use `try_from` if you're not sure it'll fit
let a = I256::try_from(20003000).unwrap();
// Or parse from a string
let b = "100".parse::<I256>().unwrap();
// With hex characters
let c = "-0x138f".parse::<I256>().unwrap();
// Underscores are ignored
let d = "1_000_000".parse::<I256>().unwrap();

// Math works great
let e = a * b + c - d;
// Out: Stylus says: '20003000 * 100 + -5007 - 1000000 = 1999294993'
console!("{} * {} + {} - {} = {}", a, b, c, d, e);

// Useful constants
let f = I256::MAX;
let g = I256::MIN;
let h = I256::ZERO;
let i = I256::MINUS_ONE;

// Stylus says: '5789...9967, -5789...9968, 0, -1'
console!("{f}, {g}, {h}, {i}");
// As hex: Stylus says: '0x7fff...ffff, 0x8000...0000, 0x0, 0xffff...ffff'
console!("{:#x}, {:#x}, {:#x}, {:#x}", f, g, h, i);
```

Address[​](#address "Direct link to Address")
---------------------------------------------

Ethereum addresses are 20 bytes in length, or 160 bits. Alloy provides a number of helper utilities for converting to addresses from strings, bytes, numbers, and addresses.

### Address Usage[​](#address-usage "Direct link to Address Usage")

```rust
// From a 20 byte slice, all 1s
let addr1 = Address::from([0x11; 20]);
// Out: Stylus says: '0x1111111111111111111111111111111111111111'
console!("{addr1}");

// Use the address! macro to parse a string as a checksummed address
let addr2 = address!("d8da6bf26964af9d7eed9e03e53415d37aa96045");
// Out: Stylus says: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'
console!("{addr2}");

// Format compressed addresses for output
// Out: Stylus says: '0xd8dA…6045'
console!("{addr2:#}");
```

Boolean[​](#boolean "Direct link to Boolean")
---------------------------------------------

Use native Rust primitives where it makes sense and where no equivalent Alloy primitive exists.

### Boolean Usage[​](#boolean-usage "Direct link to Boolean Usage")

```rust
let frightened: bool = true;
// Out: Stylus says: 'Boo! Did I scare you?'
console!("Boo! Did I scare you?");

let response = match frightened {
    true => "Yes!".to_string(),
    false => "No!".to_string(),
};

// Out: Stylus says: 'Yes!'
console!("{response}");
```

Bytes[​](#bytes "Direct link to Bytes")
---------------------------------------

The Stylus SDK provides this wrapper type around `Vec<u8>` to represent a `bytes` value in Solidity.

```rust
let vec = vec![108, 27, 56, 87];
let b = Bytes::from(vec);
// Out: Stylus says: '0x6c1b3857'
console!(String::from_utf8_lossy(b.as_slice()));

let b = Bytes::from(b"Hello!".to_vec());
// Out: Stylus says: 'Hello!'
console!(String::from_utf8_lossy(b.as_slice()));
```

Note: Return the `Bytes` type on your Rust function if you want to return the ABI `bytes memory` type.

Boilerplate[​](#boilerplate "Direct link to Boilerplate")
---------------------------------------------------------

### src/lib.rs[​](#srclibrs "Direct link to src/lib.rs")

```rust
#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;
use alloc::{string::ToString, vec::Vec};

use stylus_sdk::{
    alloy_primitives::{address, Address, I256, I8, U256, U8}, console, prelude::*, ArbResult
};

#[storage]
#[entrypoint]
pub struct Data {
    
}


#[public]
impl Data {
fn user_main(_input: Vec<u8>) -> ArbResult {
    // Use native Rust primitives where they make sense
    // and where no equivalent Alloy primitive exists
    let frightened: bool = true;
    // Out: Stylus says: 'Boo! Did I scare you?'
    console!("Boo! Did I scare you?");

    let _response = match frightened {
        true => "Yes!".to_string(),
        false => "No!".to_string(),
    };

    // Out: Stylus says: 'Yes!'
    console!("{_response}");

    // U256 stands for a 256-bit *unsigned* integer, meaning it cannot be
    // negative. The range for a U256 number is 0 to 2^256 - 1. Alloy provides
    // a set of unsigned integer types to represent the various sizes available
    // in the EVM.
    //    U256 maps to uint256
    //    U128 maps to uint128
    //    ...
    //    U8 maps to uint8
    let _eight_bit: U8 = U8::from(1);
    let _two_fifty_six_bit: U256 = U256::from(0xff_u64);

    // Out: Stylus says: '8-bit: 1 | 256-bit: 255'
    console!("8-bit: {} | 256-bit: {}", _eight_bit, _two_fifty_six_bit);

    // Negative numbers are allowed for I types. These represent signed integers.
    //    I256 maps to int256
    //    I128 maps to int128
    //    ...
    //    I8 maps to int8
    let _eight_bit: I8 = I8::unchecked_from(-1);
    let _two_fifty_six_bit: I256 = I256::unchecked_from(0xff_u64);

    // Out: Stylus says: '8-bit: -1 | 256-bit: 255'
    console!("8-bit: {} | 256-bit: {}", _eight_bit, _two_fifty_six_bit);

    // Additional usage of integers

    // Use `try_from` if you're not sure it'll fit
    let a = I256::try_from(20003000).unwrap();
    // Or parse from a string
    let b = "100".parse::<I256>().unwrap();
    // With hex characters
    let c = "-0x138f".parse::<I256>().unwrap();
    // Underscores are ignored
    let d = "1_000_000".parse::<I256>().unwrap();

    // Math works great
    let _e = a * b + c - d;
    // Out: Stylus says: '20003000 * 100 + -5007 - 1000000 = 1999294993'
    console!("{} * {} + {} - {} = {}", a, b, c, d, _e);

    // Useful constants
    let _f = I256::MAX;
    let _g = I256::MIN;
    let _h = I256::ZERO;
    let _i = I256::MINUS_ONE;

    // Stylus says: '5789...9967, -5789...9968, 0, -1'
    console!("{_f}, {_g}, {_h}, {_i}");
    // As hex: Stylus says: '0x7fff...ffff, 0x8000...0000, 0x0, 0xffff...ffff'
    console!("{:#x}, {:#x}, {:#x}, {:#x}", _f, _g, _h, _i);

    // Ethereum addresses are 20 bytes in length, or 160 bits. Alloy provides a number of helper utilities for converting to addresses from strings, bytes, numbers, and addresses

    // From a 20 byte slice, all 1s
    let _addr1 = Address::from([0x11; 20]);
    // Out: Stylus says: '0x1111111111111111111111111111111111111111'
    console!("{_addr1}");

    // Use the address! macro to parse a string as a checksummed address
    let _addr2 = address!("d8da6bf26964af9d7eed9e03e53415d37aa96045");
    // Out: Stylus says: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'
    console!("{_addr2}");

    // Format compressed addresses for output
    // Out: Stylus says: '0xd8dA…6045'
    console!("{_addr2:#}");

    Ok(Vec::new())
}
}
```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus_data_example"
version = "0.1.7"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"

```

---

# Sending Ether • Stylus by Example | Arbitrum Docs

## Sending Ether

We have three main ways to send Ether in Rust Stylus: using the `transfer_eth` method, using low level `call` method, and sending value while calling an external contract.

It's important to note that the `transfer_eth` method in Rust Stylus invokes the recipient contract, which may subsequently call other contracts. All the gas is supplied to the recipient, which it may burn. Conversely, the transfer method in Solidity is capped at 2300 gas. In Rust Stylus, you can cap the gas by using the low-level call method with a specified gas. An example of this is provided in the code on bottom of the page.

These two methods are exactly equivalent under the hood:

note

This code has yet to be audited. Please use at your own risk.

```rust
transfer_eth(recipient, value)?;

call(Call::new_in(self).value(value), recipient, &[])?;
```

Where to Send Ether[​](#where-to-send-ether "Direct link to Where to Send Ether")
---------------------------------------------------------------------------------

1.  **Externally Owned Account (EOA) Addresses**: Directly send Ether to an EOA address.
    
2.  **Solidity Smart Contracts with Receive Function (No Calldata)**: Send Ether to a Solidity smart contract that has a `receive` function without providing any calldata.
    
3.  **Solidity Smart Contracts with Fallback Function (With Calldata)**: Send Ether to a Solidity smart contract that has a `fallback` function by providing the necessary calldata.
    
4.  **Smart Contracts with Payable Methods (both Solidity and Stylus)**: Send Ether to smart contracts that have defined payable methods. Payable methods are identified by the `payable` modifier in Solidity, and the `#[payable]` macro in Rust.
    

Below you can find examples for each of these methods and how to define them in a Rust Stylus smart contract using the Stylus SDK:

### `src/lib.rs`[​](#srclibrs "Direct link to srclibrs")

```rust
// Only run this as a WASM if the export-abi feature is not set.
#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;

use alloy_primitives::Address;
use stylus_sdk::{
    abi::Bytes,
    call::{call, transfer_eth, Call},
    msg::{self},
    prelude::*,
};

sol_interface! {
    interface ITarget {
        function receiveEther() external payable;
    }
}

#[storage]
#[entrypoint]
pub struct SendEther {}

#[public]
impl SendEther {
    // Transfer Ether using the transfer_eth method
    // This can be used to send Ether to an EOA or a Solidity smart contract that has a receive() function implemented
    #[payable]
    pub fn send_via_transfer(to: Address) -> Result<(), Vec<u8>> {
        transfer_eth(to, msg::value())?;
        Ok(())
    }

    // Transfer Ether using a low-level call
    // This can be used to send Ether to an EOA or a Solidity smart contract that has a receive() function implemented
    #[payable]
    pub fn send_via_call(&mut self, to: Address) -> Result<(), Vec<u8>> {
        call(Call::new_in(self).value(msg::value()), to, &[])?;
        Ok(())
    }

    // Transfer Ether using a low-level call with a specified gas limit
    // This can be used to send Ether to an EOA or a Solidity smart contract that has a receive() function implemented
    #[payable]
    pub fn send_via_call_gas_limit(&mut self, to: Address, gas_amount: u64) -> Result<(), Vec<u8>> {
        call(
            Call::new_in(self).value(msg::value()).gas(gas_amount),
            to,
            &[],
        )?;
        Ok(())
    }

    // Transfer Ether using a low-level call with calldata
    // This can be used to call a Solidity smart contract's fallback function and send Ether along with calldata
    #[payable]
    pub fn send_via_call_with_call_data(
        &mut self,
        to: Address,
        data: Bytes,
    ) -> Result<(), Vec<u8>> {
        call(Call::new_in(self).value(msg::value()), to, data.as_slice())?;
        Ok(())
    }

    // Transfer Ether to another smart contract via a payable method on the target contract
    // The target contract can be either a Solidity smart contract or a Stylus contract that has a receiveEther function, which is a payable function
    #[payable]
    pub fn send_to_stylus_contract(&mut self, to: Address) -> Result<(), Vec<u8>> {
        let target = ITarget::new(to);
        let config = Call::new_in(self).value(msg::value());
        target.receive_ether(config)?;
        Ok(())
    }
}
```

### `Cargo.toml`[​](#cargotoml "Direct link to cargotoml")

```rust
[package]
name = "stylus_sending_ether_example"
version = "0.1.7"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"

```

---

# Variables • Stylus by Example | Arbitrum Docs

## Variables

In Solidity, there are 3 types of variables: local, state, and global. Local variables are not stored on the blockchain, while state variables are (and incur a much higher cost as a result). This is true of Arbitrum Stylus Rust smart contracts as well, although how they're defined is quite different.

In Rust, **local variables** are just ordinary variables you assign with `let` or `let mut` statements. Local variables are far cheaper than state variables, even on the EVM, however, Stylus local variables are more than 100x cheaper to allocate in memory than their Solidity equivalents.

Unlike Solidity, Rust was not built inherently with the blockchain in mind. It is a general purpose programming language. We therefore define specific _storage_ types to explicitly denote values intended to be stored permanently as part of the contract's state. **State variables** cost the same to store as their Solidity equivalents.

**Global variables** in Solidity, such as `msg.sender` and `block.timestamp`, are available as function calls pulled in from the `stylus_sdk` with their Rust equivalents being `msg::sender()` and `block::timestamp()`, respectively. These variables provide information about the blockchain or the active transaction.

Learn more[​](#learn-more "Direct link to Learn more")
------------------------------------------------------

*   [Rust Docs - Variables and Mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html)
*   [Stylus SDK Rust Docs - Storage](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/index.html)
*   [Stylus SDK Guide - Storage](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#storage)
*   [Solidity docs - state variables](https://docs.soliditylang.org/en/v0.8.19/structure-of-a-contract.html#state-variables)
*   [Solidity docs - global variables](https://docs.soliditylang.org/en/v0.8.19/cheatsheet.html#global-variables)

### src/lib.rs[​](#srclibrs "Direct link to src/lib.rs")

note

This code has yet to be audited. Please use at your own risk.

```rust
// Only run this as a WASM if the export-abi feature is not set.
#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;

use stylus_sdk::alloy_primitives::{U16, U256};
use stylus_sdk::prelude::*;
use stylus_sdk::storage::{StorageAddress, StorageBool, StorageU256};
use stylus_sdk::{block, console, msg};

#[storage]
#[entrypoint]
pub struct Contract {
    initialized: StorageBool,
    owner: StorageAddress,
    max_supply: StorageU256,
}

#[public]
impl Contract {
    // State variables are initialized in an `init` function.
    pub fn init(&mut self) -> Result<(), Vec<u8>> {
        // We check if contract has been initialized before.
        // We return if so, we initialize if not.
        let initialized = self.initialized.get();
        if initialized {
            return Ok(());
        }
        self.initialized.set(true);

        // We set the contract owner to the caller,
        // which we get from the global msg module
        self.owner.set(msg::sender());
        self.max_supply.set(U256::from(10_000));

        Ok(())
    }

    pub fn do_something() -> Result<(), Vec<u8>> {
        // Local variables are not saved to the blockchain
        // 16-bit Rust integer
        let _i = 456_u16;
        // 16-bit int inferred from U16 Alloy primitive
        let _j = U16::from(123);

        // Here are some global variables
        let _timestamp = block::timestamp();
        let _amount = msg::value();

        console!("Local variables: {_i}, {_j}");
        console!("Global variables: {_timestamp}, {_amount}");

        Ok(())
    }
}

```

### Cargo.toml[​](#cargotoml "Direct link to Cargo.toml")

```rust
[package]
name = "stylus_variable_example"
version = "0.1.7"
edition = "2021"
license = "MIT OR Apache-2.0"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]

[dependencies]
alloy-primitives = "=0.7.6"
alloy-sol-types = "=0.7.6"
mini-alloc = "0.4.2"
stylus-sdk = "0.6.0"
hex = "0.4.3"

[dev-dependencies]
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"

[features]
export-abi = ["stylus-sdk/export-abi"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"

```

---

# VM affordances • Stylus by Example | Arbitrum Docs

## VM affordances

The Stylus Rust SDK contains several modules for interacting with the Virtual Machine (VM), which can be imported from `stylus_sdk`.

Let's see an example:

note

This code has yet to be audited. Please use at your own risk.

```rust
use stylus_sdk::{msg};

let callvalue = msg::value();
```

This page lists the modules that are available, as well as the methods within those modules.

block[​](#block "Direct link to block")
---------------------------------------

Allows you to inspect the current block:

*   `basefee`: gets the basefee of the current block
*   `chainid`: gets the unique chain identifier of the Arbitrum chain
*   `coinbase`: gets the coinbase of the current block, which on Arbitrum chains is the L1 batch poster's address
*   `gas_limit`: gets the gas limit of the current block
*   `number`: gets a bounded estimate of the L1 block number at which the sequencer sequenced the transaction. See [Block gas limit, numbers and time](https://docs.arbitrum.io/build-decentralized-apps/arbitrum-vs-ethereum/block-numbers-and-time) for more information on how this value is determined
*   `timestamp`: gets a bounded estimate of the Unix timestamp at which the sequencer sequenced the transaction. See [Block gas limit, numbers and time](https://docs.arbitrum.io/build-decentralized-apps/arbitrum-vs-ethereum/block-numbers-and-time) for more information on how this value is determined

```rust
use stylus_sdk::{block};

let basefee = block::basefee();
let chainid = block::chainid();
let coinbase = block::coinbase();
let gas_limit = block::gas_limit();
let number = block::number();
let timestamp = block::timestamp();
```

contract[​](#contract "Direct link to contract")
------------------------------------------------

Allows you to inspect the contract itself:

*   `address`: gets the address of the current program
*   `args`: reads the invocation's calldata. The entrypoint macro uses this under the hood
*   `balance`: gets the balance of the current program
*   `output`: writes the contract's return data. The entrypoint macro uses this under the hood
*   `read_return_data`: copies the bytes of the last EVM call or deployment return result. Note: this function does not revert if out of bounds, but rather will copy the overlapping portion
*   `return_data_len`: returns the length of the last EVM call or deployment return result, or 0 if neither have happened during the program's execution

```rust
use stylus_sdk::{contract};

let address = contract::address();
contract::args();
let balance = contract::balance();
contract::output();
contract::read_return_data();
contract::return_data_len();
```

crypto[​](#crypto "Direct link to crypto")
------------------------------------------

Allows you to access VM-accelerated cryptographic functions:

*   `keccak`: efficiently computes the [keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of the given preimage

```rust
use stylus_sdk::{crypto};
use stylus_sdk::alloy_primitives::address;

let preimage = address!("361594F5429D23ECE0A88E4fBE529E1c49D524d8");
let hash = crypto::keccak(&preimage);
```

evm[​](#evm "Direct link to evm")
---------------------------------

Allows you to access affordances for the Ethereum Virtual Machine:

*   `gas_left`: gets the amount of gas remaining. See [Ink and Gas](https://docs.arbitrum.io/stylus/concepts/stylus-gas) for more information on Stylus's compute pricing
*   `ink_left`: gets the amount of ink remaining. See [Ink and Gas](https://docs.arbitrum.io/stylus/concepts/stylus-gas) for more information on Stylus's compute pricing
*   `log`: emits a typed alloy log
*   `pay_for_memory_grow`: this function exists to force the compiler to import this symbol. Calling it will unproductively consume gas
*   `raw_log`: emits an EVM log from its raw topics and data. Most users should prefer the alloy-typed [raw\_log](https://docs.rs/stylus-sdk/latest/stylus_sdk/evm/fn.raw_log.html)

```rust
use stylus_sdk::{evm};

let gas_left = evm::gas_left();
let ink_left = evm::ink_left();
evm::log(...);
evm::pay_for_memory_grow();
evm::raw_log(...);
```

Here's an example of how to emit a Transfer log:

```rust
sol! {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

fn foo() {
   ...
   evm::log(Transfer {
      from: Address::ZERO,
      to: address,
      value,
   });
}
```

msg[​](#msg "Direct link to msg")
---------------------------------

Allows you to inspect the current call

*   `reentrant`: whether the current call is reentrant
*   `sender`: gets the address of the account that called the program. For normal L2-to-L2 transactions the semantics are equivalent to that of the EVM's [CALLER](https://www.evm.codes/#33) opcode, including in cases arising from [DELEGATE\_CALL](https://www.evm.codes/#f4)
*   `value`: gets the ETH value in wei sent to the program

```rust
use stylus_sdk::{msg};

let reentrant = msg::reentrant();
let sender = msg::sender();
let value = msg::value();
```

tx[​](#tx "Direct link to tx")
------------------------------

Allows you to inspect the current transaction

*   `gas_price`: gets the gas price in wei per gas, which on Arbitrum chains equals the basefee
*   `gas_to_ink`: converts evm gas to ink. See [Ink and Gas](https://docs.arbitrum.io/stylus/concepts/stylus-gas) for more information on Stylus's compute-pricing model
*   `ink_price`: gets the price of ink in evm gas basis points. See [Ink and Gas](https://docs.arbitrum.io/stylus/concepts/stylus-gas) for more information on Stylus's compute-pricing model
*   `ink_to_gas`: converts ink to evm gas. See [Ink and Gas](https://docs.arbitrum.io/stylus/concepts/stylus-gas) for more information on Stylus's compute-pricing model
*   `origin`: gets the top-level sender of the transaction. The semantics are equivalent to that of the EVM's [ORIGIN](https://www.evm.codes/#32) opcode

```rust
use stylus_sdk::{tx};

let gas_price = tx::gas_price();
let gas_to_ink = tx::gas_to_ink();
let ink_price = tx::ink_price();
let ink_to_gas = tx::ink_to_gas();
let origin = tx::origin();
```

Learn More[​](#learn-more "Direct link to Learn More")
------------------------------------------------------

*   [`Arbitrum documentation`](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#evm-affordances)
*   [`Stylus SDK modules`](https://docs.rs/stylus-sdk/latest/stylus_sdk/index.html#modules)

---

# CLI Tools (cargo-stylus) | Arbitrum Docs

## CLI Tools (cargo-stylus)

The CLI tools provided for Stylus, specifically the `cargo-stylus` tool, are designed to help developers manage, compile, and optimize their Stylus contracts efficiently. This overview provides a summary of the tools available and how to use them effectively.

Available tools[​](#available-tools "Direct link to Available tools")
---------------------------------------------------------------------

### 1\. Optimize WASM binaries[​](#1-optimize-wasm-binaries "Direct link to 1. Optimize WASM binaries")

The `cargo-stylus` tool allows you to optimize WebAssembly (WASM) binaries, ensuring that your contracts are as efficient as possible.

*   **[Optimize WASM binaries](https://docs.arbitrum.io/stylus/how-tos/optimizing-binaries):** Learn how to optimize your WASM binaries for performance and size.

### 2\. Debug Stylus transactions[​](#2-debug-stylus-transactions "Direct link to 2. Debug Stylus transactions")

Gain insights into your Stylus contracts by debugging transactions.

*   **[Debug Stylus transactions](https://docs.arbitrum.io/stylus/how-tos/debug-stylus-transactions):** A guide to debugging transactions, helping you identify and fix issues.

### 3\. Verify contracts[​](#3-verify-contracts "Direct link to 3. Verify contracts")

Ensure that your Stylus contracts are correctly verified.

*   **[Verify contracts](https://docs.arbitrum.io/stylus/how-tos/verify-contracts):** Step-by-step instructions on how to verify your contracts using `cargo-stylus`.

Source code repository[​](#source-code-repository "Direct link to Source code repository")
------------------------------------------------------------------------------------------

The source code for `cargo-stylus` is available on GitHub. Explore the code, contribute, or use it as a reference.

*   **[cargo-stylus repository](https://github.com/OffchainLabs/stylus):** Visit the GitHub repository for more information.

Additional resources[​](#additional-resources "Direct link to Additional resources")
------------------------------------------------------------------------------------

For more advanced usage and detailed guides, refer to the following resources:

*   **[Optimize WASM binaries](https://docs.arbitrum.io/stylus/how-tos/optimizing-binaries)**
*   **[Troubleshooting](https://docs.arbitrum.io/stylus/troubleshooting-building-stylus)**
*   **[Run a Stylus dev node](https://docs.arbitrum.io/run-arbitrum-node/run-local-dev-node)**

This overview page serves as the starting point for mastering the CLI tools available for Stylus development. From optimizing your contracts to debugging and verifying them, the `cargo-stylus` toolset is integral to a smooth development experience.

---

# Gas metering | Arbitrum Docs

## Gas metering

**Gas and ink** are the pricing primitives that are used to determine the cost of handling specific opcodes and host I/Os on Stylus. For an overview of specific opcode and host I/O costs, see [Gas and ink costs](/stylus/reference/opcode-hostio-pricing).

Stylus gas costs[​](#stylus-gas-costs "Direct link to Stylus gas costs")
------------------------------------------------------------------------

Stylus introduces new pricing models for WASM programs. Intended for high-compute applications, Stylus makes the following more affordable:

*   Compute, which is generally **10-100x** cheaper depending on the program. This is primarily due to the efficiency of the WASM runtime relative to the EVM, and the quality of the code produced by Rust, C, and C++ compilers. Another factor that matters is the quality of the code itself. For example, highly optimized and audited C libraries that implement a particular cryptographic operation are usually deployable without modification and perform exceptionally well. The fee reduction may be smaller for highly optimized Solidity that makes heavy use of native precompiles vs. an unoptimized Stylus equivalent that doesn't do the same.
*   Memory, which is **100-500x** cheaper due to Stylus's novel exponential pricing mechanism intended to address Vitalik's concerns with the EVM's per-call, [quadratic memory pricing policy](https://notes.ethereum.org/@vbuterin/proposals_to_adjust_memory_gas_costs). For the first time ever, high-memory applications are possible on an EVM-equivalent chain.
*   Storage, for which the Rust SDK promotes better access patterns and type choices. Note that while the underlying [`SLOAD`](https://www.evm.codes/#54) and [`SSTORE`](https://www.evm.codes/#55) operations cost as they do in the EVM, the Rust SDK implements an optimal caching policy that minimizes their use. Exact savings depends on the program.
*   VM affordances, including common operations like `keccak` and reentrancy detection. No longer is it expensive to make safety the default.

There are, however, minor overheads to using Stylus that may matter to your application:

*   The first time a WASM is deployed, it must be _activated_. This is generally a few million gas, though to avoid testnet DoS, we've set it to a fixed 14 million. Note that you do not have to activate future copies of the same program. For example, the same NFT template can be deployed many times without paying this cost more than once. We will soon make the fees paid depend on the program, so that the gas used is based on the complexity of the WASM instead of this very conservative, worst-case estimate.
*   Calling a Stylus contract costs 128-2048 gas. We're working with Wasmer to improve setup costs, but there will likely always be some amount of gas one pays to jump into WASM execution. This means that if a contract does next to nothing, it may be cheaper in Solidity. However if a contract starts doing interesting work, the dynamic fees will quickly make up for this fixed-cost overhead.

Though conservative bounds have been chosen for testnet, all of this is subject to change as pricing models mature and further optimizations are made. Since gas numbers will vary across updates, it may make more sense to clock the time it takes to perform an operation rather than going solely by the numbers reported in receipts.

Ink and gas[​](#ink-and-gas "Direct link to Ink and gas")
---------------------------------------------------------

Because WASM opcodes are orders of magnitude faster than their EVM counterparts, almost every operation that Stylus does costs less than `1 gas`. “Fractional gas” isn’t an EVM concept, so the Stylus VM introduces a new unit of payment known as ink that’s orders of magnitude smaller.

```rust
1 gas = 10,000 ink
```

### Intuition[​](#intuition "Direct link to Intuition")

To build intuition for why this is the case, consider the `ADD` instruction.

#### In the EVM[​](#in-the-evm "Direct link to In the EVM")

1.  Pay for gas, requiring multiple look-ups of an in-memory table
2.  Consider tracing, even if disabled
3.  Pop two items of the simulated stack
4.  Add them together
5.  Push the result

#### In the Stylus VM[​](#in-the-stylus-vm "Direct link to In the Stylus VM")

1.  Execute a single x86 or ARM `ADD` instruction

Note that unlike the EVM, which charges for gas before running each opcode, the Stylus VM strategically charges for many opcodes all at once. This cuts fees considerably, since the VM only rarely needs to execute gas charging logic. Additionally, gas charging happens _inside the program_, removing the need for an in-memory table.

### The ink price[​](#the-ink-price "Direct link to The ink price")

The ink price, which measures the amount of ink a single EVM gas buys, is configurable by the chain owner. By default, the exchange rate is `1:10000`, but this may be adjusted as the EVM and Stylus VM improve over time.

For example, if the Stylus VM becomes 2x faster, instead of cutting the nominal cost of each operation, the ink price may instead be halved, allowing 1 EVM gas to buy twice as much ink. This provides an elegant mechanism for smoothly repricing resources between the two VMs as each makes independent progress.

### User experience[​](#user-experience "Direct link to User experience")

It is important to note that users never need to worry about this notion of ink. Receipts will always be measured in gas, with the exchange rate applied automatically under the hood as the VMs pass execution back and forth.

However, developers optimizing contracts may choose to measure performance in ink to pin down the exact cost of executing various routines. The [`ink_left`](https://docs.rs/stylus-sdk/0.3.0/stylus_sdk/evm/fn.ink_left.html) function exposes this value, and various methods throughout the Rust SDK optionally accept ink amounts too.

### See also[​](#see-also "Direct link to See also")

*   [Gas and ink costs](/stylus/reference/opcode-hostio-pricing): Detailed costs per opcode and host I/O
*   [Caching strategy](/stylus/how-tos/caching-contracts): Description of the Stylus caching strategy and the `CacheManager` contract

---

# Architecture overview | Arbitrum Docs

## Architecture overview

There are four main steps for bringing a Stylus program to life: **coding, activation, execution, and proving**.

Coding[​](#coding "Direct link to Coding")
------------------------------------------

Developers can now write smart contracts in any programming language that compiles to WASM.

note

Some high-level languages generate far more performant WASMs than others.

Currently, there is support for Rust, C, and C++. However, the levels of support vary. Rust has rich language support from day one, with an open-source SDK that makes writing smart contracts in Rust as easy as possible. C and C++ are supported off the bat, enabling the deployment of existing contracts in those languages on-chain with minimal modifications.

The Stylus SDK for Rust contains the smart contract development framework and language features most developers will need to use in Stylus. The SDK also makes it possible to perform all EVM-specific functionalities that smart contract developers use. Check out the [Rust SDK Guide](https://docs.arbitrum.io/stylus/rust-sdk-guide) and the [Crate Docs](https://docs.rs/stylus-sdk/latest/stylus_sdk/index.html).

Activation[​](#activation "Direct link to Activation")
------------------------------------------------------

Starting from a high-level language (such as Rust, C, or C++), the first compilation stage happens using the CLI provided in the Stylus SDK for Rust or any other compiler, such as Clang for C and C++. Once compiled, the WASM is posted onchain. Then, in an activation process, WASM gets lowered to a node's native machine code (such as ARM or x86).

Activating a Stylus program requires a new precompile, ArbWasm. This precompile produces efficient binary code tailored to a node's native assembly. During this step, a series of middlewares ensure that user programs execute safely and are deterministically fraud-proven. Instrumentation includes gas metering, depth-checking, memory charging, and more to guarantee all WASM programs are safe for the chain to execute. Stylus contracts can be called only after activation.

Gas metering is essential for certifying that computational resources are paid for. In Stylus, the unit for measuring cost is called **ink**, which is similar to Ethereum's gas but thousands of times smaller. There are two reasons why a new measurement is used: First, WASM execution is so much faster than the EVM that executing thousands of WASM opcodes could be done in the same amount of time it takes the EVM to execute one. Second, the conversion rate of ink to gas can change based on future hardware or VM improvements. For a conceptual introduction to Stylus gas and ink, see [gas and ink (Stylus)](https://docs.arbitrum.io/stylus/concepts/gas-metering).

Execution[​](#execution "Direct link to Execution")
---------------------------------------------------

Stylus programs execute in a fork of [Wasmer](https://wasmer.io/), the leading WebAssembly runtime, with minimal changes to optimize their codebase for blockchain-specific use cases. Wasmer executes native code much faster than  executes EVM bytecode, contributing to the significant gas savings that Stylus provides.

EVM contracts continue to execute the same way they were before Stylus. When calling a contract, the difference between an EVM contract and a WASM program is visible via an [EOF](https://notes.ethereum.org/@ipsilon/evm-object-format-overview)\-inspired contract header. From there, the contract executes using its corresponding runtime. Contracts written in Solidity and WASM languages can make cross-contract calls to each other, meaning a developer never has to consider which language the contract is in. Everything is interoperable.

Proving[​](#proving "Direct link to Proving")
---------------------------------------------

Nitro operates in two modes: a "happy case" where it compiles execution history to native code, and a "sad case" during validator disputes, where it compiles execution history to WASM for interactive fraud proofs on Ethereum. Stylus builds on Nitro's fraud-proving technology, allowing it to verify both execution history and WASM programs deployed by developers.

Stylus is made possible by Nitro’s ability to replay and verify disputes using WASM. Validators bisect disputes until an invalid step is identified and proven on-chain through a [“one-step proof.”](/how-arbitrum-works/interactive-fraud-proofs#general-bisection-protocol). This deterministic fraud-proving capability ensures the correctness of any arbitrary program compiled to WASM. The combination of WASM's and Nitro's properties enables this technological leap we call Stylus.

For more details on Nitro’s architecture, refer to the [documentation](/how-arbitrum-works/a-gentle-introduction) or the [Nitro whitepaper](https://github.com/OffchainLabs/nitro/blob/master/docs/Nitro-whitepaper.pdf).

Why does this matter?[​](#why-does-this-matter "Direct link to Why does this matter?")
--------------------------------------------------------------------------------------

Stylus innovates on many levels, with the key ones described here:

### One chain, many languages[​](#one-chain-many-languages "Direct link to One chain, many languages")

There are roughly 20k Solidity developers, compared to 3 million Rust developers or 12 million C developers \[[1](https://slashdatahq.medium.com/state-of-the-developer-nation-23rd-edition-the-fall-of-web-frameworks-coding-languages-711525e3df3a)\]. Developers can now use their preferred programming language, which is interoperable on any  with Stylus. By onboarding the next million developers, scaling to the next billion users becomes possible.

### A better EVM[​](#a-better-evm "Direct link to A better EVM")

Stylus' MultiVM brings the best of both worlds. Developers still get all of the benefits of the EVM, including the ecosystem and liquidity, while getting efficiency improvements and access to existing libraries in Rust, C, and C++, all without changing anything about how the EVM works. EVM equivalence is no longer the ceiling; it's the floor.

### Cheaper execution[​](#cheaper-execution "Direct link to Cheaper execution")

Stylus is a more efficient execution environment than the EVM, leading directly to gas savings for complex smart contracts. Computation and memory can be significantly cheaper. Deploying cryptography libraries can be done permissionlessly as custom application layer precompiles. Use cases that are impractical in the EVM are now possible in Stylus.

### Opt-in reentrancy[​](#opt-in-reentrancy "Direct link to Opt-in reentrancy")

Stylus doesn't just improve on cost and speed. WASM programs are also safer. Reentrancy is a common vulnerability developers can only attempt to mitigate in Solidity. Stylus provides cheap reentrancy detection, and using the Rust SDK, reentrancy is disabled by default unless intentionally overridden.

### Fully interoperable[​](#fully-interoperable "Direct link to Fully interoperable")

Solidity programs and WASM programs are completely composable. If working in Solidity, a developer can call a Rust program or rely on another dependency in a different language. If working in Rust, all Solidity functionalities are accessible out of the box.

---

# Public preview: What to expect | Arbitrum Docs

## Public preview: What to expect

Stylus is currently tagged as a `release-candidate` supported by _public preview_ documentation. This concept document explains what "public preview" means, what to expect from public preview capabilities, and how to engage with our team as you tinker.

### How products are developed at Offchain Labs[​](#how-products-are-developed-at-offchain-labs "Direct link to How products are developed at Offchain Labs")

Offchain Labs builds products in a way that aligns loosely with the spirit of "building in public". We like to release things **early and often** so that we can capture feedback and iterate in service of your needs, as empirically as possible.

To do this, some of our product offerings are documented with **public preview** disclaimers that look like this:

This banner's purpose is to set expectations while inviting readers like you to express your needs so that we can incorporate them into the way that we iterate on product.

### What to expect when using public preview offerings[​](#what-to-expect-when-using-public-preview-offerings "Direct link to What to expect when using public preview offerings")

As you tinker and provide feedback, we'll be listening. Sometimes, we'll learn something non-obvious that will result in a significant change. More commonly, you'll experience incremental improvements to the developer experience as the offering grows out of its **public preview** status, towards **stable** status.

Public preview offerings are evolving rapidly, so don't expect the degree of release notes discipline that you'd expect from a stable offering. Keep your eyes open for notifications regarding patch, minor, and major changes, along with corresponding relnotes that highlight breaking changes and new capabilities.

### How to provide feedback[​](#how-to-provide-feedback "Direct link to How to provide feedback")

Our product team primarily uses three feedback channels while iterating on public preview capabilities:

1.  **Docs**: Click on the `Request an update` button located in the top-right corner of any document to provide feedback on the docs and/or developer experience. This will lead you to a prefilled Github issue that members of our product team periodically review.
2.  **Discord**: [Join the Arbitrum Discord](https://discord.gg/arbitrum) to engage with members of the Arbitrum community and product team.
3.  **Google form**: Complete [this form](http://bit.ly/3yy6EUK) to ask for support.

### What to expect when providing feedback[​](#what-to-expect-when-providing-feedback "Direct link to What to expect when providing feedback")

Our ability to respond to feedback is determined by our ever-evolving capacity and priorities. We can't guarantee responses to all feedback submissions, but our small-but-mighty team is listening, and we'll try our best to acknowledge and respond to your feedback. No guarantees though!

_PS, [our small-but-mighty team is hiring](https://jobs.lever.co/offchainlabs)._

### Thank you![​](#thank-you "Direct link to Thank you!")

Thanks for helping us build things that meet your needs! We're excited to engage with OGs and newcomers alike; please don't hesitate to reach out.

---

# A gentle introduction to Stylus | Arbitrum Docs

## A gentle introduction: Stylus

### In a nutshell:[​](#in-a-nutshell "Direct link to In a nutshell:")

*   Stylus lets you write smart contracts in programming languages that compile to WASM, such as **Rust, C, C++, and many others**, allowing you to tap into their ecosystem of libraries and tools. Rich language and tooling support already exist for Rust. You can try the SDK and CLI with the [quickstart](https://docs.arbitrum.io/stylus/quickstart).
*   Solidity contracts and Stylus contracts are **fully interoperable**. In Solidity, you can call a Rust program and vice versa, thanks to a second, coequal WASM virtual machine.
*   Stylus contracts offer significantly **faster execution and lower gas fees** for memory and compute-intensive operations, thanks to the superior efficiency of  programs.

### What's Stylus?[​](#whats-stylus "Direct link to What's Stylus?")

Stylus is an upgrade to Arbitrum Nitro [(ArbOS 32)](https://docs.arbitrum.io/run-arbitrum-node/arbos-releases/arbos32), the tech stack powering Arbitrum One, Arbitrum Nova, and Arbitrum Orbit chains. This upgrade adds a second, coequal virtual machine to the EVM, where EVM contracts continue to behave exactly as they would in Ethereum. We call this paradigm **MultiVM** since **everything is entirely additive.**

![Stylus gives you MultiVM](/img/stylus-multivm.jpg)

This second virtual machine executes WebAssembly (WASM) rather than EVM bytecode. WASM is a modern binary format popularized by its use in major web standards, browsers, and companies to speed up computation. WASM is built to be fast, portable, and human-readable. It has sandboxed execution environments for security and simplicity. Working with WASM is nothing new for Arbitrum chains. Ever since the [Nitro upgrade](https://medium.com/offchainlabs/arbitrum-nitro-one-small-step-for-l2-one-giant-leap-for-ethereum-bc9108047450), WASM has been a fundamental component of Arbitrum's fully functioning fraud proofs.

With a WASM VM, any programming language compilable to WASM is within Stylus's scope. While many popular programming languages can compile into WASM, some compilers are more suitable for smart contract development than others, like Rust, C, and C++. Other languages like Go, Sway, Move, and Cairo are also supported. Languages that include their own runtimes, like Python and Javascript, are more complex for Stylus to support, although not impossible. Compared to Solidity, WASM programs are much more efficient for memory-intensive applications. There are many reasons for this, including the decades of compiler development for Rust and C. WASM also has a faster runtime than the EVM, resulting in faster execution. Third-party [contribution](#contributing) in the form of libraries for new and existing languages is welcomed!

### Use Cases[​](#use-cases "Direct link to Use Cases")

While many developers will be drawn to new use cases, rebuilding existing applications in Stylus will also open the door to innovation and optimization. dApps have never been faster, cheaper, or safer. Stylus can integrate easily into existing Solidity projects by calling a Stylus contract to optimize specific parts of your dApp or building the entire dApp with Stylus. It's impossible to list all of the use cases Stylus enables; think about the properties of all WASM-compatible languages! That said, here are some particularly exciting ideas:

*   **Efficient On-Chain Verification with ZK-Proofs**: Enable cost-effective onchain verification using zero-knowledge proving systems for privacy, interoperability, and more (see [case study](https://blog.arbitrum.io/renegade-stylus-case-study/)).
*   **Advanced DeFi Instruments**: Power complex financial instruments and processes like custom pricing curves for AMMs, synthetic assets, options, and futures with onchain computation via extending current protocols (ie. Uniswap V4 hooks) or building your own.
*   **High-Performance On-Chain Logic**: Support memory and compute-intensive applications like onchain games and generative art either by writing all of the application in Stylus or enhance performance of existing Solidity contracts by optimizing specific parts.
*   ****Endless Possibilities**:** Enable innovative use cases such as generative art, compute-heavy AI models, on-chain games, and projects utilizing advanced cryptography, unlocking the full potential of resource-intensive applications on-chain.

### Getting Started[​](#getting-started "Direct link to Getting Started")

1.  Utilize our [quickstart](https://docs.arbitrum.io/stylus/quickstart), [Rust SDK](https://docs.arbitrum.io/stylus/reference/overview), to help you start building.
2.  Join our Stylus Developer [Telegram](https://t.me/arbitrum_stylus) group and [Arbitrum Discord](https://discord.gg/arbitrum) for support as well as the official Arbitrum ([@Arbitrum](https://twitter.com/arbitrum)) and Arbitrum Developers ([@ArbitrumDevs](https://twitter.com/ArbitrumDevs)) X accounts for announcements.
3.  Check out the [Awesome Stylus](https://github.com/OffchainLabs/awesome-stylus) repository for various community contributed Stylus projects and tools. If you build something useful, we'd be happy to add it there.

---

# How to add a new programming language to Stylus | Arbitrum Docs

## How to add a new programming language to Stylus

[Arbitrum Stylus](/stylus/gentle-introduction) is a new technology developed for Arbitrum chains which gives smart contract developers superpowers. With Stylus, developers can write EVM-compatible smart contracts in many different programming languages, and reap massive performance gains. Stylus slashes fees, with performance gains ranging from 10-70x, and memory efficiency gains as high as 100-500x.

This is possible thanks to [WebAssembly](https://www.infoworld.com/article/3291780/what-is-webassembly-the-next-generation-web-platform-explained.html) technology, which all Stylus contracts compile to. Stylus smart contracts live under the **same Ethereum state trie** in Arbitrum nodes, and can fully interoperate with Solidity or Vyper EVM smart contracts. With Stylus, developers can write smart contracts in Rust that talk to Solidity and vice versa without any limitations.

Today, the Stylus testnet also comes with 2 officially supported [SDKs](/stylus/reference/stylus-sdk) for developers to write contracts in the [Rust](/stylus/reference/rust-sdk-guide) or [C](https://github.com/OffchainLabs/stylus-sdk-c) programming languages.

However, _anyone_ can add support for new languages in Stylus. **As long as a programming language can compile to WebAssembly**, Stylus will let you use it to write EVM-compatible smart contracts. Note that in order to be deployed onchain, your compiled program must fit under the 24Kb brotli-compressed limit, and should meet Stylus gas metering requirements.

In this document, we go over how we added support for the up-and-coming [Zig](https://ziglang.org/) programming language, which is meant to be a spiritual successor to C that comes with great performance and memory safety **within 20 lines of code**.

Why Zig?

1.  Zig contains **memory safety guardrails**, requiring developers to think hard about manual memory allocation in a prudent manner
2.  Zig is a **C equivalent** language, and its tooling is also a C compiler. This means C projects can incrementally adopt Zig when refactoring
3.  Zig is **lightning fast** and produces **small binaries**, making it suitable for blockchain applications

Programs written in Zig and deployed to Stylus have a tiny footprint and will have gas costs comparable, if not equal to, C programs.

Requirements[​](#requirements "Direct link to Requirements")
------------------------------------------------------------

*   Download and install [Zig 0.11.0](https://ziglang.org/downloads)
*   Install [Rust](https://www.rust-lang.org/tools/install), which we'll need for the [Stylus CLI tool](https://github.com/OffchainLabs/cargo-stylus) to deploy our program to the Stylus testnet

We'll also be using Rust to run an example script that can call our Zig contract on the Stylus testnet using the popular [ethers-rs](https://github.com/gakonst/ethers-rs) library.

Once Rust is installed, also install the Stylus CLI tool with

```rust
RUSTFLAGS="-C link-args=-rdynamic" cargo install --force cargo-stylus
```

Using Zig with Stylus[​](#using-zig-with-stylus "Direct link to Using Zig with Stylus")
---------------------------------------------------------------------------------------

First, let's clone the repository:

```rust
git clone https://github.com/offchainlabs/zig-on-stylus && cd zig-on-stylus
```

then delete everything inside of `main.zig`. We'll be filling it out ourselves in this tutorial.

To support Stylus, your Zig programs need to define a special entrypoint function, which takes in the length of its input args, `len`, and returns a status code `i32`, which is either 0 or 1. We won't need the Zig standard library for this.

One more thing it needs is to use a special function, called `memory_grow` which can allocate memory for your program. This function is _injected_ into all Stylus contracts as an external import. Internally, we call these `vm_hooks`, and also refer to them as `host-io's`, because they give you access to the host, EVM environment.

Go ahead and replace everything in your `main.zig` function with:

```rust
pub extern "vm_hooks" fn memory_grow(len: u32) void;

export fn mark_unused() void {
    memory_grow(0);
    @panic("");
}

// The main entrypoint to use for execution of the Stylus WASM program.
export fn user_entrypoint(len: usize) i32 {
    _ = len;
    return 0;
}
```

At the top, we declare the `memory_grow` external function for use.

Next, we can build our Zig library to a freestanding WASM file for our onchain deployment:

```rust
zig build-lib ./src/main.zig -target wasm32-freestanding -dynamic --export=user_entrypoint -OReleaseSmall --export=mark_unused
```

This is enough for us to deploy on the Stylus testnet! We'll use the [Stylus CLI tool](https://github.com/OffchainLabs/cargo-stylus), which you installed earlier using `cargo install`:

```rust
cargo stylus deploy --private-key=<YOUR_TESTNET_PRIVKEY> --wasm-file=main.wasm
```

The tool will send two transactions: one to deploy your Zig contract's code onchain, and the other to activate it for usage.

```rust
Uncompressed WASM size: 112 B
Compressed WASM size to be deployed onchain: 103 B
```

You can see that our Zig program is _tiny_ when compiled to WASM. Next, we can call our contract to make sure it works using any of your favorite Ethereum tooling. In this example below, we use the `cast` CLI tool provided by [foundry](https://github.com/foundry-rs/foundry). The contract above has been deployed to the Stylus testnet at address `0xe0CD04EA8c148C9a5A58Fee1C895bc2cf6896799`.

```rust
export ADDR=0xe0CD04EA8c148C9a5A58Fee1C895bc2cf6896799
cast call --rpc-url 'https://stylus-testnet.arbitrum.io/rpc' $ADDR '0x'
```

Calling the contract via RPC should simply return the value `0` as we programmed it to.

```rust
0x
```

### Reading input and writing output data[​](#reading-input-and-writing-output-data "Direct link to Reading input and writing output data")

Smart contracts on Ethereum, at the bare minimum, can take in data and output data as bytes. Stylus contracts are no different, and to do anything useful, we need to be able to read from user input also write our output to the caller. To do this, the Stylus runtime provides all Stylus contracts with two additional, useful host-ios:

```rust
pub extern "vm_hooks" fn read_args(dest: *u8) void;
pub extern "vm_hooks" fn write_result(data: *const u8, len: usize) void;
```

Add these near the top of your `main.zig` file.

The first, `read_args` takes in a pointer to a byte slice where the input arguments will be written to. The length of this byte slice must equal the length of the program args received in the `user_entrypoint`. We can write a helper function that uses this vm hook and gives us a byte slice in Zig we can then operate on.

```rust
// Allocates a Zig byte slice of length=`len` reads a Stylus contract's calldata
// using the read_args hostio function.
pub fn input(len: usize) ![]u8 {
    var input = try allocator.alloc(u8, len);
    read_args(@ptrCast(*u8, input));
    return input;
}
```

Next, we implement a helper function that outputs the data bytes to the Stylus contract's caller:

```rust
// Outputs data as bytes via the write_result hostio to the Stylus contract's caller.
pub fn output(data: []u8) void {
    write_result(@ptrCast(*u8, data), data.len);
}
```

Let's put these together:

```rust
// The main entrypoint to use for execution of the Stylus WASM program.
// It echoes the input arguments to the caller.
export fn user_entrypoint(len: usize) i32 {
    var in = input(len) catch return 1;
    output(in);
    return 0;
}
```

We're almost good to go, let's try to compile to WASM and deploy to the Stylus testnet. Let's run our build command again:

```rust
src/main.zig:21:20: error: use of undeclared identifier 'allocator'
    var data = try allocator.alloc(u8, len);
                   ^~~~~~~~~
```

Oops! Looks like we need an allocator to do our job here. Zig, as a language, requires programmers to think carefully about memory allocation and it's a typical pattern to require them to manually provide an allocator. There are many to choose from, but the Zig standard library already has one built specifically for WASM programs. Memory in WASM programs grows in increments of 64Kb, and the allocator from the stdlib has us covered here.

Let's try to use it by adding the following to the top of our `main.zig`

```rust
const std = @import("std");
const allocator = std.heap.WasmAllocator;
```

Our code compiles, but will it deploy onchain? Run `cargo stylus check --wasm-file=main.wasm` and see:

```rust
Caused by:
    missing import memory_grow
```

What's wrong? This means that the WasmAllocator from the Zig standard library should actually be using our special `memory_grow` hostio function underneath the hood. We can fix this by copying over the WasmAllocator.zig file from the standard library, and modifying a single line to use `memory_grow`.

You can find this file under `WasmAllocator.zig` in the OffchainLabs/zig-on-stylus repository. We can now use it:

```rust
const std = @import("std");
const WasmAllocator = @import("WasmAllocator.zig");

// Uses our custom WasmAllocator which is a simple modification over the wasm allocator
// from the Zig standard library as of Zig 0.11.0.
pub const allocator = std.mem.Allocator{
    .ptr = undefined,
    .vtable = &WasmAllocator.vtable,
};
```

Building again and running `cargo stylus check` should now succeed:

```rust
Uncompressed WASM size: 514 B
Compressed WASM size to be deployed onchain: 341 B
Connecting to Stylus RPC endpoint: https://stylus-testnet.arbitrum.io/rpc
Stylus program with same WASM code is already activated onchain
```

Let's deploy it:

```rust
cargo stylus deploy --private-key=<YOUR_TESTNET_PRIVKEY> --wasm-file=main.wasm
```

Now if we try to call it, it will output whatever input we send it, like an echo. Let's send it the input 0x123456:

```rust
export ADDR=0x20Aa65a9D3F077293993150C0345f62B50CCb549
cast call --rpc-url 'https://stylus-testnet.arbitrum.io/rpc' $ADDR '0x123456'

0x123456
```

Works!

Prime number checker implementation[​](#prime-number-checker-implementation "Direct link to Prime number checker implementation")
---------------------------------------------------------------------------------------------------------------------------------

Let's build something a little bit fancier: this time we'll implement a primality checker in Zig using an ancient algorithm called the [sieve of erathosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes). Given a number, our contract will output 1 if it is prime, or 0 otherwise. We'll implement in a pretty naive way, but leverage one of Zig's awesome features: [comptime](https://kristoff.it/blog/what-is-zig-comptime/).

The `comptime` keyword tells the Zig compiler to evaluate the code involved at compile time, allowing you to define computation that would normally make runtime more expensive and do it while your binary is being compiled! Comptime in Zig is extremely flexible. In this example, we use it to define a slice of booleans up to a certain limit at compile time, which we'll use to mark which numbers are prime or not.

```rust
fn sieve_of_erathosthenes(comptime limit: usize, nth: u16) bool {
    var prime = [_]bool{true} ** limit;
    prime[0] = false;
    prime[1] = false;
    var i: usize = 2;
    while (i * i < limit) : (i += 1) {
        if (prime[i]) {
            var j = i * i;
            while (j < limit) : (j += i)
                prime[j] = false;
        }
    }
    return prime[nth];
}
```

Checking if a number N is prime would involve just checking if the value at index N in this `prime` boolean slice is true. We can then integrate this function into our `user_entrypoint`:

```rust
// The main entrypoint to use for execution of the Stylus WASM program.
export fn user_entrypoint(len: usize) i32 {
    // Expects the input is a u16 encoded as little endian bytes.
    var input = args(len) catch return 1;
    var check_nth_prime = std.mem.readIntSliceLittle(u16, input);
    const limit: u16 = 10_000;
    if (check_nth_prime > limit) {
        @panic("input is greater than limit of 10,000 primes");
    }
    // Checks if the number is prime and returns a boolean using the output function.
    var is_prime = sieve_of_erathosthenes(limit, check_nth_prime);
    var out = input[0..1];
    if (is_prime) {
        out[0] = 1;
    } else {
        out[0] = 0;
    }
    output(out);
    return 0;
}
```

Let's check and deploy it:

```rust
Uncompressed WASM size: 10.8 KB
Compressed WASM size to be deployed onchain: 525 B
```

Our uncompressed size is big because of that giant array of booleans, but the program is highly compressible because all of them are zeros!

An instance of this program has been deployed to the Stylus testnet at address `0x0c503Bb757b1CaaD0140e8a2700333C0C9962FE4`

Interacting With Stylus contracts Using Ethers-rs[​](#interacting-with-stylus-contracts-using-ethers-rs "Direct link to Interacting With Stylus contracts Using Ethers-rs")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

An example is included in this repo under `rust-example` which uses the popular [ethers-rs](https://github.com/gakonst/ethers-rs) library to interact with our prime sieve contract on the Stylus testnet. To run it, do:

```rust
export STYLUS_PROGRAM_ADDRESS=0x0c503Bb757b1CaaD0140e8a2700333C0C9962FE4
cargo run
```

...and see:

```rust
Checking if 2 is_prime = true, took: 404.146917ms
Checking if 3 is_prime = true, took: 154.802083ms
Checking if 4 is_prime = false, took: 123.239583ms
Checking if 5 is_prime = true, took: 109.248709ms
Checking if 6 is_prime = false, took: 113.086625ms
Checking if 32 is_prime = false, took: 280.19975ms
Checking if 53 is_prime = true, took: 123.667958ms
```

Next steps[​](#next-steps "Direct link to Next steps")
------------------------------------------------------

The hostios defined in this walkthrough are not the only ones! Check out our [stylus-sdk-c](https://github.com/OffchainLabs/stylus-sdk-c) to see all the hostios you can use under `hostio.h`. These include affordances for the EVM, utilities to access storage, and utilities to call other Arbitrum smart contracts.

---

# Caching contracts with Stylus | Arbitrum Docs

## Caching contracts with Stylus

 is designed for fast computation and efficiency. However, the initialization process when entering a contract can be resource-intensive and time-consuming.

This initialization process, if repeated frequently, may lead to inefficiencies. To address this, we have implemented a caching strategy. By storing frequently accessed contracts in memory, we can avoid repeated initializations. This approach saves resources and time, significantly enhancing the speed and efficiency of contract execution.

Note

**Note that Stylus smart contracts will need to be re-activated once per year (365 days) or whenever a upgrade to Stylus (which will always involve an ArbOS upgrade), even if they are in the cache. This re-activation can be done using [`cargo-stylus`](https://github.com/OffchainLabs/cargo-stylus), a cargo subcommand for building, verifying, and deploying Arbitrum Stylus WASM contracts in Rust.**

CacheManager contract[​](#cachemanager-contract "Direct link to CacheManager contract")
---------------------------------------------------------------------------------------

The core component of our caching strategy is the [CacheManager contract](https://github.com/OffchainLabs/nitro-contracts/blob/main/src/chain/CacheManager.sol). This smart contract manages the cache, interacts with precompiles, and determines which contracts should be cached. The `CacheManager` can hold approximately 4,000 contracts in memory.

The `CacheManager` defines how contracts remain in the cache and how they compete with other contracts for cache space. Its primary purpose is to reduce high initialization costs, ensuring efficient contract activation and usage. The contract includes methods for adding and removing cache entries, querying the status of cached contracts, and managing the lifecycle of cached data.

### Key features[​](#key-features "Direct link to Key features")

The `CacheManager` plays a crucial role in our caching strategy by keeping a specific set of contracts in memory rather than retrieving them from disk. This significantly reduces the activation time for frequently accessed contracts. The `CacheManager` contract is an on-chain contract that accepts bids for inserting contract code into the cache. It then calls a precompile that loads or unloads the contracts in the `ArbOS` cache, which follows the on-chain cache but operates locally in the client and marks the contract as in or out of the cache in the `ArbOS` state.

The cache operates through an auction system where dApp developers submit bids to insert their contracts into the cache. If the cache is at capacity, lower bids are evicted to make space for higher bids. The cache maintains a minimum heap of bids for `codeHashes`, with bids encoded as `bid << 64 + index`, where `index` represents the position in the list of all bids. When an insertion exceeds the cache's maximum size, items are popped off the minimum heap and deleted until there is enough space to insert the new item. Contracts with equal bids will be popped in a random order, while the smallest bid is evicted first.

To ensure that developers periodically pay to maintain their position in the cache, we use a global decay parameter computed by `decay = block.timestamp * _decay`. This inflates the value of bids over time, making newer bids more valuable.

### Cache access and costs[​](#cache-access-and-costs "Direct link to Cache access and costs")

During activation, we compute the contract's initialization costs for both non-cached and cached initialization. These costs take into account factors such as the number of functions, types, code size, data length, and memory usage. It's important to note that accessing an uncached contract does not automatically add it to the `CacheManager`'s cache. Only explicit calls to the `CacheManager` contract will add a contract to the cache. If a contract is removed from the cache, calling the contract becomes more expensive unless it is re-added.

To see how much gas contract initialization would cost, you need to call `programInitGas(address)` from the [ArbWasm precompile](https://github.com/OffchainLabs/nitro/blob/d906798140e562500beb9005d2503b0272852298/precompiles/ArbWasm.go). This function returns both the initialization cost when the contract is cached and when it is not.

### How to use the CacheManager API[​](#how-to-use-the-cachemanager-api "Direct link to How to use the CacheManager API")

This section provides a practical guide for interacting with the `CacheManager` contract API, either directly or through the `cargo stylus` command-line tool.

Step 1: Determine the minimum bid[​](#step-1-determine-the-minimum-bid "Direct link to Step 1: Determine the minimum bid")
--------------------------------------------------------------------------------------------------------------------------

Before placing a bid, it's important to know the minimum bid required to cache the Stylys contract. This can be done using the `getMinBid` function, or using the `cargo stylus cache suggest-bid` command.

**Method 1: Direct smart contract call**

```rust
uint192 minBid = cacheManager.getMinBid(contractAddress);
```

**Method 2: Cargo stylus command**

Note that here, \[contractAddress\] is the address of the Stylus contract you want to cache.

```rust
cargo stylus cache suggest-bid [contractAddress]
```

Step 2: Place a bid[​](#step-2-place-a-bid "Direct link to Step 2: Place a bid")
--------------------------------------------------------------------------------

You can place a bid using either of the following methods:

**Method 1: Direct smart contract call**

Here, `bidAmount` is the amount you want to bid, and `contractAddress` is the address of the Stylus contract you're bidding for.

```rust
cacheManager.placeBid{value: bidAmount}(contractAddress);
```

**Method 2: Cargo stylus command**

You can place a bid using the `cargo stylus cache bid` command:

```rust
cargo stylus cache bid <--private-key-path <PRIVATE_KEY_PATH>|--private-key <PRIVATE_KEY>|--keystore-path <KEYSTORE_PATH>> [contractAddress] [bidAmount]
```

*   `[contractAddress]`: The address of the Stylus contract you want to cache.
*   `[bidAmount]`: The amount you want to bid. If not specified, the default bid is 0.

If you specify a bid amount using `cargo stylus`, it will automatically validate that the bid is greater than or equal to the result of the `getMinBid` function. If the bid is insufficient, the command will fail, ensuring that only valid bids are placed.

Step 3: Check cache status[​](#step-3-check-cache-status "Direct link to Step 3: Check cache status")
-----------------------------------------------------------------------------------------------------

To check if a specific address is cached, you can use the `cargo stylus status` command:

```rust
cargo stylus cache status --address=[contractAddress]
```

### Additional information[​](#additional-information "Direct link to Additional information")

*   Pausing Bids: The `CacheManager` contract has an `isPaused` state that can be toggled by the owner to prevent or allow new bids.
*   Checking Cache Size: You can monitor the current cache size and decay rate using the `getCacheSize` and `getDecayRate` functions respectively.

By following these steps, you can effectively interact with the `CacheManager` contract, either directly through smart contract calls or using the `cargo stylus` command-line tool. This ensures that your bids meet the necessary requirements for caching programs on the network, optimizing your contracts for faster and more efficient execution.

---

# How to debug Stylus transactions using Cargo Stylus Replay | Arbitrum Docs

## How to debug Stylus transactions using Cargo Stylus Replay

Debugging smart contracts can be challenging, especially when dealing with complex transactions. The `cargo-stylus` crate simplifies the debugging process by allowing developers to replay Stylus transactions. This tool leverages GDB to provide an interactive debugging experience, enabling developers to set breakpoints, inspect state changes, and trace the execution flow step-by-step. This capability is crucial for identifying and resolving issues, ensuring that smart contracts function correctly and efficiently.

### Overview[​](#overview "Direct link to Overview")

Cargo Stylus is a tool designed to simplify the development and debugging process for smart contracts written in Rust for the Stylus execution environment. One of its powerful features is the `cargo stylus` subcommand, which provides essential functionalities for developers:

1.  **Trace transactions**: Perform trace calls against Stylus transactions using Ethereum nodes' `debug_traceTransaction` RPC. This feature enables developers to analyze the execution flow and state changes of their transactions in a detailed manner.
2.  **Debugging with GDB or LLDB**: Replay and debug the execution of a Stylus transaction using a debugger. This allows developers to set breakpoints, inspect variables, and step through the transaction execution line by line, providing an in-depth understanding of the transaction's behavior.

### Replaying transactions[​](#replaying-transactions "Direct link to Replaying transactions")

#### Requirements[​](#requirements "Direct link to Requirements")

*   **Rust** (version 1.77 or higher)
*   **Crate**: `cargo-stylus`
*   **GNU Debugger (GDB)** (Linux) or **LLDB** (MacOS)
*   **[Cast](https://book.getfoundry.sh/cast/)** (an Ethereum CLI tool)
*   **[Arbitrum RPC Provider](#rpc-endpoint-compatibility)** with tracing endpoints enabled or a [local Stylus dev node](https://docs.arbitrum.io/run-arbitrum-node/run-nitro-dev-node)

`cargo stylus replay` allows users to debug the execution of a Stylus transaction using [GDB](https://sourceware.org/gdb/) or [LLDB](https://lldb.llvm.org/) against the Rust source code.

### Installation and setup[​](#installation-and-setup "Direct link to Installation and setup")

1.  **Install the required crates and debugger**: First, let's ensure that the following crates are installed:

```rust
cargo install cargo-stylus
```

If on Linux, install GDB if it's not already installed:

```rust
sudo apt-get install gdb
```

If on MacOS, install LLDB if it's not already installed:

```rust
xcode-select --install
```

2.  **Deploy your Stylus contract**: For this guide, we demonstrate how to debug the execution of the `increment()` method in the [stylus-hello-world](https://github.com/OffchainLabs/stylus-hello-world) smart contract. In Rust, it looks something like this, within `src/lib.rs`:

```rust
#[external]
impl Counter {
    ...
    /// Increments number and updates its value in storage.
    pub fn increment(&mut self) {
        let number = self.number.get();
        self.set_number(number + U256::from(1));
    }
    ...
}
```

Set your RPC endpoint to a node with **tracing enabled** and your private key:

```rust
export RPC_URL=...
export PRIV_KEY=...
```

and deploy your contract:

```rust
cargo stylus deploy --private-key=$PRIV_KEY --endpoint=$RPC_URL
```

You should see an output similar to:

```rust
contract size: 4.0 KB
wasm size: 12.1 KB
contract size: 4.0 KB
deployed code at address: 0x2c8d8a1229252b07e73b35774ad91c0b973ecf71
wasm already activated!
```

3.  **Send a transaction**: First, set the address of the deployed contract as an environment variable:

```rust
export ADDR=0x2c8d8a1229252b07e73b35774ad91c0b973ecf71
```

And send a transaction using `Cast`:

```rust
cast send --rpc-url=$RPC_URL --private-key=$PRIV_KEY $ADDR "increment()"
```

4.  **Replay the transaction with the debugger**: Now, we can replay the transaction with cargo stylus and the debugger to inspect each step of it against our source code. Make sure GDB is installed and that you are on a Linux, x86 system. Also, you should set the transaction hash as an environment variable:

```rust
export TX_HASH=0x18b241841fa0a59e02d3c6d693750ff0080ad792204aac7e5d4ce9e20c466835
```

And replay the transaction:

```rust
cargo stylus replay --tx=$TX_HASH --endpoint=$RPC_URL --use-native-tracer
```

Options:

```rust
--tx: Specifies the transaction hash to replay.
--endpoint: Specifies the RPC endpoint for fetching transaction data.
--use-native-tracer: Uses the native Stylus tracer instead of the default JS tracer. The native tracer has broader support from RPC providers.
```

**Note:** The `--use-native-tracer` flag uses `stylusTracer` instead of `jsTracer`, which is required for tracing Stylus transactions on most RPC providers. See more details [below](#rpc-endpoint-compatibility).

The debugger will load and set a breakpoint automatically at the `user_entrypoint` internal Stylus function. While the examples below showcase GDB commands, you can find the LLDB equivalents [here](https://lldb.llvm.org/use/map.html).

```rust
[Detaching after vfork from child process 370003]

Thread 1 "cargo-stylus" hit Breakpoint 1, stylus_hello_world::user_entrypoint (len=4) at src/lib.rs:38
38	    #[entrypoint]
(gdb)
```

5.  **Debugging**: Now, set a breakpoint at the `increment()` method:

```rust
(gdb) b stylus_hello_world::Counter::increment
Breakpoint 2 at 0x7ffff7e4ee33: file src/lib.rs, line 69.
```

Then, type `c` to continue the execution and you will reach that line where `increment` is called:

```rust
(gdb) c
```

Once you reach the `increment` method, inspect the state:

```rust
Thread 1 "cargo-stylus" hit Breakpoint 2, stylus_hello_world::Counter::increment (self=0x7fffffff9ae8) at src/lib.rs:69
69	        let number = self.number.get();
(gdb) p number
```

### Trace a transaction[​](#trace-a-transaction "Direct link to Trace a transaction")

For traditional tracing, `cargo stylus` supports calls to `debug_traceTransaction`. To trace a transaction, you can use the following command:

```rust
cargo stylus trace [OPTIONS] --tx <TX> --use-native-tracer
```

Options:

```rust
  -e, --endpoint <ENDPOINT>  RPC endpoint [default: http://localhost:8547]
  -t, --tx <TX>              Tx to replay
  -p, --project <PROJECT>    Project path [default: .]
  -h, --help                 Print help
  -V, --version              Print version
      --use-native-tracer    Uses the native Stylus tracer instead of the default JS tracer. The native tracer has broader support from RPC providers.
```

Run the following command to obtain a trace output:

```rust
cargo stylus trace --tx=$TX_HASH --endpoint=$RPC_URL --use-native-tracer
```

This will produce a trace of the functions called and [ink](https://docs.arbitrum.io/stylus/concepts/gas-metering#ink-and-gas) left along each method:

```rust
[{"args":[0,0,0,4],"endInk":846200000,"name":"user_entrypoint","outs":[],"startInk":846200000},{"args":[],"endInk":846167558,"name":"msg_reentrant","outs":[0,0,0,0],"startInk":846175958},{"args":[],"endInk":846047922,"name":"read_args","outs":[208,157,224,138],"startInk":846061362},{"args":[],"endInk":845914924,"name":"msg_value","outs":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"startInk":845928364},{"args":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"endInk":227196069,"name":"storage_load_bytes32","outs":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"startInk":844944549},{"args":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],"endInk":226716083,"name":"storage_cache_bytes32","outs":[],"startInk":226734563},{"args":[0],"endInk":226418732,"name":"storage_flush_cache","outs":[],"startInk":226486805},{"args":[],"endInk":226362319,"name":"write_result","outs":[],"startInk":226403481},{"args":[],"endInk":846200000,"name":"user_returned","outs":[0,0,0,0],"startInk":846200000}]
```

### RPC endpoint compatibility[​](#rpc-endpoint-compatibility "Direct link to RPC endpoint compatibility")

Both `cargo stylus trace` and `cargo stylus replay` require an RPC endpoint that supports `debug_traceTransaction`. By default, the `jsTracer` type is used, which is not supported by most RPC providers. If the `--use-native-tracer` flag is used, the `stylusTracer` type is used, which is supported by many RPC providers. Both `jsTracer` and `stylusTracer` are available on local nodes, but `stylusTracer` is more efficient. See this [list of RPC providers](https://docs.arbitrum.io/for-devs/dev-tools-and-resources/chain-info#third-party-rpc-providers) for tracing support.

---

# How to optimize Stylus WASM binaries | Arbitrum Docs

## How to optimize Stylus WASM binaries

To be deployed onchain, the size of your **uncompressed WebAssembly (WASM) file** must not exceed 128Kb, while the **compressed binary** must not exceed 24KB. Stylus conforms with the same contract size limit as the EVM to remain fully interoperable with all smart contracts on Arbitrum chains.

[cargo-stylus](https://github.com/OffchainLabs/cargo-stylus), the Stylus CLI tool, automatically compresses your WASM programs, but there are additional steps that you can take to further reduce the size of your binaries.

Your options fall into two categories: Rust compiler flags, and third-party optimization tools.

Rust compiler flags[​](#rust-compiler-flags "Direct link to Rust compiler flags")
---------------------------------------------------------------------------------

The Rust compiler supports various config options for shrinking binary sizes.

### `Cargo.toml`[​](#cargotoml "Direct link to cargotoml")

```rust
[profile.release]
codegen-units = 1        # prefer efficiency to compile time
panic = "abort"          # use simple panics
opt-level = "z"          # optimize for size ("s" may also work)
strip = true             # remove debug info
lto = true               # link time optimization
debug = false            # no debug data
rpath = false            # no run-time search path
debug-assertions = false # prune debug assertions
incremental = false      # no incremental builds
```

Third-party optimization tooling[​](#third-party-optimization-tooling "Direct link to Third-party optimization tooling")
------------------------------------------------------------------------------------------------------------------------

Additional WASM-specific tooling exists to shrink binaries. Due to being 3rd party, users should use these at their own risk.

### `wasm-opt`[​](#wasm-opt "Direct link to wasm-opt")

[wasm-opt](https://docs.rs/wasm-opt/0.113.0/wasm_opt/) applies techniques to further reduce binary size, usually netting around 10%.

### `twiggy`[​](#twiggy "Direct link to twiggy")

[twiggy](https://github.com/rustwasm/twiggy) is a code size profiler for WASM, it can help you estimate the impact of each added component on your binaries' size.

Our team has also curated a [list of recommended libraries](/stylus/recommended-libraries) that are helpful to Stylus development and optimally sized.

### Frequently asked questions[​](#frequently-asked-questions "Direct link to Frequently asked questions")

**Will future releases of Stylus introduce additional optimizations?**

Yes! We're actively working on improving WASM sizes generated by Rust code with the Stylus SDK.

**Why don't I have to worry about this type of optimization when I use `cargo` without using Stylus?**

On modern platforms, tools like `cargo` don’t have to worry about the size of the binaries they produce. This is because there’s many orders of magnitude more storage available than even the largest of binaries, and for most applications it’s media like images and videos that constitutes the majority of the footprint.

Resource constraints when building on blockchains are extremely strict. Hence, while not the default option, tooling often provides mechanisms for reducing binary bloat, such as the options outlined in this document.

---

# How to verify contracts for Stylus contracts | Arbitrum Docs

## How to verify contracts for Stylus contracts

caution

This page will walk you through how to verify your Stylus contracts locally. Stylus contract verification is also available on [Arbiscan](https://arbiscan.io/). Please note, however, that Stylus contract verification on Arbiscan is only supported for Stylus contracts deployed using `cargo-stylus` 0.5.0 or higher.

Background[​](#background "Direct link to Background")
------------------------------------------------------

Stylus contracts written in Rust and deployed onchain can be verified against a local codebase by using the `cargo stylus` tool.

Goals[​](#goals "Direct link to Goals")
---------------------------------------

*   To ensure Stylus contract deployments are reproducible by anyone who is running the same architecture as the deployed item
*   To sandbox the reproducible environment and standardize it as much as possible to prevent foot guns
*   To guarantee that programs reproducibly deployed with a cargo stylus version >= 0.4.2 are verifiable

Opting out[​](#opting-out "Direct link to Opting out")
------------------------------------------------------

By default, `cargo stylus deploy` is reproducible as it runs in a Docker container. Users can opt-out by specifying `--no-verify` as a flag.

Reproducible deployments[​](#reproducible-deployments "Direct link to Reproducible deployments")
------------------------------------------------------------------------------------------------

Required knowledge and setup:

*   System architecture of your host computer (x86 / ARM)
*   The git commit of your project used for deployment
*   A **Rust** stylus project, such as [OffchainLabs/stylus-hello-world](https://github.com/OffchainLabs/stylus-hello-world) which contains a `rust-toolchain.toml` file
*   Your cargo stylus version (run `cargo stylus --version` to obtain this value)
*   [Docker](https://www.docker.com/) installed and running on your machine

Your project's [toolchain](https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file) file must contain the Rust version you wish to use for your deployment, such as `major.minor.patch`

```rust
[toolchain]
channel = "1.79.0"
```

It **cannot** be `stable`, `nightly`, or `beta` by itself, as a specific version must be added. For instance, you can specify `nightly-YYYY-MM-DD` or `major.minor.patch` for your channel. This is so that deployments have a very specific version to prevent potential mismatches from being more generic.

```rust
# Replace {PRIV_KEY} with your actual private key or set it as a local variable
cargo stylus deploy --private-key={PRIV_KEY} --verbose
```

Upon completion, you will obtain the deployment transaction hash:

```rust
deployment tx hash: 0x1d8ae97e245e1db21dd188e5b64ad9025c1fb4e5f82a8d38bc8ae2b7a387600b
```

Save this tx hash, as verifiers will need it.

Reproducible verification[​](#reproducible-verification "Direct link to Reproducible verification")
---------------------------------------------------------------------------------------------------

To verify a program, the verifier will need Docker installed and also know:

*   System architecture the deployer used (x86 / ARM). Note: ARM devices that can emulate x86, such as Mac M series via rosetta, can verify x86 Stylus deployments
*   The git commit of the project the deployer used
*   Your cargo stylus version the deployer used
*   The deployment transaction hash

Navigate to the project's directory and check out the git commit that was used at deployment. Ensure your `cargo stylus --version` matches what the deployer used.

```rust
# Replace {DEPLOYMENT_TX_HASH} with the actual DEPLOYMENT_TX_HASH or set it as a local variable
cargo stylus verify --deployment-tx={DEPLOYMENT_TX_HASH}
```

This command will run the verification pipeline through a Docker environment, recreate the project metadata hash, and verify that the deployed program matches what the command reconstructed locally.

How it works[​](#how-it-works "Direct link to How it works")
------------------------------------------------------------

On deployment, a `keccak256` hash is created from the contents of all Rust source files in the project, sorted by file path, along with a rust-toolchain.toml, Cargo.toml and Cargo.lock files by default. This hash is injected in as a custom section of the user wasm's code. This means all data in the source files will be used for reproducible verification of a Stylus contract, including code comments.

This means the `codehash` onchain of the program will change due to this deployment metadata hash.

The verification routine fetches the deployment transaction by hash via RPC, then attempts to build the local project to reconstruct the deployment init code and WASM using cargo build. It then checks that the deployment tx data matches the created init code.

Important details[​](#important-details "Direct link to Important details")
---------------------------------------------------------------------------

**Docker image** The Docker container used for reproducibility standardizes all builds to x86, and it looks like this:

```rust
FROM --platform=linux/amd64 rust:1.79 as builder
RUN rustup toolchain install $VERSION-x86_64-unknown-linux-gnu
RUN rustup default $VERSION-x86_64-unknown-linux-gnu
RUN rustup target add wasm32-unknown-unknown
RUN rustup target add wasm32-wasi
RUN rustup target add x86_64-unknown-linux-gnu
RUN cargo install cargo-stylus
```

The docker container uses the `rust:1.79` version as a base for all projects. This will install cargo tooling and rust targets, but the toolchain actually used for compilation will be specified by the project being deployed in its `rust-toolchain.toml` file.

For instance, **a future toolchain can be used** despite the base image being 1.79, as when cargo stylus is installed, it will use that particular toolchain. Future cargo stylus updates could update this base image but may not impact the compiled WASM as the image will be using the specified toolchain. However, this is why knowing the specific cargo stylus version used for the reproducible verification from the deployer is important.

**The build toolchain**

All verifiable Stylus contracts in Rust _must_ have a standard [rust-toolchain.toml](https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file) file which specifies the channel for their deployment. It **cannot** be `stable`, `nightly`, or `beta` by itself, as a specific version must be added. For instance, you can specify `nightly-YYYY-MM-DD` or `major.minor.patch` for your channel. This is so that deployments have a very specific version to prevent potential mismatches from being more generic.

---

# How to verify Stylus contracts on Arbiscan | Arbitrum Docs

## How to verify Stylus contracts on Arbiscan

This how-to will show you how to verify deployed contracts using Arbiscan, Arbitrum's block explorer.

Here's an example of a verified contract: the [English Auction Stylus contract](https://github.com/OffchainLabs/stylus-english-auction), which has been verified on Arbitrum Sepolia. You can view the verified contract [here](https://sepolia.arbiscan.io/address/0xe85a046fd3ea22ceeb3caef3a0d38123eecbe3ca).

You can also see a list of all Stylus contracts verified on Arbiscan by visiting:

*   [Verified Stylus Contracts on Arbitrum One](https://arbiscan.io/contractsVerified?filter=stylus).
*   [Verified Stylus Contracts on Arbitrum Sepolia](https://sepolia.arbiscan.io/contractsVerified?filter=stylus).

Here are the steps to take to verify a contract on Arbiscan:

Step 1: Navigate to the verification page[​](#step-1-navigate-to-the-verification-page "Direct link to Step 1: Navigate to the verification page")
--------------------------------------------------------------------------------------------------------------------------------------------------

You have two options to access the contract verification page on Arbiscan:

1.  **Direct link:** Visit [Arbiscan Verify Contract](https://arbiscan.io/verifyContract) to go directly to the verification form. This option is ideal if you already have the contract address and details ready.
2.  **From the contract page:** If you're viewing the contract's page on Arbiscan:
    *   Go to the **Contract** tab.
    *   Click on **Verify and Publish**.

![Verify through the contract page](/img/stylus-arbiscan-verification-1.png)

Both methods will take you to the contract verification form, where you can proceed to the next step.

Step 2: Enter the contract's details[​](#step-2-enter-the-contracts-details "Direct link to Step 2: Enter the contract's details")
----------------------------------------------------------------------------------------------------------------------------------

You will need to fill in the following fields on the contract verification page:

*   **Contract address**: Enter the contract address you want to verify.
*   **Compiler type**: Select **Stylus** for Stylus contracts.
*   **Compiler version**: Choose the `cargo stylus` version that was used to deploy the contract.
*   **Open source license type**: Select the appropriate license for your contract.

![Enter contract details](/img/stylus-arbiscan-verification-2.png)

Step 3: Submit source code[​](#step-3-submit-source-code "Direct link to Step 3: Submit source code")
-----------------------------------------------------------------------------------------------------

After entering the contract details, you’ll need to provide the contract's source code:

*   **Manual submission**: Copy and paste the source code into the provided text box.
*   **Fetch from GitHub (Recommended)**: It's recommended to use the **Fetch from Git** option, as it's easier and helps automate the process. However, note that contracts located in subdirectories of the repository cannot be verified. Ensure that the contract's code is placed directly in the repository's root for verification to succeed.

![Fetch source code](/img/stylus-arbiscan-verification-3.png)

Step 4: Set EVM version[​](#step-4-set-evm-version "Direct link to Step 4: Set EVM version")
--------------------------------------------------------------------------------------------

The **EVM Version to Target** can be left as default unless specific requirements dictate otherwise.

![Verify and publish](/img/stylus-arbiscan-verification-4.png)

Step 5: Verify and publish[​](#step-5-verify-and-publish "Direct link to Step 5: Verify and publish")
-----------------------------------------------------------------------------------------------------

Click **Verify and Publish**. The verification process will take a few seconds. Refresh the contract page, and if successful, the contract will be marked as verified.

![Verified](/img/stylus-arbiscan-verification-5.png)

Behavior when deploying a verified contract[​](#behavior-when-deploying-a-verified-contract "Direct link to Behavior when deploying a verified contract")
---------------------------------------------------------------------------------------------------------------------------------------------------------

When deploying another instance of a previously verified contract, if the bytecode matches, Arbiscan will automatically link the new instance to the verified source code, displaying a message like:

> "This contract matches the deployed Bytecode of the Source Code for Contract \[verified contract address\]."

However, the new contract will still appear as "Not Verified" until you explicitly verify it.

---

# Quickstart: write a smart contract in Rust using Stylus | Arbitrum Docs

## Quickstart: write a smart contract in Rust using Stylus

![](/img/stylus-primary.svg)

This guide will get you started with ' basics. We'll cover the following steps:

1.  [Setting up your development environment](/stylus/quickstart#setting-up-your-development-environment)
2.  [Creating a Stylus project with cargo stylus](/stylus/quickstart#creating-a-stylus-project-with-cargo-stylus)
3.  [Checking the validity of your contract](/stylus/quickstart#checking-if-your-stylus-project-is-valid)
4.  [Deploying your contract](/stylus/quickstart#deploying-your-contract)
5.  [Exporting your contract's ABIs](#exporting-the-solidity-abi-interface)
6.  [Calling your contract](/stylus/quickstart#calling-your-contract)
7.  [Sending a transaction to your contract](/stylus/quickstart#sending-a-transaction-to-your-contract)

Setting up your development environment[​](#setting-up-your-development-environment "Direct link to Setting up your development environment")
---------------------------------------------------------------------------------------------------------------------------------------------

### Prerequisites[​](#prerequisites "Direct link to Prerequisites")

Rust toolchain

Follow the instructions on [Rust Lang's installation page](https://www.rust-lang.org/tools/install) to install a complete Rust toolchain (v1.81 or newer) on your system. After installation, ensure you can access the programs `rustup`, `rustc`, and `cargo` from your preferred terminal application.

VS Code

We recommend [VSCode](https://code.visualstudio.com/) as the IDE of choice for its excellent Rust support, but feel free to use another text editor or IDE if you're comfortable with those.

Some helpful VS Code extensions for Rust development:

*   [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer): Provides advanced features like smart code completion and on-the-fly error checks
*   [Error Lens](https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens): Immediately highlights errors and warnings in your code
*   [Even Better TOML](https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml): Improves syntax highlighting and other features for TOML files, often used in Rust projects
*   [Dependi](https://marketplace.visualstudio.com/items?itemName=fill-labs.dependi): Helps manage Rust crate versions directly from the editor

Docker

The testnode we will use as well as some `cargo stylus` commands require Docker to operate.

You can download Docker from [Docker's website](https://www.docker.com/products/docker-desktop).

Foundry's Cast

Foundry's Cast is a command-line tool that allows you to interact with your EVM contracts. You need to [install the Foundry CLI](https://getfoundry.sh) to use Cast.

Nitro devnode

Stylus is available on Arbitrum Sepolia, but we'll use nitro devnode which has a pre-funded wallet saving us the effort of wallet provisioning or running out of tokens to send transactions.

Install your devnode

```rust
git clone https://github.com/OffchainLabs/nitro-devnode.git
cd nitro-devnode
```

Launch your devnode

```rust
./run-dev-node.sh
```

Creating a Stylus project with cargo stylus[​](#creating-a-stylus-project-with-cargo-stylus "Direct link to Creating a Stylus project with cargo stylus")
---------------------------------------------------------------------------------------------------------------------------------------------------------

[cargo stylus](https://github.com/OffchainLabs/cargo-stylus/blob/main/main/VALID_WASM.md) is a CLI toolkit built to facilitate the development of Stylus contracts.

It is available as a plugin to the standard cargo tool used for developing Rust programs.

### Installing cargo stylus[​](#installing-cargo-stylus "Direct link to Installing cargo stylus")

In your terminal, run:

```rust
cargo install --force cargo-stylus
```

Add WASM ([WebAssembly](https://webassembly.org/)) as a build target for the specific Rust toolchain you are using. The below example sets your default Rust toolchain to 1.80 as well as adding the WASM build target:

```rust
rustup default 1.80
rustup target add wasm32-unknown-unknown --toolchain 1.80
```

You can verify that cargo stylus is installed by running `cargo stylus --help` in your terminal, which will return a list of helpful commands, we will use some of them in this guide:

cargo stylus --help returns:

```rust
Cargo command for developing Stylus projects

Usage: cargo stylus <COMMAND>

Commands:
  new         Create a new Stylus project
  init        Initializes a Stylus project in the current directory
  export-abi  Export a Solidity ABI
  activate    Activate an already deployed contract [aliases: a]
  cache       Cache a contract using the Stylus CacheManager for Arbitrum chains
  check       Check a contract [aliases: c]
  deploy      Deploy a contract [aliases: d]
  verify      Verify the deployment of a Stylus contract [aliases: v]
  cgen        Generate c code bindings for a Stylus contract
  replay      Replay a transaction in gdb [aliases: r]
  trace       Trace a transaction [aliases: t]
  help        Print this message or the help of the given command(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
```

### Creating a project[​](#creating-a-project "Direct link to Creating a project")

Let's create our first Stylus project by running:

```rust
cargo stylus new <YOUR_PROJECT_NAME>
```

`cargo stylus new` generates a starter template that implements a Rust version of the [Solidity `Counter` smart contract example](https://github.com/OffchainLabs/counter_contract/blob/master/contracts/Counter.sol).

At this point, you can move on to the next step of this guide or develop your first Rust smart contract. Feel free to use the [Stylus Rust SDK reference section](/stylus/reference/overview) as a starting point; it offers many examples to help you quickly familiarize yourself with Stylus.

Checking if your Stylus project is valid[​](#checking-if-your-stylus-project-is-valid "Direct link to Checking if your Stylus project is valid")
------------------------------------------------------------------------------------------------------------------------------------------------

By running `cargo stylus check` against your first contract, you can check if your program can be successfully **deployed and activated** onchain.

**Important:** Ensure your Docker service runs so this command works correctly.

```rust
cargo stylus check
```

`cargo stylus check` executes a dry run on your project by compiling your contract to WASM and verifying if it can be deployed and activated onchain.

If the command above fails, you'll see detailed information about why your contract would be rejected:

```rust
Reading WASM file at bad-export.wat
Compressed WASM size: 55 B
Stylus checks failed: program pre-deployment check failed when checking against
ARB_WASM_ADDRESS 0x0000…0071: (code: -32000, message: program activation failed: failed to parse program)

Caused by:
    binary exports reserved symbol stylus_ink_left

Location:
    prover/src/binary.rs:493:9, data: None
```

The contract can fail the check for various reasons (on compile, deployment, etc...). Reading the [Invalid Stylus WASM Contracts explainer](https://github.com/OffchainLabs/cargo-stylus/blob/main/main/VALID_WASM.md) can help you understand what makes a WASM contract valid or not.

If your contract succeeds, you'll see something like this:

```rust
Finished release [optimized] target(s) in 1.88s
Reading WASM file at hello-stylus/target/wasm32-unknown-unknown/release/hello-stylus.wasm
Compressed WASM size: 3 KB
Program succeeded Stylus onchain activation checks with Stylus version: 1
```

Note that running `cargo stylus check` may take a few minutes, especially if you're verifying a contract for the first time .

See `cargo stylus check --help` for more options.

Deploying your contract[​](#deploying-your-contract "Direct link to Deploying your contract")
---------------------------------------------------------------------------------------------

Once you're ready to deploy your contract onchain, `cargo stylus deploy` will help you with the deployment and its gas estimation.

### Estimating gas[​](#estimating-gas "Direct link to Estimating gas")

Note: For every transaction, we'll use the testnode pre-funded wallet, you can use `0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659` as your private key.

You can estimate the gas required to deploy your contract by running:

```rust
cargo stylus deploy \
  --endpoint='http://localhost:8547' \
  --private-key="0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659" \
  --estimate-gas
```

The command should return something like this:

```rust
deployment tx gas: 7123737
gas price: "0.100000000" gwei
deployment tx total cost: "0.000712373700000000" ETH
```

### Deployment[​](#deployment "Direct link to Deployment")

Let's move on to the contract's actual deployment. Two transactions will be sent onchain: the contract deployment and its activation.

```rust
cargo stylus deploy \
  --endpoint='http://localhost:8547' \
  --private-key="0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659"
```

Once the deployment and activations are successful, you'll see an output similar to this:

```rust
deployed code at address: 0x33f54de59419570a9442e788f5dd5cf635b3c7ac
deployment tx hash: 0xa55efc05c45efc63647dff5cc37ad328a47ba5555009d92ad4e297bf4864de36
wasm already activated!
```

Make sure to save the contract's deployment address for future interactions!

More options are available for sending and outputting your transaction data. See `cargo stylus deploy --help` for more details.

Exporting the Solidity ABI interface[​](#exporting-the-solidity-abi-interface "Direct link to Exporting the Solidity ABI interface")
------------------------------------------------------------------------------------------------------------------------------------

The cargo stylus tool makes it easy to export your contract's ABI using `cargo stylus export-abi`.

This command returns the Solidity ABI interface of your smart contract. If you have been running `cargo stylus new` without modifying the output, `cargo stylus export-abi` will return:

```rust
/**
 * This file was automatically generated by Stylus and represents a Rust program.
 * For more information, please see [The Stylus SDK](https://github.com/OffchainLabs/stylus-sdk-rs).
 */

// SPDX-License-Identifier: MIT-OR-APACHE-2.0
pragma solidity ^0.8.23;

interface ICounter {
    function number() external view returns (uint256);

    function setNumber(uint256 new_number) external;

    function mulNumber(uint256 new_number) external;

    function addNumber(uint256 new_number) external;

    function increment() external;
}
```

Ensure you save the console output to a file that you'll be able to use with your .

Interacting with your Stylus contract[​](#interacting-with-your-stylus-contract "Direct link to Interacting with your Stylus contract")
---------------------------------------------------------------------------------------------------------------------------------------

Stylus contracts are EVM-compatible, you can interact with them with your tool of choice, such as [Hardhat](https://hardhat.org/), [Foundry's Cast](https://book.getfoundry.sh/cast/), or any other Ethereum-compatible tool.

In this example, we'll use Foundry's Cast to send a call and then a transaction to our contract.

### Calling your contract[​](#calling-your-contract "Direct link to Calling your contract")

Our contract is a counter; in its initial state, it should store a counter value of `0`. You can call your contract so it returns its current counter value by sending it the following command:

Call to the function: number()(uint256)

```rust
cast call --rpc-url 'http://localhost:8547' --private-key 0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659 \
[deployed-contract-address] "number()(uint256)"
```

Let's break down the command:

*   `cast call` command sends a call to your contract
*   The `--rpc-url` option is the `RPC URL` endpoint of our testnode: [http://localhost:8547](http://localhost:8547)
*   The `--private-key` option is the private key of our pre-funded development account. It corresponds to the address `0x3f1eae7d46d88f08fc2f8ed27fcb2ab183eb2d0e`
*   The \[deployed-contract-address\] is the address we want to interact with, it's the address that was returned by `cargo stylus deploy`
*   `number()(uint256)` is the function we want to call in Solidity-style signature. The function returns the counter's current value

Calling 'number()(uint256)' returns:

```rust
0
```

The `number()(uint256)` function returns a value of `0`, the contract's initial state.

### Sending a transaction to your contract[​](#sending-a-transaction-to-your-contract "Direct link to Sending a transaction to your contract")

Let's increment the counter by sending a transaction to your contract's `increment()` function. We'll use Cast's `send` command to send our transaction.

Sending a transaction to the function: increment()

```rust
cast send --rpc-url 'http://localhost:8547' --private-key 0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659 \
[deployed-contract-address] "increment()"
```

Transaction returns:

```rust
blockHash               0xfaa2cce3b9995f3f2e2a2f192dc50829784da9ca4b7a1ad21665a25b3b161f7c
blockNumber             20
contractAddress
cumulativeGasUsed       97334
effectiveGasPrice       100000000
from                    0x3f1Eae7D46d88F08fc2F8ed27FCb2AB183EB2d0E
gasUsed                 97334
logs                    []
logsBloom               0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
root
status                  1 (success)
transactionHash         0x28c6ba8a0b9915ed3acc449cf6c645ecc406a4b19278ec1eb67f5a7091d18f6b
transactionIndex        1
type                    2
blobGasPrice
blobGasUsed
authorizationList
to                      0x11B57FE348584f042E436c6Bf7c3c3deF171de49
gasUsedForL1             "0x0"
l1BlockNumber             "0x1223"
```

Our transactions returned a status of `1`, indicating success, and the counter has been incremented (you can verify this by calling your contract's `number()(uint256)` function again).

Conclusion[​](#conclusion "Direct link to Conclusion")
------------------------------------------------------

Congratulations! You've successfully initialized, deployed, and interacted with your first contract using Stylus and Rust.

Feel free to explore the [Stylus Rust SDK reference](/stylus/reference/overview) for more information on using Stylus in your Arbitrum projects.

---

# Recommended Libraries | Arbitrum Docs

## Recommended libraries

Using public Rust crates[​](#using-public-rust-crates "Direct link to Using public Rust crates")
------------------------------------------------------------------------------------------------

Rust provides a package registry at [crates.io](https://crates.io/), which lets developers conveniently access a plethora of open source libraries to utilize as dependencies in their code. Stylus Rust contracts can take advantage of these crates to simplify their development workflow.

While **crates.io** is a fantastic resource, many of these libraries were not designed with the constraints of a blockchain environment in mind. Some produce large binaries that exceed the 24KB compressed size limit of WASM smart contracts on Arbitrum. Many also take advantage of unsupported features such as:

*   Random numbers
*   Multi threading
*   Floating point numbers and operations

Using the standard Rust library often bloats contract sizes beyond the maximum size. For this reason, libraries designated as `no_std` are typically much stronger candidates for usage as a smart contract dependency. **crates.io** has a special tag for marking crates as `no_std`; however, it's not universally used. Still, it can be a good starting point for locating supported libraries. See ["No standard library"](https://crates.io/categories/no-std) crates for more details.

Curated crates[​](#curated-crates "Direct link to Curated crates")
------------------------------------------------------------------

To save developers time on smart contract development for common dependencies, we've curated a list of crates and utilities that we found helpful. Keep in mind that we have not audited this code, and you should always be mindful about pulling dependencies into your codebase, whether they've been audited or not. We provide this list for you to use at your discretion and risk.

*   [`rust_decimal`](https://crates.io/crates/rust_decimal): Decimal number implementation written in pure Rust. Suitable for financial and fixed-precision calculations
*   [`special`](https://crates.io/crates/special): The package provides special functions, which are mathematical functions with special names due to their common usage, such as `sin`, `ln`, `tan`, etc.
*   [`hashbrown`](https://crates.io/crates/hashbrown): Rust port of Google's SwissTable hash map
*   [`time`](https://crates.io/crates/time): Date and time library
*   [`hex`](https://crates.io/crates/hex): Encoding and decoding data into/from hexadecimal representation

We'll be adding more libraries to this list as we find them. Feel free to suggest an edit if you know of any great crates that would be generally useful here.

---

# Gas and ink costs | Arbitrum Docs

## Gas and ink costs

This reference provides the latest gas and ink costs for specific WASM opcodes and host I/Os when using Stylus. For a conceptual introduction to Stylus gas and ink, see [Gas and ink (Stylus)](/stylus/concepts/gas-metering).

Opcode costs[​](#opcode-costs "Direct link to Opcode costs")
------------------------------------------------------------

The Stylus VM charges for WASM opcodes according to the following table, which was determined via a conservative statistical analysis and is expected to change as Stylus matures. Prices may fluctuate across upgrades as our analysis evolves and optimizations are made.

Hex

Opcode

Ink

Gas

Notes

0x00

Unreachable

1

0.0001

0x01

Nop

1

0.0001

0x02

Block

1

0.0001

0x03

Loop

1

0.0001

0x04

If

765

0.0765

0x05

Else

1

0.0001

0x0b

End

1

0.0001

0x0c

Br

765

0.0765

0x0d

BrIf

765

0.0765

0x0e

BrTable

2400 + 325x

0.24 + 0.0325x

Cost varies with table size

0x0f

Return

1

0.0001

0x10

Call

3800

0.38

0x11

CallIndirect

13610 + 650x

1.361 + 0.065x

Cost varies with no. of args

0x1a

Drop

9

0.0009

0x1b

Select

1250

0.125

0x20

LocalGet

75

0.0075

0x21

LocalSet

210

0.0210

0x22

LocalTee

75

0.0075

0x23

GlobalGet

225

0.0225

0x24

GlobalSet

575

0.0575

0x28

I32Load

670

0.067

0x29

I64Load

680

0.068

0x2c

I32Load8S

670

0.067

0x2d

I32Load8U

670

0.067

0x2e

I32Load16S

670

0.067

0x2f

I32Load16U

670

0.067

0x30

I64Load8S

680

0.068

0x31

I64Load8U

680

0.068

0x32

I64Load16S

680

0.068

0x33

I64Load16U

680

0.068

0x34

I64Load32S

680

0.068

0x35

I64Load32U

680

0.068

0x36

I32Store

825

0.0825

0x37

I64Store

950

0.095

0x3a

I32Store8

825

0.0825

0x3b

I32Store16

825

0.0825

0x3c

I64Store8

950

0.095

0x3d

I64Store16

950

0.095

0x3e

I64Store32

950

0.095

0x3f

MemorySize

3000

0.3

0x40

MemoryGrow

8050

0.805

0x41

I32Const

1

0.0001

0x42

I64Const

1

0.0001

0x45

I32Eqz

170

0.017

0x46

I32Eq

170

0.017

0x47

I32Ne

170

0.017

0x48

I32LtS

170

0.017

0x49

I32LtU

170

0.017

0x4a

I32GtS

170

0.017

0x4b

I32GtU

170

0.017

0x4c

I32LeS

170

0.017

0x4d

I32LeU

170

0.017

0x4e

I32GeS

170

0.017

0x4f

I32GeU

170

0.017

0x50

I64Eqz

225

0.0225

0x51

I64Eq

225

0.0225

0x52

I64Ne

225

0.0225

0x53

I64LtS

225

0.0225

0x54

I64LtU

225

0.0225

0x55

I64GtS

225

0.0225

0x56

I64GtU

225

0.0225

0x57

I64LeS

225

0.0225

0x58

I64LeU

225

0.0225

0x59

I64GeS

225

0.0225

0x5a

I64GeU

225

0.0225

0x67

I32Clz

210

0.021

0x68

I32Ctz

210

0.021

0x69

I32Popcnt

2650

0.265

0x6a

I32Add

70

0.007

0x6b

I32Sub

70

0.007

0x6c

I32Mul

160

0.016

0x6d

I32DivS

1120

0.112

0x6e

I32DivU

1120

0.112

0x6f

I32RemS

1120

0.112

0x70

I32RemU

1120

0.112

0x71

I32And

70

0.007

0x72

I32Or

70

0.007

0x73

I32Xor

70

0.007

0x74

I32Shl

70

0.007

0x75

I32ShrS

70

0.007

0x76

I32ShrU

70

0.007

0x77

I32Rotl

70

0.007

0x78

I32Rotr

70

0.007

0x79

I64Clz

210

0.021

0x7a

I64Ctz

210

0.012

0x7b

I64Popcnt

6000

0.6

0x7c

I64Add

100

0.01

0x7d

I64Sub

100

0.01

0x7e

I64Mul

160

0.016

0x7f

I64DivS

1270

0.127

0x80

I64DivU

1270

0.127

0x81

I64RemS

1270

0.127

0x82

I64RemU

1270

0.127

0x83

I64And

100

0.01

0x84

I64Or

100

0.01

0x85

I64Xor

100

0.01

0x86

I64Shl

100

0.01

0x87

I64ShrS

100

0.01

0x88

I64ShrU

100

0.01

0x89

I64Rotl

100

0.01

0x8a

I64Rotr

100

0.01

0xa7

I32WrapI64

100

0.01

0xac

I64ExtendI32S

100

0.01

0xad

I64ExtendI32U

100

0.01

0xc0

I32Extend8S

100

0.01

0xc1

I32Extend16S

100

0.01

0xc2

I64Extend8S

100

0.01

0xc3

I64Extend16S

100

0.01

0xc4

I64Extend32S

100

0.01

0xfc0a

MemoryCopy

950 + 100x

0.095 + 0.01x

Cost varies with no. of bytes

0xfc0b

MemoryFill

950 + 100x

0.095 + 0.01x

Cost varies with no. of bytes

Host I/O costs[​](#host-io-costs "Direct link to Host I/O costs")
-----------------------------------------------------------------

Certain operations require suspending WASM execution so that the Stylus VM can perform tasks natively in the host. This costs about `0.84 gas` to do. Though we’ll publish a full specification later, the following table details the costs of simple operations that run in the host.

Note that the values in this table were determined via a conservative statistical analysis and are expected to change as Stylus matures. Prices may fluctuate across upgrades as our analysis evolves and optimizations are made.

Host I/O

Ink

Gas

Notes

read\_args

8400 + 5040b

0.84 + 0.504b

`b` = bytes after first 32

write\_result

8400 + 16381b

0.84 + 1.6381b

`b` = bytes after first 32

keccak

121800 + 21000w

12.18 + 2.1w

`w` = EVM words

block\_basefee

13440

1.344

block\_coinbase

13440

1.344

block\_gas\_limit

8400

0.84

block\_number

8400

0.84

block\_timestmap

8400

0.84

chain\_id

8400

0.84

contract\_address

13440

1.344

evm\_gas\_left

8400

0.84

evm\_ink\_left

8400

0.84

msg\_reentrant

8400

0.84

msg\_sender

13440

1.344

msg\_value

13440

1.344

return\_data\_size

8400

0.84

tx\_ink\_price

8400

0.84

tx\_gas\_price

13440

1.344

tx\_origin

13440

1.344

console\_log\_text

0

0

debug-only

console\_log

0

0

debug-only

console\_tee

0

0

debug-only

null\_host

0

0

debug-only

### See also[​](#see-also "Direct link to See also")

*   [Gas and ink (Stylus)](/stylus/concepts/gas-metering): A conceptual introduction to the "gas" and "ink" primitives

---

# Other language frameworks (non-Rust) | Arbitrum Docs

## Other language frameworks (non-Rust)

If you are looking to write and deploy Stylus contracts without using Rust, please see the following SDKs.

Repo

Use cases

License

[C/C++ SDK](https://github.com/OffchainLabs/stylus-sdk-c)

Cryptography and algorithms

Apache 2.0 or MIT

[Bf SDK](https://github.com/OffchainLabs/stylus-sdk-bf)

Educational

Apache 2.0 or MIT

The Stylus SDKs are open-source, allowing anyone to build their own! The following SDKs have been developed from the ecosystem of Stylus developers.

Repo

[Zig SDK](https://github.com/Stylish-Stylus/zig-stylus)

---

# Stylus Rust SDK overview | Arbitrum Docs

## Stylus Rust SDK overview

This section provides an in-depth overview of the features provided by the [Stylus Rust SDK](https://github.com/OffchainLabs/stylus-sdk-rs). For information about deploying Rust smart contracts, see the `cargo stylus` [CLI Tool](https://github.com/OffchainLabs/cargo-stylus). For a conceptual introduction to Stylus, see [Stylus: A Gentle Introduction](/stylus/gentle-introduction). To deploy your first Stylus smart contract using Rust, refer to the [Quickstart](/stylus/quickstart).

The Stylus Rust SDK is built on top of [Alloy](https://www.paradigm.xyz/2023/06/alloy), a collection of crates empowering the Rust Ethereum ecosystem. Because the SDK uses the same [Rust primitives for Ethereum types](https://docs.rs/alloy-primitives/latest/alloy_primitives/), Stylus is compatible with existing Rust libraries.

The Stylus Rust SDK has been audited in August 2024 at [commit #62bd831](https://github.com/OffchainLabs/stylus-sdk-rs/tree/62bd8318c7f3ab5be954cbc264f85bf2ba3f4b06) by Open Zeppelin which can be viewed [on our audits page](/audit-reports).

This section contains a set of pages that describe a certain aspect of the Stylus Rust SDK, like how to work with [variables](/stylus-by-example/basic_examples/variables), or what ways are there to [send ether](/stylus-by-example/basic_examples/sending_ether). Additionally, there's also a page that compiles a set of [advanced features](/stylus/reference/rust-sdk-guide) that the Stylus Rust SDK provides.

Finally, there's also a [Stylus by example](https://stylus-by-example.org) portal available that provides most of the information included in this section, as well as many different example contracts.

---

# Stylus Rust SDK advanced features | Arbitrum Docs

## Stylus Rust SDK advanced features

This document provides information about advanced features included in the [Stylus Rust SDK](https://github.com/OffchainLabs/stylus-sdk-rs), that are not described in the previous pages. For information about deploying Rust smart contracts, see the `cargo stylus` [CLI Tool](https://github.com/OffchainLabs/cargo-stylus). For a conceptual introduction to Stylus, see [Stylus: A Gentle Introduction](/stylus/gentle-introduction). To deploy your first Stylus smart contract using Rust, refer to the [Quickstart](/stylus/quickstart).

info

Many of the affordances use macros. Though this section details what each does, it may be helpful to use [`cargo expand`](https://crates.io/crates/cargo-expand) to see what they expand into if you’re doing advanced work in Rust.

Storage[​](#storage "Direct link to Storage")
---------------------------------------------

This section provides extra information about how the Stylus Rust SDK handles storage. You can find more information and basic examples in [Variables](/stylus-by-example/basic_examples/variables).

Rust smart contracts may use state that persists across transactions. There’s two primary ways to define storage, depending on if you want to use Rust or Solidity definitions. Both are equivalent, and are up to the developer depending on their needs.

### [`#[storage]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.storage.html)[​](#storage-1 "Direct link to storage-1")

The [`#[storage]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.storage.html) macro allows a Rust struct to be used in persistent storage.

```rust
#[storage]
pub struct Contract {
    owner: StorageAddress,
    active: StorageBool,
    sub_struct: SubStruct,
}

#[storage]
pub struct SubStruct {
    // types implementing the `StorageType` trait.
}
```

Any type implementing the [`StorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html) trait may be used as a field, including other structs, which will implement the trait automatically when [`#[storage]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.storage.html) is applied. You can even implement [`StorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html) yourself to define custom storage types. However, we’ve gone ahead and implemented the common ones.

Type

Info

[`StorageBool`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageBool.html)

Stores a bool

[`StorageAddress`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageAddress.html)

Stores an Alloy [`Address`](https://docs.rs/alloy-primitives/latest/alloy_primitives/struct.Address.html)

[`StorageUint`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageUint.html)

Stores an Alloy [`Uint`](https://docs.rs/ruint/1.10.1/ruint/struct.Uint.html)

[`StorageSigned`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageSigned.html)

Stores an Alloy [`Signed`](https://docs.rs/alloy-primitives/latest/alloy_primitives/struct.Signed.html)

[`StorageFixedBytes`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageFixedBytes.html)

Stores an Alloy [`FixedBytes`](https://docs.rs/alloy-primitives/latest/alloy_primitives/struct.FixedBytes.html)

[`StorageBytes`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageBytes.html)

Stores a Solidity bytes

[`StorageString`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageString.html)

Stores a Solidity string

[`StorageVec`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageVec.html)

Stores a vector of [`StorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html)

[`StorageMap`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageMap.html)

Stores a mapping of [`StorageKey`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageKey.html) to [`StorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html)

[`StorageArray`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageArray.html)

Stores a fixed-sized array of [`StorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html)

Every [Alloy primitive](https://docs.rs/alloy-primitives/latest/alloy_primitives/) has a corresponding [`StorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html) implementation with the word `Storage` before it. This includes aliases, like [`StorageU256`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/type.StorageU256.html) and [`StorageB64`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/type.StorageB64.html).

### [`sol_storage!`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/macro.sol_storage.html)[​](#sol_storage "Direct link to sol_storage")

The types in [`#[storage]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.storage.html) are laid out in the EVM state trie exactly as they are in [Solidity](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html). This means that the fields of a struct definition will map to the same storage slots as they would in EVM programming languages.

Because of this, it is often nice to define your types using Solidity syntax, which makes that guarantee easier to see. For example, the earlier Rust struct can re-written to:

```rust
sol_storage! {
    pub struct Contract {
        address owner;                      // becomes a StorageAddress
        bool active;                        // becomes a StorageBool
        SubStruct sub_struct,
    }

    pub struct SubStruct {
        // other solidity fields, such as
        mapping(address => uint) balances;  // becomes a StorageMap
        Delegate delegates[];               // becomes a StorageVec
    }
}
```

The above will expand to the equivalent definitions in Rust, each structure implementing the [`StorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html) trait. Many contracts, like [our example ERC 20](https://github.com/OffchainLabs/stylus-sdk-rs/blob/stylus/examples/erc20/src/main.rs), do exactly this.

Because the layout is identical to [Solidity’s](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html), existing Solidity smart contracts can upgrade to Rust without fear of storage slots not lining up. You simply copy-paste your type definitions.

Storage layout in contracts using inheritance

Note that one exception to this storage layout guarantee is contracts which utilize inheritance. The current solution in Stylus using `#[borrow]` and `#[inherits(...)]` packs nested (inherited) structs into their own slots. This is consistent with regular struct nesting in solidity, but not inherited structs. We plan to revisit this behavior in an upcoming release.

tip

Existing Solidity smart contracts can upgrade to Rust if they use proxy patterns.

Consequently, the order of fields will affect the JSON ABIs produced that explorers and tooling might use. Most developers won’t need to worry about this though and can freely order their types when working on a Rust contract from scratch.

### Reading and writing storage[​](#reading-and-writing-storage "Direct link to Reading and writing storage")

You can access storage types via getters and setters. For example, the `Contract` struct from earlier might access its `owner` address as follows.

```rust
impl Contract {
    /// Gets the owner from storage.
    pub fn owner(&self) -> Address {
        self.owner.get()
    }

    /// Updates the owner in storage
    pub fn set_owner(&mut self, new_owner: Address) {
        if msg::sender() == self.owner.get() { // we'll discuss msg::sender later
            self.owner.set(new_owner);
        }
    }

    /// Unlike other storage type, stringStorage needs to
    /// use `.set_str()` and `.get_string()` to set and get.
    pub fn set_base_uri(&mut self, base_uri: String) {
        self.base_uri.set_str(base_uri);
    }

    pub fn get_base_uri(&self) -> String {
        self.base_uri.get_string()
    }
}
```

In Solidity, one has to be very careful about storage access patterns. Getting or setting the same value twice doubles costs, leading developers to avoid storage access at all costs. By contrast, the Stylus SDK employs an optimal storage-caching policy that avoids the underlying [`SLOAD`](https://www.evm.codes/#54) or [`SSTORE`](https://www.evm.codes/#55) operations.

tip

Stylus uses storage caching, so multiple accesses of the same variable is virtually free.

However it must be said that storage is ultimately more expensive than memory. So if a value doesn’t need to be stored in state, you probably shouldn’t do it.

### Collections[​](#collections "Direct link to Collections")

Collections like [`StorageVec`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageVec.html) and [`StorageMap`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageMap.html) are dynamic and have methods like [`push`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageVec.html#method.push), [`insert`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageMap.html#method.insert), [`replace`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageMap.html#method.replace), and similar.

```rust
impl SubStruct {
   pub fn add_delegate(&mut self, delegate: Address) {
        self.delegates.push(delegate);
    }

    pub fn track_balance(&mut self, address: Address) {
        self.balances.insert(address, address.balance());
    }
}
```

You may notice that some methods return types like [`StorageGuard`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageGuard.html) and [`StorageGuardMut`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageGuardMut.html). This allows us to leverage the Rust borrow checker for storage mistakes, just like it does for memory. Here’s an example that will fail to compile.

```rust
fn mistake(vec: &mut StorageVec<StorageU64>) -> U64 {
    let value = vec.setter(0);
    let alias = vec.setter(0);
    value.set(32.into());
    alias.set(48.into());
    value.get() // uh, oh. what value should be returned?
}
```

Under the hood, [`vec.setter()`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageVec.html#method.setter) returns a [`StorageGuardMut`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageGuardMut.html) instead of a [`&mut StorageU64`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/type.StorageU64.html). Because the guard is bound to a [`&mut StorageVec`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageVec.html) lifetime, `value` and `alias` cannot be alive simultaneously. This causes the Rust compiler to reject the above code, saving you from entire classes of storage aliasing errors.

In this way the Stylus SDK safeguards storage access the same way Rust ensures memory safety. It should never be possible to alias Storage without `unsafe` Rust.

### [`SimpleStorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.SimpleStorageType.html)[​](#simplestoragetype "Direct link to simplestoragetype")

You may run into scenarios where a collection’s methods like [`push`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageVec.html#method.push) and [`insert`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageMap.html#method.insert) aren’t available. This is because only primitives, which implement a special trait called [`SimpleStorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.SimpleStorageType.html), can be added to a collection by value. For nested collections, one instead uses the equivalent [`grow`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageVec.html#method.grow) and [`setter`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageVec.html#method.setter).

```rust
fn nested_vec(vec: &mut StorageVec<StorageVec<StorageU8>>) {
    let mut inner = vec.grow();  // adds a new element accessible via `inner`
    inner.push(0.into());        // inner is a guard to a StorageVec<StorageU8>
}

fn nested_map(map: &mut StorageMap<u32, StorageVec<U8>>) {
    let mut slot = map.setter(0);
    slot.push(0);
}
```

### [`Erase`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.Erase.html) and [`#[derive(Erase)]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/derive.Erase.html)[​](#erase-and-deriveerase "Direct link to erase-and-deriveerase")

Some [`StorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html) values implement [`Erase`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.Erase.html), which provides an [`erase()`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.Erase.html) method for clearing state. We’ve implemented [`Erase`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.Erase.html) for all primitives, and for vectors of primitives, but not maps. This is because a solidity [`mapping`](https://docs.soliditylang.org/en/latest/types.html#mapping-types) does not provide iteration, and so it’s generally impossible to know which slots to set to zero.

Structs may also be [`Erase`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.Erase.html) if all of the fields are. [`#[derive(Erase)]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/derive.Erase.html) lets you do this automatically.

```rust
sol_storage! {
    #[derive(Erase)]
    pub struct Contract {
        address owner;              // can erase primitive
        uint256[] hashes;           // can erase vector of primitive
    }

    pub struct NotErase {
        mapping(address => uint) balances; // can't erase a map
        mapping(uint => uint)[] roots;     // can't erase vector of maps
    }
}
```

You can also implement [`Erase`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.Erase.html) manually if desired. Note that the reason we care about [`Erase`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.Erase.html) at all is that you get storage refunds when clearing state, lowering fees. There’s also minor implications for patterns using `unsafe` Rust.

### The storage cache[​](#the-storage-cache "Direct link to The storage cache")

The Stylus SDK employs an optimal storage-caching policy that avoids the underlying [`SLOAD`](https://www.evm.codes/#54) or [`SSTORE`](https://www.evm.codes/#55) operations needed to get and set state. For the vast majority of use cases, this happens in the background and requires no input from the user.

However, developers working with `unsafe` Rust implementing their own custom [`StorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html) collections, the [`StorageCache`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageCache.html) type enables direct control over this data structure. Included are `unsafe` methods for manipulating the cache directly, as well as for bypassing it altogether.

### Immutables and [`PhantomData`](https://doc.rust-lang.org/core/marker/struct.PhantomData.html)[​](#immutables-and-phantomdata "Direct link to immutables-and-phantomdata")

So that generics are possible in [`sol_interface!`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/macro.sol_interface.html), [`core::marker::PhantomData`](https://doc.rust-lang.org/core/marker/struct.PhantomData.html) implements [`StorageType`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html) and takes up zero space, ensuring that it won’t cause storage slots to change. This can be useful when writing libraries.

```rust
pub trait Erc20Params {
    const NAME: &'static str;
    const SYMBOL: &'static str;
    const DECIMALS: u8;
}

sol_storage! {
    pub struct Erc20<T> {
        mapping(address => uint256) balances;
        PhantomData<T> phantom;
    }
}
```

The above allows consumers of `Erc20` to choose immutable constants via specialization. See our [WETH sample contract](https://github.com/OffchainLabs/stylus-sdk-rs/blob/stylus/examples/erc20/src/main.rs) for a full example of this feature.

Functions[​](#functions "Direct link to Functions")
---------------------------------------------------

This section provides extra information about how the Stylus Rust SDK handles functions. You can find more information and basic examples in [Functions](/stylus-by-example/basic_examples/function), [Bytes in, bytes out programming](/stylus-by-example/basic_examples/bytes_in_bytes_out), [Inheritance](/stylus-by-example/basic_examples/inheritance) and [Sending ether](/stylus-by-example/basic_examples/sending_ether).

### Pure, View, and Write functions[​](#pure-view-and-write-functions "Direct link to Pure, View, and Write functions")

For non-payable methods the [`#[public]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.public.html) macro can figure state mutability out for you based on the types of the arguments. Functions with `&self` will be considered `view`, those with `&mut self` will be considered `write`, and those with neither will be considered `pure`. Please note that `pure` and `view` functions may change the state of other contracts by calling into them, or even this one if the `reentrant` feature is enabled.

### [`#[entrypoint]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.entrypoint.html)[​](#entrypoint "Direct link to entrypoint")

This macro allows you to define the entrypoint, which is where Stylus execution begins. Without it, the contract will fail to pass `cargo stylus check`. Most commonly, the macro is used to annotate the top level storage struct.

```rust
sol_storage! {
    #[entrypoint]
    pub struct Contract {
        ...
    }

    // only one entrypoint is allowed
    pub struct SubStruct {
        ...
    }
}
```

The above will make the public methods of `Contract` the first to consider during invocation.

### Reentrancy[​](#reentrancy "Direct link to Reentrancy")

If a contract calls another that then calls the first, it is said to be reentrant. By default, all Stylus contracts revert when this happens. However, you can opt out of this behavior by enabling the `reentrant` feature flag.

```rust
stylus-sdk = { version = "0.6.0", features = ["reentrant"] }
```

This is dangerous, and should be done only after careful review — ideally by 3rd party auditors. Numerous exploits and hacks have in Web3 are attributable to developers misusing or not fully understanding reentrant patterns.

If enabled, the Stylus SDK will flush the storage cache in between reentrant calls, persisting values to state that might be used by inner calls. Note that preventing storage invalidation is only part of the battle in the fight against exploits. You can tell if a call is reentrant via `msg::reentrant`, and condition your business logic accordingly.

### [`TopLevelStorage`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.TopLevelStorage.html)[​](#toplevelstorage "Direct link to toplevelstorage")

The [`#[entrypoint]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.entrypoint.html) macro will automatically implement the [`TopLevelStorage`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.TopLevelStorage.html) trait for the annotated `struct`. The single type implementing [`TopLevelStorage`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.TopLevelStorage.html) is special in that mutable access to it represents mutable access to the entire program’s state. This idea will become important when discussing calls to other programs in later sections.

### Inheritance, `#[inherit]`, and `#[borrow]`.[​](#inheritance-inherit-and-borrow "Direct link to inheritance-inherit-and-borrow")

info

Stylus doesn't support contract multi-inheritance yet.

Composition in Rust follows that of Solidity. Types that implement [`Router`](https://docs.rs/stylus-sdk/latest/stylus_sdk/abi/trait.Router.html), the trait that [`#[public]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.public.html) provides, can be connected via inheritance.

```rust
#[public]
#[inherit(Erc20)]
impl Token {
    pub fn mint(&mut self, amount: U256) -> Result<(), Vec<u8>> {
        ...
    }
}

#[public]
impl Erc20 {
    pub fn balance_of() -> Result<U256> {
        ...
    }
}
```

Because `Token` inherits `Erc20` in the above, if `Token` has the [`#[entrypoint]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.entrypoint.html), calls to the contract will first check if the requested method exists within `Token`. If a matching function is not found, it will then try the `Erc20`. Only after trying everything `Token` inherits will the call revert.

Note that because methods are checked in that order, if both implement the same method, the one in `Token` will override the one in `Erc20`, which won’t be callable. This allows for patterns where the developer imports a crate implementing a standard, like the ERC 20, and then adds or overrides just the methods they want to without modifying the imported `Erc20` type.

warning

Stylus does not currently contain explicit `override` or `virtual` keywords for explicitly marking override functions. It is important, therefore, to carefully ensure that contracts are only overriding the functions.

Inheritance can also be chained. `#[inherit(Erc20, Erc721)]` will inherit both `Erc20` and `Erc721`, checking for methods in that order. `Erc20` and `Erc721` may also inherit other types themselves. Method resolution finds the first matching method by [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search).

Note that for the above to work, `Token` must implement [`Borrow<Erc20>`](https://doc.rust-lang.org/core/borrow/trait.Borrow.html). You can implement this yourself, but for simplicity, [`#[storage]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.storage.html) and [`sol_storage!`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/macro.sol_storage.html) provide a `#[borrow]` annotation.

```rust
sol_storage! {
    #[entrypoint]
    pub struct Token {
        #[borrow]
        Erc20 erc20;
        ...
    }

    pub struct Erc20 {
        ...
    }
}
```

Calls[​](#calls "Direct link to Calls")
---------------------------------------

Just as with storage and functions, Stylus SDK calls are Solidity ABI equivalent. This means you never have to know the implementation details of other contracts to invoke them. You simply import the Solidity interface of the target contract, which can be auto-generated via the `cargo stylus` [CLI tool](https://github.com/OffchainLabs/cargo-stylus#exporting-solidity-abis).

tip

You can call contracts in any programming language with the Stylus SDK.

### [`sol_interface!`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/macro.sol_interface.html)[​](#sol_interface "Direct link to sol_interface")

This macro defines a `struct` for each of the Solidity interfaces provided.

```rust
sol_interface! {
    interface IService {
        function makePayment(address user) payable returns (string);
        function getConstant() pure returns (bytes32)
    }

    interface ITree {
        // other interface methods
    }
}
```

The above will define `IService` and `ITree` for calling the methods of the two contracts.

info

Currently only functions are supported, and any other items in the interface will cause an error.

For example, `IService` will have a `make_payment` method that accepts an [`Address`](https://docs.rs/alloy-primitives/latest/alloy_primitives/struct.Address.html) and returns a [`B256`](https://docs.rs/alloy-primitives/latest/alloy_primitives/aliases/type.B256.html).

```rust
pub fn do_call(&mut self, account: IService, user: Address) -> Result<String, Error> {
    account.make_payment(self, user)  // note the snake case
}
```

Observe the casing change. [`sol_interface!`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/macro.sol_interface.html) computes the selector based on the exact name passed in, which should almost always be `CamelCase`. For aesthetics, the rust functions will instead use `snake_case`.

### Configuring gas and value with [`Call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.Call.html)[​](#configuring-gas-and-value-with-call "Direct link to configuring-gas-and-value-with-call")

[`Call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.Call.html) lets you configure a call via optional configuration methods. This is similar to how one would configure opening a [`File`](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#examples) in Rust.

```rust
pub fn do_call(account: IService, user: Address) -> Result<String, Error> {
    let config = Call::new_in()
        .gas(evm::gas_left() / 2)       // limit to half the gas left
        .value(msg::value());           // set the callvalue

    account.make_payment(config, user)
}
```

By default [`Call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.Call.html) supplies all gas remaining and zero value, which often means [`Call::new_in()`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.Call.html#method.new_in) may be passed to the method directly. Additional configuration options are available in cases of reentrancy.

### Reentrant calls[​](#reentrant-calls "Direct link to Reentrant calls")

Contracts that opt into reentrancy via the `reentrant` feature flag require extra care. When the `storage-cache` feature is enabled, cross-contract calls must [`flush`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageCache.html#method.flush) or [`clear`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageCache.html#method.clear) the [`StorageCache`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageCache.html) to safeguard state. This happens automatically via the type system.

```rust
sol_interface! {
    interface IMethods {
        function pureFoo() external pure;
        function viewFoo() external view;
        function writeFoo() external;
        function payableFoo() external payable;
    }
}

#[public]
impl Contract {
    pub fn call_pure(&self, methods: IMethods) -> Result<(), Vec<u8>> {
        Ok(methods.pure_foo(self)?)    // `pure` methods might lie about not being `view`
    }

    pub fn call_view(&self, methods: IMethods) -> Result<(), Vec<u8>> {
        Ok(methods.view_foo(self)?)
    }

    pub fn call_write(&mut self, methods: IMethods) -> Result<(), Vec<u8>> {
        methods.view_foo(self)?;       // allows `pure` and `view` methods too
        Ok(methods.write_foo(self)?)
    }

    #[payable]
    pub fn call_payable(&mut self, methods: IMethods) -> Result<(), Vec<u8>> {
        methods.write_foo(Call::new_in(self))?;   // these are the same
        Ok(methods.payable_foo(self)?)            // ------------------
    }
}
```

In the above, we’re able to pass `&self` and `&mut self` because `Contract` implements [`TopLevelStorage`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.TopLevelStorage.html), which means that a reference to it entails access to the entirety of the contract’s state. This is the reason it is sound to make a call, since it ensures all cached values are invalidated and/or persisted to state at the right time.

When writing Stylus libraries, a type might not be [`TopLevelStorage`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.TopLevelStorage.html) and therefore `&self` or `&mut self` won’t work. Building a [`Call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.Call.html) from a generic parameter via [`new_in`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.Call.html#method.new_in) is the usual solution.

```rust
pub fn do_call(
    storage: &mut impl TopLevelStorage,  // can be generic, but often just &mut self
    account: IService,                   // serializes as an Address
    user: Address,
) -> Result<String, Error> {

    let config = Call::new_in(storage)   // take exclusive access to all contract storage
        .gas(evm::gas_left() / 2)        // limit to half the gas left
        .value(msg::value());            // set the callvalue

    account.make_payment(config, user)   // note the snake case
}
```

Note that in the context of a [`#[public]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/attr.public.html) call, the `&mut impl` argument will correctly distinguish the method as being `write` or [`payable`](https://docs.alchemy.com/docs/solidity-payable-functions). This means you can write library code that will work regardless of whether the reentrant feature flag is enabled.

Note too that code that previously compiled with reentrancy disabled may require modification in order to type-check. This is done to ensure storage changes are persisted and that the storage cache is properly managed before calls.

### [`call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/fn.call.html), [`static_call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/fn.static_call.html), and [`delegate_call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/fn.delegate_call.html)[​](#call-static_call-and-delegate_call "Direct link to call-static_call-and-delegate_call")

Though [`sol_interface!`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/macro.sol_interface.html) and [`Call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.Call.html) form the most common idiom to invoke other contracts, their underlying [`call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/fn.call.html) and [`static_call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/fn.static_call.html) are exposed for direct access.

```rust
let return_data = call(Call::new_in(self), contract, call_data)?;
```

In each case the calldata is supplied as a [`Vec<u8>`](https://doc.rust-lang.org/alloc/vec/struct.Vec.html). The return result is either the raw return data on success, or a call [`Error`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/enum.Error.html) on failure.

[`delegate_call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/fn.delegate_call.html) is also available, though it's `unsafe` and doesn't have a richly-typed equivalent. This is because a delegate call must trust the other contract to uphold safety requirements. Though this function clears any cached values, the other contract may arbitrarily change storage, spend ether, and do other things one should never blindly allow other contracts to do.

### [`transfer_eth`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/fn.transfer_eth.html)[​](#transfer_eth "Direct link to transfer_eth")

This method provides a convenient shorthand for transferring ether.

Note that this method invokes the other contract, which may in turn call others. All gas is supplied, which the recipient may burn. If this is not desired, the [`call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/fn.call.html) function may be used instead.

```rust
transfer_eth(recipient, value)?;                 // these two are equivalent

call(Call::new_in().value(value), recipient, &[])?; // these two are equivalent
```

### [`RawCall`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.RawCall.html) and `unsafe` calls[​](#rawcall-and-unsafe-calls "Direct link to rawcall-and-unsafe-calls")

Occasionally, an untyped call to another contract is necessary. [`RawCall`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.RawCall.html) lets you configure an `unsafe` call by calling optional configuration methods. This is similar to how one would configure opening a [`File`](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#examples) in Rust.

```rust
let data = RawCall::new_delegate()   // configure a delegate call
    .gas(2100)                       // supply 2100 gas
    .limit_return_data(0, 32)        // only read the first 32 bytes back
    .flush_storage_cache()           // flush the storage cache before the call
    .call(contract, calldata)?;      // do the call
```

Note that the [`call`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.RawCall.html#method.call) method is `unsafe` when reentrancy is enabled. See [`flush_storage_cache`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.RawCall.html#method.flush_storage_cache) and [`clear_storage_cache`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.RawCall.html#method.clear_storage_cache) for more information.

[`RawDeploy`](https://docs.rs/stylus-sdk/latest/stylus_sdk/deploy/struct.RawDeploy.html) and `unsafe` deployments[​](#rawdeploy-and-unsafe-deployments "Direct link to rawdeploy-and-unsafe-deployments")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Right now the only way to deploy a contract from inside Rust is to use [`RawDeploy`](https://docs.rs/stylus-sdk/latest/stylus_sdk/deploy/struct.RawDeploy.html), similar to [`RawCall`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.RawCall.html). As with [`RawCall`](https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.RawCall.html), this mechanism is inherently unsafe due to reentrancy concerns, and requires manual management of the [`StorageCache`](https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageCache.html).

Note that the EVM allows init code to make calls to other contracts, which provides a vector for reentrancy. This means that this technique may enable storage aliasing if used in the middle of a storage reference's lifetime and if reentrancy is allowed.

When configured with a `salt`, [`RawDeploy`](https://docs.rs/stylus-sdk/latest/stylus_sdk/deploy/struct.RawDeploy.html) will use [`CREATE2`](https://www.evm.codes/#f5) instead of the default [`CREATE`](https://www.evm.codes/#f0), facilitating address determinism.

---

# Stylus SDK repositories | Arbitrum Docs

## Stylus SDK repositories

If you are looking to write and deploy Stylus contracts, please see the following SDKs.

Repo

Use cases

License

[Rust SDK](https://github.com/OffchainLabs/stylus-sdk-rs)

Everything!

Apache 2.0 or MIT

[C/C++ SDK](https://github.com/OffchainLabs/stylus-sdk-c)

Cryptography and algorithms

Apache 2.0 or MIT

[Bf SDK](https://github.com/OffchainLabs/stylus-sdk-bf)

Educational

Apache 2.0 or MIT

[Cargo Stylus CLI Tool](https://github.com/OffchainLabs/cargo-stylus)

Program deployment

Apache 2.0 or MIT

The Stylus SDKs are open-source, allowing anyone to build their own! The following SDKs have been developed from the ecosystem of Stylus developers.

Repo

[Zig SDK](https://github.com/Stylish-Stylus/zig-stylus)

---

# Stylus testnet information | Arbitrum Docs

## Stylus testnet information

Arbitrum public RPC endpoints[​](#arbitrum-public-rpc-endpoints "Direct link to Arbitrum public RPC endpoints")
---------------------------------------------------------------------------------------------------------------

caution

*   Unlike the RPC Urls, the Sequencer endpoints only support `eth_sendRawTransaction` and `eth_sendRawTransactionConditional` calls.
*   Arbitrum public RPCs do not provide Websocket support.
*   Stylus testnets v1 and v2 have been spun down and are not accessible anymore.
*   Visit [Quicknode's Arbitrum Sepolia faucet](https://faucet.quicknode.com/arbitrum/sepolia), [Alchemy's Arbitrum sepolia faucet](https://www.alchemy.com/faucets/arbitrum-sepolia), or [Getblock's Arbitrum Sepolia faucet](https://getblock.io/faucet/arb-sepolia) for testnet Sepolia tokens on L2.

This section provides an overview of the available public RPC endpoints for different Arbitrum chains that have Stylus enabled, and the necessary details to interact with them.

Name

RPC Url(s)

Chain ID

Block explorer

Underlying chain

Tech stack

Sequencer feed URL

Sequencer endpoint⚠️

Arbitrum Sepolia (Testnet)

[https://sepolia-rollup.arbitrum.io/rpc](https://sepolia-rollup.arbitrum.io/rpc)

421614

[https://sepolia.arbiscan.io](https://sepolia.arbiscan.io)

Sepolia

Nitro (Rollup)

wss://sepolia-rollup.arbitrum.io/feed

[https://sepolia-rollup-sequencer.arbitrum.io/rpc](https://sepolia-rollup-sequencer.arbitrum.io/rpc)

Faucets[​](#faucets "Direct link to Faucets")
---------------------------------------------

Below you can find faucets for obtaining testnet ETH. If using a faucet on Ethereum Sepolia or Arbitrum Sepolia, your testnet ETH can be bridged to the Stylus testnet on the [Arbitrum Bridge](https://bridge.arbitrum.io/).

Faucet Operator

Faucet URL

Chain

QuickNode

[https://faucet.quicknode.com/arbitrum/sepolia](https://faucet.quicknode.com/arbitrum/sepolia)

Arbitrum Sepolia

Alchemy

[https://www.alchemy.com/faucets/arbitrum-sepolia](https://www.alchemy.com/faucets/arbitrum-sepolia)

Arbitrum Sepolia

Sepolia PoW Faucet

[https://sepolia-faucet.pk910.de/](https://sepolia-faucet.pk910.de/)

Ethereum Sepolia

The following information may be useful to those building on Arbitrum. We list the addresses of the smart contracts related to the protocol, the token bridge and precompiles of the different Arbitrum chains.

Protocol smart contracts[​](#protocol-smart-contracts "Direct link to Protocol smart contracts")
------------------------------------------------------------------------------------------------

### Core contracts[​](#core-contracts "Direct link to Core contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

Rollup

[0x4DCe...Cfc0](https://etherscan.io/address/0x4DCeB440657f21083db8aDd07665f8ddBe1DCfc0)

[0xE7E8...B7Bd](https://etherscan.io/address/0xE7E8cCC7c381809BDC4b213CE44016300707B7Bd)

[0x042B...0Cf4](https://sepolia.etherscan.io/address/0x042B2E6C5E99d4c521bd49beeD5E99651D9B0Cf4)

Sequencer Inbox

[0x1c47...82B6](https://etherscan.io/address/0x1c479675ad559DC151F6Ec7ed3FbF8ceE79582B6)

[0x211E...c21b](https://etherscan.io/address/0x211E1c4c7f1bF5351Ac850Ed10FD68CFfCF6c21b)

[0x6c97...be0D](https://sepolia.etherscan.io/address/0x6c97864CE4bEf387dE0b3310A44230f7E3F1be0D)

CoreProxyAdmin

[0x5547...2dbD](https://etherscan.io/address/0x554723262467F125Ac9e1cDFa9Ce15cc53822dbD)

[0x71D7...7148](https://etherscan.io/address/0x71D78dC7cCC0e037e12de1E50f5470903ce37148)

[0x1ed7...0686](https://sepolia.etherscan.io/address/0x1ed74a4e4F4C42b86A7002e9951e98DBcC890686)

### Cross-chain messaging contracts[​](#cross-chain-messaging-contracts "Direct link to Cross-chain messaging contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

Delayed Inbox

[0x4Dbd...AB3f](https://etherscan.io/address/0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f)

[0xc444...3949](https://etherscan.io/address/0xc4448b71118c9071Bcb9734A0EAc55D18A153949)

[0xaAe2...ae21](https://sepolia.etherscan.io/address/0xaAe29B0366299461418F5324a79Afc425BE5ae21)

Bridge

[0x8315...ed3a](https://etherscan.io/address/0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a)

[0xC1Eb...76Bd](https://etherscan.io/address/0xC1Ebd02f738644983b6C4B2d440b8e77DdE276Bd)

[0x38f9...33a9](https://sepolia.etherscan.io/address/0x38f918D0E9F1b721EDaA41302E399fa1B79333a9)

Outbox

[0x0B98...4840](https://etherscan.io/address/0x0B9857ae2D4A3DBe74ffE1d7DF045bb7F96E4840)

[0xD4B8...cc58](https://etherscan.io/address/0xD4B80C3D7240325D18E645B49e6535A3Bf95cc58)

[0x65f0...B78F](https://sepolia.etherscan.io/address/0x65f07C7D521164a4d5DaC6eB8Fac8DA067A3B78F)

Classic Outbox\*\*\*

[0x7607...1A40](https://etherscan.io/address/0x760723CD2e632826c38Fef8CD438A4CC7E7E1A40)  
[0x667e...337a](https://etherscan.io/address/0x667e23ABd27E623c11d4CC00ca3EC4d0bD63337a)

\*\*\*Migrated Network Only

### Fraud proof contracts[​](#fraud-proof-contracts "Direct link to Fraud proof contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

ChallengeManager

[0xA556...9fB0](https://etherscan.io/address/0xA5565d266c3c3Ee90B16Be8A5b13d587ef559fB0)

[0xFE66...A688](https://etherscan.io/address/0xFE66b18Ef1B943F8594A2710376Af4B01AcfA688)

[0xC60b...8B4C](https://sepolia.etherscan.io/address/0xC60b56Ff6aAb3FE8B9Bd70040Fe9E95A26258B4C)

OneStepProver0

[0x35FB...F731](https://etherscan.io/address/0x35FBC5F03d86E88973B06Fb9C5a913D54AbdF731)

[0x35FB...F731](https://etherscan.io/address/0x35FBC5F03d86E88973B06Fb9C5a913D54AbdF731)

[0x3Fe7...1377](https://sepolia.etherscan.io/address/0x3Fe73F959C44e04d660dBFBbeffd51FD2c091377)

OneStepProverMemory

[0xe0ba...C48b](https://etherscan.io/address/0xe0ba77e0E24de5369e3B268Ea79fDe716e2EC48b)

[0xe0ba...C48b](https://etherscan.io/address/0xe0ba77e0E24de5369e3B268Ea79fDe716e2EC48b)

[0x6268...ec2d](https://sepolia.etherscan.io/address/0x6268Fc8dB1b5083b405b2C51808Df3619783ec2d)

OneStepProverMath

[0xaB95...F921](https://etherscan.io/address/0xaB9596a0aaF28bc798c453434EC2DC0F8F0bF921)

[0xaB95...F921](https://etherscan.io/address/0xaB9596a0aaF28bc798c453434EC2DC0F8F0bF921)

[0x42f5...e8Fa](https://sepolia.etherscan.io/address/0x42f58c90583eC3fA0E0b724dEDF755AE1068e8Fa)

OneStepProverHostIo

[0xa07c...71Cf](https://etherscan.io/address/0xa07cD154340CC74EcF156FFB9fb378Ee29Ca71Cf)

[0xa07c...71Cf](https://etherscan.io/address/0xa07cD154340CC74EcF156FFB9fb378Ee29Ca71Cf)

[0xdB2c...C165](https://sepolia.etherscan.io/address/0xdB2c541e20Bd1830c8a050341Fca0Af51489C165)

OneStepProofEntry

[0x4397...42d6](https://etherscan.io/address/0x4397fE1E959Ba81B9D5f1A9679Ddd891955A42d6)

[0x4397...42d6](https://etherscan.io/address/0x4397fE1E959Ba81B9D5f1A9679Ddd891955A42d6)

[0xB9cf...AE80](https://sepolia.etherscan.io/address/0xB9cf664A1beD8F74f4B893a18c86eCe876CdAE80)

Token bridge smart contracts[​](#token-bridge-smart-contracts "Direct link to Token bridge smart contracts")
------------------------------------------------------------------------------------------------------------

### Core contracts[​](#core-contracts-1 "Direct link to Core contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

L1 Gateway Router

[0x72Ce...31ef](https://etherscan.io/address/0x72Ce9c846789fdB6fC1f34aC4AD25Dd9ef7031ef)

[0xC840...cD48](https://etherscan.io/address/0xC840838Bc438d73C16c2f8b22D2Ce3669963cD48)

[0xcE18...8264](https://sepolia.etherscan.io/address/0xcE18836b233C83325Cc8848CA4487e94C6288264)

L1 ERC20 Gateway

[0xa3A7...0EeC](https://etherscan.io/address/0xa3A7B6F88361F48403514059F1F16C8E78d60EeC)

[0xB253...21bf](https://etherscan.io/address/0xB2535b988dcE19f9D71dfB22dB6da744aCac21bf)

[0x902b...3aFF](https://sepolia.etherscan.io/address/0x902b3E5f8F19571859F4AB1003B960a5dF693aFF)

L1 Arb-Custom Gateway

[0xcEe2...180d](https://etherscan.io/address/0xcEe284F754E854890e311e3280b767F80797180d)

[0x2312...232f](https://etherscan.io/address/0x23122da8C581AA7E0d07A36Ff1f16F799650232f)

[0xba2F...40F3](https://sepolia.etherscan.io/address/0xba2F7B6eAe1F9d174199C5E4867b563E0eaC40F3)

L1 Weth Gateway

[0xd920...e2db](https://etherscan.io/address/0xd92023E9d9911199a6711321D1277285e6d4e2db)

[0xE4E2...0BaE](https://etherscan.io/address/0xE4E2121b479017955Be0b175305B35f312330BaE)

[0xA8aD...0e1E](https://sepolia.etherscan.io/address/0xA8aD8d7e13cbf556eE75CB0324c13535d8100e1E)

L1 Weth

[0xC02a...6Cc2](https://etherscan.io/address/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)

[0xC02a...6Cc2](https://etherscan.io/address/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)

[0x7b79...E7f9](https://sepolia.etherscan.io/address/0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9)

L1 Proxy Admin

[0x9aD4...0aDa](https://etherscan.io/address/0x9aD46fac0Cf7f790E5be05A0F15223935A0c0aDa)

[0xa8f7...e560](https://etherscan.io/address/0xa8f7DdEd54a726eB873E98bFF2C95ABF2d03e560)

[0xDBFC...44b0](https://sepolia.etherscan.io/address/0xDBFC2FfB44A5D841aB42b0882711ed6e5A9244b0)

The following contracts are deployed on the corresponding L2 chain

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

L2 Gateway Router

[0x5288...F933](https://arbiscan.io/address/0x5288c571Fd7aD117beA99bF60FE0846C4E84F933)

[0x2190...DFa8](https://nova.arbiscan.io/address/0x21903d3F8176b1a0c17E953Cd896610Be9fFDFa8)

[0x9fDD...43C7](https://sepolia.arbiscan.io/address/0x9fDD1C4E4AA24EEc1d913FABea925594a20d43C7)

L2 ERC20 Gateway

[0x09e9...1EEe](https://arbiscan.io/address/0x09e9222E96E7B4AE2a407B98d48e330053351EEe)

[0xcF9b...9257](https://nova.arbiscan.io/address/0xcF9bAb7e53DDe48A6DC4f286CB14e05298799257)

[0x6e24...b502](https://sepolia.arbiscan.io/address/0x6e244cD02BBB8a6dbd7F626f05B2ef82151Ab502)

L2 Arb-Custom Gateway

[0x0967...5562](https://arbiscan.io/address/0x096760F208390250649E3e8763348E783AEF5562)

[0xbf54...51F4](https://nova.arbiscan.io/address/0xbf544970E6BD77b21C6492C281AB60d0770451F4)

[0x8Ca1...42C5](https://sepolia.arbiscan.io/address/0x8Ca1e1AC0f260BC4dA7Dd60aCA6CA66208E642C5)

L2 Weth Gateway

[0x6c41...623B](https://arbiscan.io/address/0x6c411aD3E74De3E7Bd422b94A27770f5B86C623B)

[0x7626...D9eD](https://nova.arbiscan.io/address/0x7626841cB6113412F9c88D3ADC720C9FAC88D9eD)

[0xCFB1...556D](https://sepolia.arbiscan.io/address/0xCFB1f08A4852699a979909e22c30263ca249556D)

L2 Weth

[0x82aF...Bab1](https://arbiscan.io/address/0x82aF49447D8a07e3bd95BD0d56f35241523fBab1)

[0x722E...5365](https://nova.arbiscan.io/address/0x722E8BdD2ce80A4422E880164f2079488e115365)

[0x980B...7c73](https://sepolia.arbiscan.io/address/0x980B62Da83eFf3D4576C647993b0c1D7faf17c73)

L2 Proxy Admin

[0xd570...2a86](https://arbiscan.io/address/0xd570aCE65C43af47101fC6250FD6fC63D1c22a86)

[0xada7...d92C](https://nova.arbiscan.io/address/0xada790b026097BfB36a5ed696859b97a96CEd92C)

[0x715D...5FdF](https://sepolia.arbiscan.io/address/0x715D99480b77A8d9D603638e593a539E21345FdF)

### Third party gateways[​](#third-party-gateways "Direct link to Third party gateways")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

L1 Dai Gateway

[0xD3B5...3011](https://etherscan.io/address/0xD3B5b60020504bc3489D6949d545893982BA3011)

L1 Livepeer Gateway

[0x6142...0676](https://etherscan.io/address/0x6142f1C8bBF02E6A6bd074E8d564c9A5420a0676)

The following contracts are deployed on the corresponding L2 chain

Arbitrum One

L2 Dai Gateway

[0x4671...6C65](https://arbiscan.io/address/0x467194771dAe2967Aef3ECbEDD3Bf9a310C76C65)

L2 Livepeer Gateway

[0x6D24...D318](https://arbiscan.io/address/0x6D2457a4ad276000A615295f7A80F79E48CcD318)

Precompiles[​](#precompiles "Direct link to Precompiles")
---------------------------------------------------------

The following precompiles are deployed on every L2 chain and always have the same address

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

ArbAddressTable

[0x0000...0066](https://arbiscan.io/address/0x0000000000000000000000000000000000000066)

[0x0000...0066](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000066)

[0x0000...0066](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000066)

ArbAggregator

[0x0000...006D](https://arbiscan.io/address/0x000000000000000000000000000000000000006D)

[0x0000...006D](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006D)

[0x0000...006D](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006D)

ArbFunctionTable

[0x0000...0068](https://arbiscan.io/address/0x0000000000000000000000000000000000000068)

[0x0000...0068](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000068)

[0x0000...0068](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000068)

ArbGasInfo

[0x0000...006C](https://arbiscan.io/address/0x000000000000000000000000000000000000006C)

[0x0000...006C](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006C)

[0x0000...006C](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006C)

ArbInfo

[0x0000...0065](https://arbiscan.io/address/0x0000000000000000000000000000000000000065)

[0x0000...0065](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000065)

[0x0000...0065](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000065)

ArbOwner

[0x0000...0070](https://arbiscan.io/address/0x0000000000000000000000000000000000000070)

[0x0000...0070](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000070)

[0x0000...0070](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000070)

ArbOwnerPublic

[0x0000...006b](https://arbiscan.io/address/0x000000000000000000000000000000000000006b)

[0x0000...006b](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006b)

[0x0000...006b](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006b)

ArbRetryableTx

[0x0000...006E](https://arbiscan.io/address/0x000000000000000000000000000000000000006E)

[0x0000...006E](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006E)

[0x0000...006E](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006E)

ArbStatistics

[0x0000...006F](https://arbiscan.io/address/0x000000000000000000000000000000000000006F)

[0x0000...006F](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006F)

[0x0000...006F](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006F)

ArbSys

[0x0000...0064](https://arbiscan.io/address/0x0000000000000000000000000000000000000064)

[0x0000...0064](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000064)

[0x0000...0064](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000064)

ArbWasm

[0x0000...0071](https://arbiscan.io/address/0x0000000000000000000000000000000000000071)

[0x0000...0071](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000071)

[0x0000...0071](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000071)

ArbWasmCache

[0x0000...0072](https://arbiscan.io/address/0x0000000000000000000000000000000000000072)

[0x0000...0072](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000072)

[0x0000...0072](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000072)

NodeInterface

[0x0000...00C8](https://arbiscan.io/address/0x00000000000000000000000000000000000000C8)

[0x0000...00C8](https://nova.arbiscan.io/address/0x00000000000000000000000000000000000000C8)

[0x0000...00C8](https://sepolia.arbiscan.io/address/0x00000000000000000000000000000000000000C8)

Misc[​](#misc "Direct link to Misc")
------------------------------------

The following contracts are deployed on the corresponding L2 chain

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

L2 Multicall

[0x842e...4EB2](https://arbiscan.io/address/0x842eC2c7D803033Edf55E478F461FC547Bc54EB2)

[0x5e1e...cB86](https://nova.arbiscan.io/address/0x5e1eE626420A354BbC9a95FeA1BAd4492e3bcB86)

[0xA115...d092](https://sepolia.arbiscan.io/address/0xA115146782b7143fAdB3065D86eACB54c169d092)

---

# Write Stylus Contracts | Arbitrum Docs

## Write Stylus Contracts

Let's learn how to write contracts with Stylus!

[

### A gentle introduction

Start with the basics of Stylus contracts.



](https://docs.arbitrum.io/stylus/gentle-introduction)[

### Quickstart (Rust)

Get started quickly with Rust.



](https://docs.arbitrum.io/stylus/quickstart)[

### Testnet

Explore the testnet environment.



](https://docs.arbitrum.io/stylus/reference/testnet-information)[

### Stylus by example

Learn Stylus through examples.



](https://stylus-by-example.org)[

### Stylus Rust SDK

Dive into the Stylus Rust SDK.



](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide)[

### Gas, ink and caching

Learn about gas, ink, and caching strategies.



](https://docs.arbitrum.io/stylus/concepts/gas-metering)[

### CLI tools (cargo-stylus)

Master the CLI tools for Stylus.



](/stylus/cli-tools-overview)[

### Run a Stylus dev node

Set up and run a development node.



](https://docs.arbitrum.io/run-arbitrum-node/run-local-dev-node)[

### Other supported languages

Explore other languages supported by Stylus.



](https://docs.arbitrum.io/stylus/reference/stylus-sdk)[

### Troubleshooting

Find solutions to common issues.



](https://docs.arbitrum.io/stylus/troubleshooting-building-stylus)[

### Source code repository

Check out the source code.



](https://github.com/OffchainLabs/stylus)[

### Public preview

View the public preview of Stylus.



](https://docs.arbitrum.io/stylus/concepts/public-preview-expectations)

---

# Troubleshooting Stylus | Arbitrum Docs

## Troubleshooting Stylus

### How does Stylus manage security issues in smart contracts when interacting with so many different languages?[​](#how-does-stylus-manage-security-issues-in-smart-contracts-when-interacting-with-so-many-different-languages "Direct link to How does Stylus manage security issues in smart contracts when interacting with so many different languages?")

All languages are compiled to WASM for them to be able to work with Stylus. So it just needs to verify that the produced WASM programs behave as they should inside the new virtual machine.

### Is there any analogue of the fallback function from Solidity in the Rust Stylus SDK?[​](#is-there-any-analogue-of-the-fallback-function-from-solidity-in-the-rust-stylus-sdk "Direct link to Is there any analogue of the fallback function from Solidity in the Rust Stylus SDK?")

Currently there isn't any analogue. However, you can use a minimal entrypoint and perform raw delegate calls, forwarding your calldata. You can find more information in [Bytes-in, bytes-out programming](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#bytes-in-bytes-out-programming) and [call, static\_call and delegate\_call](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#call-static_call-and-delegate_call).

### Why are constructors not yet supported for Stylus contracts?[​](#why-are-constructors-not-yet-supported-for-stylus-contracts "Direct link to Why are constructors not yet supported for Stylus contracts?")

Constructors use EVM bytecode to initialize state. While one could add EVM bytecode manually to their Stylus deployment, we don't allow WASM execution in the constructor so there's no way to express this in the SDK.

We're working on models that will make init easier, so there might be better solutions available in the future. For now, we suggest calling an init method after deploying.

### Is it possible to verify Stylus contracts on the block explorer?[​](#is-it-possible-to-verify-stylus-contracts-on-the-block-explorer "Direct link to Is it possible to verify Stylus contracts on the block explorer?")

Currently it is not possible to verify contracts compiled to WASM on the block explorer, but we are actively working with providers to have the verification process ready for when Stylus reaches mainnet-ready status.

### Do Stylus contracts compile down to EVM bytecode like prior other attempts?[​](#do-stylus-contracts-compile-down-to-evm-bytecode-like-prior-other-attempts "Direct link to Do Stylus contracts compile down to EVM bytecode like prior other attempts?")

No. Stylus contracts are compiled down to WASM. The user writes a program in Rust / C / C++ which is then compiled down to WebAssembly.

### How is a Stylus contract deployed?[​](#how-is-a-stylus-contract-deployed "Direct link to How is a Stylus contract deployed?")

Stylus contracts are deployed on chain as a blob of bytes, just like EVM ones. The only difference is that when the contract is executed, instead of invoking the EVM, we invoke a separate WASM runtime. Note that a special EOF-inspired prefix distinguishes Stylus contracts from traditional EVM contracts: when a contract's bytecode starts with the magic `0xEFF00000` prefix, it's a Stylus WASM contract.

### Is there a new transaction type to deploy Stylus contracts?[​](#is-there-a-new-transaction-type-to-deploy-stylus-contracts "Direct link to Is there a new transaction type to deploy Stylus contracts?")

You deploy a Stylus contract the same way that Solidity contracts are deployed. There are no special transaction types. As a UX note: a WASM will revert until a special instrumentation operation is performed by a call to the new  `ArbWasm` precompile, which readies the program for calls on-chain.

You can find instructions for deploying a Stylus contract in our [Quickstart](https://docs.arbitrum.io/stylus/stylus-quickstart#checking-your-stylus-project-is-valid).

### Do Stylus contracts use a different type of ABI?[​](#do-stylus-contracts-use-a-different-type-of-abi "Direct link to Do Stylus contracts use a different type of ABI?")

Stylus contracts use solidity ABIs. Methods, signatures, logs, calls, etc. work exactly as in the EVM. From a user's / explorer's perspective, it all just looks and behaves like solidity.

### Does the Stylus SDK for Rust support custom data structures?[​](#does-the-stylus-sdk-for-rust-support-custom-data-structures "Direct link to Does the Stylus SDK for Rust support custom data structures?")

For in-memory usage, you should be able to use any implementation of custom data structures without problems.

For storage usage, it might be a bit more complicated. Stylus uses the EVM storage system, so you'll need to define the data structure on top of it. However, in the SDK there's a storage trait that custom types can implement to back their collections with the EVM state trie. The SDK macros are compatible with them too, although fundamentally it's still a global key-value system.

You can read more about it in the [Stylus Rust SDK page](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#storage).

As an alternative solution, you can use [entrypoint-style contracts](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#bytes-in-bytes-out-programming) for your custom data structures.

### Why do I get an error "no library targets found in package" when trying to compile and old example?[​](#why-do-i-get-an-error-no-library-targets-found-in-package-when-trying-to-compile-and-old-example "Direct link to Why do I get an error \"no library targets found in package\" when trying to compile and old example?")

Some of the first Stylus examples were built and deployed using a previous version of [cargo-stylus](https://github.com/OffchainLabs/cargo-stylus) (`0.1.x`). In that version, Stylus projects were structured as regular Rust binaries.

Since [cargo-stylus v0.2.1](https://github.com/OffchainLabs/cargo-stylus/releases/tag/v0.2.1), Stylus projects are structured as libraries, so when trying to compile old projects you might get an error `no library targets found in package`.

To solve this, it's usually enough to rename the `main.rs` file to a `lib.rs` file.

### How can I generate the ABI of my Stylus contract?[​](#how-can-i-generate-the-abi-of-my-stylus-contract "Direct link to How can I generate the ABI of my Stylus contract?")

The [cargo-stylus tool](https://github.com/OffchainLabs/cargo-stylus/tree/main#exporting-solidity-abis) has a command that allows you to export the ABI of your Stylus contract: `cargo stylus export-abi`.

If you're using the Stylus Rust SDK, you'll need to enable the export-abi feature in your Cargo.toml file like so:

```rust
[features]
export-abi = ["stylus-sdk/export-abi"]
```

You'll also need to have a `main.rs` file that selects that feature.

This is an example of a main.rs file that allows you to export the abi of the [stylus-hello-world](https://github.com/OffchainLabs/stylus-hello-world) example project:

```rust
#![cfg_attr(not(feature = "export-abi"), no_main)]

#[cfg(feature = "export-abi")]
fn main() {
    stylus_hello_world::main();
}
```

---

# Using Stylus CLI | Arbitrum Docs

## Using Stylus CLI

This guide will get you started using [cargo stylus](https://github.com/OffchainLabs/cargo-stylus), a CLI toolkit to help developers manage, compile, deploy, and optimize their Stylus contracts efficiently.

This overview will help you discover and learn how to uses cargo stylus tools.

### Installing cargo stylus[​](#installing-cargo-stylus "Direct link to Installing cargo stylus")

Cargo stylus is a plugin to the standard cargo tool for developing Rust programs.

#### Prerequisites[​](#prerequisites "Direct link to Prerequisites")

Rust toolchain

Follow the instructions on [Rust Lang's installation page](https://www.rust-lang.org/tools/install) to install a complete Rust toolchain (v1.81 or newer) on your system. After installation, ensure you can access the programs `rustup`, `rustc`, and `cargo` from your preferred terminal application.

Docker

We will use the testnet, and some `cargo stylus` commands will require Docker to operate.

You can download Docker from [Docker's website](https://www.docker.com/products/docker-desktop).

Foundry's Cast

[Foundry's Cast](https://book.getfoundry.sh/cast/) is a command-line tool for interacting with your EVM contracts.

Nitro devnode

Stylus is available on Arbitrum Sepolia, but we'll use Nitro devnode, which has a pre-funded wallet, saving us the effort of wallet provisioning or running out of tokens to send transactions.

Install your devnode

```rust
git clone https://github.com/OffchainLabs/nitro-devnode.git
cd nitro-devnode
```

Launch your devnode

```rust
./run-dev-node.sh
```

#### Installation[​](#installation "Direct link to Installation")

In your terminal, run:

```rust
cargo install --force cargo-stylus
```

Add WASM ([WebAssembly](https://webassembly.org/)) as a build target for the specific Rust toolchain you are using. The below example sets your default Rust toolchain to 1.80 as well as adding the WASM build target:

```rust
rustup default 1.80
rustup target add wasm32-unknown-unknown --toolchain 1.80
```

You can verify the cargo stylus installation by running `cargo stylus -V` in your terminal, returning something like:`stylus 0.5.6`

### Using cargo stylus[​](#using-cargo-stylus "Direct link to Using cargo stylus")

#### Cargo Stylus Commands Reference[​](#cargo-stylus-commands-reference "Direct link to Cargo Stylus Commands Reference")

Command

Description

Arguments

Options

Example Usage

`new`

Create a new Stylus project

• `name`: Project name (required)

• `--minimal`: Create a minimal contract

`cargo stylus new <YOUR_PROJECT_NAME>`

`init`

Initialize a Stylus project in current directory

• `--minimal`: Create a minimal contract

`cargo stylus init --minimal`

`export-abi`

Export a Solidity ABI

• `--output`: Output file (defaults to stdout)  
• `--json`: Write JSON ABI using `solc`

`cargo stylus export-abi --json`

`activate`

Activate an already deployed contract

• `--address`: Contract address to activate

• `--data-fee-bump-percent`: Percent to bump estimated fee (default 20%)  
• `--estimate-gas`: Only estimate gas without sending transaction

`cargo stylus activate --address <CONTRACT_ADDRESS>`

`cache`

Cache contract using Stylus CacheManager

• `bid`: Place bid on contract  
• `status`: Check contract status  
• `suggest-bid`: Get suggested minimum bid

`cargo stylus cache bid --address <CONTRACT_ADDRESS>`

`check`

Check a contract

• `--wasm-file`: WASM file to check  
• `--contract-address`: Deployment address

`deploy`

Deploy a contract

• `--contract-address <CONTRACT_ADDRESS>`: Where to deploy and activate the contract (defaults to a random address)

• `--estimate-gas`: Only perform estimation  
• `--no-verify`: Skip reproducible container  
• `--cargo-stylus-version`: Version for Docker image  
• `--source-files-for-project-hash <SOURCE_FILES_FOR_PROJECT_HASH>`: Path to source files to include in the project hash  
• `--max-fee-per-gas-gwei <MAX_FEE_PER_GAS_GWEI>`: Optional max fee per gas in gwei units  
• `--wasm-file <WASM_FILE>`: The WASM file to check (defaults to any found in the current directory)

`cargo stylus deploy --endpoint='http://localhost:8547' --private-key="<PRIVATE_KEY>" --estimate-gas`

`verify`

Verify contract deployment

• `--deployment-tx`: Hash of deployment transaction

• `--no-verify`: Skip reproducible container  
• `--cargo-stylus-version`: Version for Docker image

`cgen`

Generate C code bindings

• `--input`: Input file path  
• `--out_dir`: Output directory path

`replay`

Replay transaction in GDB

• `-t, --tx <TX>`: Transaction to replay

• `-p, --project <PROJECT>`: Project path (default: `.`)  
• `-u, --use-native-tracer`: Use the native tracer instead of the JavaScript one (may not be available in the node)  
• `-s, --stable-rust`: Use stable Rust (note that nightly is needed to expand macros)

`cargo stylus replay --tx <TX>`

`trace`

Trace a transaction

• `--tx`: Transaction hash

• `--endpoint`: RPC endpoint  
• `--project`: Project path  
• `--use-native-tracer`: Use native tracer

##### Common options[​](#common-options "Direct link to Common options")

These options are available across multiple commands:

Option

Description

\--endpoint

Arbitrum RPC endpoint (default: [http://localhost:8547](http://localhost:8547))

\--verbose

Print debug info

\--source-files-for-project-hash

Paths to source files for project hash

\--max-fee-per-gas-gwei

Optional max fee per gas in gwei

##### Authentication options[​](#authentication-options "Direct link to Authentication options")

Available for commands involving transactions:

Option

Description

\--private-key-path

Path to file containing hex-encoded private key

\--private-key

Private key as hex string (exposes to shell history)

\--keystore-path

Path to Ethereum wallet keystore file

\--keystore-password-path

Keystore password file path

#### How-tos[​](#how-tos "Direct link to How-tos")

Topic

Description

[Learn how to optimize WASM binaries](https://docs.arbitrum.io/stylus/how-tos/optimizing-binaries)

The `cargo-stylus` tool allows you to optimize WebAssembly (WASM) binaries, ensuring that your contracts are as efficient as possible.

[Debug Stylus transactions](https://docs.arbitrum.io/stylus/how-tos/debug-stylus-transactions)

A guide to debugging transactions, helping you identify and fix issues. Gain insights into your Stylus contracts by debugging transactions.

[Verify contracts](https://docs.arbitrum.io/stylus/how-tos/verify-contracts)

Ensure that your Stylus contracts are correctly verified. Step-by-step instructions on how to verify your contracts using `cargo-stylus`.

[Run a Stylus dev node](https://docs.arbitrum.io/run-arbitrum-node/run-local-dev-node)

Learn how to run a local Arbitrum dev node to test your Stylus contracts.

#### Additional resources[​](#additional-resources "Direct link to Additional resources")

#### [Troubleshooting](https://docs.arbitrum.io/stylus/troubleshooting-building-stylus): solve the most common issues.[​](#troubleshooting-solve-the-most-common-issues "Direct link to troubleshooting-solve-the-most-common-issues")

#### [cargo-stylus repository](https://github.com/OffchainLabs/stylus): consult cargo stylus' source code.[​](#cargo-stylus-repository-consult-cargo-stylus-source-code "Direct link to cargo-stylus-repository-consult-cargo-stylus-source-code")

---

errCannot read properties of null (reading 'innerHTML')

---

errCannot read properties of null (reading 'innerHTML')

---

# Get started with Arbitrum | Arbitrum Docs

## Get started with Arbitrum

 is a suite of Ethereum scaling solutions that make it easy to build and use decentralized applications. This document provides a high-level overview of the Arbitrum suite along with onboarding guidance tailored to specific audiences.

The Arbitrum suite[​](#the-arbitrum-suite "Direct link to The Arbitrum suite")
------------------------------------------------------------------------------

The Arbitrum suite includes the protocols, chains, services, and SDKs that power the Arbitrum ecosystem:

Component

Description

[Arbitrum Rollup](/how-arbitrum-works/optimistic-rollup)

A **protocol** for scaling Ethereum smart contracts.

[Arbitrum AnyTrust](/how-arbitrum-works/anytrust-protocol)

A **protocol** for scaling Ethereum smart contracts even further, with a mild trust assumption.

[Arbitrum Nitro](/how-arbitrum-works/a-gentle-introduction)

The node **software** that codifies the Rollup and AnyTrust protocols.

[Arbitrum nodes](/run-arbitrum-node/run-full-node)

**Machines** that run Nitro in order to service and/or interact with an Arbitrum chain.

[Arbitrum One](https://portal.arbitrum.io/?chains=arbitrum-one)

A public Rollup **chain**.

[Arbitrum Nova](https://portal.arbitrum.io/?chains=arbitrum-nova)

A public AnyTrust **chain**.

[Arbitrum bridge](https://bridge.arbitrum.io/)

Lets you move ETH and ERC-20 tokens between Ethereum, Arbitrum, and select Orbit chains.

[Arbitrum Orbit](https://orbit.arbitrum.io/)

Lets you run your own Rollup and AnyTrust chains.

[Arbitrum Stylus](/stylus/gentle-introduction)

Lets you write EVM-compatible smart contracts in Rust and any other language that compiles to Wasm.

Arbitrum for users[​](#arbitrum-for-users "Direct link to Arbitrum for users")
------------------------------------------------------------------------------

**Users** interact with Arbitrum either through the Arbitrum bridge or by using dApps that have been deployed to an Arbitrum chain.

Resource

Description

[Arbitrum bridge](https://bridge.arbitrum.io/)

Lets you move ETH and ERC-20 tokens between Ethereum, Arbitrum, and select Orbit chains.

[Arbitrum Portal](https://portal.arbitrum.io/)

A directory of dApps on Arbitrum.

[Quickstart (bridge)](/arbitrum-bridge/quickstart)

Provides step-by-step instructions for first-time bridge users.

Arbitrum for developers[​](#arbitrum-for-developers "Direct link to Arbitrum for developers")
---------------------------------------------------------------------------------------------

**Developers** build Arbitrum dApps by deploying smart contracts to an Arbitrum chain.

Resource

Description

[A gentle introduction to Arbitrum](/welcome/arbitrum-gentle-introduction)

A technical introduction to Arbitrum's suite of scaling solutions.

[Quickstart (Solidity)](/build-decentralized-apps/quickstart-solidity-remix)

Targeted at web2 developers who want to deploy their first Solidity smart contract to Arbitrum.

[Quickstart (Rust)](/stylus/quickstart)

Targeted at web3 developers who want to deploy their first Rust smart contract to Arbitrum using Stylus.

Arbitrum for node runners[​](#arbitrum-for-node-runners "Direct link to Arbitrum for node runners")
---------------------------------------------------------------------------------------------------

**Node runners** run the machines that support the Arbitrum ecosystem.

Resource

Description

[Run a full node](/run-arbitrum-node/run-full-node)

Targeted at node runners who want to access Arbitrum chains without having to connect to a third-party node.

[Configure a Data Availability Committee](/run-arbitrum-node/data-availability-committees/get-started)

Targeted at Data Availability Committee members and Orbit chain operators who want to run a Data Availability Server.

Arbitrum for chain operators[​](#arbitrum-for-chain-operators "Direct link to Arbitrum for chain operators")
------------------------------------------------------------------------------------------------------------

**Chain operators** use Arbitrum Orbit to run special-purpose Rollup and AnyTrust chains.

Resource

Description

[Orbit gentle introduction](/launch-orbit-chain/a-gentle-introduction)

Targeted at readers who want to understand Orbit's value proposition and use cases.

[Orbit quickstart](/launch-orbit-chain/orbit-quickstart)

Targeted at chain operators who want to deploy their first Arbitrum chain using Arbitrum Orbit.

How it works[​](#how-it-works "Direct link to How it works")
------------------------------------------------------------

Resource

Description

[Inside Nitro](/how-arbitrum-works/a-gentle-introduction)

A technical deep dive into Nitro's architecture.

[Inside AnyTrust](/how-arbitrum-works/anytrust-protocol)

A technical deep dive into the AnyTrust protocol.

[Arbitrum whitepaper](https://github.com/OffchainLabs/nitro/blob/master/docs/Nitro-whitepaper.pdf)

The original whitepaper that introduced Nitro.

[DAO docs](https://docs.arbitrum.foundation/gentle-intro-dao-governance)

Docs that support members of the Arbitrum DAO.

---

# Quickstart: Arbitrum bridge | Arbitrum Docs

## Quickstart: Arbitrum bridge

This quickstart is for users who want to "deposit" ETH or any ERC-20 tokens from a parent chain to a child chain (for example, from Ethereum to Arbitrum One, or from Arbitrum One to a Layer 3 Orbit chain), or "withdraw" from a child chain to a parent chain, using [Arbitrum's bridge](https://bridge.arbitrum.io/).

We will go through the whole process step by step with as much detail as possible. If you feel stuck in any of the steps, don't hesitate to contact us through our [Discord](https://discord.gg/arbitrum) and we will be happy to help you complete the process.

The only prerequisite for this quickstart is to have a web3 wallet installed, e.g., Metamask/OKX Wallet. If you don't have one, visit Arbitrum's [portal page](https://portal.arbitrum.io/?categories=wallet) to download one.

Deposit ETH or ERC-20 tokens (from parent chain to child chain)[​](#deposit-eth-or-erc-20-tokens-from-parent-chain-to-child-chain "Direct link to Deposit ETH or ERC-20 tokens (from parent chain to child chain)")
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Step 1: Get some native currency[​](#step-1-get-some-native-currency "Direct link to Step 1: Get some native currency")

You'll need the native currency of the parent chain to be able to bridge your assets from it to the destination chain. For example, if you want to bridge assets from Ethereum to Arbitrum One, you'll need ETH on Ethereum to initiate the process.

There are several ways to obtain the native currency:

*   Using a [supported centralized exchange](https://portal.arbitrum.io/projects?chains=arbitrum-one_arbitrum-nova&subcategories=centralized-exchanges), which allows you to purchase ETH and withdraw it to your wallet. Most of the major centralized exchanges support direct withdrawal from your centralized exchange wallet to Arbitrum.
*   Using an [on-ramp service](https://portal.arbitrum.io/projects?chains=arbitrum-one_arbitrum-nova&subcategories=fiat-on-ramp), which allows you to purchase ETH and send it directly to your wallet.
*   If you are using a testnet, requesting funds from a faucet for [Sepolia](https://sepoliafaucet.com/) or [Arbitrum Sepolia](https://faucet.quicknode.com/arbitrum/sepolia).

### Step 2: Add the preferred network to your wallet[​](#step-2-add-the-preferred-network-to-your-wallet "Direct link to Step 2: Add the preferred network to your wallet")

You'll also need to add the desired chain's RPC endpoint to your wallet. Here we provide an example for doing this using MetaMask/OKX Wallet, although the process should be similar for other wallets. You need to first click on the MetaMask/OKX Wallet extension on your browser, click the network selector dropdown on the top-left corner, and then click the `Add Network` button at the bottom. Click "Add a network manually" and then provide the information corresponding to the chain you want to send your assets to.

![Add the desired destination network to your MetaMask/OKX wallet](/img/arb-bridge-getting_started_users_1.png)

Here we display the information of the most common Arbitrum chains, but you can find a more exhaustive list in our [RPC endpoints and providers](/build-decentralized-apps/reference/node-providers) page.

Parameter

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia (testnet)

Network name

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

RPC URL

[https://arb1.arbitrum.io/rpc](https://arb1.arbitrum.io/rpc)

[https://nova.arbitrum.io/rpc](https://nova.arbitrum.io/rpc)

[https://sepolia-rollup.arbitrum.io/rpc](https://sepolia-rollup.arbitrum.io/rpc)

Chain ID

42161

42170

421614

Currency symbol

ETH

ETH

SepoliaETH

Block explorer URL

[https://arbiscan.io](https://arbiscan.io)

[https://nova.arbiscan.io/](https://nova.arbiscan.io/)

[https://sepolia.arbiscan.io](https://sepolia.arbiscan.io)

### Step 3: Initiate the deposit[​](#step-3-initiate-the-deposit "Direct link to Step 3: Initiate the deposit")

To bridge your ETH or ERC-20 tokens to a different chain, start by visiting [bridge.arbitrum.io](https://bridge.arbitrum.io/). Log in to the bridge with your wallet and make sure you are connected to the source network (from where you want to deposit your assets) at the top of the page. Then, select the destination network (where you want your assets to go), e.g., Arbitrum One or Arbitrum Nova.

caution

Note that testnets like Arbitrum Sepolia only appear if you are connected to the appropriate parent testnet network (Ethereum Sepolia).

![Add the desired network to your web3 wallet](/img/arb-bridge-getting_started_users_2.png)

Select the token you want to bridge in the token drop-down menu. You can also enable/disable the token lists by clicking `Manage token lists` button on the bottom right corner of the drop-down menu.

![Select the token to bridge](/img/arb-bridge-getting_started_users_3.png)

Enter the amount of ETH or ERC-20 tokens you want to bridge over in the **From** box and then press `Move funds`. Follow the prompts on your web3 wallet.

Ensure sufficient ETH balance

Please make sure you leave enough ETH on your wallet to pay for the transaction, otherwise there will be no web3 wallet popup.

![Enter the amount of tokens to bridge](/img/arb-bridge-getting_started_users_4.png)

After you submit the transaction through your web3 wallet you can expect your funds to arrive on the destination chain within roughly 15-30 minutes (depending on the chain congestion).

Also make sure your wallet is set to the destination chain so you can see your funds when they arrive.

Withdraw ETH or ERC-20 tokens (from child chain to parent chain)[​](#withdraw-eth-or-erc-20-tokens-from-child-chain-to-parent-chain "Direct link to Withdraw ETH or ERC-20 tokens (from child chain to parent chain)")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

There's at least a 7 day withdrawal period for Arbitrum One and Nova networks

Once you withdraw your funds from Arbitrum One or Nova through the Arbitrum bridge, you will have to wait for at least 7 days to receive them on Ethereum mainnet. For more details, see [Arbitrum Bridge: Troubleshooting](https://docs.arbitrum.io/arbitrum-bridge/troubleshooting#how-long-does-it-take-before-i-receive-my-funds-when-i-initiate-a-withdrawal-from-arbitrum-chains-one-and-nova).

To bridge your funds back to the parent chain, you'll need to be logged in to the [Arbitrum bridge](https://bridge.arbitrum.io/) with your wallet and make sure you are connected to the source network (from where you want to withdraw assets) at the top of the page. Then, select the destination network (where you want your assets to go), e.g., Ethereum mainnet.

caution

Note that testnets like Ethereum Sepolia only appear if you are connected to the appropriate child testnet network (Arbitrum Sepolia).

![Select the token to withdraw](/img/arb-bridge-getting_started_users_5.png)

Select the token you want to bridge in the token drop-down menu. You can also enable/disable the token lists by clicking `Manage token lists` button on the bottom right corner of the drop-down menu. Enter the amount of ETH or ERC-20 tokens you want to bridge over in the **from** box and then press `Move funds`. Follow the prompts on your web3 wallet.

Ensure sufficient ETH balance

Please make sure you leave enough ETH on your wallet to pay for the transaction, otherwise there will be no web3 wallet popup.

![Enter the amount of token to withdraw](/img/arb-bridge-getting_started_users_6.png)

A countdown will pop up stating that you’ll get your funds in 7-8 days.

You can check the status of your withdrawal by clicking on your profile on the top right and opening the `Transactions` tab, and claim it there when it’s ready.

![See the transaction history](/img/arb-bridge-getting_started_users_7.png)

Once the countdown is done, switch to the destination network on your wallet and press the `Claim` button, that has now turned blue, to receive your funds!

What's next?[​](#whats-next "Direct link to What's next?")
----------------------------------------------------------

The team working on Arbitrum is always interested and looking forward to engage with its users. Why not follow us on [X (Twitter)](https://x.com/arbitrum) or join our community on [Discord](https://discord.gg/arbitrum)?

---

# Troubleshooting: Arbitrum bridge | Arbitrum Docs

## Troubleshooting: Arbitrum bridge

### How do I move assets between One and Nova?[​](#how-do-i-move-assets-between-one-and-nova "Direct link to How do I move assets between One and Nova?")

Both Arbitrum One and Arbitrum Nova run as layers on top of Ethereum. Thus, you can always move assets between the two chains in two steps by going "through" Ethereum. In other words: withdraw your assets from Arbitrum One to Ethereum and then deposit them onto Nova, or conversely, withdraw your assets from Nova on to Ethereum and then deposit them on to Arbitrum One. These steps can all be done at [](https://bridge.arbitrum.io/)[https://bridge.arbitrum.io/](https://bridge.arbitrum.io/).

### What fees do I have to pay when bridging funds from L1 to L2?[​](#what-fees-do-i-have-to-pay-when-bridging-funds-from-l1-to-l2 "Direct link to What fees do I have to pay when bridging funds from L1 to L2?")

When bridging over tokens from L1 to L2, you will have to sign one or two transactions with their corresponding fees:

1.  If you are bridging a token for the first time, you'll sign one **approval transaction**.
2.  In all cases, you'll sign a **deposit transaction** that will send your tokens to the Bridge.

Keep in mind that the approval transaction needs to be executed at least once per token and wallet. This means that if you bridge the same token from the same wallet again, you probably won't have to pay for that transaction. However, if you bridge the same token from a different wallet, you will have to pay for that transaction again.

In any case, the bridge and your wallet will guide you through the process, showing the transaction(s) that you need to sign in order to have your tokens bridged to Arbitrum.

### How long does it take before I receive my funds when I initiate a withdrawal from Arbitrum chains (One and Nova)?[​](#how-long-does-it-take-before-i-receive-my-funds-when-i-initiate-a-withdrawal-from-arbitrum-chains-one-and-nova "Direct link to How long does it take before I receive my funds when I initiate a withdrawal from Arbitrum chains (One and Nova)?")

Using the official Arbitrum Bridge, the process will take _roughly_ one week. However, some users opt to use third-party fast bridges, which often bypass this delay (remember that these bridges are created and maintained by third parties, so please DYOR!).

There's some variability in the exact wall-clock time of the dispute window, plus there's some expected additional "padding" time on both ends (no more than about an hour, typically).

The variability of the dispute window comes from the slight variance of block times. Arbitrum One's dispute window is 45818 blocks; this converts to about 6.5 days, assuming slightly more than 12 seconds per block, the average block time of Ethereum.

The "padding on both ends" involves three events that have to occur between a client receiving their transaction receipt from the sequencer and their L2-to-L1 message being executable. After getting their receipt,

1.  The sequencer posts their transaction in a batch (usually within a few minutes, though the sequencer will wait a bit longer if the L1 is congested). Then,
2.  A validator includes their transaction in an assertion (usually within the hour). Then, after the ~week long dispute window passes, the assertion is confirmable, and
3.  Somebody (anybody) confirms the assertion on L1 (usually within ~15 minutes).

Additionally, in the rare and unlikely event of a dispute, this delay period will be extended for the dispute to resolve.

### Is there a way to cancel a withdrawal from Arbitrum?[​](#is-there-a-way-to-cancel-a-withdrawal-from-arbitrum "Direct link to Is there a way to cancel a withdrawal from Arbitrum?")

There is no way to cancel a withdrawal that has been already initiated. However, you can claim your funds on L1 and deposit them again on L2 once the [withdrawal period](https://developer.arbitrum.io/learn-more/faq#why-was-one-week-chosen-for-arbitrum-ones-dispute-window) is past.

### Can I use a smart contract wallet in the bridge?[​](#can-i-use-a-smart-contract-wallet-in-the-bridge "Direct link to Can I use a smart contract wallet in the bridge?")

Support for Smart Contract Wallets is currently limited to token depositing and withdrawal. Keep in mind that when withdrawing funds, you won't be able to claim them on L1 using the [bridge](https://bridge.arbitrum.io/) (unless you also control that address on L1). In that case, you can use the [cross-chain dashboard](https://retryable-dashboard.arbitrum.io/tx) to claim your funds on L1.

ETH deposits and withdrawals using a Smart Contract Wallet are currently not supported, but will soon be available.

### How can I claim withdrawn funds if I don't control on L1 the address that initiated the transaction on L2?[​](#how-can-i-claim-withdrawn-funds-if-i-dont-control-on-l1-the-address-that-initiated-the-transaction-on-l2 "Direct link to How can I claim withdrawn funds if I don't control on L1 the address that initiated the transaction on L2?")

Once the [withdrawal period](https://developer.arbitrum.io/learn-more/faq#why-was-one-week-chosen-for-arbitrum-ones-dispute-window) is past, you can use the [cross-chain dashboard](https://retryable-dashboard.arbitrum.io/tx) to execute the message on L1. Paste the transaction hash that initiated the withdrawal on L2, and follow the process described in the dashboard.

---

# USDC on Arbitrum One | Arbitrum Docs

## USDC on Arbitrum One

Arbitrum One supports two different types of USDC:

1.  **USDC (USDC)**: USDC tokens native to the Arbitrum One chain.
2.  **Bridged USDC (USDC.e)**: Ethereum-native USDC tokens that have been bridged to Arbitrum One.

### Differences between USDC and USDC.e[​](#differences-between-usdc-and-usdce "Direct link to Differences between USDC and USDC.e")

USDC

Bridged USDC

Token Name

USDC

Bridged USDC

Token Symbol

USDC

USDC.e

Token Address

[

0xaf88d065e77c8cC2239327C5EDb3A432268e5831

](https://arbiscan.io/token/0xaf88d065e77c8cC2239327C5EDb3A432268e5831)

[

0xff970a61a04b1ca14834a43f5de4533ebddb5cc8

](https://arbiscan.io/token/0xff970a61a04b1ca14834a43f5de4533ebddb5cc8)

Benefits

CEX Support, directly redeemable 1:1 for U.S dollars

The Arbitrum Bridge will continue to facilitate transfers of all USDC tokens. When depositing Ethereum-native USDC, the option exists to receive Bridged USDC using Arbitrum's bridge or Arbitrum-native USDC using Circle’s [Cross-Chain Transfer Protocol](https://www.circle.com/en/cross-chain-transfer-protocol).

### Historical context[​](#historical-context "Direct link to Historical context")

The Arbitrum Bridge will continue to facilitate transfers of all USDC tokens. When depositing USDC from Ethereum, the option exists to receive USDC using Circle’s Cross-Chain Transfer Protocol or receive Bridged USDC using Arbitrum’s lock-and-mint bridge. Historical context In 2023, Circle launched USDC natively on Arbitrum One and added support for Cross-Chain Transfer Protocol, which enabled direct minting and burning of USDC between Ethereum and Arbitrum One. Due to this, the token symbol for Bridged USDC was renamed to USDC.e to accommodate an ecosystem-wide liquidity migration to native USDC. The expectation is that over time the liquidity migration of USDC.e to USDC will continue.

---

# Security Audit Reports | Arbitrum Docs

## Security Audit Reports

Auditor

Audit date (MM/DD/YYY)

Audited code

View report

**Trail of Bits**

12/26/2024

BoLD Proposal Payload & Upgrade Actions + Misc Changes for Nitro Contracts v3.0.0

[view](/assets/files/2024_12_26_trail_of_bits_boldfixes_securityreview-95c9ee3b07ccb11e59e57744ddc017d2.pdf)

**Trail of Bits**

10/30/2024

Changes to BoLD Solidity contracts to support EIP7702 & Fast Withdrawals

[view](/assets/files/2024_10_30_trail_of_bits_security_audit_Nitro_Contracts_with_BoLD-90984d87c800f448601b84972e544e1d.pdf)

**Trail of Bits**

10/23/2024

ArbOS 32 Bianca: Emergency Stylus Fixes

[view](/assets/files/2024_10_23_trail_of_bits_security_audit_arbos32_emergency_fixes-d3e018abb506e80f9625508dbaab2358.pdf)

**Trail of Bits**

10/07/2024

Optimizations to BoLD history commitments

[view](/assets/files/2024_10_07_trail_of_bits_security_audit_bold_optimized_history_commitments-025bd74c8af33bb436e606b55a3ef550.pdf)

**Trail of Bits**

09/25/2024

Timeboost Auction Contracts

[view](/assets/files/2024_09_25_trail_of_bits_security_audit_timeboost_auction_contracts-2a8dbdf7b139db4224d30d6d1015aa85.pdf)

**Open Zeppelin**

09/05/2024

Initial Stylus Rust SDK audit

[view](/assets/files/2024_09_05_open_zeppelin_security_audit_stylus_rust_sdk-a78b94ded01f4e5f96dfd55a47158680.pdf)

**Trail of Bits**

08/29/2024

Orbit & Governance Upgrade Actions Contracts v2.1

[view](/assets/files/2024_08_29_trail_of_bits_security_audit_orbit_and_governance_upgrade_actions_v2.1-8d6150a317148e1bfcf428b4e2c8ef2d.pdf)

**Trail of Bits**

08/29/2024

USDC Custom Gateway & ArbOS Timestamp Upgrade Action contract

[view](/assets/files/2024_08_29_trail_of_bits_security_audit_usdc_custom_gateway_and_arbos_upgrade_at_timestamp_action-f490e6aa741551bfbf4b2349fcc82579.pdf)

**Trail of Bits**

08/05/2024

BoLD contract fixes from the May 2024 audit & DAC reward updates

[view](/assets/files/2024_08_05_trail_of_bits_security_audit_bold_and_dac_rewards_updates-d0d6028126d4539be649eb05db5380c4.pdf)

**Trail of Bits**

08/01/2024

Custom fee token

[view](/assets/files/2024_08_01_trail_of_bits_security_audit_custom_fee_token-7ce514634632f4735a710c81b55f2d27.pdf)

**Trail of Bits**

07/26/2024

ArbOS 31 Bianca: Nitro Upgrade

[view](/assets/files/2024_07_26_trail_of_bits_security_audit_arbos_31-4538d946ebcd4187b211a868b6e8ea08.pdf)

**Trail of Bits**

07/26/2024

ArbOS 30 Atlas: Nitro Upgrade

[view](/assets/files/2024_07_26_trail_of_bits_security_audit_arbos30_nitro_upgrade-d3b44d44e482a44a1710c80014a6630a.pdf)

**Code4rena**

06/17/2024

Arbitrum BoLD: Public Audit Competition Report

[view](/assets/files/2024_06_17_code4arena_security_audit_arbos30_nitro_upgrade-3663f40614e5dadebbf4ef0e6a8e5c1e.pdf)

**Trail of Bits**

06/10/2024

Arbitrum Stylus

[view](/assets/files/2024_06_10_trail_of_bits_security_audit_stylus-f2f68cbe59f5ac1c085292f6811c8ac9.pdf)

**Trail of Bits**

05/02/2024

BoLD contract fixes from the Aug 2023 audit & Delay Buffer changes to the sequencer inbox

[view](/assets/files/2024_05_02_trail_of_bits_security_audit_bold_delay_buffer-7329f073827e7e12aede9a9203db1e01.pdf)

**Chainsecurity**

03/20/2024

Nova Fee Router Updates (ArbOS 31)

[view](/assets/files/2024_08_20_chainsecurity_security_audit_nova_fee_router_update_arbos_31-12a4328ecb6f0966acacb54da8f49698.pdf)

**Trail of Bits**

03/18/2024

l1-l3-teleporter

[view](/assets/files/2024_03_18_trail_of_bits_security_audit_l1_l3_teleporter-76736686c28613a9473c149615f94765.pdf)

**Trail of Bits**

08/02/2023

Arbitrum BoLD - initial audit (then called challenge protocol v2)

[view](/assets/files/2023_08_02_trail_of_bits_security_audit_challenge_protocol_v2-b63429218c10faec79c4834f8582f9d3.pdf)

**Trail of Bits**

01/06/2023

Governance & Token Bridge

[view](/assets/files/2023_06_23_trail_of_bits_security_audit_governance_report_governance_token_bridge-ca76b55fb6c017c17ef78d0721f7e714.pdf)

**Trail of Bits**

10/10/2022

Nitro Node & Core Contracts, 2 of 2

[view](/assets/files/2022_10_22_trail_of_bits_security_audit_nitro_2_of_2-11d8ca6bdf6e154c9b62e401b3220b1e.pdf)

**ConsenSys Diligence**

06/24/2022

Nitro Node & Core Contracts

[view](/assets/files/2024_06_24_consensys_diligence_security_audit_nitro_contracts-b89f0db3702d3eec15a9211233ace9a6.pdf)

**Trail of Bits**

03/14/2022

Nitro Node & Core Contracts, 1 of 2

[view](/assets/files/2022_03_14_trail_of_bits_security_audit_nitro_1_of_2-d777111730bd602222978f7d98713d40.pdf)

**ConsenSys Diligence**

11/05/2021

Core Contracts, Token Bridge

[view](/assets/files/2021_11_05_consensys_diligence_security_audit_core_contracts_token_bridge-664fbe3e5a14a41acaee4af64ae06100.pdf)

---

# BoLD: a technical deep dive | Arbitrum Docs

## BoLD: a technical deep dive

Overview[​](#overview "Direct link to Overview")
------------------------------------------------

's current dispute protocol involves defending against challengers individually in a 1-vs-1 tournament setting. In contrast,  enables an all-vs-all battle royale between Good and Evil, with a single winner always determined. This dynamic is made possible by BoLD's time-bounded, permissionless validation using deterministic Merkle proofs and hashes. This allows any party to bond in the correct state and prove their claim through interactive fraud proofs, ensuring that a single honest party bonding in the correct state will always prevail in disputes.

Validators on Arbitrum can post their claim on the validity of state roots, known as **assertions**. Ethereum, of course, does not know anything about the validity of these Arbitrum state roots, but it _can_ help prove their correctness. _Anyone_ in the world can then initiate a  over any unconfirmed  to start the protocol’s game.

The assertions being disputed concern block hashes of an  at a given /inbox position. Given that Arbitrum chains are deterministic, there is only one correct history for all parties running the standard Nitro software. Using the notion of one-step proof, Ethereum can check whether someone is making a fraudulent assertion after an interactive game is played to narrow down a dispute.

If a claim is honest, it can be confirmed on Ethereum after a 6.4-day period (although the DAO can change this period). If a claim is malicious, anyone who knows the correct Arbitrum state can successfully challenge it within that 6.4-day window _and always win_ within a  plus some small delta.

The current implementation of BoLD involves both on-chain and off-chain components:

1.  Rollup contracts to be deployed on Ethereum.
    
2.  New challenge management contracts to be deployed on Ethereum.
    
3.  [Honest validator software](https://github.com/OffchainLabs/nitro) equipped to submit assertions and perform challenge moves on any assertions it disagrees with. The honest  is robust enough to win against malicious entities and always ensures honest assertions are the only ones confirmed on-chain.
    

### Key terminology[​](#key-terminology "Direct link to Key terminology")

*   **Arbitrum Rollup contracts:** The set of smart contracts on Ethereum  that serve as both the data availability layer for Arbitrum and for confirming the rollup's state assertions after a challenge period has passed for each assertion made.
    
*   **Assertions:** A claim posted to the Arbitrum Rollup contracts on Ethereum (parent chain) about the Arbitrum () execution state. Each claim consumes messages from the Arbitrum Rollup inbox contract. Each assertion can be confirmed after a period of 6.4 days, and anyone can challenge it during that period. A BoLD challenge will add an additional upper bound of 6.4 days to confirm an assertion. Gaining the right to post assertions requires placing a large, one-time bond, which can get taken away in the case of losing a challenge to a competing assertion.
    
*   **Bonding:** Participants in the protocol need to bond a certain amount of `WETH` to gain the privilege of posting assertions to the Rollup contracts by locking up an `WETH` bond in the protocol contracts. Whenever someone wants to create a sub-challenge, they must also place a smaller bond called a challenge bond when they do so. Bonds, their rationale, and magnitude will be covered in greater detail in the [Opening challenges](#opening-challenges) and [Subchallenges](#subchallenges) sections below, as well as the [Economics of disputes](/how-arbitrum-works/bold/bold-economics-of-disputes) page.
    
*   **Bonding of funds:** Creating an assertion in the Rollup contracts requires the submitter to join the validator set by putting up a large bond as `WETH`. Subsequent assertions posted by the same party do not require more bonds. Instead, the protocol always considers validators bonded to their latest posted assertion. The bonded funds are taken away if another competing assertion is confirmed. When an assertion is confirmed, the associated bonded funds can be withdrawn.
    
*   **Chain bindings:** Software that can interact with an Ethereum node in order to make calls and transactions to the on-chain contracts needed for participating in the protocol. We utilize go-ethereum’s abigen utilities to create Go bindings to interact with the contracts above, with a few more developer-friendly wrappers.
    
*   **ChallengeManager:** This is a contract that allows for initiating challenges on assertions and provides methods for anyone to participate in challenges in a permissionless fashion. BoLD will require a new `ChallengeManager` written in Solidity and deployed to Ethereum. The challenge manager contains entry points for making challenge moves, opening leaves, creating subchallenges, and confirming challenges.
    
*   **Challenge manager :** Software that can manage the life cycles of challenges that an  participates in. Validators need to be able to participate in multiple challenges at once and manage individual challenge vertices correctly to act upon, confirm, or reject them.
    
*   **Challenge period:** Window of time ([~6.4 days on Arbitrum One](https://docs.arbitrum.io/build-decentralized-apps/reference/chain-params)) over which an assertion can be challenged, after which the assertion can be confirmed. This is configurable by the DAO.
    
*   **:** A set of rules through which a disagreement on an assertion is resolved using Ethereum as the final arbiter. Ethereum's VM can verify one-step proofs of deterministic computation that will confirm a challenge winner in Arbitrum's Rollup contracts once the challenge period has elapsed.
    
*   **Delay attacks:** In a delay attack, a malicious party (or group of parties) acts within the challenge protocol and tries to delay the  of results back to the parent chain. Before BoLD, the previous challenge protocol allowed adversaries to do this by forcing the honest party to play 1-vs-1 games against them to delay confirmation. In contrast, BoLD has a proven, constant upper bound on confirmation times for assertions in Arbitrum, addressing the biggest flaw of the current challenge mechanism. BoLD validators don’t need to play 1-vs-1 challenges and instead can defend a single assertion against many malicious claims. With delay attacks solved, Arbitrum will be able to allow permissionless validation.
    
*   **Edge:** Edges are a portion of a claim made by a validator about the history of the chain from some end state all the way back to some initial state. Edges are the fundamental unit in a challenge.
    
*   **Fraud proofs:** Proofs that prove or disprove that an invalid state transition has taken place. These proofs are generated by challenge participants and are submitted to a chain's parent chain. For example, Arbitrum Rollups that settle onto Ethereum will have their proofs submitted to Ethereum and verified via a . In this case, these proofs allow Ethereum to be the final arbiter of disagreements over assertions in the Rollup contracts, which cannot be falsified by any parties as there is only a single, correct result of executing a `<a data-quicklook-from="wasm">WASM</a>` instruction on a pre-state. `WASM` is the assembly language that is used to represent programs whose execution is being disputed. In fact, Arbitrum, before and after BoLD, uses a slightly different language called WAVM when executing challenges. The difference is not important to this discussion, but for details, see the page outlining the differences between [WASM and WAVM](/how-arbitrum-works/interactive-fraud-proofs#wasm-to-wavm).
    
*   **Honest validator:** An entity that knows the correct state of the Arbitrum child chain and who may want to participate in creating assertions, confirming assertions, and/or challenging invalid assertions if they exist. More specifically, this entity must run an  in `MakeNodes`, `Defensive`, `StakeLatest`, or `ResolveNodes` mode as described in the [How to run a validator](https://docs.arbitrum.io/run-arbitrum-node/more-types/run-validator-node). Note that there must always be an active proposer (i.e., a validator who actively submits new assertions) to advance the chain and who will need to run a validator in `MakeNodes` mode.
    
*   **OneStepProver:** A set of existing contracts that implement a miniature `WASM` VM capable of executing one-step-proofs of computation of the child  transition function. This is implemented in Solidity and exists on Ethereum. No changes to the `OSP` contracts are needed for BoLD.
    
*   **Permissionless validation:** The ability for anyone to interact with the Arbitrum rollup contracts on Ethereum to both post assertions and challenge others' assertions without needing permission. With the release of BoLD, the rollup contracts on Arbitrum will no longer have a permissioned list of validators.
    
*   **Rollup contract:** This smart contract living on Ethereum allows validators to bond on state assertions about Arbitrum. It's known as [`RollupCore.sol`](https://github.com/OffchainLabs/nitro-contracts/blob/main/src/rollup/RollupCore.sol), and Arbitrum chains use it to post assertions. BoLD requires several changes to how assertions work in this contract, and it now contains a reference to another contract called a `ChallengeManager`, which is new in BoLD.
    
*   **State manager backend:** Software that can retrieve child chain states and produce commitments to `WAVM` histories for Arbitrum based on an execution server. The validator client, described below, will have access to a state manager backend in order to make moves on challenge vertices.
    
*   **Timers:** Each unrivaled edge (that is, an edge without another competing edge) will have a timer that _ticks up_. Time in the protocol is measured using parent blocks, and block numbers are used. An edge's timer stops ticking when a rival edge is created on-chain. We'll give a more detailed definition later, but two edges are considered rivals if they agree on some prefix of a computation starting from the same state but disagree on the remainder of that computation. Most importantly, timers are used to confirm assertions when an unrivaled edge's timer and associated assertion reaches the specified challenge period. See the section on [Timers and Edges](/bold/concepts/bold-technical-deep-dive#timers) for more details.
    
*   **Validating :** The smart contract that leverages Ethereum's security and censorship-resistance to unlock bridged assets from the child chain back to the parent. Assets can be unlocked after an assertion (showing that those assets have been bridged from the child chain) has been posted and confirmed.
    
*   **Validator client:** A validator client is software that knows the correct history of the Arbitrum child chain via a state manager backend and can create assertions on the parent chain about them by bonding a claim. A validator is also active in ensuring honest assertions get confirmed and participating in challenging those it disagrees with. In BoLD, an honest validator will also participate in challenges other validators are a part of to support other honest participants. It interacts with the on-chain components via chain bindings described above.
    
*   **Validator software:** Software that has knowledge of the correct Arbitrum child chain state at any point. It tracks the on-chain rollup contracts for assertions posted and will automatically initiate challenges on malicious assertions if configured to do so by the user. It will participate in new and existing challenges and make moves as required by the protocol to win against any number of malicious entities. Its goals are to ensure only honest assertions about Arbitrum's state are confirmed on Ethereum, and that honest assertions always get confirmed on Ethereum in a timely manner (within at most two challenge periods). All Arbitrum full nodes are watchtower validators by default. This means they do not post claims or assertions unless configured to do so but will warn in case invalid assertions are detected on-chain.
    

### How BoLD uses Ethereum[​](#how-bold-uses-ethereum "Direct link to How BoLD uses Ethereum")

When it comes to implementing the protocol, BoLD needs to be deployed on a credibly-neutral, censorship-resistant backend to be fair to all participants. As such, Ethereum was chosen as the perfect candidate. Ethereum is currently the most decentralized, secure, smart contract  to which the full protocol can be deployed, with challenge moves performed as transactions to the protocol’s smart contracts.

A helpful mental model for understanding the system is that it uses Ethereum itself as the ultimate referee for deciding assertion results. Participants in the challenge protocol can disagree over the _results of child chain state transitions_ and provide proofs to the protocol's smart contracts on Ethereum to determine which result is correct. Because computation is deterministic, there will always be a single correct result.

![Transaction lifecycle diagram showing various pathways for submitting transactions](/img/haw-transaction-lifecycle.svg)

_From the **[Nitro whitepaper](https://github.com/OffchainLabs/nitro/blob/master/docs/Nitro-whitepaper.pdf)**. Parent chain blocks are “settled to the parent chain” after a 6.4 day period has elapsed and nobody has challenged their validity on Ethereum._

In effect, there is a miniature Arbitrum state-transition VM [deployed as an Ethereum smart contract](https://github.com/OffchainLabs/nitro-contracts/blob/main/src/osp/OneStepProofEntry.sol) to prove which assertions are correct. However, computation on Ethereum is expensive, which is why this mini-VM is built to handle “one-step proofs” consisting of a single step of WebAssembly (`WASM`) code. The Arbitrum state transition logic, written in Golang, is also compiled to `WASM` and will therefore obtain the same results as the VM found in the on-chain smart contract. The soundness of the protocol depends on the assumptions that computation is deterministic and equivalent between the on-chain VM and the Golang state transition compiled to `WASM`.

All actors in the protocol have a local state from which they can produce valid proofs, and all honest parties will have the same local state. Malicious entities, however, can deviate from the honest parties in attempts to confirm invalid states through the protocol. Both the protocol and the honest validator client’s job is then to allow honest parties to always win against any number of malicious participants by always claiming the absolute truth.

Assertions[​](#assertions "Direct link to Assertions")
------------------------------------------------------

A key responsibility for Arbitrum proposers is to regularly post claims about the Arbitrum chains’ state to Ethereum at certain checkpoints. These are known as assertions (and are sometimes called child chain state roots). Assertions contain information, most critically:

1.  The child chain block hash being claimed
    
2.  A "history commitment" combining hashes of the chain's intermediate state after every block the assertion covers. This is essentially a Merkle-like data structure, a tree from which the asserter only needs to provide the root when posting the assertion.
    
3.  The batch number it corresponds to for the Arbitrum chain
    
4.  The number of messages in the Arbitrum  inbox at the time the assertion is created
    

The following assertion to be posted on-chain must consume the specified number of inbox messages from the previous assertion. There is a required delay in parent chain blocks for assertion posting. Currently, this value is set to equal one hour for BoLD.

Anyone can confirm assertions after a period of 6.4 days if they have not been challenged. In particular, assertions facilitate the process of withdrawing from Arbitrum back to Ethereum. Arbitrum withdrawals require specifying a blockhash, which must be confirmed as an assertion on-chain. This is why withdrawals have a delay of 6.4 days if they are not actively challenged.

Validators must become proposers in the rollup contract before being allowed to post assertions. For  and , this involves placing a one-time bond of 3600 `WETH` that is locked in the contract until they choose to withdraw. Validators can only withdraw their bond if their latest posted assertion gets confirmed. Every assertion a validator posts will become their latest bonded assertion. Subsequent bonds are not needed to post more assertions, instead, the protocol “moves” a validator’s bonds to their latest posted assertion.

Assertions form a chain where there can be forks. For instance, a validator might disagree on the history commitment of block state hashes, which an assertion contains. All  nodes are configured to warn users if they observe an assertion they disagree with posted on-chain. However, suppose a node is configured as a validator and has deposited a bond to the [Rollup contract](https://github.com/OffchainLabs/nitro-contracts/blob/main/src/rollup/RollupCore.sol). In that case, that validator can post the correct rival assertion to any invalid one it just observed. The validator will also be able to initiate a challenge by posting a challenge bond and other data to the `ChallengeManager`, signaling it is disputing an assertion.

#### Overflow assertions[​](#overflow-assertions "Direct link to Overflow assertions")

Given the mandatory delay of one hour between assertions posted on-chain, and each assertion is a claim to a specific Arbitrum batch, there could be a very large number of blocks in between assertions. However, a single assertion only supports a maximum of 2^26 Arbitrum blocks since the previous assertion. If this value is overflowed, one or more follow-up overflow assertions needs to be posted to consume the rest of the blocks above the maximum. This overflow assertion will not be subject to the mandatory 1-hour delay between assertions.

#### Trustless bonding pools[​](#trustless-bonding-pools "Direct link to Trustless bonding pools")

A large upfront assertion bond is critical for discouraging malicious actors from attacking Arbitrum and spamming the network (e.g., delay attacks), especially because malicious actors will always lose challenges and their entire bond. On the other hand, requiring such a high upfront assertion bond may be prohibitive for a single honest entity to put up—especially since the cost to defend Arbitrum is proportional to the number of malicious entities and ongoing challenges at any given point in time.

To address this, there is a [contract](https://github.com/OffchainLabs/bold/blob/main/contracts/src/assertionStakingPool/AssertionStakingPoolCreator.sol) that anyone can use to deploy a , bonding (or staking) pool as a way of crowdsourcing funds from others who wish to help defend Arbitrum, but who may otherwise not individually be able to put up the sizeable upfront bond itself.

Anyone can deploy an assertion bonding pool using the `AssertionStakingPoolCreator.sol` contract as a means to crowdsource funds for bonding funds to an assertion. To defend Arbitrum using one of these pools, an entity would first deploy this pool with the assertion they believe is correct and wish to bond on to challenge an adversary's assertion. Then, anyone can verify that the claimed assertion is correct by running the inputs through their node's  (`STF`). If other parties agree that the assertion is correct, they can deposit their funds into the contract. When enough funds have been deposited, anyone can trigger the creation of the assertion on-chain to start the challenge in a trustless manner. Finally, once the dispute protocol confirms the honest parties' assertion, all involved entities will get their funds reimbursed and can withdraw.

Note that with bonding pools, there is no minimum `WETH` requirement and once the entire bond amount is raised (either 3600, 555, or 79 ETH for Arbitrum One), then the assertion can be posted by anyone trustlessly. Additionally, there is an optional feature in the Nitro node validator software that enables both the automatic deployment of a bonding pool contract and depositing of funds to challenge an observed invalid assertion.

Trustless bonding pools can also be created to open challenges and make moves on challenges without sacrificing decentralization.

### Opening challenges[​](#opening-challenges "Direct link to Opening challenges")

To initiate a challenge, there must first be a fork in the assertion chain within the Arbitrum Rollup contracts. However, a challenge's actual start involves creating an edge claim and posting it to the `ChallengeManager` contract on the parent chain.

If there is a fork in the assertion chain (a "top-level" dispute), anyone can begin a challenge by creating a challenge edge. No bond is needed: each branch of the fork has a unique assertion, with an attached bond, and that assertion contains enough information to uniquely determine its challenge edge; that is, there is no "wiggle room" that an adversary can use to create multiple challenge edges from a single assertion (if this were possible, it could lead to spam attacks on the protocol).

Anyone can open a subchallenge on an assertion without needing to be a bonder in the Rollup contract, so long as they post a challenge bond and an edge claiming intent to start the challenge. This challenge bond is much lower than the one required to become an assertion proposer. Challenges are not tied to specific addresses or parties - instead, anyone can participate.

Recall that a challenge is a fundamental disagreement about an assertion posted to the Arbitrum chain. At its core, validators essentially disagree about the blockhash at a certain block number, and the BoLD protocol allows them to interactively narrow down their disagreement via fraud proofs such that Ethereum can be the final referee and claim a winner.

At its core, the disagreement between validators looks something like this:

*   Common parent assertion: `batch 5, blockhash 0xabc`
    
*   Alice’s assertion: `batch 10, blockhash 0x123`
    
*   Bob’s assertion: `batch 10, blockhash 0x456`
    

Their disagreement is about an Arbitrum block somewhere between batch 5 and batch 10. Here’s how the actual challenge begins in this example:

Validators have to fetch all blocks between batch 5 and batch 10 and create a Merkle commitment out of them as a Merkle tree with 2^26+1 leaves. If there are fewer than 2^26 blocks in between the assertions, the last block is repeated to pad the leaves of the tree to that value. Validators then create an “edge” data structure, which contains the following fields:

*   **start\_hash:** the start\_hash of the claimed assertion and is also the end\_hash of the previous assertion
    
*   **end\_hash:** the end hash of the last block in the child assertion that a validator claims is correct.
    
*   **merkle\_root:** the Merkle root that results from committing to a Merkle tree from the start block hash to the end block hash
    
*   **inclusion\_proofs:** Merkle proofs that the end hashes are indeed leaves of the Merkle tree committing to a root
    

The concept of a history commitment is at the core of challenges and BoLD itself.

The validators above provide a Merkle proof of their commitment to some history. In this case, all the Arbitrum block hashes from batch 5 to batch 10. Using this tree, validators can narrow their disagreement to a single block using Merkle proofs by iteratively bisecting the merkle root and creating edges which have their own history commitments to each half of the tree.

### Challenge resolution[​](#challenge-resolution "Direct link to Challenge resolution")

The fundamental unit in a challenge is an edge data structure.

#### Initiation[​](#initiation "Direct link to Initiation")

The first validator to create an edge initiates a challenge. The smart contracts validate the Merkle inclusion proofs and hashes provided to prove this challenge is about a specific fork in the assertion chain in the rollup contract.

#### Bisections[​](#bisections "Direct link to Bisections")

When an edge is created, it claims some history from point A to B, with which validators can agree or disagree. Other validators can claim some history from point A to B’, where B’ is a different end state. A history commitment is a Merkle commitment to a list of hashes.

To narrow down a disagreement, validators have to figure out what exact hash they disagree with. To do this, the game essentially takes turns between validators playing binary search. Each move here is known as a “bisection” because each move splits a history commitment in half.

For instance:

Alice commits to 33 hashes with start = A, end = B

Bob commits to 33 hashes with start = A, end = B’

Either of them can perform a “bisection” move on their edge. For instance, if Alice “bisects” her edge E, the bisection  will produce two children, E\_1 and E\_2. E\_1 commits to 17 hashes from height A to B/2, and E\_2 commits to 17 hashes from height B/2 to B.

A validator can make a bisection move on an edge as long as that edge is “rivaled”, meaning that there is another edge with a conflicting claim.

#### Subchallenges[​](#subchallenges "Direct link to Subchallenges")

The number of steps of execution at which validators could disagree within a single Arbitrum block has a max of 2^42. To play a game of bisections on this amount of hashes would be unreasonable from a space requirement, as each history commitment would require 4.35Tb worth of hashes. Instead, BoLD plays the bisection game over different levels of granularity of this space of 2^42 hashes that we call subchallenges that can be viewed as recursive execution of the dispute resolution process.

As a reminder, the bisection game is an iterative and interactive process. The first subchallenge is at the block level and is where validators disagree over Arbitrum blocks between two assertions. The disagreeing validators create “edges” containing history commitments to all the blocks in between those two assertions, which is a max of 2^26 child chain blocks, and commence the bisection game. As they progressively narrow down to a single block of disagreement, the validators then begin the next phase of the challenge process by opening a subchallenge over up to 2^19 **BigSteps**, which are each 2^23 steps of `WASM` execution. Once they reach a single disagreement at the BigStep level, they open a final subchallenge over a maximum of 2^23 SmallSteps, which are each a single step of `WASM` execution. The bisection game is the same at each subchallenge level, and opening a subchallenge requires placing another “challenge bond”. The magnitudes of challenge bonds are different at each subchallenge level.

#### One step proof[​](#one-step-proof "Direct link to One step proof")

Once validators reach a single step of disagreement at the deepest subchallenge level, they need to provide something called a , or `OSP` for short. This is a proof of `WASM` execution showing that executing the Arbitrum state transition function at machine hash A leads to machine hash B. The parent chain, like Ethereum is for Arbitrum One, then actually runs a `WASM` emulator using a smart contract for this step and will declare a winner. An evil party cannot forge a one-step proof, and unless there is a critical bug in the smart contract, the honest party will always win. At this point, the honest party’s one-step proven edge will be confirmed, and the evil party has no more moves to make. Next, the honest party’s “branch” of edges all the way from the top to the one-step proven edge will have an ever-increasing timer until the top edge is confirmed by time.

#### Timers[​](#timers "Direct link to Timers")

Once a validator creates an edge, and if it does not have any rival edge contesting it, that edge will have a timer that ticks up called its **unrivaled timer**. Time in the protocol is measured in parent blocks, and block numbers are used. An edge's timer stops ticking when a rival edge is created on-chain.

Edges also have an **inherited timer**, which is the sum of its unrivaled timer + the minimum inherited timer of an edge's children (recursive definition). Once one of the top-level edges that initiated a challenge has achieved an inherited timer >= a CHALLENGE\_PERIOD (6.4 days), it can be confirmed. At this point, its assertion can also be confirmed as its associated challenge has completed. A minor but important detail is that edges also inherit the time their claimed assertion was unrivaled.

Feel free to read the [BoLD whitepaper](https://arxiv.org/abs/2404.10491) for more details around how timers are tracked.

#### Cached timer updates[​](#cached-timer-updates "Direct link to Cached timer updates")

An edge's "inherited timer" value exists on-chain and can be updated via a transaction. Given it is a recursive definition, it can be updated via multiple transactions. First, the lowermost edges have their timers updated, then their parents, etc., up to the top. Validators can track information locally to avoid sending wasteful transactions and only propagate updates once they are confident their edge is confirmable by time.

#### Confirmation[​](#confirmation "Direct link to Confirmation")

Once an edge has a total on-chain timer greater than or equal to a challenge period, it can be confirmed via a transaction. Not all edges need to be confirmed on-chain, as simply the top-level block challenge edge is enough to confirm the claimed assertion and resolve a dispute. A challenge is not complete at the one-step proof. It is only complete once the claimed assertion of a challenge is confirmed by time.

### Bonding in challenges[​](#bonding-in-challenges "Direct link to Bonding in challenges")

To create a challenge, there must be a fork in the Arbitrum assertion chain smart contract. A validator that wishes to initiate a challenge must then post an “edge” claiming a history of block hashes from the previous assertion to the claimed assertion they believe is correct. To do so, they need to put up some value called a "challenge bond". Note that to open a new assertion-level challenge, no challenge bond needs to be posted. This is because top-level assertions already contain enough information to uniquely determine their corresponding challenge edge (which contain a hash of this history), and have already been bonded on.

Challenge bonds are named as such because they are bonds required for opening challenges. The mechanism of how challenge bond economics are decided is contained in the [Economics of Disputes](/how-arbitrum-works/bold/bold-economics-of-disputes), which also explains the cost profile and spam prevention in BoLD. In short, the actual cost of a bond encompasses many costs associated with participating in the dispute game. More information on the bond sizes and how they were calculated can be found in the [Economics of Disputes](/how-arbitrum-works/bold/bold-economics-of-disputes) document mentioned above.

Each subchallenge that is created requires depositing a challenge bond. For Arbitrum One, the first unrivaled edge’s bond is kept in the challenge manager contract on Ethereum, while any subsequent rival bonds are kept in an excess bond receiver address. Once a challenge is complete, all bonds for an honest party are automatically refunded in-protocol while all confiscated bonds are sent to the ArbitrumDAO treasury. It is important to not offer the majority of the bonds confiscated from dishonest parties to honest parties to avoid perverse incentives, such as grieving attacks in self-challenges or to discourage needless competition between honest parties.

### Reimbursements of bonds[​](#reimbursements-of-bonds "Direct link to Reimbursements of bonds")

The reimbursement of assertion bonds and challenge bonds for honest parties will be handled “in-band” by the protocol. Please see [Economics of Disputes](/how-arbitrum-works/bold/bold-economics-of-disputes) for more information about this topic.

### Upgrade mechanism[​](#upgrade-mechanism "Direct link to Upgrade mechanism")

For BoLD to be deployed on an Arbitrum chain, an upgrade admin action needs to be taken using an `UpgradeExecutor` pattern. This is a smart contract that executes actions as the rollup owner. At the upgrade, the `RollupCore.sol` contract will be updated to a new BoLD one, and additional contracts needed for BoLD challenges, such as an `EdgeChallengeManager.sol`, will also be deployed to the parent chain.

Next, assertions will then be posted to the new rollup contract. During the upgrade period, there could have been a very large number of blocks posted in Arbitrum batches. For this purpose, BoLD assertions support the concept of an **overflow**, allowing us to efficiently handle this situation.

Withdrawals leading up to a BoLD upgrade

The confirmation timing on any withdrawal that is in-flight when the BoLD upgrade is activated will be delayed until the first BoLD assertion is confirmed. This means that for any Arbitrum chain that upgrades to use BoLD, including Arbitrum One and Arbitrum Nova, all pending withdrawals to the parent chain, Ethereum, that were initiated _before_ the upgrade will be delayed by one challenge period, plus the time between the withdrawal was initiated and the time that the BOLD upgrade takes place. This is because the upgrade effectively "resets" the challenge period for that are not yet finalized.

For example, if the upgrade happened at time _t_, then a withdrawal initiated at a time _t-2_ days will need to wait an additional _6.4_ days for their withdrawal to be finalized, totaling 8.4 days of maximum delay. Withdrawals that finalize before the upgrade takes place at time _t_ will be unaffected. In other words, the maximum delay a withdrawal will experience leading up to the upgrade is 12.8 days (two challenge periods).

The upgrade pattern for an existing Arbitrum rollup to a BoLD-enabled one is tested extensively and run as part of each of our pull requests in the BoLD repository [upgrade workflow on GitHub](https://github.com/OffchainLabs/bold/blob/c4e068b568ff662f49ed191c5c3188ea7b6138b2/.github/workflows/go.yml#L209).

---

# Block gas limit, numbers and time | Arbitrum Docs

## Block gas limit, numbers and time

Arbitrum chains and their parent chains

With the release of Arbitrum Orbit, Arbitrum chains can now be child chains (L2) that settle to Ethereum (or one of their testnets), or L3s that settle to one of the Arbitrum child chains. For simplicity, in this page we speak in terms of Arbitrum One (child chain) and Ethereum (parent chain/L1), but the same logic can be applied to any chain and its parent chain.

As in Ethereum, Arbitrum clients submit transactions, and the system executes those transactions later. In Arbitrum, clients submit transactions by posting messages to the Ethereum chain, either [through the sequencer](/how-arbitrum-works/sequencer) or via the chain's [delayed inbox](/how-arbitrum-works/sequencer).

Once in the chain's core inbox contract, transactions are processed in order. Generally, some time will elapse between when a message is put into the inbox (and timestamped) and when the contract processes the message and carries out the transaction requested by the message.

Additionally, since the calldata of Arbitrum transactions (or the DAC certificate on chains) is posted to Ethereum, the gas paid when executing them includes a parent chain component to cover the costs of the batch poster.

This page describes what this mechanism means for the block gas limit, block numbers, and the time assumptions of the transactions submitted to Arbitrum.

Block gas limit[​](#block-gas-limit "Direct link to Block gas limit")
---------------------------------------------------------------------

When submitting a transaction to Arbitrum, users are charged for both the execution cost on Arbitrum and the cost of posting its calldata to Ethereum. This dual cost structure is managed by adjusting the transaction's gas limit to reflect these two dimensions, resulting in a higher gas limit value than what would be seen for pure execution.

The gas limit of an Arbitrum block is set as the sum of all transaction gas limits, including the costs related to parent chain data posting. To accommodate potential variations in parent chain costs, Arbitrum assigns an artificially large gas limit (1,125,899,906,842,624) for each block. However, the effective execution gas limit is capped at 32 million. This means that while the visible gas limit might appear very high, the actual execution costs are constrained within this limit. Understanding this distinction helps clarify why querying a block might show an inflated gas limit that doesn’t match the effective execution costs.

For a more detailed breakdown of the gas model, refer to [this article on Arbitrum's 2-dimensional fee structure](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9).

Block numbers: Arbitrum vs. Ethereum[​](#block-numbers-arbitrum-vs-ethereum "Direct link to Block numbers: Arbitrum vs. Ethereum")
----------------------------------------------------------------------------------------------------------------------------------

Arbitrum blocks are assigned their own child chain block numbers, distinct from Ethereum's block numbers.

A single Ethereum block could include multiple Arbitrum blocks within it; however, an Arbitrum block cannot span across multiple Ethereum blocks. Thus, any given Arbitrum transaction is associated with exactly one Ethereum block and one Arbitrum block.

### Ethereum block numbers within Arbitrum[​](#ethereum-block-numbers-within-arbitrum "Direct link to Ethereum block numbers within Arbitrum")

Accessing block numbers within an Arbitrum smart contract (i.e., `block.number` in Solidity) will return a value _close to_ (but not necessarily exactly) the L1 block number at which the sequencer received the transaction.

```rust
// some Arbitrum contract:
block.number // => returns L1 block number ("ish")
```

As a general rule, any timing assumptions a contract makes about block numbers and timestamps should be considered generally reliable in the longer term (i.e., on the order of at least several hours) but unreliable in the shorter term (minutes). (It so happens these are generally the same assumptions one should operate under when using block numbers directly on Ethereum!)

### Arbitrum block numbers[​](#arbitrum-block-numbers "Direct link to Arbitrum block numbers")

Arbitrum blocks have their own block numbers, starting at 0 at the Arbitrum genesis block and updating sequentially.

ArbOS and the sequencer are responsible for delineating when one Arbitrum block ends and the next one begins. However, block creation depends entirely on chain usage, meaning that blocks are only produced when there are transactions to sequence. In active chains, one can expect to see Arbitrum blocks produced at a relatively steady rate. In more quiet chains, block production might be sporadic depending on the rate at which transactions are received.

A client that queries an Arbitrum node's RPC interface (e.g., transaction receipts) will receive the transaction's Arbitrum block number as the standard block number field. The parent chain block number will also be included in the added `l1BlockNumber field`.

```rust
const txnReceipt = await arbitrumProvider.getTransactionReceipt('0x...');
/** 
    txnReceipt.blockNumber => Arbitrum block number
    txnReceipt.l1BlockNumber => L1 block number ("ish")
*/
```

The Arbitrum block number can also be retrieved within an Arbitrum contract via [ArbSys](/build-decentralized-apps/precompiles/reference#arbsys) precompile:

```rust
 ArbSys(100).arbBlockNumber() // returns Arbitrum block number
```

### Example[​](#example "Direct link to Example")

Wall Clock time

12:00 am

12:00:15 am

12:00:30 am

12:00:45 am

12:01 am

12:01:15 am

L1 `block.number`

1000

1001

1002

1003

1004

1005

L2 `block.number` \*

1000

1000

1000

1000

1004

1004

Arbitrum Block number (from RPCs) \*\*

370000

370005

370006

370008

370012

370015

_\* **L2 `block.number`:** updated to sync with the parent chain `block.number` approximately every minute. Thus, over time, it will, like the parent chain `block.number`, average to ~12 seconds per block._

_\*\* **Arbitrum block number from RPCs:** note that this can be updated multiple times per parent chain block (this lets the sequencer give sub-parent-chain-block-time transaction receipts.)_

### Case study: the Multicall contract[​](#case-study-the-multicall-contract "Direct link to Case study: the Multicall contract")

The Multicall contract offers a great case study for the differences between parent and child chain block numbers.

The [canonical implementation](https://github.com/makerdao/multicall/) of Multicall returns the value of `block.number`. If attempting to use out-of-the-box, some applications might face unintended behaviour.

You can find a version of the adapted Multicall2 deployed on Arbitrum One at [0x7eCfBaa8742fDf5756DAC92fbc8b90a19b8815bF](https://arbiscan.io/address/0x7eCfBaa8742fDf5756DAC92fbc8b90a19b8815bF#code).

By default the `getBlockNumber`, `tryBlockAndAggregate`, and `aggregate` functions return the child chain block number. This allows you to use this value to compare your state against the tip of the chain.

The `getL1BlockNumber` function can be queried if applications need to surface the parent chain block number.

Block timestamps: Arbitrum vs. Ethereum[​](#block-timestamps-arbitrum-vs-ethereum "Direct link to Block timestamps: Arbitrum vs. Ethereum")
-------------------------------------------------------------------------------------------------------------------------------------------

Block timestamps on Arbitrum are not linked to the timestamp of the parent chain block. They are updated every child chain block based on the sequencer's clock. These timestamps must follow these two rules:

1.  Must be always equal or greater than the previous child chain block timestamp
2.  Must fall within the established boundaries (24 hours earlier than the current time or one hour in the future). More on this below.

Furthermore, for transactions that are force-included from the parent chain (bypassing the sequencer), the block timestamp will be equal to either the parent chain timestamp when the transaction was put in the delayed inbox on the parent chain (not when it was force-included), or the child chain timestamp of the previous child chain block, whichever of the two timestamps is greater.

### Timestamp boundaries of the sequencer[​](#timestamp-boundaries-of-the-sequencer "Direct link to Timestamp boundaries of the sequencer")

As mentioned, block timestamps are usually set based on the sequencer's clock. Because there's a possibility that the sequencer fails to post batches on the parent chain (i.e, Ethereum) for a period of time, it should have the ability to slightly adjust the timestamp of the block to account for those delays and prevent any potential reorganisations of the chain. To limit the degree to which the sequencer can adjust timestamps, some boundaries are set, currently to 24 hours earlier than the current time, and one hour in the future.

---

# Differences between Arbitrum and Ethereum: Overview | Arbitrum Docs

## Differences between Arbitrum and Ethereum: Overview

Arbitrum is designed to be as compatible and consistent with Ethereum as possible, from its high-level RPCs to its low-level bytecode and everything in between.  developers with experience building on Ethereum will likely find that little-to-no new specific knowledge is required to build on Arbitrum.

This section describes the differences, perks, and gotchas that devs are advised to be aware of when working with Arbitrum. This first page serves as an overview of where you might find these differences, with links to the relevant pages when needed.

Block numbers and time[​](#block-numbers-and-time "Direct link to Block numbers and time")
------------------------------------------------------------------------------------------

Time in child chains is tricky. The timing assumptions one is used to making about Ethereum blocks don't exactly carry over into the timing of Arbitrum blocks. See [Block numbers and time](/build-decentralized-apps/arbitrum-vs-ethereum/block-numbers-and-time) for details about how block numbers and time are handled in Arbitrum.

RPC methods[​](#rpc-methods "Direct link to RPC methods")
---------------------------------------------------------

Although the majority of RPC methods follow the same behavior as Ethereum, some methods might produce a different result, or add more information, when used on an Arbitrum chain. You can find more information about these differences in [RPC methods](/build-decentralized-apps/arbitrum-vs-ethereum/rpc-methods).

Solidity support[​](#solidity-support "Direct link to Solidity support")
------------------------------------------------------------------------

You can deploy Solidity contracts onto Arbitrum just like you do on Ethereum. There are only a few minor differences in behavior. Find more information about it in [Solidity support](/build-decentralized-apps/arbitrum-vs-ethereum/solidity-support).

Fees[​](#fees "Direct link to Fees")
------------------------------------

The fees for executing an Arbitrum transaction work like gas fees on Ethereum. However, Arbitrum transactions must also pay a fee component to cover the cost of posting their calldata to the parent chain (for example, calldata on Arbitrum One, a child chain, is posted to Ethereum, a parent chain). Find more information about the two components of gas fees in [Gas and fees](/how-arbitrum-works/gas-fees) and parent chain pricing.

Cross-chain messaging[​](#cross-chain-messaging "Direct link to Cross-chain messaging")
---------------------------------------------------------------------------------------

Arbitrum chains support arbitrary message passing from a parent chain (for example, a parent chain like Ethereum) to a child chain (for example, a child chain like Arbitrum One or Arbitrum Nova). These are commonly known as "parent chain to child chain messages". Developers using this functionality should familiarize themselves with how they work. Find more information about it in [Parent chain to child chain messaging](/how-arbitrum-works/l1-to-l2-messaging).

Similarly, Arbitrum chains can also send messages to the parent chain. Find more information about them in [Child chain to parent chain messaging and the outbox](/how-arbitrum-works/l2-to-l1-messaging).

Precompiles[​](#precompiles "Direct link to Precompiles")
---------------------------------------------------------

Besides supporting all precompiles available in Ethereum, Arbitrum provides child chain-specific precompiles with methods smart contracts can call the same way they can solidity functions. You can find a full reference of them in [Precompiles](/build-decentralized-apps/precompiles/overview).

NodeInterface[​](#nodeinterface "Direct link to NodeInterface")
---------------------------------------------------------------

The Arbitrum Nitro software includes a special `NodeInterface` contract available at address `0xc8` that is only accessible via RPCs (it's not actually deployed on-chain, and thus can't be called by smart contracts). Find more information about this interface in [NodeInterface](/build-decentralized-apps/nodeinterface/overview).

---

# RPC methods | Arbitrum Docs

## RPC methods

Although the majority of RPC methods follow the same behavior as in Ethereum, some methods might produce a different result, or add more information, when used on an Arbitrum chain. This page covers the differences in response body fields you'll find when calling RPC methods on an Arbitrum chain vs on Ethereum.

info

Comprehensive documentation on all generally available JSON-RPC methods for Ethereum [can be found at ethereum.org](https://ethereum.org/en/developers/docs/apis/json-rpc/). As Arbitrum has `go-ethereum` at its core, most of the documented methods there can be used with no modifications.

Transactions[​](#transactions "Direct link to Transactions")
------------------------------------------------------------

When calling [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyhash) and other methods that return a transaction, Arbitrum includes a few additional fields and leverages some existing fields in different ways than Ethereum.

### Transaction types[​](#transaction-types "Direct link to Transaction types")

In addition to the [three transaction types](https://ethereum.org/en/developers/docs/transactions/#types-of-transactions) currently supported on Ethereum, Arbitrum adds additional types listed below and [documented in full detail here](/how-arbitrum-works/geth-at-the-core#transaction-types).

On RPC calls that return transactions, the `type` field will reflect the custom codes where applicable.

Transaction type code

Transaction type name

Description

`100`

`ArbitrumDepositTxType`

Used to deposit ETH from a parent chain to child chain via the Arbitrum bridge

`101`

`ArbitrumUnsignedTxType`

Used to call a child chain contract from a parenet chain, originated by a user through the Arbitrum bridge

`102`

`ArbitrumContractTxType`

Used to call a child chain contract from a parent chain, originated by a contract through the Arbitrum bridge

`104`

`ArbitrumRetryTxType`

Used to [manually redeem a retryable ticket](/how-arbitrum-works/l1-to-l2-messaging) on a child chain that failed to execute automatically (usually due to low gas)

`105`

`ArbitrumSubmitRetryableTxType`

Used to [submit a retryable ticket](/how-arbitrum-works/l1-to-l2-messaging#submission) via the Arbitrum bridge on the parent chain

`106`

`ArbitrumInternalTxType`

Internal transactions created by the ArbOS itself for certain state updates, like the parent chain base fee and the block number

### Additional fields[​](#additional-fields "Direct link to Additional fields")

On RPC calls that return transactions, the following fields are added to the returned object.

Field name

Description

`requestId`

On parent to child chain transactions, this field is added to indicate position in the Inbox queue

### Existing fields with different behavior[​](#existing-fields-with-different-behavior "Direct link to Existing fields with different behavior")

On RPC calls that return transactions, the following fields will have a different content than what's received on Ethereum.

Field name

Description

`from`

On parent to child chain transactions, this field will contain the [_aliased_ version](/how-arbitrum-works/l1-to-l2-messaging#address-aliasing) of the parent chain's `msg.sender`

Transaction receipts[​](#transaction-receipts "Direct link to Transaction receipts")
------------------------------------------------------------------------------------

When calling [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt), Arbitrum includes a few additional fields and leverages some existing fields in different ways than Ethereum.

### Additional fields[​](#additional-fields-1 "Direct link to Additional fields")

On RPC calls that return transaction receipts, the following fields are added to the returned object.

Field name

Description

`l1BlockNumber`

The parent chain block number that would be used for `block.number` calls. More information in [Block numbers and time](/build-decentralized-apps/arbitrum-vs-ethereum/block-numbers-and-time)

`gasUsedForL1`

Amount of gas spent on parent chain calldata in units of child chain gas. More information in [Gas and fees](/how-arbitrum-works/gas-fees)

Blocks[​](#blocks "Direct link to Blocks")
------------------------------------------

When calling [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) and other methods that return a block, Arbitrum includes a few additional fields and leverages some existing fields in different ways than Ethereum.

### Additional fields[​](#additional-fields-2 "Direct link to Additional fields")

On RPC calls that return a block, the following fields are added to the returned object.

Field name

Description

`l1BlockNumber`

An approximate parent chain block number that occurred before this child chain block. More information in [Block numbers and time](/build-decentralized-apps/arbitrum-vs-ethereum/block-numbers-and-time)

`sendCount`

The number of child to parent chain messages since Nitro genesis

`sendRoot`

The Merkle root of the outbox tree state

### Existing fields with different behavior[​](#existing-fields-with-different-behavior-1 "Direct link to Existing fields with different behavior")

On RPC calls that return a block, the following fields will have a different content than what's received on Ethereum.

Field name

Description

`extraData`

This field is equivalent to `sendRoot`

`mixHash`

First 8 bytes is equivalent to `sendCount`, second 8 bytes is equivalent to `l1BlockNumber`

`difficulty`

Fixed at `0x1`

`gasLimit`

Value is fixed at `0x4000000000000`, but it's important to note that Arbitrum One currently has a 32M gas limit per block. See [Chain params](/build-decentralized-apps/reference/chain-params) for the gas limit of other chains

Other methods that are slightly different[​](#other-methods-that-are-slightly-different "Direct link to Other methods that are slightly different")
---------------------------------------------------------------------------------------------------------------------------------------------------

### `eth_syncing`[​](#eth_syncing "Direct link to eth_syncing")

Calling `eth_syncing` returns false when the node is fully synced (just like on Ethereum). If the node is still syncing, `eth_syncing` returns an object with data about the synchronization status. Here, we provide more details.

#### Understanding messages, batches, and blocks[​](#understanding-messages-batches-and-blocks "Direct link to Understanding messages, batches, and blocks")

Nitro nodes receive transactions from their parent chain and the sequencer feed in the form of messages. These messages may contain multiple transactions that are executed by the node, which then produces blocks. Each message produces exactly one block. In most Nitro chains, the message number and the block number are the same. However, Arbitrum One has pre-Nitro (classic) blocks, so for that chain, message 0 produced block `22207818` (blocks prior to that one are 'classic' blocks). Keep in mind that the offset between message and block number is constant in the chain.

On the parent chain, messages appear in batches. The number of messages per batch changes between batches.

#### Custom `eth_syncing` fields[​](#custom-eth_syncing-fields "Direct link to custom-eth_syncing-fields")

info

Note that the exact output for the `eth_syncing` RPC call of an out-of-sync Nitro node is not considered a stable API. It is still being actively developed and can be modified without notice between versions.

Field name

Description

`batchSeen`

Last batch number observed on the parent chain

`batchProcessed`

Last batch that was processed on the parent chain. Processing means dividing the batch into messages

`messageOfProcessedBatch`

Last message in the last processed batch

`msgCount`

Number of messages known/queued by the Nitro node

`blockNum`

Last block created by the Nitro node (up-to-date child chain block the node is synced to)

`messageOfLastBlock`

Message that was used to produce the block above

`broadcasterQueuedMessagesPos`

If different than 0, this is expected to be greater than `msgCount`. This field notes a message that was read from the feed but not processed because earlier messages are still missing

`lastL1BlockNum`

Last block number from the parent chain that Nitro sees. This is used to debug the connection with the parent chain

`lastl1BlockHash`

Last block hash from the parent chain that Nitro sees. This is used to debug the connection with the parent chain

info

Note that if the sync process encounters an error while trying to collect the data above (not expected) this error will be added to the response.

#### Understanding common scenarios[​](#understanding-common-scenarios "Direct link to Understanding common scenarios")

*   If `batchSeen` > `batchProcessed`, some batches have still not been processed
*   If `msgCount` > `messageOfLastBlock`, some messages have been processed, but not all relevant blocks have been built (this is usually the longest stage while syncing a new node)
*   If `broadcasterQueuedMessagesPos` > `msgCount`, the feed is ahead of the last message known to the node

### `debug_traceTransaction`[​](#debug_tracetransaction "Direct link to debug_tracetransaction")

*    The Nitro node provides a native tracer for debugging Stylus contracts called `stylusTracer`, which returns a JSON array with objects containing the metadata for each executed HostIO. HostIOs are calls the WasmVM makes to read and write data in the EVM. With the result of this tracer and the code for the Stylus contract, you have all the data to understand what happened in a Stylus transaction.

info

The `cargo-stylus` command-line tool uses the `stylusTracer` to replay transactions locally inside a debugger. More information can be found on [How to debug Stylus transactions using Cargo Stylus Replay](/stylus/how-tos/debugging-tx).

The table below describes each field of the `stylusTracer` return value.

Field Name

Description

`name`

Name of the execute HostIO.

`args`

Arguments of the HostIO encoded as hex.

`outs`

Outputs of the HostIO encoded as hex.

`startInk`

Amount of Ink before executing the HostIO.

`endInk`

Amount of Ink after executing the HostIO.

`address`

For \*call HostIOs, the address of the called contract.

`steps`

For \*call HostIOs, the steps performed by the called contract.

For example, the command below illustrates how to call this tracer for a transaction:

```rust
curl -s \
    -X POST \
    -H "Content-Type: application/json" \
    -d '{"jsonrpc":"2.0","method":"debug_traceTransaction","params":["<transaction-hash>", {"tracer": "stylusTracer"}],"id":1}' \
    <nitro-node-rpc>
```

The result of this call will be something along the lines of:

```rust
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": [
    {
      "args": "0x00000024",
      "endInk": 116090000,
      "name": "user_entrypoint",
      "outs": "0x",
      "startInk": 116090000
    },
    {
      "args": "0x",
      "endInk": 116057558,
      "name": "msg_reentrant",
      "outs": "0x00000000",
      "startInk": 116065958
    },
    {
      "args": "0x",
      "endInk": 115937952,
      "name": "read_args",
      "outs": "0x6c5283490000000000000000000000003bdff922e18bc03f1cf7b2a8b65a070cbec944f2",
      "startInk": 115951512
    },
    ...
  ]
}
```

---

# Solidity support | Arbitrum Docs

## Solidity support

Arbitrum chains are Ethereum compatible, and therefore allow you to trustlessly deploy Solidity smart contracts, as well as contracts written in Vyper or any other language that compiles to EVM bytecode. However, when calling certain properties and functions on a Solidity smart contract, there might be some differences between the result you'd obtain if that contract was on Ethereum, and the result on Arbitrum.

This page compiles a list of functions and properties that return a different result when called in Arbitrum.

Differences from Solidity on Ethereum[​](#differences-from-solidity-on-ethereum "Direct link to Differences from Solidity on Ethereum")
---------------------------------------------------------------------------------------------------------------------------------------

Although Arbitrum supports Solidity code, there are differences in the effects of a few operations, including language features that don't make much sense in the child chain context.

Operation

Description

`blockhash(x)`

Returns a cryptographically insecure, pseudo-random hash for `x` within the range `block.number - 256 <= x < block.number`. If `x` is outside of this range, `blockhash(x)` will return `0`. This includes `blockhash(block.number)`, which always returns `0` just like on Ethereum. The hashes returned do not come from the parent chain. ⚠️ Arbitrum's child chain block hashes should not be relied on as a secure source of randomness.

`block.coinbase`

Returns the designated internal address `0xA4b000000000000000000073657175656e636572` if the message was posted by a sequencer. If it's a delayed message, it returns the address of the delayed message's poster (Note: the handling of delayed message's `block.coinbase` will likely be changed in a future ArbOS version).

`block.difficulty`

Returns the constant 1.

`block.prevrandao`

Returns the constant 1.

`block.number`

Returns an "estimate" of the parent chain block number at which the sequencer received the transaction. For more information, see [Block numbers and time](/build-decentralized-apps/arbitrum-vs-ethereum/block-numbers-and-time).

`msg.sender`

Works the same way it does on Ethereum for regular child chain to child chain transactions. For transactions submitted via the delayed inbox, it will return the child chain address alias of the parent chain contract that triggered the message. For more information, see [address aliasing](/how-arbitrum-works/l1-to-l2-messaging#address-aliasing).

OPCODE `PUSH0`

This OPCODE was added as part of ArbOS 11 and is now supported.

---

# Cross-chain messaging overview | Arbitrum Docs

## Cross-chain messaging overview

The Arbitrum protocol and related tooling makes it easy for developers to build cross-chain applications; i.e., applications that involve sending messages from Ethereum to an Arbitrum chain, and/or from an Arbitrum chain to Ethereum.

Ethereum-to-Arbitrum messaging[​](#ethereum-to-arbitrum-messaging "Direct link to Ethereum-to-Arbitrum messaging")
------------------------------------------------------------------------------------------------------------------

Arbitrary parent to child chain contract calls can be created via the `Inbox`'s `createRetryableTicket` method; upon publishing the parent chain transaction, the child chain side will typically get included within minutes. Happily / commonly, the child chain execution will automatically succeed, but if reverts, and it can be rexecuted via a call to the `redeem` method of the [ArbRetryableTx](/build-decentralized-apps/precompiles/reference#arbretryabletx) precompile.

For details and protocol specification, see [Parent to child chain Messages](/how-arbitrum-works/l1-to-l2-messaging).

For an example of retryable tickets in action, see the [Greeter](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/greeter) tutorial, which uses the [Arbitrum SDK](/sdk/introduction).

Arbitrum-to-Ethereum messaging[​](#arbitrum-to-ethereum-messaging "Direct link to Arbitrum-to-Ethereum messaging")
------------------------------------------------------------------------------------------------------------------

Similarly, child chain contracts can send Arbitrary messages for execution on the parent chain. These are initiated via calls to the [ArbSys](/build-decentralized-apps/precompiles/reference#arbsys) precompile contract's `sendTxToL1` method. Upon confirmation (about one week later), they can executed by retrieving the relevant data via a call to `NodeInterface` contract's `constructOutboxProof` method, and then executing them via the `Outbox`'s `executeTransaction` method.

For details and protocol specification, see [Child to parent chain Messages](/how-arbitrum-works/l2-to-l1-messaging).

For a demo, see the [Outbox Tutorial](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/outbox-execute).

---

# How to estimate gas in Arbitrum | Arbitrum Docs

## How to estimate gas in Arbitrum

Looking for Stylus guidance?

Head over to [the Stylus gas docs](/stylus/reference/opcode-hostio-pricing) for Stylus-specific guidance.

This how-to is intended for users and developers interested in understanding how gas operates in Arbitrum, how it's calculated, and how to estimate it before submitting transactions. More detailed information about these calculations can be found in this [Medium article](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9) and the [Gas and Fees](/how-arbitrum-works/gas-fees) page.

Skip the formula, focus on practical know-how[​](#skip-the-formula-focus-on-practical-know-how "Direct link to Skip the formula, focus on practical know-how")
--------------------------------------------------------------------------------------------------------------------------------------------------------------

Before diving into the specifics and the formula, if you're looking for a practical way to estimate gas for your transaction, you can rely on the standard gas estimation process. This can be achieved by calling an Arbitrum node's `eth_estimateGas`, which provides a value (gas limit) that should sufficiently cover the entire transaction fee at the specified child chain gas price.

Multiplying the value obtained from `eth_estimateGas` by the child chain gas price will give you the total amount of Ether required for the transaction to be successful. It's important to note that, for a specific operation, the result of `eth_estimateGas` value may vary over time due to fluctuations in the parent chain calldata price, see below to learn why!

Alternatively, to obtain the gas limit for your transaction, you can call `NodeInterface.gasEstimateComponents()` and then use the first result, which is `gasEstimate`. Next, to find the total cost, you need to multiply this amount by the child chain gas price, which is available in the third result, `baseFee`.

Note that when working with parent to child chain messages (also known as [retryable tickets](/how-arbitrum-works/l1-to-l2-messaging)), you can use the function [L1ToL2MessageGasEstimator.estimateAll()](https://github.com/OffchainLabs/arbitrum-sdk/blob/main/src/lib/message/L1ToL2MessageGasEstimator.ts#L215) of the Arbitrum SDK or [NodeInterface.estimateRetryableTicket()](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L120) to get all the gas information needed to send a successful transaction.

Breaking down the formula[​](#breaking-down-the-formula "Direct link to Breaking down the formula")
---------------------------------------------------------------------------------------------------

We'll now break down the formula mentioned in the [Medium article](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9), moving then to where to get the information of each variable, and finally seeing an example of how to apply the formula in your code as well as other practical ways of estimating gas costs.

However, if you want to jump straight to the code, we have created [this script in our tutorials repository](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/gas-estimation) that goes through all the calculations explained in this how-to.

As explained in the Medium article, the transaction fees to pay at any given moment are the result of the following product:

```rust
Transaction fees (TXFEES) = L2 Gas Price (P) * Gas Limit (G)
```

This Gas Limit includes the gas of the child chain computation and an additional buffer to cover the parent chain gas to be paid by the Sequencer when [posting the batch including this transaction on the parent chain](/how-arbitrum-works/sequencer).

```rust
Gas Limit (G) = Gas used on L2 (L2G) + Extra Buffer for L1 cost (B)
```

This buffer takes into account the cost of posting the transaction, batched and compressed, on the parent chain. The parent chain estimated posting cost is calculated by multiplying these two values:

*   L1S, which estimates the amount of data the transaction will take up in the batch by compressing the transaction with Brotli.
*   L1P, which is the L2's estimated view of the current parent chain's price of data (per byte), which the child chain dynamically adjusts over time.

More information is available [in this page](/how-arbitrum-works/gas-fees).

```rust
L1 Estimated Cost (L1C) = L1 price per byte of data (L1P) * Size of data to be posted in bytes (L1S)
```

To calculate the buffer, that estimated cost is divided by the child chain Gas Price.

```rust
Extra Buffer (B) = L1 Estimated Cost (L1C) / L2 Gas Price (P)
```

Finally, using all of the above elements, the formula can be written as follows:

```rust
TXFEES = P * (L2G + ((L1P * L1S) / P))
```

Where do we get all this information from?[​](#where-do-we-get-all-this-information-from "Direct link to Where do we get all this information from?")
-----------------------------------------------------------------------------------------------------------------------------------------------------

We'll use one resource available in Arbitrum: the [NodeInterface](/build-decentralized-apps/nodeinterface/reference).

*   P (L2 Gas Price) ⇒ Price to pay for each gas unit. It starts at 0.01 gwei on Arbitrum One (0.01 gwei on Arbitrum Nova) and can increase depending on the demand for network resources.
    *   Call `NodeInterface.GasEstimateComponents()` and get the third element, `baseFee`.
*   L2G (Gas used on L2) ⇒ Gas used to compute the transaction on the child chain. This does not include the _“posting on L1”_ part of the calculations. The value of L2G will depend on the transaction itself, but having the data of the transaction, we can calculate it as follows:
    *   Call `NodeInterface.GasEstimateComponents()` with the transaction data and subtract the second element (`gasEstimateForL1`, which estimates the parent chain part of the fees) from the first (`gasEstimate`, which includes both the parent and the child chain parts).
*   L1P (L1 estimated price per byte of data) ⇒ Estimated cost of posting 1 byte of data on the parent chain:
    *   Call `NodeInterface.GasEstimateComponents()`, get the fourth element `l1BaseFeeEstimate` and multiply it by 16.
*   L1S (Size of data to be posted on L1, in bytes) ⇒ This will depend on the data of the transaction. Keep in mind that Arbitrum adds a fixed amount to this number to make up for the static part of the transaction, which is also posted on the parent chain (140 bytes). We can do a small calculation to obtain this value: call `NodeInterface.GasEstimateComponents()` take the second element, `gasEstimateForL1` (this is equivalent to `B` in our formula), multiply it by P and divide it by L1P.
    *   For Arbitrum Nova (AnyTrust), the size of the data is also a fixed value, as only the Data Availability Certificate is posted on the parent chain, [as explained here](/how-arbitrum-works/anytrust-protocol#data-availability-certificates).

note

For L1P and L1S, you can also call `NodeInterface.gasEstimateL1Component()` to get `l1BaseFeeEstimate` and `gasEstimateForL1`

An example of how to apply this formula in your code[​](#an-example-of-how-to-apply-this-formula-in-your-code "Direct link to An example of how to apply this formula in your code")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Finally, we show an example of how to get the values we just described and how to estimate the gas usage of a transaction in Javascript. We'll use our [SDK](https://github.com/OffchainLabs/arbitrum-sdk) to connect to the `NodeInterface`.

We first instantiate a factory object for the NodeInterface, using two methods from the SDK. `l2Provider` is a regular JSON RPC provider for the child chain network we are using, and `NODE_INTERFACE_ADDRESS` is the addresses that we need to call to access NodeInterface methods in said network.

```rust
const { NodeInterface__factory } = require("@arbitrum/sdk/dist/lib/abi/factories/NodeInterface__factory");
const { NODE_INTERFACE_ADDRESS } = require("@arbitrum/sdk/dist/lib/dataEntities/constants");

...

// Instantiation of the NodeInterface object
const nodeInterface = NodeInterface__factory.connect(
    NODE_INTERFACE_ADDRESS,
    baseL2Provider
);
```

For this example, we'll use the method `NodeInterface.gasEstimateComponents()` to get the information we need. For the `gasEstimateComponents()` call, we'll pass a `destinationAddress` (this should be the address that you intend to call in your transaction) and the data we want to send, to get results as accurate as possible. You can also specify a different block number (in hex) in the object passed as the last parameter.

```rust
// Getting the gas prices from ArbGasInfo.getPricesInWei()
const gasComponents = await arbGasInfo.callStatic.getPricesInWei();

// And the estimations from NodeInterface.GasEstimateComponents()
const gasEstimateComponents = await nodeInterface.callStatic.gasEstimateComponents(
  destinationAddress,
  false,
  txData,
  {
    blockTag: 'latest',
  },
);
```

With this, we can now get the values of the four variables we'll use in our formula:

```rust
// Getting useful values for calculating the formula
const l1GasEstimated = gasEstimateComponents.gasEstimateForL1;
const l2GasUsed = gasEstimateComponents.gasEstimate.sub(gasEstimateComponents.gasEstimateForL1);
const l2EstimatedPrice = gasEstimateComponents.baseFee;
const l1EstimatedPrice = gasEstimateComponents.l1BaseFeeEstimate.mul(16);

// Calculating some extra values to be able to apply all variables of the formula
// -------------------------------------------------------------------------------
// NOTE: This one might be a bit confusing, but l1GasEstimated (B in the formula) is calculated based on l2 gas fees
const l1Cost = l1GasEstimated.mul(l2EstimatedPrice);
// NOTE: This is similar to 140 + utils.hexDataLength(txData);
const l1Size = l1Cost.div(l1EstimatedPrice);

// Setting the basic variables of the formula
const P = l2EstimatedPrice;
const L2G = l2GasUsed;
const L1P = l1EstimatedPrice;
const L1S = l1Size;
```

And finally, we estimate the transaction fees applying the formula described in the beginning:

```rust
// L1C (L1 Cost) = L1P * L1S
const L1C = L1P.mul(L1S);

// B (Extra Buffer) = L1C / P
const B = L1C.div(P);

// G (Gas Limit) = L2G + B
const G = L2G.add(B);

// TXFEES (Transaction fees) = P * G
const TXFEES = P.mul(G);
```

Refer to [our tutorials repository](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/gas-estimation) for a working example of this code.

Final note[​](#final-note "Direct link to Final note")
------------------------------------------------------

Note that gas estimations from the above techniques are approximate and the actual gas fees may differ. We encourage developers to set this expectation explicitly wherever this information is shared with end-users.

---

# NodeInterface overview | Arbitrum Docs

## NodeInterface overview

The Arbitrum Nitro software includes a special `NodeInterface` contract available at address `0xc8` that is only accessible via RPCs (it's not actually deployed on-chain, and thus can't be called by smart contracts). The way it works is that the node uses Geth's [`InterceptRPCMessage`](https://github.com/OffchainLabs/go-ethereum/blob/b487f6fa366c99de26ea23ac24b59512a59b31ca/internal/ethapi/api.go#L1034) hook to detect messages sent to the address `0xc8`, and swaps out the message it's handling before deriving a transaction from it.

The [reference page](/build-decentralized-apps/nodeinterface/reference) contains information about all methods available in the NodeInterface.

---

# NodeInterface reference | Arbitrum Docs

## NodeInterface reference

The Arbitrum Nitro software includes a special `NodeInterface` contract available at address `0xc8` that is only accessible via RPCs (it's not actually deployed on-chain, and thus can't be called by smart contracts). This reference page documents the specific calls available in the NodeInterface. For a more conceptual description of what it is and how it works, please refer to the [NodeInterface conceptual page](/build-decentralized-apps/nodeinterface/overview).

NodeInterface methods[​](#nodeinterface-methods "Direct link to NodeInterface methods")
---------------------------------------------------------------------------------------

Method

Solidity interface

Go implementation

Description

`   estimateRetryableTicket(address sender, uint256 deposit, address to, uint256 l2CallValue, address excessFeeRefundAddress, address callValueRefundAddress, bytes calldata data)   `

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/node-interface/NodeInterface.sol#L25)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L0)

Estimates the gas needed for a retryable submission

`constructOutboxProof(uint64 size, uint64 leaf)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/node-interface/NodeInterface.sol#L44)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L0)

Constructs an outbox proof of an l2->l1 send's existence in the outbox accumulator

`findBatchContainingBlock(uint64 blockNum)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/node-interface/NodeInterface.sol#L60)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L0)

Finds the L1 batch containing a requested L2 block, reverting if none does

`getL1Confirmations(bytes32 blockHash)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/node-interface/NodeInterface.sol#L71)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L0)

Gets the number of L1 confirmations of the sequencer batch producing the requested L2 block

`gasEstimateComponents(address to, bool contractCreation, bytes calldata data)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/node-interface/NodeInterface.sol#L84)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L0)

Same as native gas estimation, but with additional info on the l1 costs

`gasEstimateL1Component(address to, bool contractCreation, bytes calldata data)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/node-interface/NodeInterface.sol#L112)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L0)

Estimates a transaction's l1 costs

`legacyLookupMessageBatchProof(uint256 batchNum, uint64 index)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/node-interface/NodeInterface.sol#L139)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L0)

Returns the proof necessary to redeem a message

`nitroGenesisBlock()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/node-interface/NodeInterface.sol#L157)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L0)

Returns the first block produced using the Nitro codebase

`blockL1Num(uint64 l2BlockNum)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/node-interface/NodeInterface.sol#L161)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L0)

Returns the L1 block number of the L2 block

`l2BlockRangeForL1(uint64 blockNum)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/node-interface/NodeInterface.sol#L170)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/nodeInterface/NodeInterface.go#L0)

Finds the L2 block number range that has the given L1 block number

---

# Oracles | Arbitrum Docs

## Oracles

note

This is a conceptual overview of oracles. For more detailed information on how to use oracles in your applications, check out our [third-party oracles documentation](/for-devs/oracles/oracles-content-map).

In this conceptual overview, we'll explore oracles, how they work, and some general applications. This overview will provide a foundational understanding and set expectations for developers who want to integrate oracles into their applications.

### What are oracles?[​](#what-are-oracles "Direct link to What are oracles?")

Oracles are third-party services that provide smart contracts with external information. They act as a bridge between blockchains and the outside world, which expands their functionality by enabling smart contracts to access data beyond their native networks.

### Types of oracles[​](#types-of-oracles "Direct link to Types of oracles")

Oracles can be classified based on their source, direction of information, trust, and how they provide information to smart contracts. Some common types of oracles include:

*   **Inbound and Outbound oracles**: Inbound oracles share information from external sources to smart contracts, while outbound oracles send information from smart contracts to the external world.
*   **Centralized and Decentralized oracles**: A centralized oracle is a single entity and sole data provider for a smart contract. Decentralized oracles increase reliability by relying on multiple sources of truth and distributing trust among participants.
*   **Push and Pull oracles**: Push oracles proactively provide data to smart contracts without being explicitly requested. They push data to the smart contract when a specified event or condition occurs. On the other hand, pull oracles require smart contracts to request data explicitly. They pull data from external sources in response to a query from the smart contract.
*   **Software oracles**: These oracles interact with online sources of information, such as databases, servers, or websites, and transmit the data to the blockchain. They often provide real-time information like exchange rates or digital asset prices.
*   **Hardware oracles**: These oracles obtain information from the physical world using electronic sensors, barcode scanners, or other reading devices. They "translate" real-world events into digital values that smart contracts can understand.

### How do push oracles work?[​](#how-do-push-oracles-work "Direct link to How do push oracles work?")

Push oracles proactively provide data to smart contracts without being explicitly requested. When a specified event or condition occurs, the push oracle triggers the smart contract with the relevant data. For example, a push oracle might send weather data to a smart contract once the temperature reaches a certain threshold.

![Push oracle](/img/dapps-push-oracle.svg)

### How do pull oracles work?[​](#how-do-pull-oracles-work "Direct link to How do pull oracles work?")

Pull oracles require smart contracts to request data explicitly. A smart contract sends a query to the oracle, retrieving and relaying the requested information to the contract. For example, a smart contract might request the current price of a specific digital asset from a pull oracle.

![Pull oracle](/img/dapps-pull-oracle.svg)

### Use cases for oracles[​](#use-cases-for-oracles "Direct link to Use cases for oracles")

Oracles serve a purpose in various applications across industries. Some general use cases include:

*   **Prediction markets**: Oracles provide real-world data to prediction market platforms, allowing users to bet on future events or outcomes.
*   **Supply chain management**: Hardware oracles can track the location and status of goods throughout the supply chain, enabling smart contracts to automate various processes and improve efficiency.
*   **Insurance**: Oracles can supply data about events such as natural disasters, accidents, or price fluctuations, allowing smart contracts to automate claims processing and payouts.
*   **Decentralized finance (DeFi)**: Oracles provide critical price and market data to DeFi applications, enabling them to operate efficiently and securely.

In summary, oracles are a crucial component of the blockchain ecosystem, bridging the gap between on-chain and off-chain data sources. They enhance the functionality of smart contracts and enable a wide range of applications across various industries. As blockchain technology continues to evolve, developing secure and reliable oracles will remain essential in unlocking the full potential of smart contracts and decentralized applications.

### Resources[​](#resources "Direct link to Resources")

You can learn more about oracles in our [third-party oracles documentation](/for-devs/oracles/oracles-content-map).

---

# Precompiles overview | Arbitrum Docs

## Precompiles overview

Precompiles are predefined smart contracts that have special addresses and provide specific functionality which is executed not at the EVM bytecode level, but natively by the Arbitrum client itself. Precompiles are primarily used to introduce specific functions that would be computationally expensive if executed in EVM bytecode, and functions that facilitate the interaction between the parent chain and the child chain. By having them natively in the Arbitrum client, they can be optimized for performance.

Besides supporting all precompiles available in Ethereum, Arbitrum provides child chain-specific precompiles with methods smart contracts can call the same way they can solidity functions. For more details on the addresses these precompiles live, and the specific methods available, please refer to the [methods documentation](/build-decentralized-apps/precompiles/reference).

---

# Precompiles reference | Arbitrum Docs

## Precompiles reference

ArbOS provides child chain-specific precompiles with methods smart contracts can call the same way they can solidity functions. This reference page exhaustively documents the specific calls ArbOS makes available through precompiles. For a more conceptual description of what precompiles are and how they work, please refer to the [precompiles conceptual page](/build-decentralized-apps/precompiles/overview).

This reference page is divided into two sections. The first one lists all precompiles in a summary table with links to the reference of the specific precompile, along with the address where they live, their purpose and links to the go implementation and solidity interface. The second one details the methods available in each precompile with links to the specific implementation.

General information of precompiles[​](#general-information-of-precompiles "Direct link to General information of precompiles")
------------------------------------------------------------------------------------------------------------------------------

This section is divided into two tables. We first list precompiles we expect users to most often use, and then the rest of precompiles. However, both tables display the same information: name and purpose of the precompile, address, and links to the solidity interface and the go implementation.

### Common precompiles[​](#common-precompiles "Direct link to Common precompiles")

Precompile

Address

Solidity interface

Go implementation

Purpose

[ArbAggregator](#arbaggregator)

`0x6d`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAggregator.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAggregator.go)

Configuring transaction aggregation

[ArbGasInfo](#arbgasinfo)

`0x6c`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go)

Info about gas pricing

[ArbRetryableTx](#arbretryabletx)

`0x6e`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go)

Managing retryables

[ArbSys](#arbsys)

`0x64`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go)

System-level functionality

[ArbWasm](#arbwasm)

`0x71`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go)

Manages Stylus contracts

[ArbWasmCache](#arbwasmcache)

`0x72`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasmCache.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasmCache.go)

Manages Stylus cache

### Other precompiles[​](#other-precompiles "Direct link to Other precompiles")

Precompile

Address

Solidity interface

Go implementation

Purpose

[ArbAddressTable](#arbaddresstable)

`0x66`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAddressTable.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAddressTable.go)

Supporting compression of addresses

ArbBLS

\-

\-

\-

**Disabled** (Former registry of BLS public keys)

[ArbDebug](#arbdebug)

`0xff`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go)

Testing tools

[ArbFunctionTable](#arbfunctiontable)

`0x68`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbFunctionTable.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbFunctionTable.go)

No longer used

[ArbInfo](#arbinfo)

`0x65`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbInfo.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbInfo.go)

Info about accounts

[ArbOwner](#arbowner)

`0x70`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go)

Chain administration, callable only by chain owner

[ArbOwnerPublic](#arbownerpublic)

`0x6b`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwnerPublic.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwnerPublic.go)

Info about chain owners

[ArbosTest](#arbostest)

`0x69`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbosTest.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbosTest.go)

No longer used

[ArbStatistics](#arbstatistics)

`0x6f`

[Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbStatistics.sol)

[Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbStatistics.go)

Info about the pre-Nitro state

Precompiles reference[​](#precompiles-reference "Direct link to Precompiles reference")
---------------------------------------------------------------------------------------

### ArbAddressTable[​](#arbaddresstable "Direct link to ArbAddressTable")

ArbAddressTable ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAddressTable.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAddressTable.go)) provides the ability to create short-hands for commonly used accounts.

Precompile address: `0x0000000000000000000000000000000000000066`

Method

Solidity interface

Go implementation

Description

`addressExists(address addr)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAddressTable.sol#L17)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAddressTable.go#L17)

AddressExists checks if an address exists in the table

`compress(address addr)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAddressTable.sol#L24)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAddressTable.go#L22)

Compress and returns the bytes that represent the address

`decompress(bytes calldata buf, uint256 offset)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAddressTable.sol#L32)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAddressTable.go#L27)

Decompress the compressed bytes at the given offset with those of the corresponding account

`lookup(address addr)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAddressTable.sol#L41)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAddressTable.go#L40)

Lookup the index of an address in the table

`lookupIndex(uint256 index)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAddressTable.sol#L47)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAddressTable.go#L52)

LookupIndex for an address in the table by index

`register(address addr)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAddressTable.sol#L54)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAddressTable.go#L67)

Register adds an account to the table, shrinking its compressed representation

`size()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAddressTable.sol#L59)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAddressTable.go#L73)

Size gets the number of addresses in the table

### ArbAggregator[​](#arbaggregator "Direct link to ArbAggregator")

ArbAggregator ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAggregator.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAggregator.go)) provides aggregators and their users methods for configuring how they participate in parent chain aggregation. Arbitrum One's default aggregator is the Sequencer, which a user will prefer unless `SetPreferredAggregator` is invoked to change it.

Compression ratios are measured in basis points. Methods that are checkmarked are access-controlled and will revert if not called by the aggregator, its fee collector, or a chain owner.

Precompile address: `0x000000000000000000000000000000000000006D`

Method

Solidity interface

Go implementation

Description

⚠️`getPreferredAggregator(address addr)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAggregator.sol#L14)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAggregator.go#L24)

Deprecated: Do not use this method.

⚠️`getDefaultAggregator()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAggregator.sol#L18)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAggregator.go#L30)

Deprecated: Do not use this method.

`getBatchPosters()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAggregator.sol#L22)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAggregator.go#L35)

GetBatchPosters gets the addresses of all current batch posters

`addBatchPoster(address newBatchPoster)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAggregator.sol#L27)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAggregator.go#L40)

Adds newBatchPoster as a batch poster

`getFeeCollector(address batchPoster)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAggregator.sol#L32)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAggregator.go#L63)

GetFeeCollector gets a batch poster's fee collector

`setFeeCollector(address batchPoster, address newFeeCollector)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAggregator.sol#L38)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAggregator.go#L72)

SetFeeCollector sets a batch poster's fee collector (caller must be the batch poster, its fee collector, or an owner)

⚠️`getTxBaseFee(address aggregator)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAggregator.sol#L43)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAggregator.go#L95)

Deprecated: returns 0

⚠️`setTxBaseFee(address aggregator, uint256 feeInL1Gas)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbAggregator.sol#L51)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbAggregator.go#L102)

Deprecated: does nothing

Note: methods marked with ⚠️ are deprecated and their use is not supported.

### ArbBLS[​](#arbbls "Direct link to ArbBLS")

Disabled

This precompile has been disabled. It previously provided a registry of BLS public keys for accounts.

### ArbDebug[​](#arbdebug "Direct link to ArbDebug")

ArbDebug ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go)) provides mechanisms useful for testing. The methods of `ArbDebug` are only available for chains with the `AllowDebugPrecompiles` chain parameter set. Otherwise, calls to this precompile will revert.

Precompile address: `0x00000000000000000000000000000000000000ff`

Method

Solidity interface

Go implementation

Description

`becomeChainOwner()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol#L13)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go#L58)

Caller becomes a chain owner

`events(bool flag, bytes32 value)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol#L16)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go#L28)

Emit events with values based on the args provided

`eventsView()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol#L19)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go#L47)

Tries (and fails) to emit logs in a view context

`customRevert(uint64 number)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol#L38)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go#L53)

Throws a custom error

`panic()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol#L40)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go#L63)

Halts the chain by panicking in the STF

`legacyError()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol#L42)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go#L68)

Throws a hardcoded error

Event

Solidity interface

Go implementation

Description

`Basic`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol#L22)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go#L33)

Emitted in `Events` for testing

`Mixed`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol#L23)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go#L38)

Emitted in `Events` for testing

`Store`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbDebug.sol#L30)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbDebug.go#L0)

Never emitted (used for testing log sizes)

### ArbFunctionTable[​](#arbfunctiontable "Direct link to ArbFunctionTable")

ArbFunctionTable ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbFunctionTable.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbFunctionTable.go)) provides aggregators the ability to manage function tables, to enable one form of transaction compression. The Nitro aggregator implementation does not use these, so these methods have been stubbed and their effects disabled. They are kept for backwards compatibility.

Precompile address: `0x0000000000000000000000000000000000000068`

Method

Solidity interface

Go implementation

Description

`upload(bytes calldata buf)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbFunctionTable.sol#L15)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbFunctionTable.go#L19)

Upload does nothing

`size(address addr)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbFunctionTable.sol#L18)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbFunctionTable.go#L24)

Size returns the empty table's size, which is 0

`get(address addr, uint256 index)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbFunctionTable.sol#L21)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbFunctionTable.go#L29)

Get reverts since the table is empty

### ArbGasInfo[​](#arbgasinfo "Direct link to ArbGasInfo")

ArbGasInfo ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go)) provides insight into the cost of using the chain. These methods have been adjusted to account for Nitro's heavy use of calldata compression. Of note to end-users, we no longer make a distinction between non-zero and zero-valued calldata bytes.

Precompile address: `0x000000000000000000000000000000000000006C`

Method

Solidity interface

Go implementation

Description

`getPricesInWeiWithAggregator(address aggregator)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L22)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L27)

GetPricesInWeiWithAggregator gets prices in wei when using the provided aggregator

`getPricesInWei()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L44)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L102)

GetPricesInWei gets prices in wei when using the caller's preferred aggregator

`getPricesInArbGasWithAggregator(address aggregator)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L58)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L107)

GetPricesInArbGasWithAggregator gets prices in ArbGas when using the provided aggregator

`getPricesInArbGas()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L69)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L159)

GetPricesInArbGas gets prices in ArbGas when using the caller's preferred aggregator

`getGasAccountingParams()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L80)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L164)

GetGasAccountingParams gets the rollup's speed limit, pool size, and tx gas limit

`getMinimumGasPrice()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L90)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L172)

GetMinimumGasPrice gets the minimum gas price needed for a transaction to succeed

`getL1BaseFeeEstimate()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L93)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L177)

GetL1BaseFeeEstimate gets the current estimate of the L1 basefee

`getL1BaseFeeEstimateInertia()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L96)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L182)

GetL1BaseFeeEstimateInertia gets how slowly ArbOS updates its estimate of the L1 basefee

`getL1RewardRate()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L100)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L187)

GetL1RewardRate gets the L1 pricer reward rate

`getL1RewardRecipient()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L104)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L192)

GetL1RewardRecipient gets the L1 pricer reward recipient

`getL1GasPriceEstimate()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L107)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L197)

GetL1GasPriceEstimate gets the current estimate of the L1 basefee

`getCurrentTxL1GasFees()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L110)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L202)

GetCurrentTxL1GasFees gets the fee paid to the aggregator for posting this tx

`getGasBacklog()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L113)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L207)

GetGasBacklog gets the backlogged amount of gas burnt in excess of the speed limit

`getPricingInertia()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L116)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L212)

Returns how slowly ArbOS updates the L2 basefee in response to backlogged gas

`getGasBacklogTolerance()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L119)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L217)

GetGasBacklogTolerance gets the forgivable amount of backlogged gas ArbOS will ignore when raising the basefee

`getL1PricingSurplus()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L122)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L222)

Returns the surplus of funds for L1 batch posting payments (may be negative)

`getPerBatchGasCharge()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L125)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L246)

Returns the base charge (in L1 gas) attributed to each data batch in the calldata pricer

`getAmortizedCostCapBips()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L128)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L251)

Returns the cost amortization cap in basis points

`getL1FeesAvailable()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L131)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L256)

Returns the available funds from L1 fees

`getL1PricingEquilibrationUnits()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L135)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L261)

Returns the equilibration units parameter for L1 price adjustment algorithm (Available since ArbOS 20)

`getLastL1PricingUpdateTime()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L139)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L266)

Returns the last time the L1 calldata pricer was updated (Available since ArbOS 20)

`getL1PricingFundsDueForRewards()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L143)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L271)

Returns the amount of L1 calldata payments due for rewards (per the L1 reward rate) (Available since ArbOS 20)

`getL1PricingUnitsSinceUpdate()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L147)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L276)

Returns the amount of L1 calldata posted since the last update (Available since ArbOS 20)

`getLastL1PricingSurplus()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbGasInfo.sol#L151)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbGasInfo.go#L281)

Returns the L1 pricing surplus as of the last update (may be negative) (Available since ArbOS 20)

### ArbInfo[​](#arbinfo "Direct link to ArbInfo")

ArbInfo ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbInfo.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbInfo.go)) provides the ability to lookup basic info about accounts and contracts.

Precompile address: `0x0000000000000000000000000000000000000065`

Method

Solidity interface

Go implementation

Description

`getBalance(address account)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbInfo.sol#L11)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbInfo.go#L18)

GetBalance retrieves an account's balance

`getCode(address account)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbInfo.sol#L14)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbInfo.go#L26)

GetCode retrieves a contract's deployed code

### ArbosTest[​](#arbostest "Direct link to ArbosTest")

ArbosTest ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbosTest.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbosTest.go)) provides a method of burning arbitrary amounts of gas, which exists for historical reasons. In Classic, `ArbosTest` had additional methods only the zero address could call. These have been removed since users don't use them and calls to missing methods revert.

Precompile address: `0x0000000000000000000000000000000000000069`

Method

Solidity interface

Go implementation

Description

`burnArbGas(uint256 gasAmount)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbosTest.sol#L13)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbosTest.go#L16)

BurnArbGas unproductively burns the amount of L2 ArbGas

### ArbOwner[​](#arbowner "Direct link to ArbOwner")

ArbOwner ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go)) provides owners with tools for managing the rollup. Calls by non-owners will always revert.

Most of Arbitrum Classic's owner methods have been removed since they no longer make sense in Nitro:

*   What were once chain parameters are now parts of ArbOS's state, and those that remain are set at genesis.
*   ArbOS upgrades happen with the rest of the system rather than being independent
*   Exemptions to address aliasing are no longer offered. Exemptions were intended to support backward compatibility for contracts deployed before aliasing was introduced, but no exemptions were ever requested.

Precompile address: `0x0000000000000000000000000000000000000070`

Method

Solidity interface

Go implementation

Description

`addChainOwner(address newOwner)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L18)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L37)

AddChainOwner adds account as a chain owner

`removeChainOwner(address ownerToRemove)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L21)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L42)

RemoveChainOwner removes account from the list of chain owners

`isChainOwner(address addr)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L24)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L51)

IsChainOwner checks if the account is a chain owner

`getAllChainOwners()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L27)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L56)

GetAllChainOwners retrieves the list of chain owners

`setL1BaseFeeEstimateInertia(uint64 inertia)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L30)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L61)

SetL1BaseFeeEstimateInertia sets how slowly ArbOS updates its estimate of the L1 basefee

`setL2BaseFee(uint256 priceInWei)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L33)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L66)

SetL2BaseFee sets the L2 gas price directly, bypassing the pool calculus

`setMinimumL2BaseFee(uint256 priceInWei)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L36)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L71)

SetMinimumL2BaseFee sets the minimum base fee needed for a transaction to succeed

`setSpeedLimit(uint64 limit)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L39)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L79)

SetSpeedLimit sets the computational speed limit for the chain

`setMaxTxGasLimit(uint64 limit)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L42)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L84)

SetMaxTxGasLimit sets the maximum size a tx (and block) can be

`setL2GasPricingInertia(uint64 sec)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L45)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L89)

SetL2GasPricingInertia sets the L2 gas pricing inertia

`setL2GasBacklogTolerance(uint64 sec)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L48)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L94)

SetL2GasBacklogTolerance sets the L2 gas backlog tolerance

`getNetworkFeeAccount()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L51)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L99)

GetNetworkFeeAccount gets the network fee collector

`getInfraFeeAccount()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L54)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L104)

GetInfraFeeAccount gets the infrastructure fee collector

`setNetworkFeeAccount(address newNetworkFeeAccount)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L57)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L109)

SetNetworkFeeAccount sets the network fee collector to the new network fee account

`setInfraFeeAccount(address newInfraFeeAccount)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L60)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L114)

SetInfraFeeAccount sets the infra fee collector to the new network fee account

`scheduleArbOSUpgrade(uint64 newVersion, uint64 timestamp)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L63)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L119)

ScheduleArbOSUpgrade to the requested version at the requested timestamp

`setL1PricingEquilibrationUnits(uint256 equilibrationUnits)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L66)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L124)

Sets equilibration units parameter for L1 price adjustment algorithm

`setL1PricingInertia(uint64 inertia)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L69)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L129)

Sets inertia parameter for L1 price adjustment algorithm

`setL1PricingRewardRecipient(address recipient)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L72)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L134)

Sets reward recipient address for L1 price adjustment algorithm

`setL1PricingRewardRate(uint64 weiPerUnit)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L75)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L139)

Sets reward amount for L1 price adjustment algorithm, in wei per unit

`setL1PricePerUnit(uint256 pricePerUnit)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L78)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L144)

Set how much ArbOS charges per L1 gas spent on transaction data.

`setPerBatchGasCharge(int64 cost)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L81)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L149)

Sets the base charge (in L1 gas) attributed to each data batch in the calldata pricer

`setBrotliCompressionLevel(uint64 level)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L87)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L160)

Sets the Brotli compression level used for fast compression (Available in ArbOS version 12 with default level as 1)

`setAmortizedCostCapBips(uint64 cap)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L90)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L154)

Sets the cost amortization cap in basis points

`releaseL1PricerSurplusFunds(uint256 maxWeiToRelease)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L93)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L165)

Releases surplus funds from L1PricerFundsPoolAddress for use

`setInkPrice(uint32 price)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L97)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L186)

Sets the amount of ink 1 gas buys

`setWasmMaxStackDepth(uint32 depth)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L100)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L200)

Sets the maximum depth (in wasm words) a wasm stack may grow

`setWasmFreePages(uint16 pages)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L103)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L210)

Gets the number of free wasm pages a tx gets

`setWasmPageGas(uint16 gas)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L106)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L220)

Sets the base cost of each additional wasm page

`setWasmPageLimit(uint16 limit)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L109)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L230)

Sets the initial number of pages a wasm may allocate

`setWasmMinInitGas(uint8 gas, uint16 cached)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L114)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L240)

Sets the minimum costs to invoke a program

`setWasmInitCostScalar(uint64 percent)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L118)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L251)

Sets the linear adjustment made to program init costs

`setWasmExpiryDays(uint16 _days)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L121)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L261)

Sets the number of days after which programs deactivate

`setWasmKeepaliveDays(uint16 _days)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L124)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L271)

Sets the age a program must be to perform a keepalive

`setWasmBlockCacheSize(uint16 count)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L127)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L281)

Sets the number of extra programs ArbOS caches during a given block

`addWasmCacheManager(address manager)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L130)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L291)

Adds account as a wasm cache manager

`removeWasmCacheManager(address manager)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L133)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L296)

Removes account from the list of wasm cache managers

`setChainConfig(string calldata chainConfig)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L136)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L309)

Sets serialized chain config in ArbOS state

Event

Solidity interface

Go implementation

Description

`OwnerActs`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwner.sol#L139)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwner.go#L0)

/ Emitted when a successful call is made to this precompile

### ArbOwnerPublic[​](#arbownerpublic "Direct link to ArbOwnerPublic")

ArbOwnerPublic ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwnerPublic.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwnerPublic.go)) provides non-owners with info about the current chain owners.

Precompile address: `0x000000000000000000000000000000000000006b`

Method

Solidity interface

Go implementation

Description

`isChainOwner(address addr)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwnerPublic.sol#L11)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwnerPublic.go#L35)

IsChainOwner checks if the user is a chain owner

`rectifyChainOwner(address ownerToRectify)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwnerPublic.sol#L18)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwnerPublic.go#L26)

RectifyChainOwner checks if the account is a chain owner (Available in ArbOS version 11)

`getAllChainOwners()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwnerPublic.sol#L21)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwnerPublic.go#L21)

GetAllChainOwners retrieves the list of chain owners

`getNetworkFeeAccount()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwnerPublic.sol#L24)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwnerPublic.go#L40)

GetNetworkFeeAccount gets the network fee collector

`getInfraFeeAccount()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwnerPublic.sol#L27)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwnerPublic.go#L45)

GetInfraFeeAccount gets the infrastructure fee collector

`getBrotliCompressionLevel()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwnerPublic.sol#L30)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwnerPublic.go#L53)

GetBrotliCompressionLevel gets the current brotli compression level used for fast compression

`getScheduledUpgrade()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwnerPublic.sol#L35)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwnerPublic.go#L59)

Returns (0, 0, nil) if no ArbOS upgrade is scheduled.

Event

Solidity interface

Go implementation

Description

`ChainOwnerRectified`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbOwnerPublic.sol#L40)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbOwnerPublic.go#L31)

Emitted when verifying a chain owner

### ArbRetryableTx[​](#arbretryabletx "Direct link to ArbRetryableTx")

ArbRetryableTx ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go)) provides methods for managing retryables. The model has been adjusted for Nitro, most notably in terms of how retry transactions are scheduled. For more information on retryables, please see [the retryable documentation](/how-arbitrum-works/l1-to-l2-messaging#retryable-tickets).

Precompile address: `0x000000000000000000000000000000000000006E`

Method

Solidity interface

Go implementation

Description

`redeem(bytes32 ticketId)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L18)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L49)

Redeem schedules an attempt to redeem the retryable, donating all of the call's gas to the redeem attempt

`getLifetime()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L24)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L134)

GetLifetime gets the default lifetime period a retryable has at creation

`getTimeout(bytes32 ticketId)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L31)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L139)

GetTimeout gets the timestamp for when ticket will expire

`keepalive(bytes32 ticketId)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L41)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L156)

Keepalive adds one lifetime period to the ticket's expiry

`getBeneficiary(bytes32 ticketId)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L49)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L184)

GetBeneficiary gets the beneficiary of the ticket

`cancel(bytes32 ticketId)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L56)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L197)

Cancel the ticket and refund its callvalue to its beneficiary

`getCurrentRedeemer()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L63)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L228)

Gets the redeemer of the current retryable redeem attempt

`submitRetryable()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L69)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L236)

Do not call. This method represents a retryable submission to aid explorers. Calling it will always revert.

Event

Solidity interface

Go implementation

Description

`TicketCreated`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L83)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L0)

Emitted when creating a retryable

`LifetimeExtended`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L84)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L179)

Emitted when extending a retryable's expiry date

`RedeemScheduled`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L85)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L116)

Emitted when scheduling a retryable

`Canceled`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L94)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L222)

Emitted when cancelling a retryable

`Redeemed`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbRetryableTx.sol#L97)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbRetryableTx.go#L0)

DEPRECATED in favour of new `RedeemScheduled` event after the nitro upgrade.

### ArbStatistics[​](#arbstatistics "Direct link to ArbStatistics")

ArbStatistics ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbStatistics.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbStatistics.go)) provides statistics about the chain as of just before the Nitro upgrade. In Arbitrum Classic, this was how a user would get info such as the total number of accounts, but there are better ways to get that info in Nitro.

Precompile address: `0x000000000000000000000000000000000000006F`

Method

Solidity interface

Go implementation

Description

`getStats()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbStatistics.sol#L18)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbStatistics.go#L18)

GetStats returns the current block number and some statistics about the rollup's pre-Nitro state

### ArbSys[​](#arbsys "Direct link to ArbSys")

ArbSys ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go)) provides system-level functionality for interacting with the parent chain and understanding the call stack.

Precompile address: `0x0000000000000000000000000000000000000064`

Method

Solidity interface

Go implementation

Description

`arbBlockNumber()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L17)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L34)

ArbBlockNumber gets the current L2 block number

`arbBlockHash(uint256 arbBlockNum)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L23)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L39)

ArbBlockHash gets the L2 block hash, if sufficiently recent

`arbChainID()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L29)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L60)

ArbChainID gets the rollup's unique chain identifier

`arbOSVersion()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L36)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L65)

ArbOSVersion gets the current ArbOS version

`getStorageGasAvailable()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L42)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L71)

GetStorageGasAvailable returns 0 since Nitro has no concept of storage gas

`isTopLevelCall()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L49)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L76)

IsTopLevelCall checks if the call is top-level (deprecated)

`mapL1SenderContractAddressToL2Alias(address sender, address unused)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L57)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L81)

MapL1SenderContractAddressToL2Alias gets the contract's L2 alias

`wasMyCallersAddressAliased()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L66)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L86)

WasMyCallersAddressAliased checks if the caller's caller was aliased

`myCallersAddressWithoutAliasing()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L72)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L96)

MyCallersAddressWithoutAliasing gets the caller's caller without any potential aliasing

`withdrawEth(address destination)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L80)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L207)

WithdrawEth send paid eth to the destination on L1

`sendTxToL1(address destination, bytes calldata data)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L90)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L111)

SendTxToL1 sends a transaction to L1, adding it to the outbox

`sendMerkleTreeState()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L101)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L191)

SendMerkleTreeState gets the root, size, and partials of the outbox Merkle tree state (caller must be the 0 address)

Event

Solidity interface

Go implementation

Description

`L2ToL1Tx`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L114)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L170)

Logs a send transaction from L2 to L1, including data for outbox proving

`L2ToL1Transaction`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L127)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L0)

DEPRECATED in favour of the new `L2ToL1Tx` event above after the nitro upgrade

`SendMerkleUpdate`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbSys.sol#L146)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbSys.go#L154)

Logs a new merkle branch needed for constructing outbox proofs

### ArbWasm[​](#arbwasm "Direct link to ArbWasm")

ArbWasm ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go)) provides helper methods for managing Stylus contracts

Precompile address: `0x0000000000000000000000000000000000000071`

Method

Solidity interface

Go implementation

Description

`activateProgram(address program)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L16)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L34)

Compile a wasm program with the latest instrumentation

`stylusVersion()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L23)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L94)

Gets the latest stylus version

`codehashVersion(bytes32 codehash)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L27)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L171)

Gets the stylus version that program with codehash was most recently compiled with

`codehashKeepalive(bytes32 codehash)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L31)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L58)

Extends a program's expiration date (reverts if too soon)

`codehashAsmSize(bytes32 codehash)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L36)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L180)

Gets a program's asm size in bytes

`programVersion(address program)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L40)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L189)

Gets the stylus version that program at addr was most recently compiled with

`programInitGas(address program)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L45)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L198)

Gets the cost to invoke the program

`programMemoryFootprint(address program)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L52)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L207)

Gets the footprint of program at addr

`programTimeLeft(address program)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L56)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L216)

Gets returns the amount of time remaining until the program expires

`inkPrice()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L60)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L100)

Gets the amount of ink 1 gas buys

`maxStackDepth()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L64)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L106)

Gets the wasm stack size limit

`freePages()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L68)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L112)

Gets the number of free wasm pages a tx gets

`pageGas()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L72)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L118)

Gets the base cost of each additional wasm page

`pageRamp()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L76)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L124)

Gets the ramp that drives exponential memory costs

`pageLimit()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L80)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L130)

Gets the maximum initial number of pages a wasm may allocate

`minInitGas()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L85)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L136)

Gets the minimum costs to invoke a program

`initCostScalar()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L89)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L147)

Gets the linear adjustment made to program init costs

`expiryDays()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L93)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L153)

Gets the number of days after which programs deactivate

`keepaliveDays()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L97)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L159)

Gets the age a program must be to perform a keepalive

`blockCacheSize()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L101)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L165)

Gets the number of extra programs ArbOS caches during a given block.

Event

Solidity interface

Go implementation

Description

`ProgramActivated`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L103)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L54)

Emitted when activating a WASM program

`ProgramLifetimeExtended`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasm.sol#L110)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasm.go#L70)

Emitted when extending the expiration date of a WASM program

### ArbWasmCache[​](#arbwasmcache "Direct link to ArbWasmCache")

ArbWasmCache ([Interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasmCache.sol) | [Implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasmCache.go)) provides helper methods for managing Stylus cache

Precompile address: `0x0000000000000000000000000000000000000072`

Method

Solidity interface

Go implementation

Description

`isCacheManager(address manager)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasmCache.sol#L13)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasmCache.go#L16)

See if the user is a cache manager owner.

`allCacheManagers()`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasmCache.sol#L17)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasmCache.go#L21)

Retrieve all authorized address managers.

`cacheCodehash(bytes32 codehash)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasmCache.sol#L20)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasmCache.go#L26)

Deprecated: replaced with CacheProgram.

`cacheProgram(address addr)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasmCache.sol#L26)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasmCache.go#L31)

Caches all programs with a codehash equal to the given address. Caller must be a cache manager or chain owner.

`evictCodehash(bytes32 codehash)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasmCache.sol#L30)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasmCache.go#L40)

Evicts all programs with the given codehash. Caller must be a cache manager or chain owner.

`codehashIsCached(bytes32 codehash)`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasmCache.sol#L33)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasmCache.go#L45)

Gets whether a program is cached. Note that the program may be expired.

Event

Solidity interface

Go implementation

Description

`UpdateProgramCache`

[

Interface

](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/ArbWasmCache.sol#L35)

[

Implementation

](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/ArbWasmCache.go#L62)

Emitted when caching a WASM program

---

# Arbitrum chains overview | Arbitrum Docs

## Arbitrum chains overview

Arbitrum chains are child chain solutions built on top of the Ethereum blockchain, designed to increase scalability and reduce transaction costs. In this conceptual overview, we’ll learn about the different Arbitrum chains and how they relate to each other. We’ll describe the available Arbitrum production and testnet chains, their differences, and the technology stacks that these chains use.

What Arbitrum production chains are available?[​](#what-arbitrum-production-chains-are-available "Direct link to What Arbitrum production chains are available?")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

### Arbitrum One[​](#arbitrum-one "Direct link to Arbitrum One")

**Arbitrum One** is a child chain (L2) optimistic rollup chain that implements the Arbitrum Rollup protocol and settles to Ethereum's parent chain (L1). It lets you build high-performance Ethereum dApps with low transaction costs and Ethereum-grade security guarantees, introducing no additional trust assumptions. This is made possible by the [Nitro](/how-arbitrum-works/geth-at-the-core) technology stack, a "Geth-at-the-core" architecture that gives Arbitrum One (and Nova) advanced calldata compression, separate contexts for common execution and fault proving, Ethereum parent chain gas compatibility, and more.

### Arbitrum Nova[​](#arbitrum-nova "Direct link to Arbitrum Nova")

**Arbitrum Nova** is a high-performance alternative to Arbitrum One's chain. While Arbitrum One implements the purely trustless Rollup protocol, Arbitrum Nova implements the mostly trustless [AnyTrust](/how-arbitrum-works/anytrust-protocol) protocol. The key difference between Rollup and AnyTrust is that the AnyTrust protocol introduces an additional trust assumption in the form of a data availability committee (DAC). This committee (detailed below) is responsible for expediting the process of storing, batching, and posting child chain transaction data to Ethereum's parent chain. This lets you use Arbitrum in scenarios that demand performance and affordability, while Arbitrum One is optimal for scenarios that demand Ethereum's pure trustlessness.

What Arbitrum testnet chains are available?[​](#what-arbitrum-testnet-chains-are-available "Direct link to What Arbitrum testnet chains are available?")
--------------------------------------------------------------------------------------------------------------------------------------------------------

### Arbitrum Sepolia[​](#arbitrum-sepolia "Direct link to Arbitrum Sepolia")

Arbitrum Sepolia serves as a testnet chain replicating the capabilities of Arbitrum One's main network. Linked to the Sepolia testnet, it offers developers a secure platform to experiment with and evaluate their smart contracts prior to actual deployment on the mainnet.

### Arbitrum Goerli[​](#arbitrum-goerli "Direct link to Arbitrum Goerli")

Arbitrum Goerli was a testnet chain that mirrored the functionality of the Arbitrum One mainnet and was connected to the Ethereum Goerli testnet. It was deprecated on November 18th 2023, and deactivated on March 18th, 2024.

caution

The old testnet RinkArby was deprecated on December 20th, 2022.

### Stylus testnet[​](#stylus-testnet "Direct link to Stylus testnet")

Stylus uses the Nitro technology and allows for efficient smart contract creation using languages like Rust, C, and C++. Leveraging Arbitrum's EVM equivalence, Stylus contracts achieve remarkable speed and low gas fees. With full interoperability between Solidity and Stylus contracts, new horizons emerge, while significantly cheaper memory costs unlock novel blockchain use cases.

caution

Stylus testnet was deprecated as of June 17, 2024.

What differences there are between the available Arbitrum chains?[​](#what-differences-there-are-between-the-available-arbitrum-chains "Direct link to What differences there are between the available Arbitrum chains?")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The main differences between the Arbitrum chains lie in their purpose and the environment they operate in.

Arbitrum One and Arbitrum Nova are production chains designed for real-world use. They're connected to the Ethereum mainnet and handle real, valuable transactions. They both use Arbitrum's Nitro technology stack under the hood, but Arbitrum One implements the Rollup protocol, while Nova implements the AnyTrust protocol. Arbitrum One is designed for general use, providing a scalable and cost-effective solution for running Ethereum-compatible smart contracts. On the other hand, Arbitrum Nova is designed for applications that require a higher transaction throughput and don’t require the full decentralization that rollups provide.

Finally, Arbitrum Sepolia is a testnet chain. It's designed for testing purposes and is connected to the Sepolia testnet, which uses test Ether with no real-world value.

What technology stacks use the Arbitrum chains?[​](#what-technology-stacks-use-the-arbitrum-chains "Direct link to What technology stacks use the Arbitrum chains?")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Nitro[​](#nitro "Direct link to Nitro")

Nitro is the technology that powers Arbitrum One, Arbitrum Nova (with AnyTrust configuration),and Arbitrum Sepolia. It's designed to offer high throughput and low cost, making it ideal for scaling Ethereum applications. Nitro is a major upgrade to the “Classic” stack, offering several improvements including advanced calldata compression, separate contexts for common execution and fault proving, Ethereum parent chain gas compatibility, and more. You can find more information about Nitro in [How Arbitrum works](/how-arbitrum-works/a-gentle-introduction).

### AnyTrust (variant of Nitro)[​](#anytrust-variant-of-nitro "Direct link to AnyTrust (variant of Nitro)")

AnyTrust is a variant of the Nitro technology stack that lowers costs by accepting a mild trust assumption. The AnyTrust protocol relies on an external Data Availability Committee (DAC) to store data and provide it on demand. The DAC has `N` members, of which AnyTrust assumes at least two are honest. Keeping the data off-chain in the happy/common case means the system can charge the user significantly lower fees. You can find more information about AnyTrust in [Anytrust protocol](/how-arbitrum-works/anytrust-protocol).

### Classic (deprecated)[​](#classic-deprecated "Direct link to Classic (deprecated)")

The Classic technology stack is the original version of Arbitrum. It has been deprecated and replaced by the Nitro technology stack.

Conclusion[​](#conclusion "Direct link to Conclusion")
------------------------------------------------------

Understanding the different Arbitrum chains and their technology stacks is crucial for developers working on blockchain and Web3 applications. Each chain offers a unique set of features and benefits, making them suitable for different use cases. By choosing the right chain and technology stack, developers can ensure their applications are secure, scalable, and cost-effective.

---

# Quickstart: Build a decentralized app (Solidity) | Arbitrum Docs

## Quickstart: Build a decentralized app (Solidity)

Want to use Rust instead?

Head over to [the Stylus quickstart](/stylus/quickstart) if you'd like to use Rust instead of Solidity.

This quickstart is for web developers who want to start building **decentralized applications** (dApps) using . It makes no assumptions about your prior experience with Ethereum, Arbitrum, or Solidity. Familiarity with Javascript and yarn is expected. If you're new to Ethereum, consider studying the [Ethereum documentation](https://ethereum.org/en/developers/docs/) before proceeding.

### What we'll learn[​](#what-well-learn "Direct link to What we'll learn")

In this tutorial we will learn:

1.  The basics of Ethereum vs. client/server architecture
2.  What is a Solidity smart contract
3.  How to compile and deploy a smart contract
4.  How to use an Ethereum wallet

We're going to build a digital cupcake vending machine using Solidity smart contracts[1](#user-content-fn-1). This vending machine will follow two rules:

1.  The vending machine will distribute a cupcake to anyone who hasn't recently received one.
2.  The vending machine's rules can't be changed by anyone.

Here's the vending machine implemented with Javascript. To use it, enter a name in the form below and press the 'Cupcake please!' button, you should see your cupcake balance go up.

#### Free Cupcakes

web2NameContract addressCupcake please!🧁

Cupcake balance:0 (no name)

We can assume that this vending machine operates as we expect, but it's largely up to the **centralized service provider** that hosts it. In the case of a compromised cloud host:

1.  Our centralized service provider can deny access to particular users.
2.  A malicious actor can change the rules of the vending machine at any time, for example, to give their friends extra cupcakes.

Centralized third-party intermediaries represent a **single point of failure** that malicious actors can exploit. With a blockchain infrastructure such as Ethereum, we decentralize our vending machine's **business logic and data**, making this type of exploits nearly impossible.

This is Arbitrum's core value proposition to you, dear developer. Arbitrum makes it easy for you to deploy your vending machines to Ethereum's permissionless, , decentralized network of nodes[2](#user-content-fn-2) **while keeping costs low for you and your users**.

Let's implement the "Web3" version of the above vending machine using Arbitrum.

### Prerequisites[​](#prerequisites "Direct link to Prerequisites")

VS Code

VS Code is the IDE we'll use to build our vending machine. See [code.visualstudio.com](https://code.visualstudio.com/) to install.

Web3 wallet

We will use Metamask as the  to interact with our vending machine. See [metamask.io](https://metamask.io/) and click View MetaMask Web or [OKX Wallet](https://www.okx.com/web3) and click Connect Wallet to install.

Yarn

Yarn is the package manager we'll use to install dependencies. See [yarnpkg.com](https://yarnpkg.com/) to install.

Foundry

Foundry is the toolchain we'll use to compile and deploy our smart contract. See [getfoundry.sh](https://getfoundry.sh) to install.

We'll address any remaining dependencies as we go.

### Ethereum and Arbitrum in a nutshell[​](#ethereum-and-arbitrum-in-a-nutshell "Direct link to Ethereum and Arbitrum in a nutshell")

*   **Ethereum**
    *   Ethereum is a decentralized network of [nodes](https://docs.prylabs.network/docs/concepts/nodes-networks) that use Ethereum's client software (like [Offchain's Prysm](https://docs.prylabs.network/docs/getting-started) to maintain a public  data structure.
    *   The data within Ethereum's blockchain data structure changes one transaction at a time.
    *    are small programs that execute transactions according to predefined rules. Ethereum's nodes host and execute smart contracts.
    *   You can use smart contracts to build decentralized apps (dApps) that use Ethereum's network to process transactions and store data. Think of smart contracts as your dApp's backend
    *   DApps let users carry their data and identity between applications without trusting centralized service providers.
    *   People who run Ethereum validator nodes[3](#user-content-fn-3) can earn `$ETH` for processing and validating transactions on behalf of users and dApps.
    *   These transactions can be expensive when the network is under heavy load.
*   **Arbitrum**
    *   Arbitrum is a suite of child chain scaling solutions for dApp developers.
    *    is a child chain that implements the .
    *   You can use Arbitrum One to build user-friendly dApps with high throughput, low latency, and low transaction costs while inheriting Ethereum's high-security standards[4](#user-content-fn-4).

### Review the Javascript vending machine[​](#review-the-javascript-vending-machine "Direct link to Review the Javascript vending machine")

Here's the vending machine implemented as a Javascript class:

VendingMachine.js

```rust
class VendingMachine {
  // state variables = internal memory of the vending machine
  cupcakeBalances = {};
  cupcakeDistributionTimes = {};

  // Vend a cupcake to the caller
  giveCupcakeTo(userId) {
    if (this.cupcakeDistributionTimes[userId] === undefined) {
      this.cupcakeBalances[userId] = 0;
      this.cupcakeDistributionTimes[userId] = 0;
    }

    // Rule 1: The vending machine will distribute a cupcake to anyone who hasn't recently received one.
    const fiveSeconds = 5000;
    const userCanReceiveCupcake = this.cupcakeDistributionTimes[userId] + fiveSeconds <= Date.now();
    if (userCanReceiveCupcake) {
      this.cupcakeBalances[userId]++;
      this.cupcakeDistributionTimes[userId] = Date.now();
      console.log(`Enjoy your cupcake, ${userId}!`);
      return true;
    } else {
      console.error(
        'HTTP 429: Too Many Cupcakes (you must wait at least 5 seconds between cupcakes)',
      );
      return false;
    }
  }

  getCupcakeBalanceFor(userId) {
    return this.cupcakeBalances[userId];
  }
}
```

The `VendingMachine` class uses _state variables_ and _functions_ to implement _predefined rules_. This implementation is useful because it automates cupcake distribution, but there's a problem: it's hosted by a centralized server controlled by a third-party service provider.

Let's decentralize our vending machine's business logic and data by porting the above JavaScript implementation into a Solidity smart contract.

### Review the Solidity vending machine[​](#review-the-solidity-vending-machine "Direct link to Review the Solidity vending machine")

Here is a Solidity implementation of the vending machine. Solidity is a language that compiles to [EVM bytecode](https://blog.chain.link/what-are-abi-and-bytecode-in-solidity/). This means that it is deployable to any Ethereum-compatible blockchain, including Ethereum mainnet, , and .

VendingMachine.sol

```rust
// SPDX-License-Identifier: MIT
// Specify the Solidity compiler version - this contract requires version 0.8.9 or higher
pragma solidity ^0.8.9;

// Define a smart contract named VendingMachine
// Unlike regular classes, once deployed, this contract's code cannot be modified
// This ensures that the vending machine's rules remain constant and trustworthy
contract VendingMachine {
   // State variables are permanently stored in blockchain storage
   // These mappings associate Ethereum addresses with unsigned integers
   // The 'private' keyword means these variables can only be accessed from within this contract
   mapping(address => uint) private _cupcakeBalances;     // Tracks how many cupcakes each address owns
   mapping(address => uint) private _cupcakeDistributionTimes;  // Tracks when each address last received a cupcake

   // Function to give a cupcake to a specified address
   // 'public' means this function can be called by anyone
   // 'returns (bool)' specifies that the function returns a boolean value
   function giveCupcakeTo(address userAddress) public returns (bool) {
       // Initialize first-time users
       // In Solidity, uninitialized values default to 0, so this check isn't strictly necessary
       // but is included to mirror the JavaScript implementation
       if (_cupcakeDistributionTimes[userAddress] == 0) {
           _cupcakeBalances[userAddress] = 0;
           _cupcakeDistributionTimes[userAddress] = 0;
       }

       // Calculate when the user is eligible for their next cupcake
       // 'seconds' is a built-in time unit in Solidity
       // 'block.timestamp' gives us the current time in seconds since Unix epoch
       uint fiveSecondsFromLastDistribution = _cupcakeDistributionTimes[userAddress] + 5 seconds;
       bool userCanReceiveCupcake = fiveSecondsFromLastDistribution <= block.timestamp;

       if (userCanReceiveCupcake) {
           // If enough time has passed, give them a cupcake and update their last distribution time
           _cupcakeBalances[userAddress]++;
           _cupcakeDistributionTimes[userAddress] = block.timestamp;
           return true;
       } else {
           // If not enough time has passed, revert the transaction with an error message
           // 'revert' cancels the transaction and returns the error message to the user
           revert("HTTP 429: Too Many Cupcakes (you must wait at least 5 seconds between cupcakes)");
       }
   }

   // Function to check how many cupcakes an address owns
   // 'public' means anyone can call this function
   // 'view' means this function only reads data and doesn't modify state
   // This makes it free to call (no gas cost) when called externally
   function getCupcakeBalanceFor(address userAddress) public view returns (uint) {
       return _cupcakeBalances[userAddress];
   }
}
```

### Compile your smart contract with Remix[​](#compile-your-smart-contract-with-remix "Direct link to Compile your smart contract with Remix")

Smart contracts need to be compiled to bytecode to be stored and executed on-chain by the EVM; we'll use Remix to do that.

Remix is a browser-based IDE for EVM development. There are other IDEs to choose from (Foundry, Hardhat), but Remix doesn't require any local environment setup, so we'll choose it for this tutorial.

Let's first add our smart contract to Remix following these steps:

#### 1\. Load Remix: [https://remix.ethereum.org](https://remix.ethereum.org)[​](#1-load-remix-httpsremixethereumorg "Direct link to 1-load-remix-httpsremixethereumorg")

#### 2\. Create a blank workspace in Remix:[​](#2-create-a-blank-workspace-in-remix "Direct link to 2. Create a blank workspace in Remix:")

File explorer > Workspaces > Create blank

![](/img/dapps-remix-create-blank-project-2025-01-07.gif)

#### 3\. Copy your vending machine contract[​](#3-copy-your-vending-machine-contract "Direct link to 3. Copy your vending machine contract")

#### 4\. Paste your contract in Remix[​](#4-paste-your-contract-in-remix "Direct link to 4. Paste your contract in Remix")

File explorer > New file

#### 5\. Compile your contract in Remix[​](#5-compile-your-contract-in-remix "Direct link to 5. Compile your contract in Remix")

Select vending machine contract > Click compile menu > Compile

![](/img/dapps-remix-compile-contract-2025-01-07.gif)

### Deploy the smart contract to a local Ethereum chain[​](#deploy-the-smart-contract-to-a-local-ethereum-chain "Direct link to Deploy the smart contract to a local Ethereum chain")

Once a smart contract gets compiled, it is deployable to a blockchain. The safest way to do this is to deploy it to a locally hosted chain, where you can test and debug your contract before deploying it to a public chain.

To deploy our `VendingMachine` smart contract locally, we will:

1.  Run Foundry's local Ethereum node in a terminal window
2.  Configure a wallet so we can interact with our smart contract after deployment (1)
3.  Deploy our smart contract to (1)'s node using Remix

#### Run a local chain[​](#run-a-local-chain "Direct link to Run a local chain")

Here, we'll use [Foundry's `anvil`](https://book.getfoundry.sh/anvil/) to run a local Ethereum network and node.

```rust
curl -L https://foundry.paradigm.xyz | bash && anvil
```

Once you've run the above commands, you should see a prompt showing what test accounts automatically were generated for you and other infos about your local Anvil testnet.

```rust
                            (_) | |
      __ _   _ __   __   __  _  | |
     / _` | | '_ \  \ \ / / | | | |
    | (_| | | | | |  \ V /  | | | |
     \__,_| |_| |_|   \_/   |_| |_|

    0.2.0 (7f0f5b4 2024-08-08T00:19:07.020431000Z)
    https://github.com/foundry-rs/foundry

# Available Accounts

(0) 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 (10000.000000000000000000 ETH)
(1) 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 (10000.000000000000000000 ETH)
(2) 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC (10000.000000000000000000 ETH)
(3) 0x90F79bf6EB2c4f870365E785982E1f101E93b906 (10000.000000000000000000 ETH)
(4) 0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65 (10000.000000000000000000 ETH)
(5) 0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc (10000.000000000000000000 ETH)
(6) 0x976EA74026E726554dB657fA54763abd0C3a0aa9 (10000.000000000000000000 ETH)
(7) 0x14dC79964da2C08b23698B3D3cc7Ca32193d9955 (10000.000000000000000000 ETH)
(8) 0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f (10000.000000000000000000 ETH)
(9) 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720 (10000.000000000000000000 ETH)

# Private Keys

(0) 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
(1) 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d
(2) 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a
(3) 0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6
(4) 0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a
(5) 0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba
(6) 0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e
(7) 0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356
(8) 0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97
(9) 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6

# Wallet

Mnemonic: test test test test test test test test test test test junk
Derivation path: m/44'/60'/0'/0/

# Chain ID

31337.
```

#### Configure Metamask[​](#configure-metamask "Direct link to Configure Metamask")

Next, open Metamask and create or import a wallet by following the displayed instructions.

By default, Metamask will connect to Ethereum's mainnet. To connect to our local "testnet," enable test networks for Metamask by clicking `Show/hide test networks.`

Next, click Metamask's network selector dropdown and click the `Add Network` button. Click "Add a network manually" and then provide the following information:

*   Network Name: `localhost`
*   New RPC URL: `https://127.0.0.1:8545`
*   Chain ID: `31337`
*   Currency Symbol: `ETH`

Add Localhost 8545 to Metamask

![](/img/dapps-metamask-add-localhost-2025-01-13.png)

Your wallet won't have a balance on your local testnet's node, but we can import one of the test accounts into Metamask to access to 10,000 testnet `$ETH`. Copy the private key of one of the test accounts (it works with or without the `0x` prefix, so e.g., `0xac0..f80` or `ac0..f80`) and import it into Metamask. Metamask will ask you if you want to connect this new account to Remix, to which you should answer "yes":

![Connect Metamask to Localhost 8545](/img/dapps-quickstart-import-metamask.png)

Never share your private keys

Your Ethereum Mainnet wallet's private key is the password to all of your money. Never share it with anyone; avoid copying it to your clipboard.

Note that in the context of this quickstart, "account" refers to a public wallet address and its associated private key[5](#user-content-fn-5).

You should see a balance of 10,000 `$ETH`. Keep your private key handy; we'll use it again shortly.

As we interact with our cupcake vending machine, we'll use Metamask's network selector dropdown to choose which network our cupcake transactions get sent to. We'll leave the network set to `Localhost 8545` for now.

#### Connect Remix to Metamask[​](#connect-remix-to-metamask "Direct link to Connect Remix to Metamask")

In the last step, we'll connect Remix to Metamask so we can deploy our smart contract to the local chain using Remix.

Connect remix to Metamask

![](/img/dapps-remix-connect-metamask-2025-01-13.gif)

At this point, we're ready to deploy our smart contract to any chain we want.

#### Deploy the smart contract to your local chain[​](#deploy-the-smart-contract-to-your-local-chain "Direct link to Deploy the smart contract to your local chain")

*   In MetaMask, ensure that the `Localhost` network is selected.
*   In Remix, deploy the `VendingMachine` contract to the `Localhost` network, then go to the "Deploy & Run Transactions" tab and click "Deploy."

Deploy the VendingMachine contract to the Localhost network

![](/img/dapps-remix-deploy-to-local-chain-2025-01-14.gif)

Then copy and paste your **contract address** below and click `Get cupcake!`. A prompt should ask you to sign a transaction that gives you a cupcake.

#### Free Cupcakes

web3-localhostMetamask wallet addressContract addressCupcake please!🧁

Cupcake balance:0 (no name)

### What's going on, here?[​](#whats-going-on-here "Direct link to What's going on, here?")

Our first `VendingMachine` is labeled `Web2` because it demonstrates traditional client-server web application architecture: the back-end lives in a centralized network of servers.

![Architecture diagram](/img/dapps-quickstart-vending-machine-architecture.png)

The `Web3` architecture is similar to the `Web2` architecture, with one key difference: with the `Web3` version, business logic and data are hosted by decentralized network of nodes\*\*

Let's take a closer look at the differences between our `VendingMachine` implementations:

`WEB2`  
(the first one)

`WEB3-LOCALHOST`  
(the latest one)

`WEB3-ARB-SEPOLIA`  
(the next one)

`WEB3-ARB-MAINNET`  
(the final one)

**Data** (cupcakes)

Stored only in your **browser**. (Usually, stored by centralized infrastructure.)

Stored on your **device** in an **emulated Ethereum network** (via smart contract).

Stored on Ethereum's **decentralized test network** (via smart contract).

Stored on Ethereum's **decentralized mainnet network** (via smart contract).

**Logic** (vending)

Served from **Offchain's servers**. Executed by your **browser**.

Stored and executed by your **locally emulated Ethereum network** (via smart contract).

Stored and executed by Arbitrum's **decentralized test network** (via smart contract).

Stored and executed by Arbitrum's **decentralized mainnet network** (via smart contract).

**Presentation** (UI)

Served from **Offchain's servers**. Rendered and executed by your **browser**.

← same

← same

← same

**Money**

Devs and users pay centralized service providers for server access using fiat currency.

← same, but only for the presentation-layer concerns (code that supports frontend UI/UX).

← same, but devs and users pay **testnet $ETH** to testnet validators.

← same, but instead of testnet $ETH, they use **mainnet $ETH**.

So far, we've deployed our `Web3` app to an emulated blockchain (Anvil), which is a normal step in EVM development.

Next, we'll deploy our smart contract to a network of real nodes: Arbitrum's Sepolia testnet.

### Deploy the smart contract to the Arbitrum Sepolia testnet[​](#deploy-the-smart-contract-to-the-arbitrum-sepolia-testnet "Direct link to Deploy the smart contract to the Arbitrum Sepolia testnet")

We were able to deploy to a testnet for free because we were using Remix' built-in network, but now we'll deploy our contract to Arbitrum's Sepolia testnet. Sepolia is powered by a network of nodes ran across the world by various participants, we'll need to compensate them with a small transaction fee in order to deploy our smart contract.

To be able to pay the transaction fee, we will:

*   Use our MetaMask crypto wallet
*   Obtain some Arbitrum Sepolia testnet's token called `$ETH`.

Click Metamask's network selector dropdown, and then click the `Add Network` button. Click "Add a network manually" and then provide the following information:

*   Network Name: `Arbitrum Sepolia`
*   New RPC URL: `https://sepolia-rollup.arbitrum.io/rpc`
*   Chain ID: `421614`
*   Currency Symbol: `$ETH`

As we interact with the cupcake vending machine, we'll use Metamask's network selector dropdown to determine which network our cupcake transactions are sent to.

Next, let's deposit some `$ETH` into the wallet corresponding to the private key we added to Remix. At the time of this quickstart's writing, the easiest way to acquire `$ETH` is to bridge Sepolia `$ETH` from Ethereum's parent chain Sepolia network to Arbitrum's child chain Sepolia network:

1.  Use a parent chain Sepolia `$ETH` faucet like [sepoliafaucet.com](https://sepoliafaucet.com/) to acquire some testnet `$ETH` on parent chain Sepolia.
2.  Bridge your parent chain Sepolia `$ETH` into Arbitrum child chain using [the Arbitrum bridge](https://bridge.arbitrum.io/).

Once you've acquired some `$ETH`, you'll be able to deploy your smart contract to Arbitrum's Sepolia testnet by issuing the following command:

This tells remix to deploy the compiled smart contract through the RPC endpoint corresponding to `Arbitrum Sepolia` in MetaMask (MetaMask uses [INFURA](https://www.infura.io)'s nodes as endpoints)

Congratulations! You've just deployed **business logic and data** to Arbitrum Sepolia. This logic and data will be hashed and submitted within a transaction to Ethereum's parent chian Sepolia network, and then it will be mirrored across all nodes in the Sepolia network[6](#user-content-fn-6).

To view your smart contract in a blockchain explorer, visit `https://sepolia.arbiscan.io/address/0x...B3`, but replace the `0x...B3` part of the URL with the full address of your deployed smart contract.

Select `Arbitrum Sepolia` from Metamask's dropdown, paste your contract address into the `VendingMachine` below, and click `Get cupcake!`. You should be prompted to sign a transaction that gives you a cupcake.

#### Free Cupcakes

web3-arb-sepoliaMetamask wallet addressContract addressCupcake please!🧁

Cupcake balance:0 (no name)

The final step is deploying our Cupcake machine to a production network, such as Ethereum, Arbitrum One, or Arbitrum Nitro. The good news is: deploying a smart contract in production is exactly the same as for Sepolia Testnet. The harder news: it will cost real money, this time. If you deploy on Ethereum, the fees can be significant and the transaction confirmation time 12 seconds on average. Arbitrum, a child chain, reduces these costs about 10X and a confirmation time in the same order while maintaining a similar level of security and decentralization.

### Summary[​](#summary "Direct link to Summary")

In this quickstart, we:

*   Identified **two business rules**: 1) fair and permissionless cupcake distribution 2) immutable business logic and data.
*   Identified a **challenge**: These rules are difficult to follow in a centralized application.
*   Identified a **solution**: Using Arbitrum, we can decentralize business logic and data.
*   Converted a vending machine's Javascript business logic into a **Solidity smart contract**.
*   **Deployed our smart contract** to a local development network, and then Arbitrum's Sepolia testnet.

If you have any questions or feedback, reach out to us on [Discord](https://discord.gg/ZpZuw7p) and/or click the `Request an update` button at the top of this page - we're listening!

### Learning resources[​](#learning-resources "Direct link to Learning resources")

Resource

Description

[Official Solidity documentation](https://soliditylang.org)

Official documentation for Solidity programming language

[Solidity by example](https://solidity-by-example.org)

Learn Solidity patterns via a series of classic examples

[Upgrading Ethereum (e-book)](https://eth2book.info/altair)

Guide on upgrading Ethereum

[Ethernaut](https://ethernaut.openzeppelin.com)

Interactive smart contract hacking game

[RareSkills](https://www.rareskills.io/rust-bootcamp)

Rust programming course for blockchain development

[CryptoZombies](https://cryptozombies.io/en/course/)

Free online smart contract courses and tutorials

[LearnWeb3](https://learnweb3.io)

Web3 education platform with interactive lessons and projects

[HackQuest](https://www.hackquest.io/en)

Web3 hackathon and project-based learning platform

[Rise In](https://www.risein.com/bootcamps/solidity-bootcamp)

Solidity bootcamp for beginners

[Encode Club](https://www.encode.club)

Community-driven coding club with a focus on web3 development

[Metana](https://metana.io)

Metana is not mentioned in the resources, please provide more information about this resource.

[Alchemy University](https://www.alchemy.com/university)

Online education platform for blockchain and web3 development courses

Footnotes[​](#footnote-label "Direct link to Footnotes")
--------------------------------------------------------

1.  The vending machine example was inspired by [Ethereum.org's "Introduction to Smart Contracts"](https://ethereum.org/en/developers/docs/smart-contracts/), which was inspired by [Nick Szabo's "From vending machines to smart contracts"](http://unenumerated.blogspot.com/2006/12/from-vending-machines-to-smart.html). [↩](#user-content-fnref-1)
    
2.  Although application front-ends are usually hosted by centralized services, smart contracts allow the underlying logic and data to be partially or fully decentralized. These smart contracts are hosted and executed by Ethereum's public, decentralized network of nodes. Arbitrum has its own network of nodes that use advanced cryptography techniques to "batch process" Ethereum transactions and then submit them to the Ethereum parent chain, which significantly reduces the cost of using Ethereum. All without requiring developers to compromise on security or decentralization. [↩](#user-content-fnref-2)
    
3.  There are multiple types of Ethereum nodes. The ones that earn `$ETH` for processing and validating transactions are called _validators_. See [Nodes and Networks](https://docs.prylabs.network/docs/concepts/nodes-networks) for a beginner-friendly introduction to Ethereum's node types. [↩](#user-content-fnref-3)
    
4.  When our `VendingMachine` contract is deployed to Ethereum, it'll be hosted by Ethereum's decentralized network of nodes. Generally speaking, we won't be able to modify the contract's code after it's deployed. [↩](#user-content-fnref-4)
    
5.  To learn more about how Ethereum wallets work, see [Ethereum.org's introduction to Ethereum wallets](https://ethereum.org/en/wallets/). [↩](#user-content-fnref-5)
    
6.  Visit the [Gentle Introduction to Arbitrum](/intro/) for a beginner-friendly introduction to Arbitrum's Rollup protocol. [↩](#user-content-fnref-6)

---

# Chain parameters | Arbitrum Docs

## Chain parameters

Param

Description

Arbitrum One

Arbitrum Nova

Arb Sepolia

Dispute window

Time for assertions to get confirmed during which validators can issue a challenge

45818 blocks (~ 6.4 days )

45818 blocks (~ 6.4 days)

20 blocks (~ 4.0 minutes)

Base stake

Amount of stake required for a validator to make an assertion

1 ETH

1 ETH

1 Sepolia ETH

Force-include period

Period after which a delayed message can be included into the inbox without any action from the Sequencer

5760 blocks / 24 hours

5760 blocks / 24 hours

5760 blocks / 24 hours

Gas speed limit

Target gas/sec, over which the congestion mechanism activates

7,000,000 gas/sec

7,000,000 gas/sec

7,000,000 gas/sec

Gas price floor

Minimum gas price

0.01 gwei

0.01 gwei

0.1 gwei

Block gas limit

Maximum amount of gas that all the transactions inside a block are allowed to consume

32,000,000

32,000,000

32,000,000

---

# Smart contract addresses | Arbitrum Docs

## Smart contract addresses

The following information may be useful to those building on Arbitrum. We list the addresses of the smart contracts related to the protocol, the token bridge and precompiles of the different Arbitrum chains.

Protocol smart contracts[​](#protocol-smart-contracts "Direct link to Protocol smart contracts")
------------------------------------------------------------------------------------------------

### Core contracts[​](#core-contracts "Direct link to Core contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

Rollup

[0x4DCe...Cfc0](https://etherscan.io/address/0x4DCeB440657f21083db8aDd07665f8ddBe1DCfc0)

[0xE7E8...B7Bd](https://etherscan.io/address/0xE7E8cCC7c381809BDC4b213CE44016300707B7Bd)

[0x042B...0Cf4](https://sepolia.etherscan.io/address/0x042B2E6C5E99d4c521bd49beeD5E99651D9B0Cf4)

Sequencer Inbox

[0x1c47...82B6](https://etherscan.io/address/0x1c479675ad559DC151F6Ec7ed3FbF8ceE79582B6)

[0x211E...c21b](https://etherscan.io/address/0x211E1c4c7f1bF5351Ac850Ed10FD68CFfCF6c21b)

[0x6c97...be0D](https://sepolia.etherscan.io/address/0x6c97864CE4bEf387dE0b3310A44230f7E3F1be0D)

CoreProxyAdmin

[0x5547...2dbD](https://etherscan.io/address/0x554723262467F125Ac9e1cDFa9Ce15cc53822dbD)

[0x71D7...7148](https://etherscan.io/address/0x71D78dC7cCC0e037e12de1E50f5470903ce37148)

[0x1ed7...0686](https://sepolia.etherscan.io/address/0x1ed74a4e4F4C42b86A7002e9951e98DBcC890686)

### Cross-chain messaging contracts[​](#cross-chain-messaging-contracts "Direct link to Cross-chain messaging contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

Delayed Inbox

[0x4Dbd...AB3f](https://etherscan.io/address/0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f)

[0xc444...3949](https://etherscan.io/address/0xc4448b71118c9071Bcb9734A0EAc55D18A153949)

[0xaAe2...ae21](https://sepolia.etherscan.io/address/0xaAe29B0366299461418F5324a79Afc425BE5ae21)

Bridge

[0x8315...ed3a](https://etherscan.io/address/0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a)

[0xC1Eb...76Bd](https://etherscan.io/address/0xC1Ebd02f738644983b6C4B2d440b8e77DdE276Bd)

[0x38f9...33a9](https://sepolia.etherscan.io/address/0x38f918D0E9F1b721EDaA41302E399fa1B79333a9)

Outbox

[0x0B98...4840](https://etherscan.io/address/0x0B9857ae2D4A3DBe74ffE1d7DF045bb7F96E4840)

[0xD4B8...cc58](https://etherscan.io/address/0xD4B80C3D7240325D18E645B49e6535A3Bf95cc58)

[0x65f0...B78F](https://sepolia.etherscan.io/address/0x65f07C7D521164a4d5DaC6eB8Fac8DA067A3B78F)

Classic Outbox\*\*\*

[0x7607...1A40](https://etherscan.io/address/0x760723CD2e632826c38Fef8CD438A4CC7E7E1A40)  
[0x667e...337a](https://etherscan.io/address/0x667e23ABd27E623c11d4CC00ca3EC4d0bD63337a)

\*\*\*Migrated Network Only

### Fraud proof contracts[​](#fraud-proof-contracts "Direct link to Fraud proof contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

ChallengeManager

[0xA556...9fB0](https://etherscan.io/address/0xA5565d266c3c3Ee90B16Be8A5b13d587ef559fB0)

[0xFE66...A688](https://etherscan.io/address/0xFE66b18Ef1B943F8594A2710376Af4B01AcfA688)

[0xC60b...8B4C](https://sepolia.etherscan.io/address/0xC60b56Ff6aAb3FE8B9Bd70040Fe9E95A26258B4C)

OneStepProver0

[0x35FB...F731](https://etherscan.io/address/0x35FBC5F03d86E88973B06Fb9C5a913D54AbdF731)

[0x35FB...F731](https://etherscan.io/address/0x35FBC5F03d86E88973B06Fb9C5a913D54AbdF731)

[0x3Fe7...1377](https://sepolia.etherscan.io/address/0x3Fe73F959C44e04d660dBFBbeffd51FD2c091377)

OneStepProverMemory

[0xe0ba...C48b](https://etherscan.io/address/0xe0ba77e0E24de5369e3B268Ea79fDe716e2EC48b)

[0xe0ba...C48b](https://etherscan.io/address/0xe0ba77e0E24de5369e3B268Ea79fDe716e2EC48b)

[0x6268...ec2d](https://sepolia.etherscan.io/address/0x6268Fc8dB1b5083b405b2C51808Df3619783ec2d)

OneStepProverMath

[0xaB95...F921](https://etherscan.io/address/0xaB9596a0aaF28bc798c453434EC2DC0F8F0bF921)

[0xaB95...F921](https://etherscan.io/address/0xaB9596a0aaF28bc798c453434EC2DC0F8F0bF921)

[0x42f5...e8Fa](https://sepolia.etherscan.io/address/0x42f58c90583eC3fA0E0b724dEDF755AE1068e8Fa)

OneStepProverHostIo

[0xa07c...71Cf](https://etherscan.io/address/0xa07cD154340CC74EcF156FFB9fb378Ee29Ca71Cf)

[0xa07c...71Cf](https://etherscan.io/address/0xa07cD154340CC74EcF156FFB9fb378Ee29Ca71Cf)

[0xdB2c...C165](https://sepolia.etherscan.io/address/0xdB2c541e20Bd1830c8a050341Fca0Af51489C165)

OneStepProofEntry

[0x4397...42d6](https://etherscan.io/address/0x4397fE1E959Ba81B9D5f1A9679Ddd891955A42d6)

[0x4397...42d6](https://etherscan.io/address/0x4397fE1E959Ba81B9D5f1A9679Ddd891955A42d6)

[0xB9cf...AE80](https://sepolia.etherscan.io/address/0xB9cf664A1beD8F74f4B893a18c86eCe876CdAE80)

Token bridge smart contracts[​](#token-bridge-smart-contracts "Direct link to Token bridge smart contracts")
------------------------------------------------------------------------------------------------------------

### Core contracts[​](#core-contracts-1 "Direct link to Core contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

L1 Gateway Router

[0x72Ce...31ef](https://etherscan.io/address/0x72Ce9c846789fdB6fC1f34aC4AD25Dd9ef7031ef)

[0xC840...cD48](https://etherscan.io/address/0xC840838Bc438d73C16c2f8b22D2Ce3669963cD48)

[0xcE18...8264](https://sepolia.etherscan.io/address/0xcE18836b233C83325Cc8848CA4487e94C6288264)

L1 ERC20 Gateway

[0xa3A7...0EeC](https://etherscan.io/address/0xa3A7B6F88361F48403514059F1F16C8E78d60EeC)

[0xB253...21bf](https://etherscan.io/address/0xB2535b988dcE19f9D71dfB22dB6da744aCac21bf)

[0x902b...3aFF](https://sepolia.etherscan.io/address/0x902b3E5f8F19571859F4AB1003B960a5dF693aFF)

L1 Arb-Custom Gateway

[0xcEe2...180d](https://etherscan.io/address/0xcEe284F754E854890e311e3280b767F80797180d)

[0x2312...232f](https://etherscan.io/address/0x23122da8C581AA7E0d07A36Ff1f16F799650232f)

[0xba2F...40F3](https://sepolia.etherscan.io/address/0xba2F7B6eAe1F9d174199C5E4867b563E0eaC40F3)

L1 Weth Gateway

[0xd920...e2db](https://etherscan.io/address/0xd92023E9d9911199a6711321D1277285e6d4e2db)

[0xE4E2...0BaE](https://etherscan.io/address/0xE4E2121b479017955Be0b175305B35f312330BaE)

[0xA8aD...0e1E](https://sepolia.etherscan.io/address/0xA8aD8d7e13cbf556eE75CB0324c13535d8100e1E)

L1 Weth

[0xC02a...6Cc2](https://etherscan.io/address/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)

[0xC02a...6Cc2](https://etherscan.io/address/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)

[0x7b79...E7f9](https://sepolia.etherscan.io/address/0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9)

L1 Proxy Admin

[0x9aD4...0aDa](https://etherscan.io/address/0x9aD46fac0Cf7f790E5be05A0F15223935A0c0aDa)

[0xa8f7...e560](https://etherscan.io/address/0xa8f7DdEd54a726eB873E98bFF2C95ABF2d03e560)

[0xDBFC...44b0](https://sepolia.etherscan.io/address/0xDBFC2FfB44A5D841aB42b0882711ed6e5A9244b0)

The following contracts are deployed on the corresponding L2 chain

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

L2 Gateway Router

[0x5288...F933](https://arbiscan.io/address/0x5288c571Fd7aD117beA99bF60FE0846C4E84F933)

[0x2190...DFa8](https://nova.arbiscan.io/address/0x21903d3F8176b1a0c17E953Cd896610Be9fFDFa8)

[0x9fDD...43C7](https://sepolia.arbiscan.io/address/0x9fDD1C4E4AA24EEc1d913FABea925594a20d43C7)

L2 ERC20 Gateway

[0x09e9...1EEe](https://arbiscan.io/address/0x09e9222E96E7B4AE2a407B98d48e330053351EEe)

[0xcF9b...9257](https://nova.arbiscan.io/address/0xcF9bAb7e53DDe48A6DC4f286CB14e05298799257)

[0x6e24...b502](https://sepolia.arbiscan.io/address/0x6e244cD02BBB8a6dbd7F626f05B2ef82151Ab502)

L2 Arb-Custom Gateway

[0x0967...5562](https://arbiscan.io/address/0x096760F208390250649E3e8763348E783AEF5562)

[0xbf54...51F4](https://nova.arbiscan.io/address/0xbf544970E6BD77b21C6492C281AB60d0770451F4)

[0x8Ca1...42C5](https://sepolia.arbiscan.io/address/0x8Ca1e1AC0f260BC4dA7Dd60aCA6CA66208E642C5)

L2 Weth Gateway

[0x6c41...623B](https://arbiscan.io/address/0x6c411aD3E74De3E7Bd422b94A27770f5B86C623B)

[0x7626...D9eD](https://nova.arbiscan.io/address/0x7626841cB6113412F9c88D3ADC720C9FAC88D9eD)

[0xCFB1...556D](https://sepolia.arbiscan.io/address/0xCFB1f08A4852699a979909e22c30263ca249556D)

L2 Weth

[0x82aF...Bab1](https://arbiscan.io/address/0x82aF49447D8a07e3bd95BD0d56f35241523fBab1)

[0x722E...5365](https://nova.arbiscan.io/address/0x722E8BdD2ce80A4422E880164f2079488e115365)

[0x980B...7c73](https://sepolia.arbiscan.io/address/0x980B62Da83eFf3D4576C647993b0c1D7faf17c73)

L2 Proxy Admin

[0xd570...2a86](https://arbiscan.io/address/0xd570aCE65C43af47101fC6250FD6fC63D1c22a86)

[0xada7...d92C](https://nova.arbiscan.io/address/0xada790b026097BfB36a5ed696859b97a96CEd92C)

[0x715D...5FdF](https://sepolia.arbiscan.io/address/0x715D99480b77A8d9D603638e593a539E21345FdF)

### Third party gateways[​](#third-party-gateways "Direct link to Third party gateways")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

L1 Dai Gateway

[0xD3B5...3011](https://etherscan.io/address/0xD3B5b60020504bc3489D6949d545893982BA3011)

L1 Livepeer Gateway

[0x6142...0676](https://etherscan.io/address/0x6142f1C8bBF02E6A6bd074E8d564c9A5420a0676)

The following contracts are deployed on the corresponding L2 chain

Arbitrum One

L2 Dai Gateway

[0x4671...6C65](https://arbiscan.io/address/0x467194771dAe2967Aef3ECbEDD3Bf9a310C76C65)

L2 Livepeer Gateway

[0x6D24...D318](https://arbiscan.io/address/0x6D2457a4ad276000A615295f7A80F79E48CcD318)

Precompiles[​](#precompiles "Direct link to Precompiles")
---------------------------------------------------------

The following precompiles are deployed on every L2 chain and always have the same address

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

ArbAddressTable

[0x0000...0066](https://arbiscan.io/address/0x0000000000000000000000000000000000000066)

[0x0000...0066](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000066)

[0x0000...0066](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000066)

ArbAggregator

[0x0000...006D](https://arbiscan.io/address/0x000000000000000000000000000000000000006D)

[0x0000...006D](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006D)

[0x0000...006D](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006D)

ArbFunctionTable

[0x0000...0068](https://arbiscan.io/address/0x0000000000000000000000000000000000000068)

[0x0000...0068](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000068)

[0x0000...0068](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000068)

ArbGasInfo

[0x0000...006C](https://arbiscan.io/address/0x000000000000000000000000000000000000006C)

[0x0000...006C](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006C)

[0x0000...006C](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006C)

ArbInfo

[0x0000...0065](https://arbiscan.io/address/0x0000000000000000000000000000000000000065)

[0x0000...0065](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000065)

[0x0000...0065](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000065)

ArbOwner

[0x0000...0070](https://arbiscan.io/address/0x0000000000000000000000000000000000000070)

[0x0000...0070](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000070)

[0x0000...0070](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000070)

ArbOwnerPublic

[0x0000...006b](https://arbiscan.io/address/0x000000000000000000000000000000000000006b)

[0x0000...006b](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006b)

[0x0000...006b](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006b)

ArbRetryableTx

[0x0000...006E](https://arbiscan.io/address/0x000000000000000000000000000000000000006E)

[0x0000...006E](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006E)

[0x0000...006E](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006E)

ArbStatistics

[0x0000...006F](https://arbiscan.io/address/0x000000000000000000000000000000000000006F)

[0x0000...006F](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006F)

[0x0000...006F](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006F)

ArbSys

[0x0000...0064](https://arbiscan.io/address/0x0000000000000000000000000000000000000064)

[0x0000...0064](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000064)

[0x0000...0064](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000064)

ArbWasm

[0x0000...0071](https://arbiscan.io/address/0x0000000000000000000000000000000000000071)

[0x0000...0071](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000071)

[0x0000...0071](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000071)

ArbWasmCache

[0x0000...0072](https://arbiscan.io/address/0x0000000000000000000000000000000000000072)

[0x0000...0072](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000072)

[0x0000...0072](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000072)

NodeInterface

[0x0000...00C8](https://arbiscan.io/address/0x00000000000000000000000000000000000000C8)

[0x0000...00C8](https://nova.arbiscan.io/address/0x00000000000000000000000000000000000000C8)

[0x0000...00C8](https://sepolia.arbiscan.io/address/0x00000000000000000000000000000000000000C8)

Misc[​](#misc "Direct link to Misc")
------------------------------------

The following contracts are deployed on the corresponding L2 chain

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

L2 Multicall

[0x842e...4EB2](https://arbiscan.io/address/0x842eC2c7D803033Edf55E478F461FC547Bc54EB2)

[0x5e1e...cB86](https://nova.arbiscan.io/address/0x5e1eE626420A354BbC9a95FeA1BAd4492e3bcB86)

[0xA115...d092](https://sepolia.arbiscan.io/address/0xA115146782b7143fAdB3065D86eACB54c169d092)

;

---

# Debugging tools | Arbitrum Docs

## Debugging tools

KNOW MORE TOOLS?

See something missing? Let us know on the [Arbitrum Discord](https://discord.gg/arbitrum) or by [opening an issue on GitHub](https://github.com/OffchainLabs/arbitrum-docs/issues/new).

The following tools will help you debug your decentralized apps (dApps):

### Tenderly[​](#tenderly "Direct link to Tenderly")

[Tenderly](https://tenderly.co/) is an all-in-one Web3 development platform that empowers developers to build, test, monitor, and operate smart contracts from inception to mass adoption. Tenderly's debugging options focus on providing developers with efficient and user-friendly tools to identify and fix smart contract bugs and production issues. The Debugger enables developers to inspect smart contracts by analyzing precise lines of code in a human-readable format. With Tenderly's Simulator, developers can play out specific historical transactions and current transaction outcomes before sending them on-chain, allowing them to change relevant parameters and source code to test and debug contracts. The platform streamlines the debugging process, saving time and resources while improving smart contract reliability.

Although Tenderly provides great debugging options, there are certain limitations when debugging parent-to-child chain messages (also known as Retryable Tickets), due to the utilization of custom Geth errors. For further information on this constraint, please refer to the following [resource](/for-devs/troubleshooting-building#i-tried-to-create-a-retryable-ticket-but-the-transaction-reverted-on-l1--how-can-i-debug-the-issue).

### Arbiscan[​](#arbiscan "Direct link to Arbiscan")

[Arbiscan](https://arbiscan.io/) is a prominent blockchain explorer and analytics platform that allows users to access and analyze public data on the Arbitrum network, such as transactions, wallet addresses, and smart contracts. Arbiscan offers VMTrace and Debug tools to aid developers and users in understanding the execution of transactions on the Ethereum network. VMTrace provides a step-by-step visualization of the EVM execution, enabling developers to trace transaction processing and identify potential issues. Debug tools offer additional information such as input data, logs, and events emitted by the smart contract during execution.

---

# Development frameworks | Arbitrum Docs

## Development frameworks

KNOW MORE TOOLS?

See something missing? Let us know on the [Arbitrum Discord](https://discord.gg/arbitrum) or by [opening an issue on GitHub](https://github.com/OffchainLabs/arbitrum-docs/issues/new).

The following tools will help you develop and test your decentralized apps (dApps):

Hardhat[​](#hardhat "Direct link to Hardhat")
---------------------------------------------

[Hardhat](https://hardhat.org/) is a comprehensive development environment designed specifically for Ethereum, Arbitrum and, in general, EVM developers. It streamlines the process of creating, compiling, deploying, testing, and debugging smart contracts. By providing a robust and customizable framework, Hardhat makes it easy to manage complex projects and integrate with other tools in the ecosystem. Its features include a built-in console, advanced debugging capabilities, and support for extending functionality through plugins, allowing developers to create efficient and secure decentralized applications.

Foundry[​](#foundry "Direct link to Foundry")
---------------------------------------------

[Foundry](https://github.com/foundry-rs/foundry) is a high-performance, portable, and modular toolkit designed for EVM application development, leveraging the Rust programming language. It offers a comprehensive suite of tools to streamline the process of creating, testing, and deploying smart contracts on the Ethereum, Arbitrum and, in general, any EVM network. Foundry facilitates seamless interaction with EVM smart contracts, transactions, and chain data, while also providing a local node and a user-friendly Solidity REPL environment for efficient development.

Truffle[​](#truffle "Direct link to Truffle")
---------------------------------------------

[Truffle](https://trufflesuite.com/) is a comprehensive suite of tools for smart contract development, providing an end-to-end solution for building, testing, debugging, and deploying on Ethereum, Arbitrum and other EVM compatible chains. It features advanced debugging capabilities, fast EVM simulation with Ganache, a user-centered design with a VS Code extension, and robust parent and child chain support. Truffle prioritizes security and partners with ConsenSys Diligence to bring continuous security to projects, providing a seamless and secure developer experience.

thirdweb[​](#thirdweb "Direct link to thirdweb")
------------------------------------------------

[thirdweb SDK](https://portal.thirdweb.com/sdk) covers all aspects of the web3 development stack, including connecting to user’s wallets, interacting with the blockchain and smart contracts, decentralized storage, authentication, and more; enabling you to build scalable and performant web3 applications on any EVM-compatible blockchain. Out of the box, infrastructure is provided for everything required to create decentralized applications, including connection to the blockchain (RPC), decentralized storage (IPFS + pinning services), and tools to create powerful user experiences; such as gasless transactions, wallet connection components, FIAT on-ramps, data APIs, and more.

Brownie[​](#brownie "Direct link to Brownie")
---------------------------------------------

[Brownie](https://github.com/eth-brownie/brownie) is a Python-based framework designed for developing and testing smart contracts on the Ethereum Virtual Machine. It offers full support for Solidity and Vyper programming languages and utilizes pytest for contract testing. Brownie also incorporates trace-based coverage evaluation, property-based and stateful testing with Hypothesis, and powerful debugging tools, including python-style tracebacks and custom error strings.

---

# Arbitrum: Understanding the risks | Arbitrum Docs

## Arbitrum: Understanding the risks

Arbitrum One — the first permissionless Ethereum parent chain rollup with full Ethereum smart contract functionality — is [live on mainnet](https://offchain.medium.com/mainnet-for-everyone-27ce0f67c85e) — as is [Nova](https://medium.com/offchainlabs/its-time-for-a-new-dawn-nova-is-open-to-the-public-a081df1e4ad2), our first [AnyTrust chain](/how-arbitrum-works/anytrust-protocol); We're sure you're (almost) as excited as we are! Here are some risks you should know about before using the system:

### State Of progressive decentralization[​](#state-of-progressive-decentralization "Direct link to State Of progressive decentralization")

The Arbitrum DAO system is the owner of both the Arbitrum One and Arbitrum AnyTrust chains; see [“State of Progressive Decentralization”](https://docs.arbitrum.foundation/state-of-progressive-decentralization) for more.

### General words of caution: Software bugs[​](#general-words-of-caution-software-bugs "Direct link to General words of caution: Software bugs")

Offchain Labs’ [implementation](https://github.com/OffchainLabs/nitro) of the Arbitrum protocol has been carefully constructed, is perpetually being audited by several independent firms, and is continuously reviewed and tested following best engineering practices. That said, there remains a non-zero chance that our codebase contains some undiscovered vulnerabilities that put user funds at risk. Users should carefully factor this risk into their decision to use Arbitrum One and/or Arbitrum Nova, and in deciding how much of their value to entrust into the system. Note that Offchain Labs also sponsors a [multi-million dollar bug bounty program](https://immunefi.com/bounty/arbitrum/) to incentivize any party who finds such a critical bug to disclose it responsibly.

### General words of caution: Scams[​](#general-words-of-caution-scams "Direct link to General words of caution: Scams")

Arbitrum, like Ethereum, is permissionless; on both platforms, anybody can deploy any smart contract code they want. Users should treat interacting with contracts on Arbitrum exactly as they do with Ethereum, i.e., they should only do so if they have good reason to trust that the application is secure.

---

# Monitoring tools and block explorers | Arbitrum Docs

## Monitoring tools and block explorers

KNOW MORE TOOLS?

See something missing? Let us know on the [Arbitrum Discord](https://discord.gg/arbitrum) or by [opening an issue on GitHub](https://github.com/OffchainLabs/arbitrum-docs/issues/new).

Here, we offer a compilation of tools and blockchain explorers that enable you to examine and oversee transactions, smart contracts, and overall blockchain activity related to decentralized applications (dApps) on different Arbitrum chains.

Tool

Use-cases

Relevant links

Arbiscan

Track/trace transactions and examine addresses on Arbitrum networks

*   Arbitrum One: [https://arbiscan.io/](https://arbiscan.io/)
*   Arbitrum Nova: [https://nova.arbiscan.io/](https://nova.arbiscan.io/)
*   Arbitrum Sepolia: [https://sepolia.arbiscan.io](https://sepolia.arbiscan.io)

Blockscout

Track/trace transactions and examine addresses on Arbitrum networks

*   Arbitrum One: [https://arbitrum.blockscout.com/](https://arbitrum.blockscout.com/)
*   Arbitrum Nova: [https://arbitrum-nova.blockscout.com/](https://arbitrum-nova.blockscout.com/)
*   Arbitrum Sepolia: [https://arbitrum-sepolia.blockscout.com/](https://arbitrum-sepolia.blockscout.com/)

Chainbase

Index, transform, and use on-chain data at scale

[Chainbase](https://chainbase.com/)

DexGuru

Track/trace transactions and examine addresses on Arbitrum networks

*   Arbitrum One: [https://arbitrum.dex.guru/](https://arbitrum.dex.guru/)
*   Arbitrum Nova: [https://nova.dex.guru/](https://nova.dex.guru/)

Dune

Visualize and analyze Arbitrum network data

*   [Dune](https://dune.com/)
*   [Arbitrum community-created Duune dashboard](https://dune.com/browse/dashboards?q=arbitrum)

OKLINK

Track/trace transactions and examine addresses on Arbitrum One network

*   Arbitrum One: [https://www.oklink.com/arbitrum](https://www.oklink.com/arbitrum)

---

# RPC endpoints and providers | Arbitrum Docs

## RPC endpoints and providers

Arbitrum public RPC endpoints[​](#arbitrum-public-rpc-endpoints "Direct link to Arbitrum public RPC endpoints")
---------------------------------------------------------------------------------------------------------------

caution

*   Unlike the RPC Urls, the Sequencer endpoints only support `eth_sendRawTransaction` and `eth_sendRawTransactionConditional` calls.
*   Arbitrum public RPCs do not provide Websocket support.
*   View the [faucets](https://docs.arbitrum.io/for-devs/dev-tools-and-resources/chain-info#faucets) for testnet Sepolia tokens on L2.

This section provides an overview of the available public RPC endpoints for different Arbitrum chains and necessary details to interact with them.

Name

RPC Url(s)

Chain ID

Block explorer

Underlying chain

Tech stack

Sequencer feed URL

Sequencer endpoint⚠️

Arbitrum One

[https://arb1.arbitrum.io/rpc](https://arb1.arbitrum.io/rpc)

42161

[Arbiscan](https://arbiscan.io/), [Blockscout](https://arbitrum.blockscout.com/)

Ethereum

Nitro (Rollup)

wss://arb1.arbitrum.io/feed

[https://arb1-sequencer.arbitrum.io/rpc](https://arb1-sequencer.arbitrum.io/rpc)

Arbitrum Nova

[https://nova.arbitrum.io/rpc](https://nova.arbitrum.io/rpc)

42170

[Arbiscan](https://nova.arbiscan.io/), [Blockscout](https://arbitrum-nova.blockscout.com/)

Ethereum

Nitro (AnyTrust)

wss://nova.arbitrum.io/feed

[https://nova-sequencer.arbitrum.io/rpc](https://nova-sequencer.arbitrum.io/rpc)

Arbitrum Sepolia (Testnet)

[https://sepolia-rollup.arbitrum.io/rpc](https://sepolia-rollup.arbitrum.io/rpc)

421614

[Arbiscan](https://sepolia.arbiscan.io/), [Blockscout](https://arbitrum-sepolia.blockscout.com/)

Sepolia

Nitro (Rollup)

wss://sepolia-rollup.arbitrum.io/feed

[https://sepolia-rollup-sequencer.arbitrum.io/rpc](https://sepolia-rollup-sequencer.arbitrum.io/rpc)

More RPC endpoints

More Arbitrum chain RPC endpoints can be found in Chain Connect: [Arbitrum One](https://www.alchemy.com/chain-connect/chain/arbitrum-one) and [Arbitrum Nova](https://www.alchemy.com/chain-connect/chain/arbitrum-nova).

Alternatively, to interact with public Arbitrum chains, you can rely on many of the same popular node providers that you are already using on Ethereum:

Third-party RPC providers[​](#third-party-rpc-providers "Direct link to Third-party RPC providers")
---------------------------------------------------------------------------------------------------

WANT TO BE LISTED HERE?

Complete [this form](https://docs.google.com/forms/d/e/1FAIpQLSc_v8j7sc4ffE6U-lJJyLMdBoIubf7OIhGtCqvK3cGPGoLr7w/viewform) , if you'd like to see your project added to this list (and the [Arbitrum portal](https://portal.arbitrum.one/)).

Provider

Arb One?

Arb Nova?

Arb Sepolia?

Websocket?

Stylus Tracing?

[1RPC](https://docs.1rpc.io/overview/supported-networks#arbitrum)

✅

[Alchemy](https://docs.alchemy.com/reference/arbitrum-api-quickstart)

✅

✅

✅

✅

Available on paid plans

[Allnodes](https://arbitrum.publicnode.com)

✅

✅

✅

[Ankr](https://www.ankr.com/docs/rpc-service/chains/chains-list/#arbitrum)

✅

✅

Available on paid plans

[Blast](https://blastapi.io/public-api/arbitrum)

✅

✅

✅

[BlockPi](https://docs.blockpi.io/documentations/api-reference/arbitrum)

✅

✅

[BlockVision](https://dashboard.blockvision.org/connect)

✅

[Chainbase](https://docs.chainbase.com/docs/chain-api-overview#arbitrum-one)

✅

✅

[Chainnodes](https://www.chainnodes.org/chains/arbitrum)

✅

[Chainstack](https://chainstack.com/build-better-with-arbitrum/)

✅

✅

Available on paid plans

[DataHub](https://datahub.figment.io/)

✅

[DRPC](https://drpc.org/public-endpoints/arbitrum)

✅

✅

✅

[GetBlock](https://getblock.io/nodes/arb/)

✅

✅

[Infura](https://docs.infura.io/infura/networks/arbitrum)

✅

✅

✅

Enabled on request

[Lava](https://docs.lavanet.xyz/gateway-access)

✅

✅

[Moralis](https://docs.moralis.io/reference/introduction)

✅

[Nirvana Labs](https://nirvanalabs.io)

✅

✅

✅

✅

[NodeReal](https://nodereal.io/meganode/api-marketplace/arbitrum-nitro-rpc)

✅

✅

[NOWNodes](https://nownodes.io/nodes/arbitrum-arb)

✅

[Pocket Network](https://docs.pokt.network/welcome-to-pokt-network/supported-chains)

✅

[Quicknode](https://www.quicknode.com/chains/arb)

✅

✅

✅

✅

Testnet supported in free tier

[Unifra](https://unifra.io/)

✅

[Tenderly](https://tenderly.co/)

✅

✅

✅

✅

Testnet supported in free tier

---

# Web3 libraries and tools | Arbitrum Docs

## Web3 libraries and tools

KNOW MORE TOOLS?

See something missing? Let us know on the [Arbitrum Discord](https://discord.gg/arbitrum) or by [opening an issue on GitHub](https://github.com/OffchainLabs/arbitrum-docs/issues/new).

The following frameworks will help you build your decentralized apps:

Name

Language

Description

Documentation

Ethers.js

TypeScript

Ethers.js is a lightweight library for Ethereum and EVM-compatible blockchains. It offers secure key management, node compatibility, ENS integration and supports JSON wallets, mnemonic phrases, and HD wallets. The library is TypeScript-ready and well-documented under the MIT License.

[Ethers.js Documentation](https://docs.ethers.org/)

alloy

Rust

Alloy is a collection of utilities and crates for Ethereum development in Rust. It helps create and manage Rust prototypes that support Ethereum-like smart contract execution. Alloy focuses on interoperability and cross-chain communication..

[alloy Documentation](https://alloy.rs/)

thirdweb SDK

TypeScript

thirdweb SDK offers a comprehensive suite for web3 development on EVM-compatible blockchains. It includes wallet connectivity, blockchain interaction, decentralized storage, and authentication. Gasless transactions, wallet components, FIAT on-ramps, and data APIs are key features.

[thirdweb SDK Portal](https://portal.thirdweb.com/sdk)

Viem

TypeScript

Viem is a modular tool for Ethereum and EVM-compatible blockchain development. It provides performance-optimized APIs, JSON-RPC API abstractions, and smart contract interaction tools, and it supports environments like Anvil, Hardhat, and Ganache.

[Viem](https://viem.sh/)

Web3.js

JavaScript

Web3.js is a JavaScript library for Ethereum and EVM-compatible node interaction. It enables transactions via HTTP, IPC, or WebSocket. Compatible with web browsers, Node.js, and Electron, it's commonly used with MetaMask.

[Web3.js GitHub](https://github.com/web3/web3.js/)

Web3.py

Python

Web3.py is a Python library for interacting with Ethereum and EVM-compatible blockchains. It facilitates transactions, smart contract operations, and blockchain data access. Tailored for Python developers, it's a versatile tool for Ethereum-based applications.

[Web3.py GitHub](https://github.com/ethereum/web3.py/)

---

# Get started with token bridging | Arbitrum Docs

## Get started with token bridging

Token bridging is a fundamental aspect of any Layer 2 (L2) protocol. It allows projects to quickly integrate with the Arbitrum ecosystem by leveraging their existing Layer 1 (L1) tokens.

This section offers a series of how-tos showcasing the different methods available for making your token bridgeable.

You have three options to consider when deciding on how to bridge your token:

1.  [Standard gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-standard): opt for this method if you want to have an standard ERC-20 token automatically deployed on Arbitrum, which will act as the L2 counterpart to your L1 token. For additional information, please refer to [this section on the standard ERC-20 gateway in the conceptual page](/build-decentralized-apps/token-bridging/token-bridge-erc20#default-standard-bridging).
2.  [Generic-custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-generic-custom): choose this method if you require custom functionality for your ERC20 token on Arbitrum. You will deploy your counterpart token on Arbitrum equipped with the unique features you wish to implement. For additional information, please refer to [this section on the Arbitrum generic custom gateway in the conceptual page](/build-decentralized-apps/token-bridging/token-bridge-erc20#the-arbitrum-generic-custom-gateway).
3.  [Custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-custom-gateway): this method is intended for edge cases where a custom ERC20 token is insufficient and you need an additional layer of flexibility with the gateway (for example, your token has the capacity to increase its supply on L2, and you want those L2-minted tokens to be withdrawable back to L1 and recognized by the L1 contract). For additional information, please refer to [this section on other types of gateways in the conceptual page](/build-decentralized-apps/token-bridging/token-bridge-erc20#other-flavors-of-gateways).

What if I just want to bridge a token programmatically?[​](#what-if-i-just-want-to-bridge-a-token-programmatically "Direct link to What if I just want to bridge a token programmatically?")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Section [How to bridge tokens via Arbitrum’s standard gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-standard) provides an example of how to deposit your tokens (from L1 to L2) programmatically, specifically in steps 2 to 5.

You can also find scripts demonstrating [L1-to-L2 bridging (deposits)](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/token-deposit) and [L2-to-L1 bridging (withdrawals)](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/token-withdraw) using the Arbitrum SDK.

---

# How to bridge tokens via a custom gateway | Arbitrum Docs

## How to bridge tokens via a custom gateway

Do you really need a custom gateway?

Before starting to implement and deploy a custom gateway, it is strongly encouraged to analyze the current solutions that Arbitrum’s token bridge provides: the [standard gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-standard) and the [generic-custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-generic-custom). These solutions provide enough functionality to solve the majority of bridging needs from projects. And if you are in doubt about your current approach, you can always ask for assistance on our [Discord server](https://discord.gg/arbitrum).

In this how-to you’ll learn how to bridge your own token between Ethereum (Layer 1 or L1) and Arbitrum (Layer 2 or L2), using a custom gateway. For alternative ways of bridging tokens, don’t forget to check out this [overview](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/get-started).

Familiarity with [Arbitrum’s token bridge system](/build-decentralized-apps/token-bridging/overview), smart contracts, and blockchain development is expected. If you’re new to blockchain development, consider reviewing our [Quickstart: Build a dApp with Arbitrum (Solidity, Hardhat)](/build-decentralized-apps/quickstart-solidity-remix) before proceeding. We will use [Arbitrum’s SDK](https://github.com/OffchainLabs/arbitrum-sdk) throughout this how-to, although no prior knowledge is required.

We will go through all steps involved in the process. However, if you want to jump straight to the code, we have created [this script in our tutorials repository](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/custom-gateway-bridging) that encapsulates the entire process.

Step 0: Review the prerequisites (a.k.a. do I really need a custom gateway?)[​](#step-0-review-the-prerequisites-aka-do-i-really-need-a-custom-gateway "Direct link to Step 0: Review the prerequisites (a.k.a. do I really need a custom gateway?)")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Before starting to implement and deploy a custom gateway, it is strongly encouraged to analyze the current solutions that Arbitrum’s token bridge provides: the [standard gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-standard) and the [generic-custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-generic-custom). These solutions provide enough functionality to solve the majority of bridging needs from projects. And if you are in doubt about your current approach, you can always ask for assistance on our [Discord server](https://discord.gg/arbitrum).

Having said that, there are multiple prerequisites to keep in mind when deploying your own custom gateway.

First of all, the **L1 counterpart of the gateway**, must conform to the [IL1ArbitrumGateway](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/IL1ArbitrumGateway.sol) and the [ITokenGateway](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/libraries/gateway/ITokenGateway.sol) interfaces. This means that it must have, at least:

*   A method `outboundTransferCustomRefund`, to handle forwarded calls from `L1GatewayRouter.outboundTransferCustomRefund`. It should only allow calls from the router.
*   A method `outboundTransfer`, to handle forwarded calls from `L1GatewayRouter.outboundTransfer`. It should only allow calls from the router.
*   A method `finalizeInboundTransfer`, to handle messages coming ONLY from L2’s gateway.
*   Two methods `calculateL2TokenAddress` and `getOutboundCalldata` to handle other bridging operations.
*   Methods to send cross-chain messages through the [inbox contract](https://github.com/OffchainLabs/nitro-contracts/blob/main/src/bridge/Inbox.sol). An example implementation can be found in `sendTxToL2` and `sendTxToL2CustomRefund` on [L1ArbitrumMessenger](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/L1ArbitrumMessenger.sol).

Furthermore, if you plan on having permissionless registration of tokens in your gateway, your L1 gateway should also have a `registerCustomL2Token` method, similar to the one being used in Arbitrum’s [generic-custom gateway](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1CustomGateway.sol#L146).

On the other hand, the **L2 counterpart of the gateway**, must conform to the [ITokenGateway](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/libraries/gateway/ITokenGateway.sol) interface. This means that it must have, at least:

*   A method `outboundTransfer`, to handle external calls, and forwarded calls from `L2GatewayRouter.outboundTransfer`.
*   A method `finalizeInboundTransfer`, to handle messages coming ONLY from L1’s gateway.
*   Two methods `calculateL2TokenAddress` and `getOutboundCalldata` to handle other bridging operations.
*   Methods to send cross-chain messages through the [ArbSys precompile](/build-decentralized-apps/precompiles/reference#arbsys). An example implementation can be found in `sendTxToL1` on [L2ArbitrumMessenger](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/arbitrum/L2ArbitrumMessenger.sol).

### What about my custom tokens?[​](#what-about-my-custom-tokens "Direct link to What about my custom tokens?")

If you are deploying custom gateways, you will probably want to support your custom tokens on L1 and L2 too. They also have several requirements they must comply with. You can find more information about it in [How to bridge tokens via Arbitrum’s generic-custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-generic-custom).

Step 1: Create a gateway and deploy it on L1[​](#step-1-create-a-gateway-and-deploy-it-on-l1 "Direct link to Step 1: Create a gateway and deploy it on L1")
-----------------------------------------------------------------------------------------------------------------------------------------------------------

This code is for testing purposes

The code contained within the following sections is meant for testing purposes only and does not guarantee any level of security. It has not undergone any formal audit or security analysis, so it is not ready for production use. Please exercise caution and due diligence while using this code in any environment.

We‘ll begin the process by creating our custom gateway and deploying it on L1. A good example of a custom gateway is [Arbitrum’s generic-custom gateway](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1CustomGateway.sol). It includes all methods required plus some more to support the wide variety of tokens that can be bridged through it.

In this case, we’ll use a simpler approach. We’ll create a gateway that supports only one token and has the ability to be disabled/enabled by the owner of the contract. It will also implement all necessary methods. To simplify the deployment process even further, we won’t worry about setting the addresses of the counterpart gateway and the custom tokens at deployment time. Instead, we will use a function `setTokenBridgeInformation` that will be called by the owner of the contract to initialize the gateway.

```rust
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import "./interfaces/ICustomGateway.sol";
import "./CrosschainMessenger.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title Example implementation of a custom gateway to be deployed on L1
 * @dev Inheritance of Ownable is optional. In this case we use it to call the function setTokenBridgeInformation
 * and simplify the test
 */
contract L1CustomGateway is IL1CustomGateway, L1CrosschainMessenger, Ownable {

    // Token bridge state variables
    address public l1CustomToken;
    address public l2CustomToken;
    address public l2Gateway;
    address public router;

    // Custom functionality
    bool public allowsDeposits;

    /**
     * Contract constructor, sets the L1 router to be used in the contract's functions and calls L1CrosschainMessenger's constructor
     * @param router_ L1GatewayRouter address
     * @param inbox_ Inbox address
     */
    constructor(
        address router_,
        address inbox_
    ) L1CrosschainMessenger(inbox_) {
        router = router_;
        allowsDeposits = false;
    }

    /**
     * Sets the information needed to use the gateway. To simplify the process of testing, this function can be called once
     * by the owner of the contract to set these addresses.
     * @param l1CustomToken_ address of the custom token on L1
     * @param l2CustomToken_ address of the custom token on L2
     * @param l2Gateway_ address of the counterpart gateway (on L2)
     */
    function setTokenBridgeInformation(
        address l1CustomToken_,
        address l2CustomToken_,
        address l2Gateway_
    ) public onlyOwner {
        require(l1CustomToken == address(0), "Token bridge information already set");
        l1CustomToken = l1CustomToken_;
        l2CustomToken = l2CustomToken_;
        l2Gateway = l2Gateway_;

        // Allows deposits after the information has been set
        allowsDeposits = true;
    }

    /// @dev See {ICustomGateway-outboundTransfer}
    function outboundTransfer(
        address l1Token,
        address to,
        uint256 amount,
        uint256 maxGas,
        uint256 gasPriceBid,
        bytes calldata data
    ) public payable override returns (bytes memory) {
        return outboundTransferCustomRefund(l1Token, to, to, amount, maxGas, gasPriceBid, data);
    }

    /// @dev See {IL1CustomGateway-outboundTransferCustomRefund}
    function outboundTransferCustomRefund(
        address l1Token,
        address refundTo,
        address to,
        uint256 amount,
        uint256 maxGas,
        uint256 gasPriceBid,
        bytes calldata data
    ) public payable override returns (bytes memory res) {
        // Only execute if deposits are allowed
        require(allowsDeposits == true, "Deposits are currently disabled");

        // Only allow calls from the router
        require(msg.sender == router, "Call not received from router");

        // Only allow the custom token to be bridged through this gateway
        require(l1Token == l1CustomToken, "Token is not allowed through this gateway");

        address from;
        uint256 seqNum;
        {
            bytes memory extraData;
            uint256 maxSubmissionCost;
            (from, maxSubmissionCost, extraData) = _parseOutboundData(data);

            // The inboundEscrowAndCall functionality has been disabled, so no data is allowed
            require(extraData.length == 0, "EXTRA_DATA_DISABLED");

            // Escrowing the tokens in the gateway
            IERC20(l1Token).transferFrom(from, address(this), amount);

            // We override the res field to save on the stack
            res = getOutboundCalldata(l1Token, from, to, amount, extraData);

            // Trigger the crosschain message
            seqNum = _sendTxToL2CustomRefund(
                l2Gateway,
                refundTo,
                from,
                msg.value,
                0,
                maxSubmissionCost,
                maxGas,
                gasPriceBid,
                res
            );
        }

        emit DepositInitiated(l1Token, from, to, seqNum, amount);
        res = abi.encode(seqNum);
    }

    /// @dev See {ICustomGateway-finalizeInboundTransfer}
    function finalizeInboundTransfer(
        address l1Token,
        address from,
        address to,
        uint256 amount,
        bytes calldata data
    ) public payable override onlyCounterpartGateway(l2Gateway) {
        // Only allow the custom token to be bridged through this gateway
        require(l1Token == l1CustomToken, "Token is not allowed through this gateway");

        // Decoding exitNum
        (uint256 exitNum, ) = abi.decode(data, (uint256, bytes));

        // Releasing the tokens in the gateway
        IERC20(l1Token).transfer(to, amount);

        emit WithdrawalFinalized(l1Token, from, to, exitNum, amount);
    }

    /// @dev See {ICustomGateway-getOutboundCalldata}
    function getOutboundCalldata(
        address l1Token,
        address from,
        address to,
        uint256 amount,
        bytes memory data
    ) public pure override returns (bytes memory outboundCalldata) {
        bytes memory emptyBytes = "";

        outboundCalldata = abi.encodeWithSelector(
            ICustomGateway.finalizeInboundTransfer.selector,
            l1Token,
            from,
            to,
            amount,
            abi.encode(emptyBytes, data)
        );

        return outboundCalldata;
    }

    /// @dev See {ICustomGateway-calculateL2TokenAddress}
    function calculateL2TokenAddress(address l1Token) public view override returns (address) {
        if (l1Token == l1CustomToken) {
            return l2CustomToken;
        }

        return address(0);
    }

    /// @dev See {ICustomGateway-counterpartGateway}
    function counterpartGateway() public view override returns (address) {
        return l2Gateway;
    }

    /**
     * Parse data received in outboundTransfer
     * @param data encoded data received
     * @return from account that initiated the deposit,
     *         maxSubmissionCost max gas deducted from user's L2 balance to cover base submission fee,
     *         extraData decoded data
     */
    function _parseOutboundData(bytes memory data)
    internal
    pure
    returns (
        address from,
        uint256 maxSubmissionCost,
        bytes memory extraData
    )
    {
        // Router encoded
        (from, extraData) = abi.decode(data, (address, bytes));

        // User encoded
        (maxSubmissionCost, extraData) = abi.decode(extraData, (uint256, bytes));
    }

    // --------------------
    // Custom methods
    // --------------------
    /**
     * Disables the ability to deposit funds
     */
    function disableDeposits() external onlyOwner {
        allowsDeposits = false;
    }

    /**
     * Enables the ability to deposit funds
     */
    function enableDeposits() external onlyOwner {
        require(l1CustomToken != address(0), "Token bridge information has not been set yet");
        allowsDeposits = true;
    }
}
```

`IL1CustomGateway` is an interface very similar to `ICustomGateway`, and `L1CrosschainMessenger` implements a method to send the cross-chain message to L2 through the Inbox.

```rust
/**
 * @title Minimum expected implementation of a crosschain messenger contract to be deployed on L1
 */
abstract contract L1CrosschainMessenger {
    IInbox public immutable inbox;

    /**
     * Emitted when calling sendTxToL2CustomRefund
     * @param from account that submitted the retryable ticket
     * @param to account recipient of the retryable ticket
     * @param seqNum id for the retryable ticket
     * @param data data of the retryable ticket
     */
    event TxToL2(
        address indexed from,
        address indexed to,
        uint256 indexed seqNum,
        bytes data
    );

    constructor(address inbox_) {
        inbox = IInbox(inbox_);
    }

    modifier onlyCounterpartGateway(address l2Counterpart) {
        // A message coming from the counterpart gateway was executed by the bridge
        IBridge bridge = inbox.bridge();
        require(msg.sender == address(bridge), "NOT_FROM_BRIDGE");

        // And the outbox reports that the L2 address of the sender is the counterpart gateway
        address l2ToL1Sender = IOutbox(bridge.activeOutbox()).l2ToL1Sender();
        require(l2ToL1Sender == l2Counterpart, "ONLY_COUNTERPART_GATEWAY");

        _;
    }

    /**
     * Creates the retryable ticket to send over to L2 through the Inbox
     * @param to account to be credited with the tokens in the destination layer
     * @param refundTo account, or its L2 alias if it have code in L1, to be credited with excess gas refund in L2
     * @param user account with rights to cancel the retryable and receive call value refund
     * @param l1CallValue callvalue sent in the L1 submission transaction
     * @param l2CallValue callvalue for the L2 message
     * @param maxSubmissionCost max gas deducted from user's L2 balance to cover base submission fee
     * @param maxGas max gas deducted from user's L2 balance to cover L2 execution
     * @param gasPriceBid gas price for L2 execution
     * @param data encoded data for the retryable
     * @return seqnum id for the retryable ticket
     */
    function _sendTxToL2CustomRefund(
        address to,
        address refundTo,
        address user,
        uint256 l1CallValue,
        uint256 l2CallValue,
        uint256 maxSubmissionCost,
        uint256 maxGas,
        uint256 gasPriceBid,
        bytes memory data
    ) internal returns (uint256) {
        uint256 seqNum = inbox.createRetryableTicket{ value: l1CallValue }(
            to,
            l2CallValue,
            maxSubmissionCost,
            refundTo,
            user,
            maxGas,
            gasPriceBid,
            data
        );

        emit TxToL2(user, to, seqNum, data);
        return seqNum;
    }
}
```

We now deploy that gateway to L1.

```rust
const { ethers } = require('hardhat');
const { providers, Wallet, BigNumber } = require('ethers');
const { getArbitrumNetwork, ParentToChildMessageStatus } = require('@arbitrum/sdk');
const {
  AdminErc20Bridger,
  Erc20Bridger,
} = require('@arbitrum/sdk/dist/lib/assetBridger/erc20Bridger');
require('dotenv').config();

/**
 * Set up: instantiate L1 / L2 wallets connected to providers
 */
const walletPrivateKey = process.env.DEVNET_PRIVKEY;
const l1Provider = new providers.JsonRpcProvider(process.env.L1RPC);
const l2Provider = new providers.JsonRpcProvider(process.env.L2RPC);
const l1Wallet = new Wallet(walletPrivateKey, l1Provider);
const l2Wallet = new Wallet(walletPrivateKey, l2Provider);

const main = async () => {
  /**
   * Use l2Network to create an Arbitrum SDK AdminErc20Bridger instance
   * We'll use AdminErc20Bridger for its convenience methods around registering tokens to a custom gateway
   */
  const l2Network = await getArbitrumNetwork(l2Provider);
  const erc20Bridger = new Erc20Bridger(l2Network);
  const adminTokenBridger = new AdminErc20Bridger(l2Network);
  const l1Router = l2Network.tokenBridge.parentGatewayRouter;
  const l2Router = l2Network.tokenBridge.childGatewayRouter;
  const inbox = l2Network.ethBridge.inbox;

  /**
   * Deploy our custom gateway to L1
   */
  const L1CustomGateway = await await ethers.getContractFactory('L1CustomGateway', l1Wallet);
  console.log('Deploying custom gateway to L1');
  const l1CustomGateway = await L1CustomGateway.deploy(l1Router, inbox);
  await l1CustomGateway.deployed();
  console.log(`Custom gateway is deployed to L1 at ${l1CustomGateway.address}`);
  const l1CustomGatewayAddress = l1CustomGateway.address;
};

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

Step 2: Create a gateway and deploy it on L2[​](#step-2-create-a-gateway-and-deploy-it-on-l2 "Direct link to Step 2: Create a gateway and deploy it on L2")
-----------------------------------------------------------------------------------------------------------------------------------------------------------

We’ll now create the counterpart of the gateway we created on L1 and deploy it on L2. A good example of a custom gateway on L2 is [Arbitrum’s generic-custom gateway on L2](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/arbitrum/gateway/L2CustomGateway.sol).

As we did with the L1 gateway, we’ll use a simpler approach with the same characteristics of that in L1: supports only one token and has the ability to be disabled/enabled by the owner of the contract. It will also have a `setTokenBridgeInformation` to be called by the owner of the contract to initialize the gateway.

```rust
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import "./interfaces/ICustomGateway.sol";
import "./CrosschainMessenger.sol";
import "./interfaces/IArbToken.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title Example implementation of a custom gateway to be deployed on L2
 * @dev Inheritance of Ownable is optional. In this case we use it to call the function setTokenBridgeInformation
 * and simplify the test
 */
contract L2CustomGateway is IL2CustomGateway, L2CrosschainMessenger, Ownable {
    // Exit number (used for tradeable exits)
    uint256 public exitNum;

    // Token bridge state variables
    address public l1CustomToken;
    address public l2CustomToken;
    address public l1Gateway;
    address public router;

    // Custom functionality
    bool public allowsWithdrawals;

    /**
     * Contract constructor, sets the L2 router to be used in the contract's functions
     * @param router_ L2GatewayRouter address
     */
    constructor(address router_) {
        router = router_;
        allowsWithdrawals = false;
    }

    /**
     * Sets the information needed to use the gateway. To simplify the process of testing, this function can be called once
     * by the owner of the contract to set these addresses.
     * @param l1CustomToken_ address of the custom token on L1
     * @param l2CustomToken_ address of the custom token on L2
     * @param l1Gateway_ address of the counterpart gateway (on L1)
     */
    function setTokenBridgeInformation(
        address l1CustomToken_,
        address l2CustomToken_,
        address l1Gateway_
    ) public onlyOwner {
        require(l1CustomToken == address(0), "Token bridge information already set");
        l1CustomToken = l1CustomToken_;
        l2CustomToken = l2CustomToken_;
        l1Gateway = l1Gateway_;

        // Allows withdrawals after the information has been set
        allowsWithdrawals = true;
    }

    /// @dev See {ICustomGateway-outboundTransfer}
    function outboundTransfer(
        address l1Token,
        address to,
        uint256 amount,
        bytes calldata data
    ) public payable returns (bytes memory) {
        return outboundTransfer(l1Token, to, amount, 0, 0, data);
    }

    /// @dev See {ICustomGateway-outboundTransfer}
    function outboundTransfer(
        address l1Token,
        address to,
        uint256 amount,
        uint256, /* _maxGas */
        uint256, /* _gasPriceBid */
        bytes calldata data
    ) public payable override returns (bytes memory res) {
        // Only execute if deposits are allowed
        require(allowsWithdrawals == true, "Withdrawals are currently disabled");

        // The function is marked as payable to conform to the inheritance setup
        // This particular code path shouldn't have a msg.value > 0
        require(msg.value == 0, "NO_VALUE");

        // Only allow the custom token to be bridged through this gateway
        require(l1Token == l1CustomToken, "Token is not allowed through this gateway");

        (address from, bytes memory extraData) = _parseOutboundData(data);

        // The inboundEscrowAndCall functionality has been disabled, so no data is allowed
        require(extraData.length == 0, "EXTRA_DATA_DISABLED");

        // Burns L2 tokens in order to release escrowed L1 tokens
        IArbToken(l2CustomToken).bridgeBurn(from, amount);

        // Current exit number for this operation
        uint256 currExitNum = exitNum++;

        // We override the res field to save on the stack
        res = getOutboundCalldata(l1Token, from, to, amount, extraData);

        // Trigger the crosschain message
        uint256 id = _sendTxToL1(
            from,
            l1Gateway,
            res
        );

        emit WithdrawalInitiated(l1Token, from, to, id, currExitNum, amount);
        return abi.encode(id);
    }

    /// @dev See {ICustomGateway-finalizeInboundTransfer}
    function finalizeInboundTransfer(
        address l1Token,
        address from,
        address to,
        uint256 amount,
        bytes calldata data
    ) public payable override onlyCounterpartGateway(l1Gateway) {
        // Only allow the custom token to be bridged through this gateway
        require(l1Token == l1CustomToken, "Token is not allowed through this gateway");

        // Abi decode may revert, but the encoding is done by L1 gateway, so we trust it
        (, bytes memory callHookData) = abi.decode(data, (bytes, bytes));
        if (callHookData.length != 0) {
            // callHookData should always be 0 since inboundEscrowAndCall is disabled
            callHookData = bytes("");
        }

        // Mints L2 tokens
        IArbToken(l2CustomToken).bridgeMint(to, amount);

        emit DepositFinalized(l1Token, from, to, amount);
    }

    /// @dev See {ICustomGateway-getOutboundCalldata}
    function getOutboundCalldata(
        address l1Token,
        address from,
        address to,
        uint256 amount,
        bytes memory data
    ) public view override returns (bytes memory outboundCalldata) {
        outboundCalldata = abi.encodeWithSelector(
            ICustomGateway.finalizeInboundTransfer.selector,
            l1Token,
            from,
            to,
            amount,
            abi.encode(exitNum, data)
        );

        return outboundCalldata;
    }

    /// @dev See {ICustomGateway-calculateL2TokenAddress}
    function calculateL2TokenAddress(address l1Token) public view override returns (address) {
        if (l1Token == l1CustomToken) {
            return l2CustomToken;
        }

        return address(0);
    }

    /// @dev See {ICustomGateway-counterpartGateway}
    function counterpartGateway() public view override returns (address) {
        return l1Gateway;
    }

    /**
     * Parse data received in outboundTransfer
     * @param data encoded data received
     * @return from account that initiated the deposit,
     *         extraData decoded data
     */
    function _parseOutboundData(bytes memory data)
    internal
    view
    returns (
        address from,
        bytes memory extraData
    )
    {
        if (msg.sender == router) {
            // Router encoded
            (from, extraData) = abi.decode(data, (address, bytes));
        } else {
            from = msg.sender;
            extraData = data;
        }
    }

    // --------------------
    // Custom methods
    // --------------------
    /**
     * Disables the ability to deposit funds
     */
    function disableWithdrawals() external onlyOwner {
        allowsWithdrawals = false;
    }

    /**
     * Enables the ability to deposit funds
     */
    function enableWithdrawals() external onlyOwner {
        require(l1CustomToken != address(0), "Token bridge information has not been set yet");
        allowsWithdrawals = true;
    }
}
```

`IL2CustomGateway` is also an interface very similar to `ICustomGateway`, and `L2CrosschainMessenger` implements a method to send the cross-chain message to L1 through ArbSys.

```rust
/**
 * @title Minimum expected implementation of a crosschain messenger contract to be deployed on L2
 */
abstract contract L2CrosschainMessenger {
    address internal constant ARB_SYS_ADDRESS = address(100);

    /**
     * Emitted when calling sendTxToL1
     * @param from account that submits the L2-to-L1 message
     * @param to account recipient of the L2-to-L1 message
     * @param id id for the L2-to-L1 message
     * @param data data of the L2-to-L1 message
     */
    event TxToL1(
        address indexed from,
        address indexed to,
        uint256 indexed id,
        bytes data
    );

    modifier onlyCounterpartGateway(address l1Counterpart) {
        require(
            msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),
            "ONLY_COUNTERPART_GATEWAY"
        );

        _;
    }

    /**
     * Creates an L2-to-L1 message to send over to L1 through ArbSys
     * @param from account that is sending funds from L2
     * @param to account to be credited with the tokens in the destination layer
     * @param data encoded data for the L2-to-L1 message
     * @return id id for the L2-to-L1 message
     */
    function _sendTxToL1(
        address from,
        address to,
        bytes memory data
    ) internal returns (uint256) {
        uint256 id = ArbSys(ARB_SYS_ADDRESS).sendTxToL1(to, data);

        emit TxToL1(from, to, id, data);
        return id;
    }
}
```

We now deploy that gateway to L2.

```rust
const { ethers } = require('hardhat');
const { providers, Wallet, BigNumber } = require('ethers');
const {
  getArbitrumNetwork,
  ParentToChildMessageStatus,
  AdminErc20Bridger,
  Erc20Bridger,
} = require('@arbitrum/sdk');
require('dotenv').config();

/**
 * Set up: instantiate L1 / L2 wallets connected to providers
 */
const walletPrivateKey = process.env.DEVNET_PRIVKEY;
const l1Provider = new providers.JsonRpcProvider(process.env.L1RPC);
const l2Provider = new providers.JsonRpcProvider(process.env.L2RPC);
const l1Wallet = new Wallet(walletPrivateKey, l1Provider);
const l2Wallet = new Wallet(walletPrivateKey, l2Provider);

const main = async () => {
  /**
   * Use l2Network to create an Arbitrum SDK AdminErc20Bridger instance
   * We'll use AdminErc20Bridger for its convenience methods around registering tokens to a custom gateway
   */
  const l2Network = await getArbitrumNetwork(l2Provider);
  const erc20Bridger = new Erc20Bridger(l2Network);
  const adminTokenBridger = new AdminErc20Bridger(l2Network);
  const l1Router = l2Network.tokenBridge.l1GatewayRouter;
  const l2Router = l2Network.tokenBridge.l2GatewayRouter;
  const inbox = l2Network.ethBridge.inbox;

  /**
   * Deploy our custom gateway to L2
   */
  const L2CustomGateway = await await ethers.getContractFactory('L2CustomGateway', l2Wallet);
  console.log('Deploying custom gateway to L2');
  const l2CustomGateway = await L2CustomGateway.deploy(l2Router);
  await l2CustomGateway.deployed();
  console.log(`Custom gateway is deployed to L2 at ${l2CustomGateway.address}`);
  const l2CustomGatewayAddress = l2CustomGateway.address;
};

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

Step 3: Deploy the custom tokens on L1 and L2[​](#step-3-deploy-the-custom-tokens-on-l1-and-l2 "Direct link to Step 3: Deploy the custom tokens on L1 and L2")
--------------------------------------------------------------------------------------------------------------------------------------------------------------

This step will depend on your setup. In this case, as our simplified gateway supports only one token, we will deploy those on L1 and L2 to be able to call the `setTokenBridgeInformation` method on both gateways afterwards.

We won’t go through the process of deploying custom tokens in this How-to, but you can see a detailed explanation of the steps to take in the page [How to bridge tokens via Arbitrum’s generic-custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-generic-custom)

Step 4: Configure your custom tokens on your gateways[​](#step-4-configure-your-custom-tokens-on-your-gateways "Direct link to Step 4: Configure your custom tokens on your gateways")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

This step will also depend on your setup. In this case, our simplified gateway requires method `setTokenBridgeInformation` to be called on both gateways to set the addresses of the counterpart gateway and both custom tokens.

```rust
/**
 * Set the token bridge information on the custom gateways
 * (This is an optional step that depends on your configuration. In this example, we've added one-shot
 * functions on the custom gateways to set the token bridge addresses in a second step. This could be
 * avoided if you are using proxies or the opcode CREATE2 for example)
 */
console.log('Setting token bridge information on L1CustomGateway:');
const setTokenBridgeInfoOnL1 = await l1CustomGateway.setTokenBridgeInformation(
  l1CustomToken.address,
  l2CustomToken.address,
  l2CustomGatewayAddress,
);

const setTokenBridgeInfoOnL1Rec = await setTokenBridgeInfoOnL1.wait();
console.log(
  `Token bridge information set on L1CustomGateway! L1 receipt is: ${setTokenBridgeInfoOnL1Rec.transactionHash}`,
);

console.log('Setting token bridge information on L2CustomGateway:');
const setTokenBridgeInfoOnL2 = await l2CustomGateway.setTokenBridgeInformation(
  l1CustomToken.address,
  l2CustomToken.address,
  l1CustomGatewayAddress,
);

const setTokenBridgeInfoOnL2Rec = await setTokenBridgeInfoOnL2.wait();
console.log(
  `Token bridge information set on L2CustomGateway! L2 receipt is: ${setTokenBridgeInfoOnL2Rec.transactionHash}`,
);
```

Step 5: Register the custom token to your custom gateway[​](#step-5-register-the-custom-token-to-your-custom-gateway "Direct link to Step 5: Register the custom token to your custom gateway")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Once all contracts are deployed on their respective chains, and they all have the information of the gateways and tokens, it’s time to register the token in your custom gateway.

As mentioned in [How to bridge tokens via Arbitrum’s generic-custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-generic-custom), this action needs to be done by the L1 token, and we’ve implemented the function `registerTokenOnL2` to do it. So now we only need to call that function.

In this case, when using this function only one action will be performed:

1.  Call function `setGateway` of `L1GatewayRouter`. This will change the `l1TokenToGateway` internal mapping it holds and will send a retryable ticket to the counterpart `L2GatewayRouter` contract in L2, to also set its mapping to the new values.

To simplify the process, we’ll use Arbitrum’s SDK and call the method [registerCustomToken](/sdk/reference/assetBridger/erc20Bridger#registercustomtoken) of the [AdminErc20Bridger](/sdk/reference/assetBridger/erc20Bridger#adminerc20bridger) class, which will call the registerTokenOnL2 method of the token passed by parameter.

```rust
/**
 * Register the custom gateway as the gateway of our custom token
 */
console.log('Registering custom token on L2:');
const registerTokenTx = await adminTokenBridger.registerCustomToken(
  l1CustomToken.address,
  l2CustomToken.address,
  l1Wallet,
  l2Provider,
);

const registerTokenRec = await registerTokenTx.wait();
console.log(
  `Registering token txn confirmed on L1! 🙌 L1 receipt is: ${registerTokenRec.transactionHash}.`,
);
console.log(
  `Waiting for L2 retryable (takes 10-15 minutes); current time: ${new Date().toTimeString()})`,
);

/**
 * The L1 side is confirmed; now we listen and wait for the L2 side to be executed; we can do this by computing the expected txn hash of the L2 transaction.
 * To compute this txn hash, we need our message's "sequence numbers", unique identifiers of each L1 to L2 message.
 * We'll fetch them from the event logs with a helper method.
 */
const l1ToL2Msgs = await registerTokenRec.getParentToChildMessages(l2Provider);

/**
 * In this case, the registerTokenOnL2 method creates 1 L1-to-L2 messages to set the L1 token to the Custom Gateway via the Router
 * Here, We check if that message is redeemed on L2
 */
expect(l1ToL2Msgs.length, 'Should be 1 message.').to.eq(1);

const setGateways = await l1ToL2Msgs[0].waitForStatus();
expect(setGateways.status, 'Set gateways not redeemed.').to.eq(ParentToChildMessageStatus.REDEEMED);

console.log('Your custom token and gateways are now registered on the token bridge 🥳!');
```

Conclusion[​](#conclusion "Direct link to Conclusion")
------------------------------------------------------

Once this step is done, your L1 and L2 gateways will be registered in the token bridge and both tokens will be connected through your custom gateway.

You can bridge tokens between L1 and L2 using the custom tokens, along with the router and gateway contracts from each layer.

If you want to see an example of bridging a token from L1 to L2 using Arbitrum’s SDK, you can check out [How to bridge tokens via Arbitrum’s standard ERC20 gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-standard), where the process is described in steps 2-5.

The full code of this how-to and a more extensive deployment and testing script can be found [in this package of our tutorials repository](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/custom-gateway-bridging).

Resources[​](#resources "Direct link to Resources")
---------------------------------------------------

1.  [Concept page: Token Bridge](/build-decentralized-apps/token-bridging/overview)
2.  [Arbitrum SDK](https://github.com/OffchainLabs/arbitrum-sdk)
3.  [Token bridge contract addresses](/build-decentralized-apps/reference/contract-addresses)

---

# Bridge tokens via Arbitrum’s generic-custom gateway | Arbitrum Docs

## Bridge tokens via Arbitrum’s generic-custom gateway

In this how-to you’ll learn how to bridge your own token between Ethereum (Layer 1 or L1) and Arbitrum (Layer 2 or L2), using [Arbitrum’s generic-custom gateway](/build-decentralized-apps/token-bridging/token-bridge-erc20#the-arbitrum-generic-custom-gateway). For alternative ways of bridging tokens, don’t forget to check out this [overview](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/get-started).

Familiarity with [Arbitrum’s token bridge system](/build-decentralized-apps/token-bridging/overview), smart contracts, and blockchain development is expected. If you’re new to blockchain development, consider reviewing our [Quickstart: Build a dApp with Arbitrum (Solidity, Hardhat)](/build-decentralized-apps/quickstart-solidity-remix) before proceeding. We will use [Arbitrum’s SDK](https://github.com/OffchainLabs/arbitrum-sdk) throughout this how-to, although no prior knowledge is required.

We will go through all steps involved in the process. However, if you want to jump straight to the code, we have created [this script in our tutorials repository](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/custom-token-bridging) that encapsulates the entire process.

Step 1: Review the prerequisites[​](#step-1-review-the-prerequisites "Direct link to Step 1: Review the prerequisites")
-----------------------------------------------------------------------------------------------------------------------

As stated in the [token bridge conceptual page](/build-decentralized-apps/token-bridging/token-bridge-erc20#the-arbitrum-generic-custom-gateway), there are a few prerequisites to keep in mind while using this method to make a token bridgeable.

First of all, the **L1 counterpart of the token**, must conform to the [ICustomToken](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/ICustomToken.sol) interface. This means that:

*   It must have a `isArbitrumEnabled` method that returns `0xb1`
*   It must have a method that makes an external call to `L1CustomGateway.registerCustomL2Token` specifying the address of the L2 contract, and to `L1GatewayRouter.setGateway` specifying the address of the custom gateway. These calls should be made only once to configure the gateway.

These methods are needed to register the token via the gateway contract. If your L1 contract does not include these methods and it is not upgradeable, registration could alternatively be performed in one of these ways:

*   As a chain-owner registration via an [Arbitrum DAO](https://forum.arbitrum.foundation/) proposal.
*   By wrapping your L1 token and registering the wrapped version of your token.

Keep in mind that this registration can only be done once.

Also, the **L2 counterpart of the token**, must conform to the [IArbToken](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/arbitrum/IArbToken.sol) interface. This means that:

*   It must have`bridgeMint` and `bridgeBurn` methods only callable by the L2CustomGateway contract
*   It must have an `l1Address` view method that returns the address of the token in L1

Token compatibility with available tooling

If you want your token to be compatible out of the box with all the tooling available (e.g., the [Arbitrum bridge](https://bridge.arbitrum.io/)), we recommend that you keep the implementation of the IArbToken interface as close as possible to the [L2GatewayToken](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/libraries/L2GatewayToken.sol) implementation example.

For example, if an allowance check is added to the `bridgeBurn()` function, the token will not be easily withdrawable through the Arbitrum bridge UI, as the UI does not prompt an approval transaction of tokens by default (it expects the tokens to follow the recommended L2GatewayToken implementation).

Step 2: Create a token and deploy it on L1[​](#step-2-create-a-token-and-deploy-it-on-l1 "Direct link to Step 2: Create a token and deploy it on L1")
-----------------------------------------------------------------------------------------------------------------------------------------------------

We‘ll begin the process by creating and deploying on L1 a sample token to bridge. If you already have a token contract on L1, you don’t need to perform this step.

However, you will need to upgrade the contract if it doesn’t include the required methods described in the previous step.

We first create a standard ERC20 contract using OpenZeppelin’s implementation. We make only 1 adjustment to that implementation, for simplicity, although it is not required: we specify an `initialSupply` to be pre-minted and sent to the deployer address upon creation.

We’ll also add the required methods to make our token bridgeable via the generic-custom gateway.

```rust
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./interfaces/ICustomToken.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title Interface needed to call function registerTokenToL2 of the L1CustomGateway
 */
interface IL1CustomGateway {
    function registerTokenToL2(
        address _l2Address,
        uint256 _maxGas,
        uint256 _gasPriceBid,
        uint256 _maxSubmissionCost,
        address _creditBackAddress
    ) external payable returns (uint256);
}

/**
 * @title Interface needed to call function setGateway of the L2GatewayRouter
 */
interface IL2GatewayRouter {
    function setGateway(
        address _gateway,
        uint256 _maxGas,
        uint256 _gasPriceBid,
        uint256 _maxSubmissionCost,
        address _creditBackAddress
    ) external payable returns (uint256);
}

contract L1Token is Ownable, ICustomToken, ERC20 {
    address private customGatewayAddress;
    address private routerAddress;
    bool private shouldRegisterGateway;

    /**
     * @dev See {ERC20-constructor} and {Ownable-constructor}
     *
     * An initial supply amount is passed, which is preminted to the deployer.
     */
    constructor(address _customGatewayAddress, address _routerAddress, uint256 _initialSupply) ERC20("L1CustomToken", "LCT") {
        customGatewayAddress = _customGatewayAddress;
        routerAddress = _routerAddress;
        _mint(msg.sender, _initialSupply * 10 ** decimals());
    }

    /// @dev we only set shouldRegisterGateway to true when in `registerTokenOnL2`
    function isArbitrumEnabled() external view override returns (uint8) {
        require(shouldRegisterGateway, "NOT_EXPECTED_CALL");
        return uint8(0xb1);
    }

    /// @dev See {ICustomToken-registerTokenOnL2}
    function registerTokenOnL2(
        address l2CustomTokenAddress,
        uint256 maxSubmissionCostForCustomGateway,
        uint256 maxSubmissionCostForRouter,
        uint256 maxGasForCustomGateway,
        uint256 maxGasForRouter,
        uint256 gasPriceBid,
        uint256 valueForGateway,
        uint256 valueForRouter,
        address creditBackAddress
    ) public override payable onlyOwner {
        // we temporarily set `shouldRegisterGateway` to true for the callback in registerTokenToL2 to succeed
        bool prev = shouldRegisterGateway;
        shouldRegisterGateway = true;

        IL1CustomGateway(customGatewayAddress).registerTokenToL2{ value: valueForGateway }(
            l2CustomTokenAddress,
            maxGasForCustomGateway,
            gasPriceBid,
            maxSubmissionCostForCustomGateway,
            creditBackAddress
        );

        IL2GatewayRouter(routerAddress).setGateway{ value: valueForRouter }(
            customGatewayAddress,
            maxGasForRouter,
            gasPriceBid,
            maxSubmissionCostForRouter,
            creditBackAddress
        );

        shouldRegisterGateway = prev;
    }

    /// @dev See {ERC20-transferFrom}
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override(ICustomToken, ERC20) returns (bool) {
        return super.transferFrom(sender, recipient, amount);
    }

    /// @dev See {ERC20-balanceOf}
    function balanceOf(address account) public view override(ICustomToken, ERC20) returns (uint256) {
        return super.balanceOf(account);
    }
}
```

We now deploy that token to L1.

```rust
const { ethers } = require('hardhat');
const { providers, Wallet } = require('ethers');
const { getArbitrumNetwork } = require('@arbitrum/sdk');
require('dotenv').config();

const walletPrivateKey = process.env.DEVNET_PRIVKEY;
const l1Provider = new providers.JsonRpcProvider(process.env.L1RPC);
const l2Provider = new providers.JsonRpcProvider(process.env.L2RPC);
const l1Wallet = new Wallet(walletPrivateKey, l1Provider);

/**
 * For the purpose of our tests, here we deploy an standard ERC20 token (L1Token) to L1
 * It sends its deployer (us) the initial supply of 1000
 */
const main = async () => {
  /**
   * Use l2Network to get the token bridge addresses needed to deploy the token
   */
  const l2Network = await getArbitrumNetwork(l2Provider);

  const l1Gateway = l2Network.tokenBridge.l1CustomGateway;
  const l1Router = l2Network.tokenBridge.l1GatewayRouter;

  /**
   * Deploy our custom token smart contract to L1
   * We give the custom token contract the address of l1CustomGateway and l1GatewayRouter as well as the initial supply (premine)
   */
  console.log('Deploying the test L1Token to L1:');
  const L1Token = await (await ethers.getContractFactory('L1Token')).connect(l1Wallet);
  const l1Token = await L1Token.deploy(l1Gateway, l1Router, 1000);

  await l1Token.deployed();
  console.log(`L1Token is deployed to L1 at ${l1Token.address}`);

  /**
   * Get the deployer token balance
   */
  const tokenBalance = await l1Token.balanceOf(l1Wallet.address);
  console.log(`Initial token balance of deployer: ${tokenBalance}`);
};

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

Step 3: Create a token and deploy it on L2[​](#step-3-create-a-token-and-deploy-it-on-l2 "Direct link to Step 3: Create a token and deploy it on L2")
-----------------------------------------------------------------------------------------------------------------------------------------------------

We’ll now create and deploy on L2 the counterpart of the token we created on L1.

We’ll create a standard ERC20 contract using OpenZeppelin’s implementation, and add the required methods from `IArbToken`.

```rust
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import "./interfaces/IArbToken.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract L2Token is ERC20, IArbToken {
    address public l2Gateway;
    address public override l1Address;

    modifier onlyL2Gateway() {
        require(msg.sender == l2Gateway, "NOT_GATEWAY");
        _;
    }

    constructor(address _l2Gateway, address _l1TokenAddress) ERC20("L2CustomToken", "LCT") {
        l2Gateway = _l2Gateway;
        l1Address = _l1TokenAddress;
    }

    /**
     * @notice should increase token supply by amount, and should only be callable by the L2Gateway.
     */
    function bridgeMint(address account, uint256 amount) external override onlyL2Gateway {
        _mint(account, amount);
    }

    /**
     * @notice should decrease token supply by amount, and should only be callable by the L2Gateway.
     */
    function bridgeBurn(address account, uint256 amount) external override onlyL2Gateway {
        _burn(account, amount);
    }

		// Add any extra functionality you want your token to have.
}
```

We now deploy that token to L2.

```rust
const { ethers } = require('hardhat');
const { providers, Wallet } = require('ethers');
const { getArbitrumNetwork } = require('@arbitrum/sdk');
require('dotenv').config();

const walletPrivateKey = process.env.DEVNET_PRIVKEY;
const l2Provider = new providers.JsonRpcProvider(process.env.L2RPC);
const l2Wallet = new Wallet(walletPrivateKey, l2Provider);

const l1TokenAddress = '<address of the l1 token deployed in the previous step>';

/**
 * For the purpose of our tests, here we deploy an standard ERC20 token (L2Token) to L2
 */
const main = async () => {
  /**
   * Use l2Network to get the token bridge addresses needed to deploy the token
   */
  const l2Network = await getArbitrumNetwork(l2Provider);
  const l2Gateway = l2Network.tokenBridge.childCustomGateway;

  /**
   * Deploy our custom token smart contract to L2
   * We give the custom token contract the address of childCustomGateway as well as the address of the counterpart L1 token
   */
  console.log('Deploying the test L2Token to L2:');
  const L2Token = await (await ethers.getContractFactory('L2Token')).connect(l2Wallet);
  const l2Token = await L2Token.deploy(l2Gateway, l1TokenAddress);

  await l2Token.deployed();
  console.log(`L2Token is deployed to L2 at ${l2Token.address}`);
};

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

Step 4: Register the custom token to the generic-custom gateway[​](#step-4-register-the-custom-token-to-the-generic-custom-gateway "Direct link to Step 4: Register the custom token to the generic-custom gateway")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Once both our contracts are deployed in their respective chains, it’s time to register the token in the generic-custom gateway.

As mentioned before, this action needs to be done by the L1 token, and we’ve implemented the function `registerTokenOnL2` to do it. So now we only need to call that function.

When using this function two actions will be performed:

1.  Call function `registerTokenToL2` of `L1CustomGateway`. This will change the `l1ToL2Token` internal mapping it holds and will send a retryable ticket to the counterpart `L2CustomGateway` contract in L2, to also set its mapping to the new values.
2.  Call function `setGateway` of `L1GatewayRouter`. This will change the `l1TokenToGateway` internal mapping it holds and will send a retryable ticket to the counterpart `L2GatewayRouter` contract in L2, to also set its mapping to the new values.

To simplify the process, we’ll use Arbitrum’s SDK. We’ll call the method [registerCustomToken](/sdk/reference/assetBridger/erc20Bridger#registercustomtoken) of the [AdminErc20Bridger](/sdk/reference/assetBridger/erc20Bridger#adminerc20bridger) class, which will call the registerTokenOnL2 method of the token passed by parameter.

```rust
/**
 * Register custom token on our custom gateway
 */
const adminTokenBridger = new AdminErc20Bridger(l2Network);
const registerTokenTx = await adminTokenBridger.registerCustomToken(
  l1CustomToken.address,
  l2CustomToken.address,
  l1Wallet,
  l2Provider,
);

const registerTokenRec = await registerTokenTx.wait();
console.log(
  `Registering token txn confirmed on L1! 🙌 L1 receipt is: ${registerTokenRec.transactionHash}`,
);

/**
 * The L1 side is confirmed; now we listen and wait for the L2 side to be executed; we can do this by computing the expected txn hash of the L2 transaction.
 * To compute this txn hash, we need our message's "sequence numbers", unique identifiers of each L1 to L2 message.
 * We'll fetch them from the event logs with a helper method.
 */
const l1ToL2Msgs = await registerTokenRec.getParentToChildMessages(l2Provider);

/**
 * In principle, a single L1 txn can trigger any number of L1-to-L2 messages (each with its own sequencer number).
 * In this case, the registerTokenOnL2 method created 2 L1-to-L2 messages;
 * - (1) one to set the L1 token to the Custom Gateway via the Router, and
 * - (2) another to set the L1 token to its L2 token address via the Generic-Custom Gateway
 * Here, We check if both messages are redeemed on L2
 */
expect(l1ToL2Msgs.length, 'Should be 2 messages.').to.eq(2);

const setTokenTx = await l1ToL2Msgs[0].waitForStatus();
expect(setTokenTx.status, 'Set token not redeemed.').to.eq(ParentToChildMessageStatus.REDEEMED);

const setGateways = await l1ToL2Msgs[1].waitForStatus();
expect(setGateways.status, 'Set gateways not redeemed.').to.eq(ParentToChildMessageStatus.REDEEMED);

console.log(
  'Your custom token is now registered on our custom gateway 🥳  Go ahead and make the deposit!',
);
```

Conclusion[​](#conclusion "Direct link to Conclusion")
------------------------------------------------------

Once this step is done, your L1 and L2 tokens will be connected through the generic-custom gateway.

You can bridge tokens between L1 and L2 using the origin L1 token and the custom token deployed on L2, along with the router and gateway contracts from each layer.

If you want to see an example of bridging a token from L1 to L2 using Arbitrum’s SDK, you can check out [How to bridge tokens via Arbitrum’s standard ERC20 gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-standard), where the process is described in steps 2-5.

Frequently asked questions[​](#frequently-asked-questions "Direct link to Frequently asked questions")
------------------------------------------------------------------------------------------------------

### Can I run the same register token process multiple times for the same L1 token?[​](#can-i-run-the-same-register-token-process-multiple-times-for-the-same-l1-token "Direct link to Can I run the same register token process multiple times for the same L1 token?")

No, you can only register once an L2 token for the same L1 token. After that, the call to `registerTokenToL2` will revert if run again.

### What can I do if my L1 token is not upgradable?[​](#what-can-i-do-if-my-l1-token-is-not-upgradable "Direct link to What can I do if my L1 token is not upgradable?")

As mentioned in the concept page, the token registration can alternatively be performed as a chain-owner registration via **[Arbitrum DAO](https://forum.arbitrum.foundation/)** proposal.

### Can I set up the generic-custom gateway after a standard ERC20 token exists on L2?[​](#can-i-set-up-the-generic-custom-gateway-after-a-standard-erc20-token-exists-on-l2 "Direct link to Can I set up the generic-custom gateway after a standard ERC20 token exists on L2?")

Yes, if your token has a standard ERC20 counterpart on L2, you can go through the process of registering your custom L2 token as outlined in this page. At that moment, your L1 token will have 2 counterpart tokens on L2, but only your new custom L2 token will be minted when depositing tokens from L1 (L1-to-L2 bridging). Both L2 tokens will be withdrawable (L2-to-L1 bridging), so users holding the old standard ERC20 token will be able to withdraw back to L1 (using the L2CustomGateway contract instead of the bridge UI) and then deposit to L2 to get the new custom L2 tokens.

Resources[​](#resources "Direct link to Resources")
---------------------------------------------------

1.  [Concept page: Token Bridge](/build-decentralized-apps/token-bridging/overview)
2.  [Arbitrum SDK](https://github.com/OffchainLabs/arbitrum-sdk)
3.  [Token bridge contract addresses](/build-decentralized-apps/reference/contract-addresses) )

---

# Bridge tokens via Arbitrum's standard ERC20 gateway | Arbitrum Docs

## Bridge tokens via Arbitrum's standard ERC20 gateway

In this how-to you’ll learn how to bridge your own token between Ethereum (Layer 1 or L1) and Arbitrum (Layer 2 or L2), using [Arbitrum’s standard ERC20 gateway](/build-decentralized-apps/token-bridging/token-bridge-erc20#default-standard-bridging). For alternative ways of bridging tokens, don’t forget to check out this [overview](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/get-started).

Familiarity with [Arbitrum’s token bridge system](/build-decentralized-apps/token-bridging/overview), smart contracts, and blockchain development is expected. If you’re new to blockchain development, consider reviewing our [Quickstart: Build a dApp with Arbitrum (Solidity, Hardhat)](/build-decentralized-apps/quickstart-solidity-remix) before proceeding. We will use [Arbitrum’s SDK](https://github.com/OffchainLabs/arbitrum-sdk) throughout this how-to, although no prior knowledge is required.

We will go through all steps involved in the process. However, if you want to jump straight to the code, we have created [this script in our tutorials repository](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/token-deposit) that encapsulates the entire process.

Step 1: Create a token and deploy it on L1[​](#step-1-create-a-token-and-deploy-it-on-l1 "Direct link to Step 1: Create a token and deploy it on L1")
-----------------------------------------------------------------------------------------------------------------------------------------------------

We‘ll begin the process by creating and deploying on L1 a sample token to bridge. If you already have a token contract on L1, you don’t need to perform this step.

We first create a standard ERC20 contract using OpenZeppelin’s implementation. We make only 1 adjustment to that implementation, for simplicity, although it is not required: we specify an `initialSupply` to be pre-minted and sent to the deployer address upon creation.

```rust
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract DappToken is ERC20 {
    /**
     * @dev See {ERC20-constructor}.
     *
     * An initial supply amount is passed, which is preminted to the deployer.
     */
    constructor(uint256 _initialSupply) ERC20("Dapp Token", "DAPP") {
        _mint(msg.sender, _initialSupply * 10 ** decimals());
    }
}
```

We now deploy that token to L1.

```rust
const { ethers } = require('hardhat');
const { providers, Wallet } = require('ethers');
require('dotenv').config();
const walletPrivateKey = process.env.DEVNET_PRIVKEY;
const l1Provider = new providers.JsonRpcProvider(process.env.L1RPC);
const l1Wallet = new Wallet(walletPrivateKey, l1Provider);

/**
 * For the purpose of our tests, here we deploy an standard ERC20 token (DappToken) to L1
 * It sends its deployer (us) the initial supply of 1000
 */
const main = async () => {
  console.log('Deploying the test DappToken to L1:');
  const L1DappToken = await (await ethers.getContractFactory('DappToken')).connect(l1Wallet);
  const l1DappToken = await L1DappToken.deploy(1000);

  await l1DappToken.deployed();
  console.log(`DappToken is deployed to L1 at ${l1DappToken.address}`);

  /**
   * Get the deployer token balance
   */
  const tokenBalance = await l1DappToken.balanceOf(l1Wallet.address);
  console.log(`Initial token balance of deployer: ${tokenBalance}`);
};

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

Step 2: Identify the bridge contracts to call (concepts summary)[​](#step-2-identify-the-bridge-contracts-to-call-concepts-summary "Direct link to Step 2: Identify the bridge contracts to call (concepts summary)")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

As stated in the [token bridge conceptual page](/build-decentralized-apps/token-bridging/token-bridge-erc20#default-standard-bridging), when using Arbitrum’s standard ERC20 gateway, you don’t need to do any pre-configuration process. Your token will be “bridgeable” out of the box.

As explained in the conceptual page, there are 2 contracts that we need to be aware of when bridging tokens:

*   **Router contract**: this is the contract that we’ll interact with. It keeps a mapping of the gateway contracts assigned to each token, fallbacking to a default gateway for standard ERC20 tokens.
*   **Gateway contract**: this is the contract that escrows or burns the tokens in the layer of origin, and sends the message over to the counterpart layer to mint or release the tokens there.

For simplicity, in this how-to we’ll focus on the first case: bridging from Ethereum (L1) to Arbitrum (L2).

We’ll explain below what specific contracts and methods need to be called to bridge your token, but you can abstract this whole process of finding the right addresses by using Arbitrum’s SDK. You can use the [deposit](/sdk/reference/assetBridger/erc20Bridger#deposit) function of the [Erc20Bridger](/sdk/reference/assetBridger/erc20Bridger) class to bridge your tokens, which will use the appropriate router contract based on the network you’re connected to, and will relay the request to the appropriate gateway contract. You can also use the function [getParentGatewayAddress](https://docs.arbitrum.io/sdk/reference/assetBridger/erc20Bridger#getparentgatewayaddress) to get the address of the gateway contract that’s going to be used. But don’t worry about any of this yet, we’ll use those functions in the next steps.

Now, here’s an explanation of the contracts and methods that need to be called to manually bridge your token:

*   When bridging from Ethereum (L1) to Arbitrum (L2), you’ll need to interact with the `L1GatewayRouter` contract, by calling the `outboundTransferCustomRefund` method. This router contract will relay your request to the appropriate gateway contract, in this case, the `L1ERC20Gateway` contract. To get the address of the gateway contract that’s going to be used, you can call the `getGateway` function in the `L1GatewayRouter` contract.
*   When bridging from Arbitrum (L2) to Ethereum (L1), you’ll need to interact with the `L2GatewayRouter` contract, by calling the `outBoundTransfer` method. This router contract will relay your request to the appropriate gateway contract, in this case, the `L2ERC20Gateway` contract. To get the address of the gateway contract that’s going to be used, you can call the `getGateway` function in the `L2GatewayRouter` contract.

You can find the addresses of the contracts involved in the process in [this page](/build-decentralized-apps/reference/contract-addresses#token-bridge-smart-contracts).

Step 3: Approve token allowance for the gateway contract[​](#step-3-approve-token-allowance-for-the-gateway-contract "Direct link to Step 3: Approve token allowance for the gateway contract")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The gateway contract will be the one that will transfer the tokens to be bridged over. So the next step is to allow the gateway contract to do so.

We typically do that by using the `approve` method of the token, but you can use Arbitrum’s SDK to abstract this process, by calling the method [approveToken](/sdk/reference/assetBridger/erc20Bridger#approvetoken) of the [Erc20Bridger](/sdk/reference/assetBridger/erc20Bridger) class, which will call the approve method of the token passed by parameter, and set the allowance to the appropriate gateway contract.

```rust
/**
 * Use l2Network to create an Arbitrum SDK Erc20Bridger instance
 * We'll use Erc20Bridger for its convenience methods around transferring token to L2
 */
const l2Network = await getArbitrumNetwork(l2Provider);
const erc20Bridge = new Erc20Bridger(l2Network);

/**
 * The Standard Gateway contract will ultimately be making the token transfer call; thus, that's the contract we need to approve.
 * erc20Bridger.approveToken handles this approval
 * Arguments required are:
 * (1) l1Signer: The L1 address transferring token to L2
 * (2) erc20L1Address: L1 address of the ERC20 token to be deposited to L2
 */
console.log('Approving:');
const l1Erc20Address = l1DappToken.address;
const approveTx = await erc20Bridger.approveToken({
  parentSigner: l1Wallet,
  erc20ParentAddress: l1Erc20Address,
});

const approveRec = await approveTx.wait();
console.log(
  `You successfully allowed the Arbitrum Bridge to spend DappToken ${approveRec.transactionHash}`,
);
```

As mentioned before, you can also call the `approve` method of the token and send as a parameter the address of the gateway contract, which you can find by calling the method `getGateway` function in the router contract.

Step 4: Start the bridging process through the router contract[​](#step-4-start-the-bridging-process-through-the-router-contract "Direct link to Step 4: Start the bridging process through the router contract")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

After allowing the gateway contract to transfer the tokens, we can now start the bridging process.

You can use Arbitrum’s SDK to abstract this process, by calling the method [deposit](/sdk/reference/assetBridger/erc20Bridger#deposit) of the [Erc20Bridger](/sdk/reference/assetBridger/erc20Bridger) class, which will estimate the gas parameters (\_maxGas, \_gasPriceBid and maxSubmissionCost, explained below) and call the `outboundTransferCustomRefund` method of the router contract. You will only need to specify the following parameters:

*   `amount`: Amount of tokens to bridge
*   `erc20L1Address`: L1 address of the ERC20 token being bridged
*   `l1Signer`: Signer object of the account transferring the tokens, connected to the L1 network
*   `l2Provider`: Provider connected to the L2 network

```rust
/**
 * Deposit DappToken to L2 using erc20Bridger. This will escrow funds in the Gateway contract on L1, and send a message to mint tokens on L2.
 * The erc20Bridge.deposit method handles computing the necessary fees for automatic-execution of retryable tickets — maxSubmission cost & l2 gas price * gas — and will automatically forward the fees to L2 as callvalue
 * Also note that since this is the first DappToken deposit onto L2, a standard Arb ERC20 contract will automatically be deployed.
 * Arguments required are:
 * (1) amount: The amount of tokens to be transferred to L2
 * (2) erc20L1Address: L1 address of the ERC20 token to be depositted to L2
 * (2) l1Signer: The L1 address transferring token to L2
 * (3) l2Provider: An l2 provider
 */
const depositTx = await erc20Bridger.deposit({
  amount: tokenDepositAmount,
  erc20ParentAddress: l1Erc20Address,
  parentSigner: l1Wallet,
  childProvider: l2Provider,
});
```

As mentioned before, you can also call the method `outboundTransferCustomRefund` manually in the router contract and specify the following parameters:

*   address `_token`: L1 address of the ERC20 token being bridged
*   address `_refundTo`: Account to be credited with the excess gas refund in L2
*   address `_to`: Account to be credited with the tokens in L2
*   uint256 `_amount`: Amount of tokens to bridge
*   uint256 `_maxGas`: Max gas deducted from user’s L2 balance to cover the execution in L2
*   uint256 `_gasPriceBid`: Gas price for the execution in L2
*   bytes `_data`: 2 pieces of data encoded:
    *   uint256 `maxSubmissionCost`: Max gas deducted from user's L2 balance to cover base submission fee
    *   bytes `extraData`: “0x”

Step 5: Wait for execution on L2[​](#step-5-wait-for-execution-on-l2 "Direct link to Step 5: Wait for execution on L2")
-----------------------------------------------------------------------------------------------------------------------

After calling the deposit method (or the `outboundTransferCustomRefund` if you’re choosing the manual way), you’ll have to wait a bit until the message is executed on L2. We will verify the status of the underlying retryable ticket created to bridge the tokens. Check this page to learn more about [L1-to-L2 messages, also known as retryables](/how-arbitrum-works/l1-to-l2-messaging).

You can programmatically wait for the execution of the transaction on L2 using Arbitrum’s SDK. You should first wait for the execution of the submission transaction (the one sent to the router contract) and then the execution of the L2 transaction.

```rust
/**
 * Now we wait for L1 and L2 side of transactions to be confirmed
 */
const depositRec = await depositTx.wait();
const l2Result = await depositRec.waitForChildTransactionReceipt(l2Provider);

/**
 * The `complete` boolean tells us if the l1 to l2 message was successful
 */
l2Result.complete
  ? console.log(`L2 message successful: status: ${L1ToL2MessageStatus[l2Result.status]}`)
  : console.log(`L2 message failed: status ${L1ToL2MessageStatus[l2Result.status]}`);
```

If you’re going the manual way, you can verify if the message has been executed on L2 through the [Retryables Dashboard](https://retryable-dashboard.arbitrum.io/). Just paste the hash of transaction submitted to the router contract and the tool will tell you whether it’s been redeemed or not.

Step 6: Check the new token contract created on L2[​](#step-6-check-the-new-token-contract-created-on-l2 "Direct link to Step 6: Check the new token contract created on L2")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Finally, let’s find the token contract that has been created on L2.

Using Arbitrum’s SDK, you can call method [getChildErc20Address](https://docs.arbitrum.io/sdk/reference/assetBridger/erc20Bridger#getchildgatewayaddress) of the [Erc20Bridger](/sdk/reference/assetBridger/erc20Bridger) class, which will return the address of the token contract in L2 that corresponds to the L1 token contract sent as parameter.

```rust
/**
 * Check if our l2Wallet DappToken balance has been updated correctly
 * To do so, we use erc20Bridge to get the l2Token address and contract
 */
const l2TokenAddress = await erc20Bridger.getChildErc20Address(l1Erc20Address, l1Provider);
const l2Token = erc20Bridger.getChildTokenContract(l2Provider, l2TokenAddress);
```

To do this operation manually, you can call method `calculateL2TokenAddress` of the router contract.

If you visit that address in [Arbiscan](https://arbiscan.io/), you’ll notice that it is a copy of the contract [StandardArbERC20](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/arbitrum/StandardArbERC20.sol). This is the standard contract that is automatically created the first time a token that doesn’t exist in Arbitrum is bridged. [The token bridge conceptual page](/build-decentralized-apps/token-bridging/token-bridge-erc20#default-standard-bridging) has more information about this contract.

Conclusion[​](#conclusion "Direct link to Conclusion")
------------------------------------------------------

After finishing this process, you’ll now have a counterpart token contract automatically created on L2. You can bridge tokens between L1 and L2 using the original token contract on L1 and the standard created contract on L2, along with the router and gateway contracts from each layer.

Resources[​](#resources "Direct link to Resources")
---------------------------------------------------

1.  [Concept page: Token Bridge](/build-decentralized-apps/token-bridging/overview)
2.  [Arbitrum SDK](https://github.com/OffchainLabs/arbitrum-sdk)
3.  [Token bridge contract addresses](/build-decentralized-apps/reference/contract-addresses)

---

# Token bridging overview | Arbitrum Docs

## Token bridging overview

Token bridging is a fundamental aspect of any Layer 2 (child chain) protocol. Arbitrum uses its ability to pass messages between parent and child chains (see [Cross-chain messaging](/build-decentralized-apps/cross-chain-messaging)) to allow projects to trustlessly move assets from Ethereum to an Arbitrum chain and back. Any asset and asset type can in principle be bridged, including Ether, ERC-20 tokens and ERC-721 tokens among others.

This section offers a series of conceptual documents explaining how asset bridging works and what options exist to bridge ether (ETH) and other types of asset between layers, as well as a series of how-tos showcasing the different methods available for making your token bridgeable.

This section is divided in three parts:

*   [ETH bridging](/build-decentralized-apps/token-bridging/token-bridge-ether): explains how Arbitrum handles bridging ETH, the native token of Ethereum and the Arbitrum chains, between the parent and child chain.
*   [ERC-20 token bridging](/build-decentralized-apps/token-bridging/token-bridge-erc20): explains the architecture of the token bridge for this type of asset, describing the different options available to make a token bridgeable.
*   [Bridge tokens programmatically](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/get-started): goes over the process of making an ERC-20 token bridgeable using the different types of gateway available in the token bridge.

---

# ERC-20 token bridging | Arbitrum Docs

## ERC-20 token bridging

The Arbitrum protocol itself technically has no native notion of any token standards, and gives no built-in advantage or special recognition to any particular token bridge. In this page we describe the "canonical bridge", which was implemented by Offchain Labs, and should be the primary bridge most users and applications use; it is (effectively) a decentralized app (dApp) with contracts on both Ethereum (the Layer 1, or L1) and Arbitrum (the Layer 2, or L2) that leverages Arbitrum's [cross-chain message passing system](/build-decentralized-apps/cross-chain-messaging) to achieve basic desired token-bridging functionality. We recommend that you use it!

Design rationale[​](#design-rationale "Direct link to Design rationale")
------------------------------------------------------------------------

In our token bridge design, we use the term "gateway" as per [this proposal](https://ethereum-magicians.org/t/outlining-a-standard-interface-for-cross-domain-erc20-transfers/6151); i.e., one of a pair of contracts on two different domains (i.e., Ethereum and an Arbitrum chain), used to facilitate cross-domain asset transfers.

We now describe some core goals that motivated the design of our bridging system.

### Custom gateway functionality[​](#custom-gateway-functionality "Direct link to Custom gateway functionality")

For many ERC-20 tokens, "standard" bridging functionality is sufficient, which entails the following: a token contract on Ethereum is associated with a "paired" token contract on Arbitrum.

Depositing a token entails escrowing some amount of the token in an L1 bridge contract, and minting the same amount at the paired token contract on L2. On L2, the paired contract behaves much like a normal ERC-20 token contract. Withdrawing entails burning some amount of the token in the L2 contract, which then can later be claimed from the L1 bridge contract.

Many tokens, however, require custom gateway systems, the possibilities of which are hard to generalize, e.g.:

*   Tokens which accrue interest to their holders need to ensure that the interest is dispersed properly across layers, and doesn't simply accrue to the bridge contracts
*   Our cross-domain WETH implementations requires tokens be wrapped and unwrapped as they move across layers.

Thus, our bridge architecture must allow not just the standard deposit and withdraw functionalities, but for new, custom gateways to be dynamically added over time.

### Canonical L2 representation per L1 token contract[​](#canonical-l2-representation-per-l1-token-contract "Direct link to Canonical L2 representation per L1 token contract")

Having multiple custom gateways is well and good, but we also want to avoid a situation in which a single L1 token that uses our bridging system can be represented at multiple addresses/contracts on the L2 as this adds significant friction and confusion for users and developers. Thus, we need a way to track which L1 token uses which gateway, and in turn, to have a canonical address oracle that maps the tokens addresses across the Ethereum and Arbitrum domains.

Canonical token bridge implementation[​](#canonical-token-bridge-implementation "Direct link to Canonical token bridge implementation")
---------------------------------------------------------------------------------------------------------------------------------------

With this in mind, we provide an overview of our token bridging architecture.

Our architecture consists of three types of contracts:

1.  **Asset contracts**: These are the token contracts themselves, i.e., an ERC-20 on L1 and it's counterpart on Arbitrum.
2.  **Gateways**: Pairs of contracts (one on L1, one on L2) that implement a particular type of cross-chain asset bridging.
3.  **Routers**: Exactly two contracts (one on L1, one on L2) that route each asset to its designated gateway.

![](/img/dapps-gatewayUML.svg)

All Ethereum to Arbitrum token transfers are initiated via the router contract on L1, the `L1GatewayRouter` contract. `L1GatewayRouter` forwards the token's deposit call to the appropriate gateway contract on L1, the `L1ArbitrumGateway` contract. `L1GatewayRouter` is responsible for mapping L1 token addresses to L1Gateway contracts, thus acting as an L1/L2 address oracle and ensuring each token corresponds to only one gateway. The `L1ArbitrumGateway` then communicates to its counterpart gateway contract on L2, the `L2ArbitrumGateway` contract (typically/expectedly via [retryable tickets](/how-arbitrum-works/l1-to-l2-messaging)).

![](/img/dapps-bridge_deposits.png)

Similarly, Arbitrum to Ethereum transfers are initiated via the router contract on L2, the `L2GatewayRouter` contract, which calls the token's gateway contract on L2, the `L2ArbitrumGateway` contract, which in turn communicates to its corresponding gateway contract on L1, the `L1ArbitrumGateway` contract (typically/expectedly via [sending L2-to-L1 messages to the outbox](/how-arbitrum-works/l2-to-l1-messaging)).

![](/img/dapps-bridge-withdrawals.png)

For any given gateway pairing, we require that calls be initiated through the corresponding router (`L1GatewayRouter` or `L2GatewayRouter`), and that the gateways conform to the [TokenGateway](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/libraries/gateway/TokenGateway.sol) interfaces; the `TokenGateway` interfaces should be flexible and extensible enough to support any bridging functionality a particular token may require.

The standard ERC-20 gateway[​](#default-standard-bridging "Direct link to The standard ERC-20 gateway")
-------------------------------------------------------------------------------------------------------

By default, any ERC-20 token on L1 that isn't registered to a gateway can be permissionlessly bridged through the `StandardERC20Gateway`.

You can use the [bridge UI](https://bridge.arbitrum.io/) or follow the instructions in [How to bridge tokens via Arbitrum’s standard ERC-20 gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-standard) to bridge a token to L2 via this gateway.

### Example: Standard Arb-ERC20 deposit and withdraw[​](#example-standard-arb-erc20-deposit-and-withdraw "Direct link to Example: Standard Arb-ERC20 deposit and withdraw")

To help illustrate what this all looks like in practice, let's go through the steps of what depositing and withdrawing `SomeERC20Token` via our standard ERC-20 gateway looks like. Here, we're assuming that `SomeERC20Token` has already been registered in the `L1GatewayRouter` to use the standard ERC-20 gateway.

#### Deposits[​](#deposits "Direct link to Deposits")

1.  A user calls `L1GatewayRouter.outboundTransferCustomRefund` **\[1\]** (with `SomeERC20Token`'s L1 address as an argument).
2.  `L1GatewayRouter` looks up `SomeERC20Token`'s gateway, and finds that it's the standard ERC-20 gateway (the `L1ERC20Gateway` contract).
3.  `L1GatewayRouter` calls `L1ERC20Gateway.outboundTransferCustomRefund`, forwarding the appropriate parameters.
4.  `L1ERC20Gateway` escrows the tokens sent and creates a retryable ticket to trigger `L2ERC20Gateway`'s `finalizeInboundTransfer` method on L2.
5.  `L2ERC20Gateway.finalizeInboundTransfer` mints the appropriate amount of tokens at the `arbSomeERC20Token` contract on L2.

❗️ _\[1\] Please keep in mind that some older custom gateways might not have `outboundTransferCustomRefund` implemented and `L1GatewayRouter.outboundTransferCustomRefund` does not fallback to `outboundTransfer`. In those cases, please use function `L1GatewayRouter.outboundTransfer`._

Note that arbSomeERC20Token is an instance of [StandardArbERC20](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/arbitrum/StandardArbERC20.sol), which includes `bridgeMint` and `bridgeBurn` methods only callable by the L2ERC20Gateway.

#### Withdrawals[​](#withdrawals "Direct link to Withdrawals")

1.  On Arbitrum, a user calls `L2GatewayRouter.outBoundTransfer`, which in turn calls `outBoundTransfer` on arbSomeERC20Token's gateway (i.e., L2ERC20Gateway).
2.  This burns arbSomeERC20Token tokens, and calls `ArbSys` with an encoded message to `L1ERC20Gateway.finalizeInboundTransfer`, which will be eventually executed on L1.
3.  After the dispute window expires and the assertion with the user's transaction is confirmed, a user can call `Outbox.executeTransaction`, which in turn calls the encoded `L1ERC20Gateway.finalizeInboundTransfer` message, releasing the user's tokens from the `L1ERC20Gateway` contract's escrow.

The Arbitrum generic-custom gateway[​](#the-arbitrum-generic-custom-gateway "Direct link to The Arbitrum generic-custom gateway")
---------------------------------------------------------------------------------------------------------------------------------

Just because a token has requirements beyond what are offered via the standard ERC-20 gateway, that doesn't necessarily mean that a unique gateway needs to be tailor-made for the token in question. Our generic-custom gateway is designed to be flexible enough to be suitable for most (but not necessarily all) custom fungible token needs. As a general rule:

**If your custom token has the ability to increase its supply (i.e., mint) directly on the L2, and you want the L2-minted tokens be withdrawable back to L1 and recognized by the L1 contract, it will probably require its own special gateway. Otherwise, the generic-custom gateway is likely the right solution for you!**

Some examples of token features suitable for the generic-custom gateway:

*   An L2 token contract upgradable via a proxy
*   An L2 token contract that includes address whitelisting/blacklisting
*   The deployer determines the address of the L2 token contract

### Setting up your token with the generic-custom gateway[​](#setting-up-your-token-with-the-generic-custom-gateway "Direct link to Setting up your token with the generic-custom gateway")

Follow the following steps to get your token set up to use the generic-custom gateway. You can also find more detailed instructions in the page [How to bridge tokens via Arbitrum’s generic-custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-generic-custom).

**0\. Have an L1 token**

Your token on L1 should conform to the [ICustomToken](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/ICustomToken.sol) interface (see [TestCustomTokenL1](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/test/TestCustomTokenL1.sol) for an example implementation). Crucially, it must have an `isArbitrumEnabled` method in its interface.

**1\. Deploy your token on Arbitrum**

Your token should conform to the minimum [IArbToken](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/arbitrum/IArbToken.sol) interface; i.e., it should have `bridgeMint` and `bridgeBurn` methods only callable by the L2CustomGateway contract, and the address of its corresponding Ethereum token accessible via `l1Address`. For an example implementation, see [L2GatewayToken](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/libraries/L2GatewayToken.sol).

Token compatibility with available tooling

If you want your token to be compatible out of the box with all the tooling available (e.g., the [Arbitrum bridge](https://bridge.arbitrum.io/)), we recommend that you keep the implementation of the IArbToken interface as close as possible to the [L2GatewayToken](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/libraries/L2GatewayToken.sol) implementation example.

For example, if an allowance check is added to the `bridgeBurn()` function, the token will not be easily withdrawable through the Arbitrum bridge UI, as the UI does not prompt an approval transaction of tokens by default (it expects the tokens to follow the recommended L2GatewayToken implementation).

**2\. Register your token on L1 to your token on L2 via the L1CustomGateway contract**

Have your L1 token's contract make an external call to `L1CustomGateway.registerTokenToL2`. This registration can alternatively be performed as a chain-owner registration via an [Arbitrum DAO](https://forum.arbitrum.foundation) proposal.

**3\. Register your token on L1 to the L1GatewayRouter**

After your token's registration to the generic-custom gateway is complete, have your L1 token's contract make an external call to `L1GatewayRouter.setGateway`; this registration can also alternatively be performed as a chain-owner registration via an [Arbitrum DAO](https://forum.arbitrum.foundation) proposal.

We are here to help

If you have questions about your custom token needs, feel free to reach out on our [Discord server](https://discord.gg/arbitrum).

Other flavors of gateways[​](#other-flavors-of-gateways "Direct link to Other flavors of gateways")
---------------------------------------------------------------------------------------------------

Note that in the system described above, one pair of gateway contracts handles the bridging of many ERC-20s; i.e., many ERC-20s on L1 are each paired with their own ERC-20s on Arbitrum via a single gateway contract pairing. Other gateways may well bear different relations with the contracts that they bridge.

Take our wrapped Ether implementation for example: here, a single WETH contract on L1 is connected to a single WETH contract on L2. When transferring WETH from one domain to another, the L1/L2 gateway architecture is used to unwrap the WETH on domain A, transfer the now-unwrapped Ether, and then re-wrap it on domain B. This ensures that WETH can behave on Arbitrum the way users are used to it behaving on Ethereum, while ensuring that all WETH tokens are always fully collateralized on the layer in which they reside.

No matter the complexity of a particular token's bridging needs, a gateway can in principle be created to accommodate it within our canonical bridging system.

You can find an example of implementation of a custom gateway in the page [How to bridge tokens via a custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-custom-gateway).

Demos[​](#demos "Direct link to Demos")
---------------------------------------

Our [How to bridge tokens](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/get-started) section provides example of interacting with Arbitrum's token bridge via the [Arbitrum SDK](https://github.com/OffchainLabs/arbitrum-sdk).

A word of caution on bridges (aka, "I've got a bridge to sell you")[​](#a-word-of-caution-on-bridges-aka-ive-got-a-bridge-to-sell-you "Direct link to A word of caution on bridges (aka, \"I've got a bridge to sell you\")")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Cross chain bridging is an exciting design space; alternative bridge designs can potentially offer faster withdrawals, interoperability with other chains, different trust assumptions with their own potentially valuable UX tradeoffs, etc. They can also potentially be completely insecure and/or outright scams. Users should treat other, non-canonical bridge applications the same way they treat any application running on Arbitrum, and exercise caution and due diligence before entrusting them with their value.

---

# ETH bridging | Arbitrum Docs

## ETH bridging

Ether (ETH) is the native currency of Ethereum and all Arbitrum chains. It is used to pay the necessary fees to execute a transaction in those chains. Bridging ETH from Ethereum (parent chain) to an Arbitrum chain (child chain) follows, thus, a different process than the one followed when bridging other types of asset.

Depositing ether[​](#depositing-ether "Direct link to Depositing ether")
------------------------------------------------------------------------

To move ETH from the parent chain to the child chain, you execute a deposit transaction via `Inbox.depositEth`. This transfers funds to the Bridge contract on the parent chain and credits the same funds to you inside the Arbitrum chain at the specified address.

```rust
function depositEth(address destAddr) external payable override returns (uint256)
```

The following diagram depicts the process that funds follow during a deposit operation.

![Depositing Ether](/img/dapps-depositing-ether.svg)

As far as the parent chain knows, all deposited funds are held by Arbitrum's Bridge contract.

Withdrawing ether[​](#withdrawing-ether "Direct link to Withdrawing ether")
---------------------------------------------------------------------------

Withdrawing ether can be done using the [ArbSys precompile](/build-decentralized-apps/precompiles/reference#arbsys)'s `withdrawEth` method:

```rust
ArbSys(100).withdrawEth{ value: 2300000 }(destAddress)
```

Upon withdrawing, the Ether balance is burnt on the Arbitrum side, and will later be made available on the Ethereum side.

`ArbSys.withdrawEth` is a convenience function equivalent to calling `ArbSys.sendTxToL1` with empty `calldataForL1`. Like any other `sendTxToL1` call, it will require an additional call to `Outbox.executeTransaction` on the parent chain after the dispute period elapses for the user to finalize claiming their funds on the parent chain (see ["Child chain to parent cahin Messages"](/how-arbitrum-works/l2-to-l1-messaging)). Once the withdrawal is executed from the Outbox, the user's Ether balance will be credited on the parent chain.

The following diagram depicts the process that funds follow during a withdraw operation.

![Withdrawing Ether](/img/dapps-withdrawing-ether.svg)

---

# Contribute docs | Arbitrum Docs

## Contribute docs

Thank you for considering to contribute to the Arbitrum documentation! We're excited to have you on board.

The [`docs.arbitrum.io`](https://docs.arbitrum.io/) docs portal is the **single source of truth** for documentation that supports Offchain Labs' product portfolio. Contributions are welcome from the entire Ethereum community.

This document shows you how to craft and publish Arbitrum documentation. Familiarity with [Markdown](https://www.markdownguide.org/basic-syntax/) syntax, Github, and [Docusaurus](https://docusaurus.io/docs) is expected.

### Add a new core document[​](#add-a-new-core-document "Direct link to Add a new core document")

If a document isn't in a `Third-party content` sidebar node, it's a **core document**. To contribute a new core doc:

1.  Begin by creating a branch (internal) or fork (external) of the [Arbitrum docs repo](https://github.com/OffchainLabs/arbitrum-docs).
2.  Issue a `Draft` pull request into `master`. Pull requests into `master` generate a preview of your changes via a PR-specific Docusaurus deployment; this preview will update as you push commits to your remote.
3.  Include answers to the following questions in your PR description:
    
    ```rust
    1. Audience: Who am I writing for?
    2. Problem: What specific problem are they trying to solve?
    3. Discovery: How are they looking for a solution to this problem? What search terms are they using?
    4. Document type: Which document type is most suitable?
    5. Policy acknowledgment (Third-party docs only): Do you agree to the third-party content policy outlined within "Contribute docs"?
    ```
    
4.  As you craft your contribution, refer to the [document types](#document-type-conventions), [Style guidance](#style-conventions), and other conventions below.
5.  Mark your PR as `Open` when it's ready for review.

### Add a new third-party document[​](#add-a-new-third-party-document "Direct link to Add a new third-party document")

**Third-party docs** are documents that help readers of Arbitrum docs use other products, services, and protocols (like the ones listed in the [Arbitrum portal](https://portal.arbitrum.io/)) with Arbitrum products.

See [Contribute third-party docs](/for-devs/third-party-docs/contribute) for detailed instructions.

### Request an update[​](#request-an-update "Direct link to Request an update")

If you'd like to request an update or share a suggestion related to an **existing document** without submitting a pull request to implement the improvement yourself, click the `Request an update` button located at the top of each published document. This button will lead you to a prefilled Github issue that you can use to elaborate on your request or suggestion.

### Add a new translation page[​](#add-a-new-translation-page "Direct link to Add a new translation page")

If you would like to participate in translating the Arbitrum docs, you can:

1.  Check whether `/website/i18n` has a corresponding language (currently there are `ja` and `zh`). If not, you can use the following command to add it (we take adding French as an example):

```rust
cd ./website
npm run write-translations -- --locale fr
```

It will help generate folder `website/i18n/fr`.

2.  Create the folders `current` and `translated` under the newly generated folder `website/i18n/fr/docusaurus-plugin-content-docs`:

```rust
mkdir i18n/{Your_language}/docusaurus-plugin-content-docs/current && mkdir i18n/{Your_language}/docusaurus-plugin-content-docs/translated
```

3.  Translate one of more docs files located in `/arbitrum-docs`.
    
4.  Place the translated document into the folder `i18n/{Your_language}/docusaurus-plugin-content-docs/translated` according to its relative path in `arbitrum-docs`. For example, if you translated `/arbitrum-docs/how-arbitrum-works/arbos/introduction.md`, then its path in i18n should be `i18n/{Your_language}/docusaurus-plugin-content-docs/translated/how-arbitrum-works/arbos/introduction.md`.
    

Test run:

1.  Check that the i18n settings in `website/docusaurus.config.js` have included your new language:

```rust
i18n: {
    defaultLocale: 'en',
    // locales: ['en', 'ja', 'zh'],
    locales: ['en'], // You can add your new language to this array
  },
```

2.  Check whether the `locale Dropdown` component exists in navbar, if not, add it:

```rust
navbar: {
    title: 'Arbitrum Docs',
    logo: {
        alt: 'My Site Logo',
        src: 'img/logo.svg',
        href: '/welcome/arbitrum-gentle-introduction',
    },
    items: [
        // note:  we can uncomment this when we want to display the locale dropdown in the top navbar
        //        if we enable this now, the dropdown will appear above every document; if `ja` is selected for a document that isn't yet translated, it will 404
        //        there may be a way to show the dropdown only on pages that have been translated, but that's out of scope for the initial version
        {
        type: 'localeDropdown',
        position: 'right',
        }
    ],
},
```

2.  Build translation and docs:

```rust
yarn build_translation && yarn build
```

6.  Start docs:

```rust
npm run serve
```

  

* * *

### Document type conventions[​](#document-type-conventions "Direct link to Document type conventions")

Every document should be a specific _type_ of document. Each type of document has its own purpose:

Document type

Purpose

Gentle introduction

Onboard a specific reader audience with tailored questions and answers

Quickstart

Onboard a specific reader audience with step-by-step "learn by doing" instructions

| How-to | Provide task-oriented procedural guidance | | Concept | Explain what things are and how they work | | FAQ | Address frequently asked questions | | Troubleshooting | List common troubleshooting scenarios and solutions | | Reference | Lists and tables of things, such as API endpoints and developer resources |

This isn't an exhaustive list, but it includes most of the document types that we use.

### Style conventions[​](#style-conventions "Direct link to Style conventions")

The following style guidelines provide a number of loose recommendations that help us deliver **a consistent content experience** across our docs:

1.  **Casing**
    *   Sentence-case "content labels": document titles, sidebar titles, menu items, section headers, etc.
2.  **Linking**
    *   Avoid anchoring links to words like "here" or "this". Descriptive anchor text can help set expectations for readers who may hesitate to click on ambiguous links. When linking to docs, try to link to the document's title verbatim.
3.  **Titling**
    *   Titles should balance brevity with precision - _Node running overview_ is preferred to _Overview_. This helps with SEO and reader UX.
4.  **Separate procedural from conceptual (most of the time)**
    *   Within procedural docs like how-tos and quickstarts, avoid including too much conceptual content. Provide only the conceptual information that the target reader _needs_ in order to complete the task at hand. Otherwise, organize conceptual information within conceptual docs, and link to them "just in case" from other docs.
5.  **Voice**
    *   Address the reader as "you".
    *   Write like you'd speak to a really smart friend who's in a rush.
    *   Opt for short, clear sentences that use translation-friendly, plain language.
    *   Use contractions wherever it feels natural - this can help convey a friendly and conversational tone.
6.  **Formality**
    *   Don't worry too much about formality. The most valuable writing is writing that provides value to readers, and readers generally want to "flow" through guidance.
    *   Aim at "informal professionalism" that prioritizes **audience-tailored problem-solving** and **consistent style and structure**.
7.  **Targeting**
    *   Don't try to write for everyone; write for a _specific reader persona_ (also referred to as "audience" in this document) who has a _specific need_.
    *   Make assumptions about prior knowledge (or lack thereof) and make these assumptions explicit in the beginning of your document.
8.  **Flow**
    *   **Set expectations**: Begin documents by setting expectations. Who is the document for? What value will it provide to your target audience? What assumptions are you making about their prior knowledge? Are there any prerequisites?
    *   **Value up front**: Lead with what matters most to the reader persona you're targeting. Then, progressively build a bridge that carries them towards task completion as efficiently as possible.
9.  **Cross-linking**
    *   We want to maintain both **high discoverability** and **high relevance**. As a general rule of thumb, links to other docs should be "very likely to be useful for most readers". Every link is a subtle call to action; we want to avoid CTA overload.
10.  **Things to avoid**
    *   **Symbols where words will do**: Minimize usage of `&` and `/` - spell out words like "_and_" and "_or_".
    *   **Jargon**: Using precise technical terminology is ok, as long as your target audience is likely to understand the terminology. When in doubt, opt for clear, unambiguous, _accessible_ language.

Don't stress too much about checking off all of these boxes; we periodically review and edit our most heavily-trafficked docs, bringing them up to spec with the latest style guidelines.

Some important disclaimers:

*   **This isn't an exhaustive list**. These are just the min-bar guidelines that will be applied to all new content moving forward.
*   **Many of our docs don't yet follow this guidance**. Our small-but-mighty team is working on it! If you notice an obvious content bug, feel free to submit an [issue](https://github.com/OffchainLabs/arbitrum-docs/issues) or [PR](https://github.com/OffchainLabs/arbitrum-docs/pulls).

### Banner conventions[​](#banner-conventions "Direct link to Banner conventions")

You can use banners (Docusaurus refers to them as ["admonitions"](https://docusaurus.io/docs/markdown-features/admonitions)) to set expectations for your readers and to emphasize important callouts. Use these conservatively, as they interrupt the flow of the document.

#### Under construction banner[​](#under-construction-banner "Direct link to Under construction banner")

Example:

UNDER CONSTRUCTION

The following steps are under construction and will be updated with more detailed guidance soon. Stay tuned, and don't hesitate to click the `Request an update` at the top of this document if you have any feedback along the way.

Usage:

```rust
:::caution[UNDER CONSTRUCTION]

The following steps are under construction and will be updated with more detailed guidance soon. Stay tuned, and don't hesitate to click the `Request an update` at the top of this document if you have any feedback along the way.

:::
```

  

#### Community member contribution banner[​](#community-member-contribution-banner "Direct link to Community member contribution banner")

Example:

Community member contribution

The following document was contributed by @todo-twitter-handle. Give them a shoutout if you find it useful!

Usage:

```rust
:::info[Community member contribution]

The following document was contributed by @todo-twitter-handle. Give them a shoutout if you find it useful!

:::
```

### Frequently asked questions[​](#frequently-asked-questions "Direct link to Frequently asked questions")

#### Can I point to my product from core docs? For example - if my product hosts a public RPC endpoint, can I add it to your [RPC endpoints and providers](/build-decentralized-apps/reference/node-providers) page?[​](#can-i-point-to-my-product-from-core-docs-for-example---if-my-product-hosts-a-public-rpc-endpoint-can-i-add-it-to-your-rpc-endpoints-and-providers-page "Direct link to can-i-point-to-my-product-from-core-docs-for-example---if-my-product-hosts-a-public-rpc-endpoint-can-i-add-it-to-your-rpc-endpoints-and-providers-page")

These types of contributions are generally **not merged** unless they're submitted by employees of Offchain Labs.

Instead of opening a PR for this type of contribution, click the `Request an update` button at the top of the published document to create an issue. Generally, third-party services are included in core docs only if we can confidently assert that the services are "**trustworthy, highly relevant to the core document at hand, and battle-tested by Arbitrum developers**" under a reasonable scrutiny.

#### How long does it take for my third-party content contribution to be reviewed?[​](#how-long-does-it-take-for-my-third-party-content-contribution-to-be-reviewed "Direct link to How long does it take for my third-party content contribution to be reviewed?")

Our small-but-mighty team is continuously balancing competing priorities, so we can't guarantee a specific turnaround time for third-party docs PRs. They're processed in the order in which they're received, generally within a week or two.

#### Is there any way to expedite third-party content contribution reviews?[​](#is-there-any-way-to-expedite-third-party-content-contribution-reviews "Direct link to Is there any way to expedite third-party content contribution reviews?")

The most effective way to expedite processing is to ensure that your PR incorporates the conventions outlined in this document. Please don't ask for status updates - if you've submitted a PR, it's on our radar!

---

# Arbitrum chain information | Arbitrum Docs

## Arbitrum chain information

Arbitrum public RPC endpoints[​](#arbitrum-public-rpc-endpoints "Direct link to Arbitrum public RPC endpoints")
---------------------------------------------------------------------------------------------------------------

caution

*   Unlike the RPC Urls, the Sequencer endpoints only support `eth_sendRawTransaction` and `eth_sendRawTransactionConditional` calls.
*   Arbitrum public RPCs do not provide Websocket support.
*   View the [faucets](https://docs.arbitrum.io/for-devs/dev-tools-and-resources/chain-info#faucets) for testnet Sepolia tokens on L2.

This section provides an overview of the available public RPC endpoints for different Arbitrum chains and necessary details to interact with them.

Name

RPC Url(s)

Chain ID

Block explorer

Underlying chain

Tech stack

Sequencer feed URL

Sequencer endpoint⚠️

Arbitrum One

[https://arb1.arbitrum.io/rpc](https://arb1.arbitrum.io/rpc)

42161

[Arbiscan](https://arbiscan.io/), [Blockscout](https://arbitrum.blockscout.com/)

Ethereum

Nitro (Rollup)

wss://arb1.arbitrum.io/feed

[https://arb1-sequencer.arbitrum.io/rpc](https://arb1-sequencer.arbitrum.io/rpc)

Arbitrum Nova

[https://nova.arbitrum.io/rpc](https://nova.arbitrum.io/rpc)

42170

[Arbiscan](https://nova.arbiscan.io/), [Blockscout](https://arbitrum-nova.blockscout.com/)

Ethereum

Nitro (AnyTrust)

wss://nova.arbitrum.io/feed

[https://nova-sequencer.arbitrum.io/rpc](https://nova-sequencer.arbitrum.io/rpc)

Arbitrum Sepolia (Testnet)

[https://sepolia-rollup.arbitrum.io/rpc](https://sepolia-rollup.arbitrum.io/rpc)

421614

[Arbiscan](https://sepolia.arbiscan.io/), [Blockscout](https://arbitrum-sepolia.blockscout.com/)

Sepolia

Nitro (Rollup)

wss://sepolia-rollup.arbitrum.io/feed

[https://sepolia-rollup-sequencer.arbitrum.io/rpc](https://sepolia-rollup-sequencer.arbitrum.io/rpc)

More RPC endpoints

More Arbitrum chain RPC endpoints can be found in Chain Connect: [Arbitrum One](https://www.alchemy.com/chain-connect/chain/arbitrum-one) and [Arbitrum Nova](https://www.alchemy.com/chain-connect/chain/arbitrum-nova).

Alternatively, to interact with public Arbitrum chains, you can rely on many of the same popular node providers that you are already using on Ethereum:

Third-party RPC providers[​](#third-party-rpc-providers "Direct link to Third-party RPC providers")
---------------------------------------------------------------------------------------------------

WANT TO BE LISTED HERE?

Complete [this form](https://docs.google.com/forms/d/e/1FAIpQLSc_v8j7sc4ffE6U-lJJyLMdBoIubf7OIhGtCqvK3cGPGoLr7w/viewform) , if you'd like to see your project added to this list (and the [Arbitrum portal](https://portal.arbitrum.one/)).

Provider

Arb One?

Arb Nova?

Arb Sepolia?

Websocket?

Stylus Tracing?

[1RPC](https://docs.1rpc.io/overview/supported-networks#arbitrum)

✅

[Alchemy](https://docs.alchemy.com/reference/arbitrum-api-quickstart)

✅

✅

✅

✅

Available on paid plans

[Allnodes](https://arbitrum.publicnode.com)

✅

✅

✅

[Ankr](https://www.ankr.com/docs/rpc-service/chains/chains-list/#arbitrum)

✅

✅

Available on paid plans

[Blast](https://blastapi.io/public-api/arbitrum)

✅

✅

✅

[BlockPi](https://docs.blockpi.io/documentations/api-reference/arbitrum)

✅

✅

[BlockVision](https://dashboard.blockvision.org/connect)

✅

[Chainbase](https://docs.chainbase.com/docs/chain-api-overview#arbitrum-one)

✅

✅

[Chainnodes](https://www.chainnodes.org/chains/arbitrum)

✅

[Chainstack](https://chainstack.com/build-better-with-arbitrum/)

✅

✅

Available on paid plans

[DataHub](https://datahub.figment.io/)

✅

[DRPC](https://drpc.org/public-endpoints/arbitrum)

✅

✅

✅

[GetBlock](https://getblock.io/nodes/arb/)

✅

✅

[Infura](https://docs.infura.io/infura/networks/arbitrum)

✅

✅

✅

Enabled on request

[Lava](https://docs.lavanet.xyz/gateway-access)

✅

✅

[Moralis](https://docs.moralis.io/reference/introduction)

✅

[Nirvana Labs](https://nirvanalabs.io)

✅

✅

✅

✅

[NodeReal](https://nodereal.io/meganode/api-marketplace/arbitrum-nitro-rpc)

✅

✅

[NOWNodes](https://nownodes.io/nodes/arbitrum-arb)

✅

[Pocket Network](https://docs.pokt.network/welcome-to-pokt-network/supported-chains)

✅

[Quicknode](https://www.quicknode.com/chains/arb)

✅

✅

✅

✅

Testnet supported in free tier

[Unifra](https://unifra.io/)

✅

[Tenderly](https://tenderly.co/)

✅

✅

✅

✅

Testnet supported in free tier

Arbitrum Smart Contract Addresses[​](#arbitrum-smart-contract-addresses "Direct link to Arbitrum Smart Contract Addresses")
---------------------------------------------------------------------------------------------------------------------------

The following information may be useful to those building on Arbitrum. We list the addresses of the smart contracts related to the protocol, the token bridge and precompiles of the different Arbitrum chains.

Protocol smart contracts[​](#protocol-smart-contracts "Direct link to Protocol smart contracts")
------------------------------------------------------------------------------------------------

### Core contracts[​](#core-contracts "Direct link to Core contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

Rollup

[0x4DCe...Cfc0](https://etherscan.io/address/0x4DCeB440657f21083db8aDd07665f8ddBe1DCfc0)

[0xE7E8...B7Bd](https://etherscan.io/address/0xE7E8cCC7c381809BDC4b213CE44016300707B7Bd)

[0x042B...0Cf4](https://sepolia.etherscan.io/address/0x042B2E6C5E99d4c521bd49beeD5E99651D9B0Cf4)

Sequencer Inbox

[0x1c47...82B6](https://etherscan.io/address/0x1c479675ad559DC151F6Ec7ed3FbF8ceE79582B6)

[0x211E...c21b](https://etherscan.io/address/0x211E1c4c7f1bF5351Ac850Ed10FD68CFfCF6c21b)

[0x6c97...be0D](https://sepolia.etherscan.io/address/0x6c97864CE4bEf387dE0b3310A44230f7E3F1be0D)

CoreProxyAdmin

[0x5547...2dbD](https://etherscan.io/address/0x554723262467F125Ac9e1cDFa9Ce15cc53822dbD)

[0x71D7...7148](https://etherscan.io/address/0x71D78dC7cCC0e037e12de1E50f5470903ce37148)

[0x1ed7...0686](https://sepolia.etherscan.io/address/0x1ed74a4e4F4C42b86A7002e9951e98DBcC890686)

### Cross-chain messaging contracts[​](#cross-chain-messaging-contracts "Direct link to Cross-chain messaging contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

Delayed Inbox

[0x4Dbd...AB3f](https://etherscan.io/address/0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f)

[0xc444...3949](https://etherscan.io/address/0xc4448b71118c9071Bcb9734A0EAc55D18A153949)

[0xaAe2...ae21](https://sepolia.etherscan.io/address/0xaAe29B0366299461418F5324a79Afc425BE5ae21)

Bridge

[0x8315...ed3a](https://etherscan.io/address/0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a)

[0xC1Eb...76Bd](https://etherscan.io/address/0xC1Ebd02f738644983b6C4B2d440b8e77DdE276Bd)

[0x38f9...33a9](https://sepolia.etherscan.io/address/0x38f918D0E9F1b721EDaA41302E399fa1B79333a9)

Outbox

[0x0B98...4840](https://etherscan.io/address/0x0B9857ae2D4A3DBe74ffE1d7DF045bb7F96E4840)

[0xD4B8...cc58](https://etherscan.io/address/0xD4B80C3D7240325D18E645B49e6535A3Bf95cc58)

[0x65f0...B78F](https://sepolia.etherscan.io/address/0x65f07C7D521164a4d5DaC6eB8Fac8DA067A3B78F)

Classic Outbox\*\*\*

[0x7607...1A40](https://etherscan.io/address/0x760723CD2e632826c38Fef8CD438A4CC7E7E1A40)  
[0x667e...337a](https://etherscan.io/address/0x667e23ABd27E623c11d4CC00ca3EC4d0bD63337a)

\*\*\*Migrated Network Only

### Fraud proof contracts[​](#fraud-proof-contracts "Direct link to Fraud proof contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

ChallengeManager

[0xA556...9fB0](https://etherscan.io/address/0xA5565d266c3c3Ee90B16Be8A5b13d587ef559fB0)

[0xFE66...A688](https://etherscan.io/address/0xFE66b18Ef1B943F8594A2710376Af4B01AcfA688)

[0xC60b...8B4C](https://sepolia.etherscan.io/address/0xC60b56Ff6aAb3FE8B9Bd70040Fe9E95A26258B4C)

OneStepProver0

[0x35FB...F731](https://etherscan.io/address/0x35FBC5F03d86E88973B06Fb9C5a913D54AbdF731)

[0x35FB...F731](https://etherscan.io/address/0x35FBC5F03d86E88973B06Fb9C5a913D54AbdF731)

[0x3Fe7...1377](https://sepolia.etherscan.io/address/0x3Fe73F959C44e04d660dBFBbeffd51FD2c091377)

OneStepProverMemory

[0xe0ba...C48b](https://etherscan.io/address/0xe0ba77e0E24de5369e3B268Ea79fDe716e2EC48b)

[0xe0ba...C48b](https://etherscan.io/address/0xe0ba77e0E24de5369e3B268Ea79fDe716e2EC48b)

[0x6268...ec2d](https://sepolia.etherscan.io/address/0x6268Fc8dB1b5083b405b2C51808Df3619783ec2d)

OneStepProverMath

[0xaB95...F921](https://etherscan.io/address/0xaB9596a0aaF28bc798c453434EC2DC0F8F0bF921)

[0xaB95...F921](https://etherscan.io/address/0xaB9596a0aaF28bc798c453434EC2DC0F8F0bF921)

[0x42f5...e8Fa](https://sepolia.etherscan.io/address/0x42f58c90583eC3fA0E0b724dEDF755AE1068e8Fa)

OneStepProverHostIo

[0xa07c...71Cf](https://etherscan.io/address/0xa07cD154340CC74EcF156FFB9fb378Ee29Ca71Cf)

[0xa07c...71Cf](https://etherscan.io/address/0xa07cD154340CC74EcF156FFB9fb378Ee29Ca71Cf)

[0xdB2c...C165](https://sepolia.etherscan.io/address/0xdB2c541e20Bd1830c8a050341Fca0Af51489C165)

OneStepProofEntry

[0x4397...42d6](https://etherscan.io/address/0x4397fE1E959Ba81B9D5f1A9679Ddd891955A42d6)

[0x4397...42d6](https://etherscan.io/address/0x4397fE1E959Ba81B9D5f1A9679Ddd891955A42d6)

[0xB9cf...AE80](https://sepolia.etherscan.io/address/0xB9cf664A1beD8F74f4B893a18c86eCe876CdAE80)

Token bridge smart contracts[​](#token-bridge-smart-contracts "Direct link to Token bridge smart contracts")
------------------------------------------------------------------------------------------------------------

### Core contracts[​](#core-contracts-1 "Direct link to Core contracts")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

L1 Gateway Router

[0x72Ce...31ef](https://etherscan.io/address/0x72Ce9c846789fdB6fC1f34aC4AD25Dd9ef7031ef)

[0xC840...cD48](https://etherscan.io/address/0xC840838Bc438d73C16c2f8b22D2Ce3669963cD48)

[0xcE18...8264](https://sepolia.etherscan.io/address/0xcE18836b233C83325Cc8848CA4487e94C6288264)

L1 ERC20 Gateway

[0xa3A7...0EeC](https://etherscan.io/address/0xa3A7B6F88361F48403514059F1F16C8E78d60EeC)

[0xB253...21bf](https://etherscan.io/address/0xB2535b988dcE19f9D71dfB22dB6da744aCac21bf)

[0x902b...3aFF](https://sepolia.etherscan.io/address/0x902b3E5f8F19571859F4AB1003B960a5dF693aFF)

L1 Arb-Custom Gateway

[0xcEe2...180d](https://etherscan.io/address/0xcEe284F754E854890e311e3280b767F80797180d)

[0x2312...232f](https://etherscan.io/address/0x23122da8C581AA7E0d07A36Ff1f16F799650232f)

[0xba2F...40F3](https://sepolia.etherscan.io/address/0xba2F7B6eAe1F9d174199C5E4867b563E0eaC40F3)

L1 Weth Gateway

[0xd920...e2db](https://etherscan.io/address/0xd92023E9d9911199a6711321D1277285e6d4e2db)

[0xE4E2...0BaE](https://etherscan.io/address/0xE4E2121b479017955Be0b175305B35f312330BaE)

[0xA8aD...0e1E](https://sepolia.etherscan.io/address/0xA8aD8d7e13cbf556eE75CB0324c13535d8100e1E)

L1 Weth

[0xC02a...6Cc2](https://etherscan.io/address/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)

[0xC02a...6Cc2](https://etherscan.io/address/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)

[0x7b79...E7f9](https://sepolia.etherscan.io/address/0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9)

L1 Proxy Admin

[0x9aD4...0aDa](https://etherscan.io/address/0x9aD46fac0Cf7f790E5be05A0F15223935A0c0aDa)

[0xa8f7...e560](https://etherscan.io/address/0xa8f7DdEd54a726eB873E98bFF2C95ABF2d03e560)

[0xDBFC...44b0](https://sepolia.etherscan.io/address/0xDBFC2FfB44A5D841aB42b0882711ed6e5A9244b0)

The following contracts are deployed on the corresponding L2 chain

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

L2 Gateway Router

[0x5288...F933](https://arbiscan.io/address/0x5288c571Fd7aD117beA99bF60FE0846C4E84F933)

[0x2190...DFa8](https://nova.arbiscan.io/address/0x21903d3F8176b1a0c17E953Cd896610Be9fFDFa8)

[0x9fDD...43C7](https://sepolia.arbiscan.io/address/0x9fDD1C4E4AA24EEc1d913FABea925594a20d43C7)

L2 ERC20 Gateway

[0x09e9...1EEe](https://arbiscan.io/address/0x09e9222E96E7B4AE2a407B98d48e330053351EEe)

[0xcF9b...9257](https://nova.arbiscan.io/address/0xcF9bAb7e53DDe48A6DC4f286CB14e05298799257)

[0x6e24...b502](https://sepolia.arbiscan.io/address/0x6e244cD02BBB8a6dbd7F626f05B2ef82151Ab502)

L2 Arb-Custom Gateway

[0x0967...5562](https://arbiscan.io/address/0x096760F208390250649E3e8763348E783AEF5562)

[0xbf54...51F4](https://nova.arbiscan.io/address/0xbf544970E6BD77b21C6492C281AB60d0770451F4)

[0x8Ca1...42C5](https://sepolia.arbiscan.io/address/0x8Ca1e1AC0f260BC4dA7Dd60aCA6CA66208E642C5)

L2 Weth Gateway

[0x6c41...623B](https://arbiscan.io/address/0x6c411aD3E74De3E7Bd422b94A27770f5B86C623B)

[0x7626...D9eD](https://nova.arbiscan.io/address/0x7626841cB6113412F9c88D3ADC720C9FAC88D9eD)

[0xCFB1...556D](https://sepolia.arbiscan.io/address/0xCFB1f08A4852699a979909e22c30263ca249556D)

L2 Weth

[0x82aF...Bab1](https://arbiscan.io/address/0x82aF49447D8a07e3bd95BD0d56f35241523fBab1)

[0x722E...5365](https://nova.arbiscan.io/address/0x722E8BdD2ce80A4422E880164f2079488e115365)

[0x980B...7c73](https://sepolia.arbiscan.io/address/0x980B62Da83eFf3D4576C647993b0c1D7faf17c73)

L2 Proxy Admin

[0xd570...2a86](https://arbiscan.io/address/0xd570aCE65C43af47101fC6250FD6fC63D1c22a86)

[0xada7...d92C](https://nova.arbiscan.io/address/0xada790b026097BfB36a5ed696859b97a96CEd92C)

[0x715D...5FdF](https://sepolia.arbiscan.io/address/0x715D99480b77A8d9D603638e593a539E21345FdF)

### Third party gateways[​](#third-party-gateways "Direct link to Third party gateways")

The following contracts are deployed on Ethereum (L1)

Arbitrum One

L1 Dai Gateway

[0xD3B5...3011](https://etherscan.io/address/0xD3B5b60020504bc3489D6949d545893982BA3011)

L1 Livepeer Gateway

[0x6142...0676](https://etherscan.io/address/0x6142f1C8bBF02E6A6bd074E8d564c9A5420a0676)

The following contracts are deployed on the corresponding L2 chain

Arbitrum One

L2 Dai Gateway

[0x4671...6C65](https://arbiscan.io/address/0x467194771dAe2967Aef3ECbEDD3Bf9a310C76C65)

L2 Livepeer Gateway

[0x6D24...D318](https://arbiscan.io/address/0x6D2457a4ad276000A615295f7A80F79E48CcD318)

Precompiles[​](#precompiles "Direct link to Precompiles")
---------------------------------------------------------

The following precompiles are deployed on every L2 chain and always have the same address

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

ArbAddressTable

[0x0000...0066](https://arbiscan.io/address/0x0000000000000000000000000000000000000066)

[0x0000...0066](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000066)

[0x0000...0066](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000066)

ArbAggregator

[0x0000...006D](https://arbiscan.io/address/0x000000000000000000000000000000000000006D)

[0x0000...006D](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006D)

[0x0000...006D](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006D)

ArbFunctionTable

[0x0000...0068](https://arbiscan.io/address/0x0000000000000000000000000000000000000068)

[0x0000...0068](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000068)

[0x0000...0068](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000068)

ArbGasInfo

[0x0000...006C](https://arbiscan.io/address/0x000000000000000000000000000000000000006C)

[0x0000...006C](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006C)

[0x0000...006C](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006C)

ArbInfo

[0x0000...0065](https://arbiscan.io/address/0x0000000000000000000000000000000000000065)

[0x0000...0065](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000065)

[0x0000...0065](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000065)

ArbOwner

[0x0000...0070](https://arbiscan.io/address/0x0000000000000000000000000000000000000070)

[0x0000...0070](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000070)

[0x0000...0070](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000070)

ArbOwnerPublic

[0x0000...006b](https://arbiscan.io/address/0x000000000000000000000000000000000000006b)

[0x0000...006b](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006b)

[0x0000...006b](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006b)

ArbRetryableTx

[0x0000...006E](https://arbiscan.io/address/0x000000000000000000000000000000000000006E)

[0x0000...006E](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006E)

[0x0000...006E](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006E)

ArbStatistics

[0x0000...006F](https://arbiscan.io/address/0x000000000000000000000000000000000000006F)

[0x0000...006F](https://nova.arbiscan.io/address/0x000000000000000000000000000000000000006F)

[0x0000...006F](https://sepolia.arbiscan.io/address/0x000000000000000000000000000000000000006F)

ArbSys

[0x0000...0064](https://arbiscan.io/address/0x0000000000000000000000000000000000000064)

[0x0000...0064](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000064)

[0x0000...0064](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000064)

ArbWasm

[0x0000...0071](https://arbiscan.io/address/0x0000000000000000000000000000000000000071)

[0x0000...0071](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000071)

[0x0000...0071](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000071)

ArbWasmCache

[0x0000...0072](https://arbiscan.io/address/0x0000000000000000000000000000000000000072)

[0x0000...0072](https://nova.arbiscan.io/address/0x0000000000000000000000000000000000000072)

[0x0000...0072](https://sepolia.arbiscan.io/address/0x0000000000000000000000000000000000000072)

NodeInterface

[0x0000...00C8](https://arbiscan.io/address/0x00000000000000000000000000000000000000C8)

[0x0000...00C8](https://nova.arbiscan.io/address/0x00000000000000000000000000000000000000C8)

[0x0000...00C8](https://sepolia.arbiscan.io/address/0x00000000000000000000000000000000000000C8)

Misc[​](#misc "Direct link to Misc")
------------------------------------

The following contracts are deployed on the corresponding L2 chain

Arbitrum One

Arbitrum Nova

Arbitrum Sepolia

L2 Multicall

[0x842e...4EB2](https://arbiscan.io/address/0x842eC2c7D803033Edf55E478F461FC547Bc54EB2)

[0x5e1e...cB86](https://nova.arbiscan.io/address/0x5e1eE626420A354BbC9a95FeA1BAd4492e3bcB86)

[0xA115...d092](https://sepolia.arbiscan.io/address/0xA115146782b7143fAdB3065D86eACB54c169d092)

---

# API3 | Arbitrum Docs

## API3

[API3](https://api3.org/) is a collaborative project to deliver traditional API services to smart contract platforms in a decentralized and trust-minimized way. API3 provides the technology for [Airnodes](https://docs.api3.org/reference/airnode/latest/understand/) to push off-chain data to on-chain contracts. This data can then be queried directly through the Airnode (initiating a “pull-type” request) or through [dAPIs](https://docs.api3.org/guides/dapis/) (data-feeds sourced directly from multiple first-party oracles owned and operated by API providers).

### Querying the price of $ARB through API3[​](#querying-the-price-of-arb-through-api3 "Direct link to Querying the price of $ARB through API3")

Here’s an example of how to use an API3 data feed to query the current price of $ARB on-chain. The [API3 market](https://market.api3.org/arbitrum) provides a list of all the dAPIs available across multiple chains including testnets. You can go forward and activate the dAPI you want to use.

API3 provides an npm package with the contracts needed to access their feeds. We first install that package in our project:

```rust
yarn add @api3/contracts
```

To use a data feed, we retrieve the information through the specific proxy address for that feed. We’ll use the IProxy interface to do so.

```rust
import "@api3/contracts/api3-server-v1/proxies/interfaces/IProxy.sol";
```

In this case, we want to obtain the current price of $ARB in $USD in Arbitrum One, so we need to know the proxy address that will provide that information. We will search the feed on the API3 Market and connect our wallet. We would then want to see if the feed is active, and if it is, we can check its configuration parameters, deploy the proxy contract and click on `Integrate.` You can find the proxy address of ARB/USD [here](https://market.api3.org/arbitrum?search=ARB%2FUSD).

info

If a dAPI is already active, you can use the proxy address directly. If it is not active, you can activate it by clicking on `Activate` and following the instructions to deploy a proxy contract.

We can now build the function to get the latest price of $ARB. We’ll use this example contract:

```rust
contract ARBPriceConsumer {
    /**
     * Network: Arbitrum One
     * Aggregator: ARB/USD
     * Proxy: 0x0cB281EC7DFB8497d07196Dc0f86D2eFD21066A5
     */
    address constant PROXY = 0x0cB281EC7DFB8497d07196Dc0f86D2eFD21066A5;

    /**
     * Returns the latest price.
     */
    function getLatestPrice()
        external
        view
        returns (int224 value, uint256 timestamp)
    {
        (value, timestamp) = IProxy(PROXY).read();
        // If you have any assumptions about `value` and `timestamp`, make sure
        // to validate them right after reading from the proxy.
    }
}
```

You can adapt this contract to your needs. Just remember to use the address of the asset you want to request the price for in the appropriate network and to **deploy your contract to the same network**. Remember we have a [Quickstart](/build-decentralized-apps/quickstart-solidity-remix) available that goes through the process of compiling and deploying a contract.

### Querying a random number through API3[​](#querying-a-random-number-through-api3 "Direct link to Querying a random number through API3")

[API3 QRNG](https://docs.api3.org/explore/qrng/) is a public utility provided with the courtesy of [Australian National University (ANU)](https://www.anu.edu.au/). It is served as a public good, it is free of charge (apart from the gas costs), and it provides quantum randomness when requiring RNG on-chain.

To request randomness on-chain, the requester submits a request for a random number to `AirnodeRrpV0`. The ANU Airnode gathers the request from the `AirnodeRrpV0` protocol contract, retrieves the random number off-chain, and sends it back to `AirnodeRrpV0`. Once received, it performs a callback to the requester with the random number.

Here’s an example of a basic `QrngRequester` that requests a random number.

API3 provides an npm package with the contracts needed to access the ANU QRNG airnode. We first install that package in our project:

```rust
yarn add @api3/airnode-protocol
```

We’ll need several pieces of data to request a random number:

*   `address airnodeRrp`: Address of the protocol contract. See the [Chains](https://docs.api3.org/reference/qrng/chains.html) page for a list of addresses on different chains. For Arbitrum, we’ll use `0xb015ACeEdD478fc497A798Ab45fcED8BdEd08924`.
*   `address airnode`: The address that belongs to the Airnode that will be called to get the QRNG data via its endpoints. See the [Providers](https://docs.api3.org/reference/qrng/providers.html) page for a list of addresses on different chains. For Arbitrum we’ll use `0x9d3C147cA16DB954873A498e0af5852AB39139f2`.
*   `bytes32 endpointId`: Endpoint ID known by the Airnode that will map to an API provider call (allowed to be `bytes32(0)`). You can also find that information in the [Providers](https://docs.api3.org/reference/qrng/providers.html) page. For Arbitrum we’ll use `0xfb6d017bb87991b7495f563db3c8cf59ff87b09781947bb1e417006ad7f55a78`.
*   `address sponsorWallet`: The address of the wallet that will pay for the gas costs for the callback request to get the random number on-chain. You need to fund this wallet with enough ETH to cover the gas costs.

To derive your sponsorWallet address, you can use the following command:

```rust
yarn @api3/airnode-admin derive-sponsor-wallet-address \
  --airnode-address 0x9d3C147cA16DB954873A498e0af5852AB39139f2 \
  --airnode-xpub xpub6DXSDTZBd4aPVXnv6Q3SmnGUweFv6j24SK77W4qrSFuhGgi666awUiXakjXruUSCDQhhctVG7AQt67gMdaRAsDnDXv23bBRKsMWvRzo6kbf \
  --sponsor-address <use-the-address-of-your-requester-contract>

  # The command outputs.
  Sponsor wallet address: 0x6394...5906757
  # Use this address as the value for _sponsorWallet.
```

We can now build the function to get a random number. We’ll use this example contract:

```rust
import "@api3/airnode-protocol/contracts/rrp/requesters/RrpRequesterV0.sol";

contract QrngRequester is RrpRequesterV0 {
    event RequestedUint256(bytes32 indexed requestId);
    event ReceivedUint256(bytes32 indexed requestId, uint256 response);

    /**
     * Network: Arbitrum One
     * AirnodeRrpV0 Address: 0xb015ACeEdD478fc497A798Ab45fcED8BdEd08924
     * Airnode: 0x9d3C147cA16DB954873A498e0af5852AB39139f2
     * Endpoint ID: 0xfb6d017bb87991b7495f563db3c8cf59ff87b09781947bb1e417006ad7f55a78
     */
    address constant _airnodeRrp = 0xb015ACeEdD478fc497A798Ab45fcED8BdEd08924;
    address constant airnode = 0x9d3C147cA16DB954873A498e0af5852AB39139f2;
    bytes32 constant endpointIdUint256 = 0xfb6d017bb87991b7495f563db3c8cf59ff87b09781947bb1e417006ad7f55a78;
    mapping(bytes32 => bool) public waitingFulfillment;
    address sponsorWallet;

    constructor() RrpRequesterV0(_airnodeRrp) {}

    // Set the sponsor wallet address that you just derived.
    function setSponsorWallet(address _sponsorWallet) external {
        sponsorWallet = _sponsorWallet;
    }

    function makeRequestUint256() external {
        bytes32 requestId = airnodeRrp.makeFullRequest(
            airnode,
            endpointIdUint256,
            address(this),
            sponsorWallet,
            address(this),
            this.fulfillUint256.selector,
            ""
        );
        waitingFulfillment[requestId] = true;
        emit RequestedUint256(requestId);
    }

    function fulfillUint256(bytes32 requestId, bytes calldata data)
        external
        onlyAirnodeRrp
    {
        require(
            waitingFulfillment[requestId],
            "Request ID not known"
        );
        waitingFulfillment[requestId] = false;
        uint256 qrngUint256 = abi.decode(data, (uint256));

        // Use `qrngUint256` here...

        emit ReceivedUint256(requestId, qrngUint256);
    }
}
```

You can adapt this contract to your needs. Just remember to set the `sponsorWallet` address before making the request to use the appropriate network's addresses, and to **deploy your contract to the same network**. Remember, we have a [Quickstart](/build-decentralized-apps/quickstart-solidity-remix) available that goes through the process of compiling and deploying a contract.

### More examples[​](#more-examples "Direct link to More examples")

Refer to [API3’s documentation](https://docs.api3.org/) for more examples of querying other data feeds and Airnodes.

You can also check out some other detailed guides:

*   [Subscribing to dAPIs](https://docs.api3.org/guides/dapis/subscribing-to-dapis/)
*   [Reading a dAPI Proxy](https://docs.api3.org/guides/dapis/read-a-dapi/)
*   [Using QRNG with Remix](https://docs.api3.org/guides/qrng/qrng-remix/)

---

# Chainlink | Arbitrum Docs

## Chainlink

[Chainlink](https://chain.link/) is a widely-recognized Web3 services platform that specializes in decentralized oracle networks. It lets you build Ethereum and Arbitrum dApps that connect to a variety of off-chain data feeds and APIs, including those that provide asset prices, weather data, random number generation, and more.

### Querying the price of $ARB through Chainlink[​](#querying-the-price-of-arb-through-chainlink "Direct link to Querying the price of $ARB through Chainlink")

Here’s an example on how to use a price feed from Chainlink to query the current price of $ARB on-chain. We’ll use an interface provided by Chainlink that can be configured with the address of the proxy that holds the information we want to request, and wrap the operation in a contract.

Chainlink provides an npm package with the contracts needed to access their feeds. We first install that package in our project:

```rust
yarn add @chainlink/contracts
```

To use a data feed, we retrieve the information through the `AggregatorV3Interface` and the proxy address of the feed we want to query.

```rust
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
```

In this case, we want to obtain the current price of $ARB in $USD in Arbitrum One, so we need to know the address of the proxy that will provide that information. Chainlink maintains a list of price feed address [here](https://docs.chain.link/data-feeds/price-feeds/addresses?network=arbitrum). For $ARB/$USD, we’ll use the address `0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6`.

We can now build the function to get the latest price of $ARB. We’ll use this example contract:

```rust
contract ARBPriceConsumer {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Arbitrum One
     * Aggregator: ARB/USD
     * Address: 0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6
     */
		address constant PROXY = 0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6;

    constructor() {
        priceFeed = AggregatorV3Interface(PROXY);
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}
```

You can adapt this contract to your needs. Just remember to use the address of the asset you want to request the price for in the appropriate network, and to **deploy your contract to the same network**. Remember we have a [Quickstart](/build-decentralized-apps/quickstart-solidity-remix) available that goes through the process of compiling and deploying a contract.

### More examples[​](#more-examples "Direct link to More examples")

Refer to [Chainlink’s documentation](https://docs.chain.link/) for more examples of querying price feeds plus other data feeds available.

---

# Chronicle | Arbitrum Docs

## Chronicle

[Chronicle Protocol](https://chroniclelabs.org/) is a novel Oracle solution that overcomes the current limitations of transferring data on-chain by developing scalable, cost-efficient, decentralized, and verifiable Oracles, rewriting the rulebook on data transparency and accessibility.

### Querying the price of $ARB using Chronicle[​](#querying-the-price-of-arb-using-chronicle "Direct link to Querying the price of $ARB using Chronicle")

Chronicle contracts are read-protected by a whitelist, meaning you won't be able to read them on-chain without your address being added to the whitelist. On the Testnet, users can add themselves to the whitelist through the SelfKisser contract; a process playfully referred to as "kissing" themselves. To access production Oracles on the Mainnet, please open a support ticket in [Discord](https://discord.com/invite/CjgvJ9EspJ) in the 🆘 ｜ support channel.

For the deployment addresses, please check out the [Dashboard](https://chroniclelabs.org/dashboard/oracles).

```rust
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

/**
 * @title OracleReader
 * @notice A simple contract to read from Chronicle oracles
 * @dev To see the full repository, visit https://github.com/chronicleprotocol/OracleReader-Example.
 * @dev Addresses in this contract are hardcoded for the Arbitrum Sepolia testnet.
 * For other supported networks, check the https://chroniclelabs.org/dashboard/oracles.
 */
contract OracleReader {
    /**
    * @notice The Chronicle oracle to read from.
    * Chronicle_ARB_USD_1 - 0xdD7c06561689c73f0A67F2179e273cCF45EFc964
    * Network: Arbitrum Sepolia
    */

    IChronicle public chronicle = IChronicle(address(0xdD7c06561689c73f0A67F2179e273cCF45EFc964));

    /**
    * @notice The SelfKisser granting access to Chronicle oracles.
    * SelfKisser_1:0xc0fe3a070Bc98b4a45d735A52a1AFDd134E0283f
    * Network: Arbitrum Sepolia
    */
    ISelfKisser public selfKisser = ISelfKisser(address(0xc0fe3a070Bc98b4a45d735A52a1AFDd134E0283f));

    constructor() {
        // Note to add address(this) to chronicle oracle's whitelist.
        // This allows the contract to read from the chronicle oracle.
        selfKisser.selfKiss(address(chronicle));
    }

    /**
    * @notice Function to read the latest data from the Chronicle oracle.
    * @return val The current value returned by the oracle.
    * @return age The timestamp of the last update from the oracle.
    */
    function read() external view returns (uint256 val, uint256 age) {
        (val, age) = chronicle.readWithAge();
    }
}

// Copied from [chronicle-std](https://github.com/chronicleprotocol/chronicle-std/blob/main/src/IChronicle.sol).
interface IChronicle {
    /**
    * @notice Returns the oracle's current value.
    * @dev Reverts if no value set.
    * @return value The oracle's current value.
    */
    function read() external view returns (uint256 value);

    /**
    * @notice Returns the oracle's current value and its age.
    * @dev Reverts if no value set.
    * @return value The oracle's current value using 18 decimals places.
    * @return age The value's age as a Unix Timestamp .
    * */
    function readWithAge() external view returns (uint256 value, uint256 age);
}

// Copied from [self-kisser](https://github.com/chronicleprotocol/self-kisser/blob/main/src/ISelfKisser.sol).
interface ISelfKisser {
    /// @notice Kisses caller on oracle `oracle`.
    function selfKiss(address oracle) external;
}
```

### More examples[​](#more-examples "Direct link to More examples")

For more examples of integrating Chronicle Oracles, please check the [documentation portal](https://docs.chroniclelabs.org/).

---

# DIA | Arbitrum Docs

## DIA

[DIA](https://www.diadata.org/) is a cross-chain oracle provider that enhances data transparency, customization, and accessibility. With a novel architecture aggregating raw trade data directly from first-party sources, namely centralized and decentralized exchanges, DIA offers 100% source transparency, bespoke customization, and chain-native asset price feeds.

You can find an example on how to use DIA in your project on this [page](https://docs.diadata.org/introduction/intro-to-dia-oracles/request-an-oracle).

### How to use DIA oracles on Arbitrum[​](#how-to-use-dia-oracles-on-arbitrum "Direct link to How to use DIA oracles on Arbitrum")

**Requesting a custom oracle**: DIA deploys oracles tailored to each dApp’s needs. Each oracle is customizable, including data sources, cleansing filters, pricing, computational methodologies, update mechanisms, and more. This flexibility ensures that the data and oracle remain robust and resilient to the market conditions and provide a global market price and specific individual or cross-chain market prices. → [Request a Custom Oracle for your dApp | DIA Documentation](https://docs.diadata.org/introduction/intro-to-dia-oracles/request-an-oracle)

### Token Price Feeds[​](#token-price-feeds "Direct link to Token Price Feeds")

DIA token price feeds provide smart contracts with real-time price information for [3,000+ cryptocurrencies](https://diadata.org/app/price), sourced from [80+ trusted, high-volume DEXs and CEXs](https://diadata.org/app/source/defi).

### How to access DIA oracles?[​](#how-to-access-dia-oracles "Direct link to How to access DIA oracles?")

Here is an example of how to access a price value on DIA oracles:

1.  Access your custom oracle smart contract on Arbitrum.
2.  Call `getValue(pair_name)` with `pair_name` being the full pair name such as `BTC/USD`. You can use the "Read" section on the explorer to execute this call.
3.  The response of the call contains two values:

*   The current asset price in USD with a fix-comma notation of 8 decimals.
*   The UNIX timestamp of the last oracle update.

You can find DIA's oracle integration samples in Solidity and Vyper languages by visiting: → [Access the Oracle | DIA Documentation](https://docs.diadata.org/products/token-price-feeds/access-the-oracle)

### Arbitrum demo price oracles[​](#arbitrum-demo-price-oracles "Direct link to Arbitrum demo price oracles")

DIA has deployed the following demo oracles for the Arbitrum community. It provides a limited selection of cryptocurrency price feeds with predefined configuration settings.

note

DIA demo oracles are not intended for use in production environments. Developers can request a dedicated, production-ready oracle with custom price feeds and configuration settings. Start the request process: [Request a Custom Oracle | DIA Documentation](https://docs.diadata.org/introduction/intro-to-dia-oracles/request-an-oracle)

### Demo Oracle Smart Contracts[​](#demo-oracle-smart-contracts "Direct link to Demo Oracle Smart Contracts")

Network

Contract address

Arbitrum

[`0xd041478644048d9281f88558e6088e9da97df624`](https://arbiscan.io/address/0xd041478644048d9281f88558e6088e9da97df624)

Arbitrum Nova

[`0xa707a5c6a180da0ae2ef17ebff54f1f3589d9670`](https://nova.arbiscan.io/address/0xa707a5c6a180da0ae2ef17ebff54f1f3589d9670)

### Included Price Feeds[​](#included-price-feeds "Direct link to Included Price Feeds")

[DIA/USD](https://diadata.org/app/price/asset/Ethereum/0x84cA8bc7997272c7CfB4D0Cd3D55cd942B3c9419/), [BTC/USD](https://diadata.org/app/price/asset/Bitcoin/0x0000000000000000000000000000000000000000/), [USDC/USD](https://diadata.org/app/price/asset/Ethereum/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/)

### Supported token API endpoints[​](#supported-token-api-endpoints "Direct link to Supported token API endpoints")

DIA supports API and GraphQL endpoints to return cryptocurrency price data. You can [visit the DIA Documentation](https://docs.diadata.org/products/token-price-feeds/access-api-endpoints) to see all API endpoints.

### NFT Price Feeds[​](#nft-price-feeds "Direct link to NFT Price Feeds")

DIA NFT floor price feeds provide smart contracts with real-time price information of [18,000+ NFT collections](https://diadata.org/app/floor-price), sourced on-chain with 100% transparency from [multiple, cross-chain NFT marketplaces](https://diadata.org/app/source/nft).

### Supported NFT API endpoints[​](#supported-nft-api-endpoints "Direct link to Supported NFT API endpoints")

DIA supports API endpoints to return cryptocurrency price data. Developers can directly access the example endpoints listed below or [visit the DIA Documentation](https://docs.diadata.org/use-nexus-product/readme/token-price-feeds/access-api-endpoints) to see all API endpoints.

---

# ORA | Arbitrum Docs

## ORA

[ORA](https://ora.io) is Ethereum's Trustless AI. As a verifiable oracle protocol, ORA brings AI and complex compute onchain. Its main product, **Onchain AI Oracle (OAO)**, integrates AI capabilities directly onchain.

ORA breaks down the limitations of smart contracts by offering verifiable AI inference so that developers can innovate freely.

OAO quickstart[​](#oao-quickstart "Direct link to OAO quickstart")
------------------------------------------------------------------

This quickstart is designed to help you build a smart contract on Arbitrum able to interact with OAO. You can find more details in [our docs Quickstart](https://docs.ora.io/doc/oao-onchain-ai-oracle/develop-guide).

### Workflow[​](#workflow "Direct link to Workflow")

1.  The user contract sends the AI request to OAO on Arbitrum, by calling `requestCallback` function on the OAO contract.
2.  Each AI request will initiate an opML inference.
3.  OAO will emit a `requestCallback` event which will be collected by opML node.
4.  opML node will run the AI inference, and then upload the result on Arbitrum, waiting for the challenge period.
    1.  During the challenge period, the opML validators will check the result and challenge it if the submitted result is incorrect.
    2.  If the submitted result is successfully challenged by one of the validators, the submitted result will be updated on Arbitrum.
    3.  After the challenge period, the submitted result onchain is finalized.
5.  When the result is uploaded or updated on Arbitrum, the provided AI inference in opML will be dispatched to the user's smart contract via its specific callback function.

Integration[​](#integration "Direct link to Integration")
---------------------------------------------------------

### Overview[​](#overview "Direct link to Overview")

To integrate with OAO, you will need to write your own contract.

To build with AI models of OAO, we provided an example of contract using OAO: [Prompt](https://arbiscan.io/address/0xC20DeDbE8642b77EfDb4372915947c87b7a526bD).

### Smart contract integration[​](#smart-contract-integration "Direct link to Smart contract integration")

1.  Inherit `AIOracleCallbackReceiver` in your contract and bind with a specific OAO address:

```rust
constructor(IAIOracle _aiOracle) AIOracleCallbackReceiver(_aiOracle) {}
```

2.  Write your callback function to handle the AI result from OAO. Note that only OAO can call this function:

```rust
function aiOracleCallback(uint256 requestId, bytes calldata output, bytes calldata callbackData) external override onlyAIOracleCallback()
```

3.  When you want to initiate an AI inference request, call OAO as follows:

```rust
aiOracle.requestCallback(modelId, input, address(this), gas_limit, callbackData);
```

Reference[​](#reference "Direct link to Reference")
---------------------------------------------------

**4 models** are available on Arbitrum One: Stable Diffusion (ID: 50), Llama3 8B Instruct (ID: 11), OpenLM Score 7B (ID: 14) and OpenLM Chat 7B (ID: 15).

[Prompt](https://docs.ora.io/doc/oao-onchain-ai-oracle/reference) and [SimplePrompt](https://docs.ora.io/doc/oao-onchain-ai-oracle/reference) are both example smart contracts interacted with OAO.

For simpler application scenarios (eg. Prompt Engineering based AI like GPTs), you can directly use Prompt or SimplePrompt.

SimplePrompt saves gas by only emitting the event without storing historical data.

Arbitrum One:

*   OAO Proxy: [0x0A0f4321214BB6C7811dD8a71cF587bdaF03f0A0](https://arbiscan.io/address/0x0A0f4321214BB6C7811dD8a71cF587bdaF03f0A0)
*   Prompt: [0xC20DeDbE8642b77EfDb4372915947c87b7a526bD](https://arbiscan.io/address/0xC20DeDbE8642b77EfDb4372915947c87b7a526bD)
*   SimplePrompt: [0xC3287BDEF03b925A7C7f54791EDADCD88e632CcD](https://arbiscan.io/address/0xC3287BDEF03b925A7C7f54791EDADCD88e632CcD)

Arbitrum Sepolia tesnet:

*   OAO Proxy: [0x0A0f4321214BB6C7811dD8a71cF587bdaF03f0A0](https://sepolia.arbiscan.io/address/0x0A0f4321214BB6C7811dD8a71cF587bdaF03f0A0)
*   Prompt: [0xC3287BDEF03b925A7C7f54791EDADCD88e632CcD](https://sepolia.arbiscan.io/address/0xC3287BDEF03b925A7C7f54791EDADCD88e632CcD)
*   SimplePrompt: [0xBC24514E541d5CBAAC1DD155187A171a593e5CF6](https://sepolia.arbiscan.io/address/0xBC24514E541d5CBAAC1DD155187A171a593e5CF6)

Useful links:[​](#useful-links "Direct link to Useful links:")
--------------------------------------------------------------

*   Read [ORA documentation](https://docs.ora.io)
*   [Join our Discord](https://discord.gg/ora-io) where our team can help you
*   Follow us [on X](https://x.com/OraProtocol)

---

# Oracles providers | Arbitrum Docs

## Oracles providers

Learn how to run an Arbitrum node.

[

### API3

Learn out to use API3



](/for-devs/oracles/api3/)[

### Chainlink

Learn out to use Chainlink



](/for-devs/oracles/chainlink/)[

### Chronicle

Learn out to use Chronicle



](/for-devs/oracles/chronicle/)[

### Ora

Learn out to use Ora



](/for-devs/oracles/ora/)[

### Pyth

Learn out to use Pyth



](/for-devs/oracles/pyth/)[

### Supra price feed

Querying price feeds with Supra



](/for-devs/oracles/supra/use-supras-price-feed-oracle)[

### Supra VRF

Using Supra VRF



](/for-devs/oracles/supra/use-supras-vrf)[

### Trellor

Learn out to use Trellor



](/for-devs/oracles/trellor/)[

### DIA

Learn out to use DIA



](/for-devs/oracles/dia/)

---

# Pyth | Arbitrum Docs

## Pyth

The [Pyth network](https://pyth.network/) a first-party oracle network, securely and transparently delivering real-time market data to [multiple chains](https://docs.pyth.network/price-feeds/contract-addresses).

The network comprises some of the world’s [largest exchanges, market makers, and financial services providers](https://pyth.network/publishers). These publish proprietary data on-chain for aggregation and distribution to smart contract applications.

Pyth price feeds[​](#pyth-price-feeds "Direct link to Pyth price feeds")
------------------------------------------------------------------------

The Pyth network introduces an innovative low-latency [pull oracle design](https://docs.pyth.network/price-feeds/pull-updates), where users can pull price updates on-chain when needed, enabling everyone in the blockchain environment to access that data point. Pyth network updates the prices every 400ms, making Pyth the fastest on-chain oracle.

Here is a working example of a contract that fetches the latest price of ARB/USD on the Arbitrum network.

You have to pass Pyth's contract address for Arbitrum mainnet/testnet and the desired price feed ID to fetch the latest price.

Install the Pyth SDK Solidity package in your project:

```rust
npm install @pythnetwork/pyth-sdk-solidity
```

And then, in a few lines of code you can fetch the latest price on the Arbitrum network.

```rust
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "@pythnetwork/pyth-sdk-solidity/IPyth.sol";
import "@pythnetwork/pyth-sdk-solidity/PythStructs.sol";
contract MyFirstPythContract {
    IPyth pyth;
    // Pass the address of Pyth's contract for Arbitrum mainnet(0xff1a0f4744e8582DF1aE09D5611b887B6a12925C)
    constructor(address _pyth) {
        pyth = IPyth(_pyth);
    }
    function fetchPrice(
        bytes[] calldata updateData,
        bytes32 priceFeed
    ) public payable returns (int64) {
   // Fetch the priceUpdate from hermes.
        uint updateFee = pyth.getUpdateFee(updateData);
        pyth.updatePriceFeeds{value: updateFee}(updateData);
        // Fetch the latest price
        PythStructs.Price memory price = pyth.getPrice(priceFeed);
        return price.price;
    }
}
```

Here you can fetch the `updateData` from Pyth's [Hermes](https://hermes.pyth.network/docs/) feed, which listens to Pythnet and Wormhole for price updates; or you can use the [pyth-evm-js](https://github.com/pyth-network/pyth-crosschain/blob/main/target_chains/ethereum/sdk/js/src/EvmPriceServiceConnection.ts#L15) SDK. Check [How to Fetch Price Updates](https://docs.pyth.network/price-feeds/fetch-price-updates) to pull the latest data.

Pyth Entropy[​](#pyth-entropy "Direct link to Pyth Entropy")
------------------------------------------------------------

Pyth Entropy allows developers to quickly and easily generate secure **random numbers** on the blockchain.

Check [how to generate random numbers in EVM contracts](https://docs.pyth.network/entropy/generate-random-numbers/evm) for a detailed walkthrough.

### Supported networks for Arbitrum(Pyth Entropy):[​](#supported-networks-for-arbitrumpyth-entropy "Direct link to Supported networks for Arbitrum(Pyth Entropy):")

*   Arbitrum: [`0x7698E925FfC29655576D0b361D75Af579e20AdAc`](https://arbiscan.io/address/0x7698E925FfC29655576D0b361D75Af579e20AdAc)
*   Arbitrum Sepolia: [`0x549Ebba8036Ab746611B4fFA1423eb0A4Df61440`](https://sepolia.arbiscan.io/address/0x549Ebba8036Ab746611B4fFA1423eb0A4Df61440)

Additional resources[​](#additional-resources "Direct link to Additional resources")
------------------------------------------------------------------------------------

Check out the following links to get started with Pyth:

*   [Pyth EVM Integration Guide](https://docs.pyth.network/price-feeds/use-real-time-data/evm)
*   [Pyth Docs](https://docs.pyth.network/home)
*   [Pyth API Reference](https://api-reference.pyth.network/price-feeds/evm/getPrice)
*   [Pyth Examples](https://github.com/pyth-network/pyth-examples)
*   [Pyth Price Feed Ids](https://pyth.network/developers/price-feed-ids)

---

# Supra, price feed oracle | Arbitrum Docs

## Supra, price feed oracle

Community member contribution

Shoutout to [@ksdumont](https://github.com/ksdumont) for contributing the following [third-party document](/for-devs/third-party-docs/contribute)!

Supra is a novel, high-throughput Oracle & IntraLayer: A vertically integrated toolkit of cross-chain solutions (data oracles, asset bridges, automation network, and more) that interlink all blockchains, public (L1s and L2s) or private (enterprises).

Integrating with Supra's price feeds is quick and easy. Supra currently supports several Solidity/EVM-based networks, like Arbitrum, and non-EVM networks like Sui, Aptos.

To see all of the networks Supra is on, please visit [Supras' Networks](https://supraoracles.com/docs/price-feeds/networks)!

To get started, you will want to visit [Supras' docs site](https://supraoracles.com/docs/price-feeds/) and review the documentation or continue to follow this guide for a quick start.

### Step 1: Create The S-Value interface[​](#step-1-create-the-s-value-interface "Direct link to Step 1: Create The S-Value interface")

Add the following code to the solidity smart contract that you wish to retrieve an S-Value.

```rust
interface ISupraSValueFeed {

    function getSvalue(uint64 _pairIndex) external view returns (bytes32, bool);

    function getSvalues(uint64[] memory _pairIndexes) external view returns (bytes32[] memory, bool[] memory);

}
```

This creates the interface that you will later apply in order to fetch a price from SupraOracles.

### Step 2: Configure The S-Value feed address[​](#step-2-configure-the-s-value-feed-address "Direct link to Step 2: Configure The S-Value feed address")

To fetch the S-Value from a SupraOracles smart contract, you must first find the S-Value feed address for the chain of your choice.

For Arbitrum, the address is [0x8a358F391d93f7558D5F5E61BDf533e2cc3Cf7a3](https://arbiscan.io/address/0x8a358f391d93f7558d5f5e61bdf533e2cc3cf7a3)

When you have the proper address, create an instance of the S-Value feed using the interface we previously defined for Arbitrum:

```rust
contract ISupraSValueFeedExample {
    ISupraSValueFeed internal sValueFeed;
    constructor() {
        sValueFeed = ISupraSValueFeed(0x8a358F391d93f7558D5F5E61BDf533e2cc3Cf7a3);
    }
}
```

### Step 3: Add unpack function to decode response for S-Value feed[​](#step-3-add-unpack-function-to-decode-response-for-s-value-feed "Direct link to Step 3: Add unpack function to decode response for S-Value feed")

To decode S-value response from SupraOracles smart contract, you need to add the following code in your contract.

```rust
// Some codefunction unpack(bytes32 data) internal pure returns(uint256[4] memory) {
        uint256[4] memory info;

        info[0] = bytesToUint256(abi.encodePacked(data >> 192));       // round
        info[1] = bytesToUint256(abi.encodePacked(data << 64 >> 248)); // decimal
        info[2] = bytesToUint256(abi.encodePacked(data << 72 >> 192)); // timestamp
        info[3] = bytesToUint256(abi.encodePacked(data << 136 >> 160)); // price

        return info;
    }

    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {
        require(_bs.length == 32, "bytes length is not 32.");
        assembly {
            value := mload(add(_bs, 0x20))
        }
    }
```

### Step 4: Get the S-Value crypto price[​](#step-4-get-the-s-value-crypto-price "Direct link to Step 4: Get the S-Value crypto price")

Now you can simply access the S-Value crypto price of our supported market pairs. In this step, we'll get the price of single or multiple trading pairs in our smart contract.

```rust
function getPrice(uint64 _priceIndex) external view returns (uint256[4] memory) {

        (bytes32 val,)= sValueFeed.getSvalue(_priceIndex);

        uint256[4] memory decoded = unpack(val);

        return decoded;
}

function getPriceForMultiplePair(uint64[] memory _pairIndexes) external view returns (uint256[4][] memory) {

        (bytes32[] memory val, ) = sValueFeed.getSvalues(_pairIndexes);

        uint256[4][] memory decodedArray = new uint256[4][](val.length);

        for(uint i=0; i< val.length; i++){

            uint256[4] memory decoded = unpack(val[i]);
            decodedArray[i] = decoded;
        }

        return decodedArray;
}
```

Tada! You now have a method in your smart contract that you can call at any time to retrieve the price of any crypto pair!

Going further with Supra[​](#going-further-with-supra "Direct link to Going further with Supra")
------------------------------------------------------------------------------------------------

If you want to take the next step, consider registering for the [Supra Network Activate Program (SNAP)](https://join.supraoracles.com/network-activate-program).

The Supra Network Activate Program (SNAP) offers companies discounted oracle credits, technical documentation, and customer support to embed much-needed oracles and VRF/RNG. SNAP supports Web3 scaling and growth to buffer costs which could typically inhibit a company’s success.

The SNAP program is partnered with some of Web3's most prolific names who are helping with project selection and qualification.

Connect with us![​](#connect-with-us "Direct link to Connect with us!")
-----------------------------------------------------------------------

Still looking for answers? We got them! Check out all the ways you can reach us:

*   Visit us at [supraoracles.com](https://supraoracles.com)
*   Read our [Docs](https://supraoracles.com/docs/overview)
*   Chat with us on [Telegram](https://t.me/SupraOracles)
*   Follow us on [Twitter](https://twitter.com/SupraOracles)
*   Join our [Discord](https://discord.gg/supraoracles)
*   Check us out on [Youtube](https://www.youtube.com/SupraOfficial)

---

# Supra, VRF | Arbitrum Docs

## Supra, VRF

Community member contribution

Shoutout to [@ksdumont](https://github.com/ksdumont) for contributing the following [third-party document](/for-devs/third-party-docs/contribute)!

Supra’s VRF can provide the exact properties required for a random number generator (RNG) to be fair with tamper-proof, unbiased, and cryptographically verifiable random numbers to be employed by smart contracts.

Integrating with Supras' VRF is quick and easy. Supra currently supports several Solidity/EVM-based networks, like Arbitrum, and non-EVM networks like Sui, Aptos.

To get started, you will want to visit [Supras' docs site](https://supraoracles.com/docs/vrf) and review the documentation or continue to follow this guide for a quick start.

Latest version of Supra VRF requires a customer controlled wallet address to act as the main reference for access permissions and call back(response) transaction gas fee payments. Therefore, users planning to consume Supra VRF should get in touch with our team to get your wallet registered with Supra.

Once your wallet is registered by the Supra team, you could use it to whitelist any number of VRF requester smart contracts and pre-pay/top up the deposit balance maintained with Supra in order to pay for the gas fees of callback(response) transactions.

You will be interacting with two main contracts:

*   **Supra Deposit Contract:** To whitelist smart contracts under the registered wallet address, pre-pay/top up the callback gas fee deposit maintained with Supra.
*   **Supra Router Contract:** To request and receive random numbers.

Step 1: Create the Supra router contract interface​[​](#step-1-create-the-supra-router-contract-interface "Direct link to Step 1: Create the Supra router contract interface​")
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Add the following code to the requester contract i.e, the contract which uses VRF as a service. You can also add the code in a separate interface and inherit the interface in the requester contract.

```rust
interface ISupraRouterContract {
	function generateRequest(string memory _functionSig, uint8 _rngCount, uint256 _numConfirmations, uint256 _clientSeed, address _clientWalletAddress) external returns(uint256);
	function generateRequest(string memory _functionSig, uint8 _rngCount, uint256 _numConfirmations, address _clientWalletAddress) external returns(uint256);
}
```

This interface will help the requester contract interact with the Supra router contract and through which the requester contract can use the VRF service.

Step 2: Configure the Supra router contract address​[​](#step-2-configure-the-supra-router-contract-address "Direct link to Step 2: Configure the Supra router contract address​")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Contracts that need random numbers should utilize the Supra router contract. In order to do that, they need to create an interface and bind it to the on-chain address of the Supra router contract.

```rust
contract ExampleContract {
    ISupraRouter internal supraRouter;

    constructor(address routerAddress) {
        supraRouter = ISupraRouter(0x7d86fbfc0701d0bf273fd550eb65be1002ed304e);
    }
}
```

Step 3: Use the VRF service and request a random number​[​](#step-3-use-the-vrf-service-and-request-a-random-number "Direct link to Step 3: Use the VRF service and request a random number​")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

In this step, we will use the “generateRequest” function of the Supra Router Contract to create a request for random numbers. There are two modes for the "generateRequest" function. The only difference between them is that you can optionally provide a client-side input, which will also be part of the payload being threshold signed to provide randomness.

\_functionSig- a string parameter, here the requester contract will have to pass the function signature which will receive the callback i.e., a random number from the Supra Router Contract. The function signature should be in the form of the function name following the parameters it accepts. We will see an example later in the document. \_rngCount - an integer parameter, it is for the number of random numbers a particular requester wants to generate. Currently, we can generate a maximum of 255 random numbers per request. \_numConfirmations - an integer parameter that specifies the number of block confirmations needed before supra VRF can generate the random number. \_clientSeed (optional) - an optional integer parameter that could be provided by the client (defaults to 0). This is for additional unpredictability. The source of the seed can be a UUID of 256 bits. This can also be from a centralized source. \_clientWalletAddress - an “address” type parameter, which takes the client wallet address which is already registered with the Supra Team, as input. Supra's VRF process requires splitting the contract logic into two functions. The request function - the signature of this function is up to the developer The callback function - the signature must be of the form “uint256 nonce, uint256\[\] calldata rngList”

```rust
function exampleRNG() external {
     //Function validation and logic
     // requesting 10 random numbers
     uint8 rngCount = 10;

     // we want to wait for 1 confirmation before the request is considered complete/final
     uint256 numConfirmations = 1;
	address _clientWalletAddress = //Add the whitelisted wallet address here
     uint256 generated_nonce = supraRouter.generateRequest(“exampleCallback(uint256,uint256[])”, rngCount, numConfirmations, _clientWalletAddress);

     // store generated_nonce if necessary (eg: in a hashmap)
     // this can be used to track parameters related to the request, such as user address, nft address etc in a lookup table
     // these can be accessed inside the callback since the response from supra will include the nonce
}
```

Step 4 - Add the validation in the callback function of requester contract​[​](#step-4---add-the-validation-in-the-callback-function-of-requester-contract "Direct link to Step 4 - Add the validation in the callback function of requester contract​")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Inside the callback function where the requester contract wants the random number (in this example the callback function is exampleCallback), the requester contract will have to add the validation such that only the Supra router contract can call the function. The validation is necessary to protect against malicious contracts/users executing the callback with fake data. For example, if the callback function is pickWinner in the requester contract, the snippet can be as follows.

```rust
function exampleCallback(uint256 _nonce ,uint256[] _rngList) external {
    require(msg.sender == address(SupraRouter));
    // Following the required logic of the function
 }
```

Step 5 : Whitelist your requester contract with Supra deposit contract and deposit funds​[​](#step-5--whitelist-your-requester-contract-with-supra-deposit-contract-and-deposit-funds "Direct link to Step 5 : Whitelist your requester contract with Supra deposit contract and deposit funds​")
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

It is important to note that your wallet address must be registered with Supra before this step. If that is completed, then you need to whitelist your requester smart contract under your wallet address and deposit funds to be paid for your call back transactions gas fees. The simplest way to interact with the deposit contract will be through Remix IDE. Go to Remix IDE & create a file with name IDepositContract.sol Paste the following code in the file:

```rust
interface IDepositUserContract {
	function depositFundClient() external payable;
	function addContractToWhitelist(address _contractAddress) external;
	function removeContractFromWhitelist(address _contractAddress) external;
	function setMinBalanceClient(uint256 _limit) external;
	function withdrawFundClient(uint256 _amount) external;
	function checkClientFund(address _clientAddress) external view returns (uint256);
	function checkEffectiveBalance(address _clientAddress) external view returns (uint256);
	function checkMinBalanceSupra() external view returns (uint256);
	function checkMinBalance(address _clientAddress) external view returns(uint256);
	function countTotalWhitelistedContractByClient(address _clientAddress) external view returns (uint256);
	function getSubscriptionInfoByClient(address _clientAddress) external view returns (uint256, uint256, bool);
	function isMinimumBalanceReached(address _clientAddress) external view returns (bool);
	function listAllWhitelistedContractByClient(address _clientAddress) external view returns (address[] memory);

}
```

Navigate to the “Navigate & run Transactions” tab in remix, and paste the deposit contract address into the text box besides the “At Address” button & press the at address button. You will find the instance for the deposit contract created using which a user can interact and use the features provided by the deposit contract. Following functions will facilitate whitelisting your requester smart contracts and fund deposits. “addContracttoWhitelist(address)” - The whitelisted users will have to whitelist their contract which they will be using to request for random numbers. The parameter this function takes is the User’s contract address. This function will be called after the user deploys the requester contract post development and makes it ready for interacting with the Supra Contracts. “depositFundClient()” - is another mandatory function for a user to use once, before the user starts requesting from that contract. This is a function which will deposit funds in the deposit contract from the users for the response/callback transaction. The funds for a specific user should remain higher than the minimum amount set by the Supra( 0.1 Eth for Arbitrum testnet) for the new request transactions to be accepted.  
Basically the gist here is that the user will have to interact with the Deposit contract and add funds for their accounts, which will be utilized for the response transaction gas fee. There will be a script from Supra which will be monitoring the funds and will alert the user if a refill is required.

Example implementation[​](#example-implementation "Direct link to Example implementation")
------------------------------------------------------------------------------------------

```rust
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
interface ISupraRouter {
   function generateRequest(string memory _functionSig , uint8 _rngCount, uint256 _numConfirmations, uint256 _clientSeed,address _clientWalletAddress) external returns(uint256);
   function generateRequest(string memory _functionSig , uint8 _rngCount, uint256 _numConfirmations,address _clientWalletAddress) external returns(uint256);
}
contract Interaction {
   address supraAddr;
   constructor(address supraSC) {
       supraAddr = supraSC;
   }
   mapping (uint256 => string ) result;
   mapping (string => uint256[] ) rngForUser;
   function getRNGForUser(uint8 rngCount, string memory username) external {
      uint256 nonce =  ISupraRouter(supraAddr).generateRequest("myCallbackUsername(uint256,uint256[])", rngCount, 1, 123, msg.sender);
//Can pass "msg.sender" when calling from the whitelisted wallet address
      result[nonce] = username;
   }
   function myCallbackUsername(uint256 nonce, uint256[] calldata rngList) external {
      require(msg.sender == supraAddr, "only supra router can call this function");
      uint8 i = 0;
      uint256[] memory x = new uint256[](rngList.length);
      rngForUser[result[nonce]] = x;
      for(i=0; i<rngList.length;i++){
         rngForUser[result[nonce]][i] = rngList[i] % 100;
      }
   }
   function viewUserName(string memory username) external view returns (uint256[] memory) {
      return rngForUser[username];
   }
   }
```

Going further with Supra[​](#going-further-with-supra "Direct link to Going further with Supra")
------------------------------------------------------------------------------------------------

If you want to take the next step, consider registering for the [Supra Network Activate Program (SNAP)](https://join.supraoracles.com/network-activate-program).

The Supra Network Activate Program (SNAP) offers companies discounted oracle credits, technical documentation, and customer support to embed much-needed oracles and VRF/RNG. SNAP supports Web3 scaling and growth to buffer costs which could typically inhibit a company’s success.

The SNAP program is partnered with some of Web3's most prolific names who are helping with project selection and qualification.

Connect with us![​](#connect-with-us "Direct link to Connect with us!")
-----------------------------------------------------------------------

Still looking for answers? We got them! Check out all the ways you can reach us:

*   Visit us at [supraoracles.com](https://supraoracles.com)
*   Read our [Docs](https://supraoracles.com/docs/overview)
*   Chat with us on [Telegram](https://t.me/SupraOracles)
*   Follow us on [Twitter](https://twitter.com/SupraOracles)
*   Join our [Discord](https://discord.gg/supraoracles)
*   Check us out on [Youtube](https://www.youtube.com/SupraOfficial)

---

# Trellor | Arbitrum Docs

## Trellor

[Tellor](https://tellor.io/) is a decentralized oracle network that incentivizes an open, permissionless network of data reporting and validation, ensuring that any verifiable data can be brought on-chain. It supports basic spot prices, sophisticated pricing specs (TWAP/VWAP), Snapshot Vote Results, and custom data needs.

### Querying the price of $ETH through Tellor[​](#querying-the-price-of-eth-through-tellor "Direct link to Querying the price of $ETH through Tellor")

Here’s an example of how to use a Tellor data feed to query the current price of $ETH on-chain. The way it works is that a query is crafted asking for the price of one currency against another and sent to the oracle contract. If the information for that query is available, it will be returned. Oracle contracts can be found on the [Contracts Reference](https://docs.tellor.io/tellor/the-basics/contracts-reference) page.

Tellor provides an npm package with the contracts needed to query the contract. We first install that package in our project:

```rust
npm install usingtellor
```

Our function will just wrap the call to the Oracle contract with the query we are interested in. In this case, we want to obtain the “SpotPrice” of “eth” against “usd”. We will request this information to the Arbitrum oracle contract `0xD9157453E2668B2fc45b7A803D3FEF3642430cC0`. We’ll use this example contract:

```rust
contract ARBPriceConsumer is UsingTellor {
    /**
     * Network: Arbitrum One
     * Aggregator: ARB/USD
     * Address: 0xD9157453E2668B2fc45b7A803D3FEF3642430cC0
     */
    constructor(address payable _tellorAddress) UsingTellor(_tellorAddress)
    {}

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (uint256) {
        bytes memory _queryData = abi.encode("SpotPrice", abi.encode("eth", "usd"));
        bytes32 _queryId = keccak256(_queryData);

        (bytes memory _value, uint256 _timestampRetrieved) =
            getDataBefore(_queryId, block.timestamp - 20 minutes);
        if (_timestampRetrieved == 0) return 0;
        require(block.timestamp - _timestampRetrieved < 24 hours);
        return abi.decode(_value, (uint256));
    }
}
```

You can adapt this contract to your needs. Just remember to use the ticker of the assets you want to request the price for and to **deploy your contract to the appropriate network, with the address of the Oracle contract in that network**. Remember, we have a [Quickstart](/build-decentralized-apps/quickstart-solidity-remix) available that goes through the process of compiling and deploying a contract.

### See also[​](#see-also "Direct link to See also")

*   [Tellor’s documentation](https://docs.tellor.io/) demonstrates how to query price feeds and other data feeds.

---

# Circle Paymaster quickstart | Arbitrum Docs

## Circle Paymaster quickstart

Gas fees are often a barrier to entry for users interacting with apps that process transactions over blockchain networks. Typically, these fees are paid in the blockchain’s native token, like `ETH`, which adds complexity for users who primarily transact with USDC. Circle Paymaster simplifies this process by allowing users to pay for gas fees directly from their USDC balance.

What is Circle Paymaster?[​](#what-is-circle-paymaster "Direct link to What is Circle Paymaster?")
--------------------------------------------------------------------------------------------------

[Circle Paymaster](https://hubs.li/Q034mZmH0) is a smart contract within the Account Abstraction (ERC-4337) framework that sponsors gas fees on behalf of users.

### How Circle Paymaster handles transactions with a bundler[​](#how-circle-paymaster-handles-transactions-with-a-bundler "Direct link to How Circle Paymaster handles transactions with a bundler")

Paymaster is operated by Circle and integrates seamlessly with bundlers such as Pimlico and Alchemy, which facilitate transaction bundling. A bundler is a service that collects user operations, combines them into a single transaction, and submits it to the blockchain network for execution, optimizing gas usage and efficiency. Below are the sequential steps outlining how Paymaster processes a transaction, with references to relevant contract functions:

1.  **USDC Balance Verification:** Paymaster uses the `balanceOf(address)` function of the USDC token contract to check whether the user’s balance is sufficient to cover the transaction and associated gas fees.
2.  **USDC to `ETH` Conversion for Gas Calculation:** The `fetchPrice()` function retrieves the real-time USDC to `ETH` conversion rate, ensuring accurate calculation of the gas fee equivalent in USDC and preventing overcharging.
3.  **Transaction Authorization with Bundlers:** The `_validatePaymasterUserOp()` function processes an EIP-2612 permit, which authorizes Paymaster to deduct the required USDC amount from the user. The permit is signed off-chain by the user and submitted with the transaction.
4.  **Gas Payment Processing:** The `_postOp()` function debits the required USDC from the user’s balance and handles the exchange of USDC for `ETH` using the `swapForNative(uint256 amountIn, uint256 slippageBips, uint24 poolFee)` function. The bundler then processes the transaction on the blockchain.
5.  **Transaction Finalization:** The bundler confirms the transaction completion and Paymaster ensures all balances and gas payment records are updated accordingly.

Key functions involved in this process include:

*   `balanceOf(address)` – Retrieves the USDC balance of the user.
*   `getPrice(address token1, address token2)` – Fetches the exchange rate between USDC and `ETH` for accurate gas fee calculations.
*   `processTransaction(bytes calldata userOperation)` – Manages the transaction execution and gas fee deduction.

The paymaster contract addresses for Circle Paymaster are as follows:

*   **Arbitrum Mainnet:** [0x6C973eBe80dCD8660841D4356bf15c32460271C9](https://arbiscan.io/address/0x6C973eBe80dCD8660841D4356bf15c32460271C9)
*   **Arbitrum Testnet:** [0x31BE08D380A21fc740883c0BC434FcFc88740b58](https://sepolia.arbiscan.io/address/0x31BE08D380A21fc740883c0BC434FcFc88740b58)

These addresses are essential for configuring and interacting with Paymaster in your application. The paymaster interacts with the blockchain network to cover gas fees by leveraging off-chain signatures that authorize the paymaster to spend a user's USDC balance. It calculates the required gas, converts it into an equivalent USDC value, and then deducts the amount from the user's balance while ensuring the transaction is processed seamlessly on-chain without needing the native token.

Why use Circle Paymaster?[​](#why-use-circle-paymaster "Direct link to Why use Circle Paymaster?")
--------------------------------------------------------------------------------------------------

1.  **Improved User Experience:** Users can interact with your app using only USDC, eliminating the need to acquire `ETH` for gas payments.
2.  **EIP-2612 Permit Support:** Paymaster supports EIP-2612, allowing users to authorize gas payments through off-chain signatures, reducing gas costs.
3.  **Reliability from Circle:** Backed by Circle, the issuer of USDC, Paymaster offers trust and operational reliability.
4.  **Deep Liquidity:** Paymaster is funded with deep native gas token liquidity, ensuring consistent transaction reliability.

Here’s a step-by-step guide to building an app that uses Paymaster. You can fork and run the code directly from Circle's Replit [link](https://replit.com/@buildoncircle/Circle-Paymaster-Wallet?v=1)—feel free to check it out!

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAnAAAAD0CAYAAAAbrRtEAAA5kklEQVR4Xu3dd5gU1Z7/8d/fIDkJIqgXAcWIAbOiclUEFTMq14SyZrkoAoIoSDZiQMWEXhHMJMUEIiYQ9V4DkqPEZcksadnz2/dxv7WnDz0wAzTTU/N5PU89VXUqV/dUfeac6u7/50RERESkRPl/cYGIiIiI5DcFOBEREZESRgFOREREpIQpcoD77//+b99t27ZNnTp16tTlSWfXZpE9Rff74usK8/dcqABnL+CWLVvcokWL3OLFi9WpU6dOXR51XJtXrVrltm7dutMLv8iO8P7hffTv//7vuucXY7ds2bId/j3vNMDZC8mK1q5dG08WEZE8snTpUrd582b/T7dIUXHP/6//+i+3ZMmSeJIUA/t7zhbidhjg7IUkCWZbWERE8g8X/U2bNinESZFxz/+P//iPuFiKEbWgvC6xHQY4/vg3bNigi4CISAlDDcqOml9EYrxXqO3hHwDJH2Qw/iGL/5YLDHDMyDNveiFFREoeruHUpGT7z10kG6u02bhxYzxJitn69eu3q0wrMMAxIwv853/+ZzxJRERKAGrh+EdcpDC4769bt04BLg/xGYT4n7EdBjg+0RQnPhERKRmWL1+etelFJBsFuPxVpACnBxlFREo2vgaCVhQFOCkMBbj8pQAnIlKKKMBJUSjA5S8FOBGRUkQBTopCAS5/KcCJiJQiCnBSFApw+UsBTkSkFFGAk6IobICLg0Qo/u5B5rUuxvb4lHS29+eOlgvtjQ9ack7CL8bml6nKlCnju6+//jqaOxN/g8z317/+1ZUrV86tWLHCl5cvX95VrlzZVahQwe2///7RUttTgBMRKUUU4KQoChvgqlatmgyvXr3ahwuCG0Hl+OOPd/vuu6976aWX/PR99tnHHXbYYe6QQw5xZcuWTd6LkyZNcgceeKA76aSTfLCZM2dOss5wuQYNGrgaNWpkTDN8Z90pp5wSF+9RBKyLL77Y3XTTTe7QQw/1Zc2aNfP5qDABrm7duq5Xr15++I8//nDdunWL5nB+PRzLjijAiYiUIgpwUhS7E+B+//1317p166Sc4IVatWolZYS8M888078fCS0hgk7IlscJJ5yQDI8cOdL94x//8MNhgJswYYJ7/PHH3ZQpU/z46NGj3bfffus+/PDDZNlp06a5l19+OalJY5kXXnjBf+etLRNjPwv6LsXCBLg333zT17Bx7AS5r776KpnGuWb/4nORjQKciEgpogAnRbE7AQ5t2rTxYYSQZvkhDHBgOtOOOeaYjPIY81H7Rb9Ro0a+jBo5ssmaNWtckyZNkgB3yy23+N9sx6mnnposz3EMGTLEdenSxb3xxhu+D2oC//Wvf7mZM2f68aOPPtqtXLkyWUfotdde8+s64IAD3GeffZYxrTAB7rvvvvO1ic8884yvhZw+fXoy7d133/XnLA6v2ez1AMeb4YMPPvAnLt7wnsQL8csvv2Qd54VmPBvKeYF5EefNmxdPLhBpnGVJ1HsCb8LXX3+9wJQvIrIrFOCkKAob4Hh2y8ydOzcJcOb7779PapWyBTjmj5/74kunQ2ENXIcOHXwt2fDhw93BBx/s13HssccmAY73+BFHHJEEPlifgHnrrbe6K6+80s2aNStZ5+233+7nsa6gnADuzewf84X3/cIEuOrVq/u/Q/B3yH7HaHL+6aef4uIMezXAWXt42O0J/DoED/+FeDjQ1k/aDrd33XXXFbhtyjlpjRs3dhdccEE82eONTFoPzZ8/3y9Le3Y2VCWTuAvL9lcXWRHZkxTgpCgKG+DCe+oNN9zgNm/e7Nq3b+/uueeepJwwhTDALViwwA0ePNgPh+uw58lCYYDjvs4+2X2SHEANngW4evXqJc+Q1a5d2/dtfRbgevbs6QMgeKaOyiVrSm3btq3/2blsODarXGGd4blhPA5wlF177bXJeM2aNX0zLfgAQ8uWLf1w+DfJMvEzgLG9GuAmT56c8eAhLya1XJx4DoKdJblj6dKlvvrSUMX41ltv+XJwEaIm7ZtvvvHVkRwsnwIxloxB9akFItCn2pKTNW7cOF8Far/vyrQ4wPFJk1GjRiX/Ufz222/bbS8McJTzJuB4ODY88cQTGcuwfxxT+AkW3hQjRoxIPs1i8y5atMiXh+eD5d97772MMt5sX375ZTIuIhJTgJOiKGyA415s99nwPn/QQQf5Mj6U8Omnn/oym49KDWqaDPd0KkeYFtboGVuOeWy5+vXr+zI+/ECzowW4v//978m8559/frI8LMCBpl/K27Vr58fZT8Zt/bZMqE6dOr7SqGLFiu6pp55Kym3/6B544IGM8jDAcU5tO3RkDLA+K2vRokUyf0H2aoCzhxStI6XjnHPO8ePWrkw3aNAg3yf4XH/99T5N86CiLUdVK8Mk1yuuuMIP84mQeFuEIvqENPqkZvo04fLC9unTJ6NGjn4Y4HjDUUa7NCf8qquucldfffV22wsDnB0DgdOWPe200/zwzTff7Pu8OW677TY/zItHn0DbtGlTd/fdd/tx+lS18gZ7/vnnfRnVvbTZU87DmZQtXLjQ92mPJ9UzHL+oIiJQgJOiKGyAK23y4fGmvRrgwEE/+uijviqUoMGnLSzAwYIZ6N9///1+eODAge7000/3ZZdffnnGfDyvZsMhyqi+pU8qJwhRRco4+0G4I6Vb6rVlwgBn2+zevbvfJiErrN0zcYAbO3Zssj72nY9Ph9tg3ayTYT6BQr93797J+mxeLrJ8uoYHNSn74osvfP/jjz/20+3Fo4xjsXVSSygiElOAk6JQgMtfezXAUa3JJ1EMDxhSvRoGOKomw6BDgOP7Vg4//HD/UWDKePCwMAHOqlBtGrVt4Th9whW1WmFZGOD4qDJltJNbV5gAZx+YsG3EAe7OO+9M1mf7TzOpsXkJnVRHT5061ZfRtk7/nXfe8dOplbRaRT4Kbeu0ByRFREIKcFIUCnD5a68GOJ7RImgQ3AhIFnR2FuAIbyeeeKJ75JFHfBmBjgBXpUoVPx/PmlFO02ZoxowZvpzAZxhnXTbMd7zQdh5uMwxwH330kS97//33fXs9gcoermzVqlWy3p0FOL73hWE+5kyf9n3a3BnmuT76Vqtmy1mfBzD/9re/+WFqLPv27etrAmnCDbfJg5GEOIbt2TsRkZACnBSFAlz+2qsBzvDRXD48UBTxd63EuCjxaZai4gMQhUG4Cj8qTBMlb+qi4Fk1w8XTvlxwZ3744Ye4yL8Wn3zyScZFmDJ7SFREJBsFOCkKBbj8VSwBTkREiocCnBSFAlz+UoATESlFFOCkKBTg8pcCnIhIKaIAJ0VBgONbHPiuVskv/BKFfZesUYATEUkpBTgpCt4nfFdptt8EleLDhx+pFVWAExEpJRTgpKj4AB+/XqBvN8gPNJ0S4PgKsfjvWAFORCSlFOCkqKjl4Yvv+XlHftqRZ+IoU7d3O5qyOf+Et2zNp8h5gOP74Ar60ffiwIXMfgtVSqbwN2GzjWfDf5RFxfvWfhMXO9uOXeh2hHXQ8d/tzuYV2V0KcLIreL9Q40OI4NpJFlC3dzvOO8GN16Gge0VOA1yHDh3csGHD/A+xM7wrOnfuHBftFm6c/HqBZGc/Z7a38b1+fJFyYdgPB3fs2NH3C3pv8V8kvyGLBx98MJpaMEIb6+Sn2Hr27OleeeUVX96tW7fMGSMvvvjiTv9mWO+rr77qv4SZn36zL4HOpQkTJsRFUkoowMmu4j1DcCAL0Kyqbu92nHfO/47+dnMW4Lhw8LNRxr7I9u233/Y3FKoGeVhyyJAh/hcSDL8+wA2T7RO2uOFNmzbNT+MH47Pd5KnqZT1ffvmlH//+++/9zZubJAkWPADIOJ+uCQMcJ4r1M40HN/myX27cht85ZdqaNWv8OL/4wC8thPPwA/b8fJbhlxoYZ70cIzjuoUOHZrwYrNO+tJhy+3UGjsV+aovzYB/ptuPjp7UIxvyKhGHf2U875/zsFr8oQXjmGJlmtUm8roQN+yJgjmXUqFH+C5c535MnT07Wa9OZf/r06X6cNxX7yOth4/yGaxgU2D9eS5tuOF72h/MxZswYvxwGDx7sfzfX8P6w33hlXvBacgycb5YlAIF9Zlv2m7SG5QhdvOYEOPYpfN04Zo4jxvrCj9F36tTJ91kf5479IoSB88z7lf0KAxzHyfZiYdjkPNg4rzfL81NvP/74o38P4ddff/VV6Gyb9z4/r8bPu/F62nuJ+cPXnv/YWBe/u4vHHnssOYe8v5nXXhPKGWdfJH0U4ETSK2cBjp/CyoYbFs2qhBer7SHkEE64KdovHoQ3ZxvnIkSVLrUioYceesj3WZ6aHG6ohELmt+WtzzxhgONGHc7Dcb/wwgu++pK+BbB4PQRSAgM/dWUXR36gnl9geO6555J5ubE/+eSTyTz33nuv7xuOi5sp5eH+2s2dIGpNd4MGDfJ9yq2d3NhyBArWYzWXhDGCUbjurl27+j4B7Pfff3f33Xef30/WFwYMEFht35kPNg/LEDAYZ57x48e7L774IhnnxsFxheGgf//+Geec13vSpEk+HMbhnHl4r9j6nn/++aQcYQ0c+05Y5XgM27cauC5duvg+NV6EON579p069l4z8bhhO7Nnz3a9evXy46yTsGTTLMAR+Aib4Tk3jPN+6Nevnz83c+fO9efEXsvu3bv7vr1PbHnrM92C+7PPPuvPG+cc9vrYeeFXPXgfW5B++OGHk18Iidcr6aQAJ5JeOQtwYU2HCW9o1ARwo+SmQ0foInwxnRtgHODo27x2ozJMY35uevPmzfPrsufcmEZIIFyBQBYHOGoobF68/vrrvvaPddh2bRo3XxBsqAWi1snm4QbJzdRqsKiBsea4gvaddXCjjY/XhsMAxw07nsd88803yXZgAY5zyjZgy3F+ucnTUZsU7lO8bnvNmJc+gcVCBnifhM2uhLWwqZFldhTgQK1StgBHUOcfAbb52muvJctYP25C5T0V/mRZGOCsCZXzweu/o9ckPgdWs0U5AY6aTcRBzwJcvG4LiojXDWrd7BzbOi3YWw2lLcd71d7bTzzxRPL68N6nzzj/HLE842zbAly4T3SEu2z7I+mhACeSXjkLcAQPqzECNVWwGwahxG783OC5eTONmxbLxoHGauCY1qNHD1+GqVOnJqGKAMWP3ccBLuxTQxUHOLvJ2zwW4GycbdpwHOCsnH0jcND0ZU2BTCPAEULsAprtmT7mo9nXhhHWwHGMsOCU7aZr54umSEJZQQGOAELtD3hNqJHaUYCzcBuGb+sThidOnJiME8JoJmbcauAYtuZwEDSyBTjOZ9iUDsKx1URxfE8//bQftmV3FuDYjtUExwGO2jMLlvFrwvvr888/98N2DLDzZ/+csJytg/20AMd+WZP7zsJhXGavI+GK9zM1zuE8cYDjtSQA2jz8/dg2ed9Qy2oBjvcn+w+rPcy2P5IeCnAi6ZWzAAduaNwg6AhVCG8YPEvGuN20eCaL8QEDBiTz0RzJfIQDyrhRclEK2TaopSFQ0EwaBzhCAsNMs2e3QAjhRhjOS60HgYNmXcqoveOmyM1x4MCBfh4LcAQm5uGGaMfB+hnmYXvWbzdKOqu9CXGjNgRAO07CG1gXXbyfIZp7KbfmPQslNJnZDdyWY92sj+efePYqDBmcwzB4U3vJcqzPgq4FVwtXBCfG7cMFNGMyTk1f2MTI/ITbOMBRe2ghOf60qIV1ptGcasPgGGz/wH5QmxlimzTtxgGO5ayWimfIYgR1pnFu7O+A8TDAEd5sHTxPx3OPNi/HTrk9t2jC4zb8w2DnuE+fPkl5OK8N8xrY83m8H+z46Ti3nCOCMOMWUu09Bf4JYNjeh9n2R9JDAU4kvXIa4Eojakyogfn2228LdXPkAwmFmU9KF/5psdpekV2lACeSXgpwOUCIo9ajMBdNaoTCZ6REYJ9CFdkdCnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6ZXTAMc6NmzYoK6Ed1u2bIlfWhEpARTgRNIrpwHOAsD69evdunXr3Nq1a0ttx/FzHuJwVFI6hTiRkkcBTiS9chbgNm3a5G/8BJc1a9boAvI/LMiW1CAnIiWLApxIeuUswHHDJ6isXr06nlSqbdy40Ye4OByVhI73hIiUHApwIumV0wBH06Ga3ra3cuXKElkLp9dSpGRRgBNJr5wGONW+Zbd8+XIFOBHJOQU4kfTKaYBbtWpVXCz/Y+nSpSWyGVUBTqRkUYATSa9iD3BVq1Z1559/vp+3TJkybsqUKfEsO8VyhcF81atXj4v3KGrWzjzzzLg4w5IlSwoMcIsXL3aTJk1y3bt3dxMnTvTD8TxF7Z5//nl/fuPyonYKcCIliwKcSHoVa4AjrFSqVCkZp2aqT58+7uyzz3Zdu3Z1Rx11lNu6daurVq2aO/LII/3wtm3b3OWXX+7D2FVXXeWXY7hRo0Y+YJx88sl+fO7cucl6zZNPPpkR9ghSlStXdlWqVPHjNPnut99+rnnz5v6Ct3nzZtegQQPXpEkTPxxq3769vziy3UsvvdTts88+vvy4447z2xg/fnzG/KEdBTjrOA+cf4b79evnhgwZ4st++OEH16FDB3fvvfe6FStWuM8//9z9+OOP7p577nH//Oc//fwTJkzw83zxxRd+Owz36NHDD/ft29eP29ebPPfcc65jx46FatJVgBMpWRTgRNKrWANcz5493aOPPhoXu/r167suXbr4gEFAAsMEo8cee8yNGDHClxH0YKGsYcOGbtasWX64QoUKvm8efvhh/9UmhCFqt8ByhBLC2ZgxY/w4QebBBx90zzzzjB8n1E2fPt3VqVMnY31XXnmlD6DMwwWSdROOdrcGzrowwN1///1+/xi/7777fBnb7t+/vxs1apSflzKCWdgfMGCA73PM9Hv37u1mz57thzt37uy/3oV5C1s7pwAnUrIowImkV7EGuFdeecVdcsklGWWEBAKcISCFHWGrdevWvlbOar0swMXzhqhla9asmTvrrLNcxYoVfU0etW2GC5zVxJny5csnw/H6wgBnqAXLVYAjwDI8evRo99BDD/ngxTwEOKt5s+BGrRrDw4YN8+MW4CgLOwJct27dttt2QZ0CnEjJogAnkl7FGuBQtmxZH2hwxhln+FqjMMBZyLKARWCy9do0C1E1a9Z0c+bM8cMEPPPRRx/5ZldzwQUX+D7LEeTw4osv+nGaaYcPH+5rAC0wLly4MNkGoQjU8GULcFwsaXLdkV0JcFZO7SH9cePGuV69evkA9/PPP/syaxq1Wjpq3NiOBThqFmlaZphmUwIcTavxtgvqFOBEShYFOJH0KvYAR0AiiBGEXn31VV8WBjhCg9WoEUZ4To5hwtzQoUN9jRcP+lvYql27th+2ZlbUq1fPzZs3LxlftmyZ69Spk/86D2rxLIQRfghmp5xyir/g0SzKtLp16yZfYss4z+1Rc0UQCwMcwQm1atXy0wtS1ADH84BWTpgjqE2ePNn3aVoNAxz9zz77zA+/9NJLfpymVvocH8GUaTw/xzjN2PG2C+oU4ERKFgU4kfQq9gBXGhUmwOVjpwAnUrIowImklwJcMdD3wInI3qAAJ5JeOQ9w8ddvyJ9NuIX52o586xTgREoWBTiR9MppgOMheZ4zk0ycVwU4Eck1BTiR9MppgKOZkIfluYjIn/jkKsE2DkclodNNQKRkUYATSa+cBThw0yfE0ZTKc198Hcf8+fNLXbdgwQIf3LiYEt5KYu2bmsJFSh4FOJH0ymmAYx3c/AlxfGUFv2pQWjuCG+dB4U1E9hYFOJH0ymmAM3w5Lt+ppq5kdQQ3XfhFSi4FOJH02isBTkRE9j4FOJH0UoATEUkpBTiR9FKAExFJKQU4kfRSgBMRSSkFOJH0UoATEUkpBTiR9FKAExFJKQU4kfRSgBMRSSkFOJH0UoATEUkpBTiR9FKAExFJKQU4kfRSgBMRSSkFOJH0UoATEUkpBTiR9FKAExFJKQU4kfRSgBMRSSkFOJH0ylmA44JRpkyZpPvyyy/jWYqkXr16yfC2bdtc2bJlk3HWv379ej981FFH+YtWrFq1ahn9GMvFuPCx7mzi8q1bt7rRo0dnlImIFCcFOJH0ylmAmzZtWsZFo0KFCr6/YcMGt3LlSrdlyxa3adMmN2fOnGQepv3yyy/JcuvWrXNLly714axmzZp+GWMBbsyYMW7EiBGuRYsWftyCFeuaOnWqPw7EAY7pc+fO9WHQlmN7oQYNGriffvrJLVmyJClbtWqVn8+2w/Jsh/UR4DZv3uw7C5HMT2dYNj7mmTNnJuMiInuKApxIeuUswKFKlSo+6Nx6663+IkIAsyBH+YwZM/x29ttvP9epUyc3YcKEZJr1V69e7Ydr1ar150r/V//+/d3YsWPdvvvu68eZl/B35513uscee8yNHDkyKUcY4ObPn+/ee+89P05I27hx43Y1aqhUqZLvs38YOnSoPw4CWriPYHsEuD59+rhzzjknCXlcOJn/3/7t39ybb77pnn32WT//BRdc4L777jt32223+fEmTZr4vojInqIAJ5JeOQ1w4MLx9NNP+zBDgDv66KN9uQU5EMKoZbvmmmtc5cqVtwtHiAMctXgXX3xxMs8RRxzhOnfu7EMcbrzxRj8tW4AbNGhQMo1u3Lhx2wW4G264wdWtW9c1b97cT1u+fLk7+eSTk+kVK1b0/Xbt2vk+58sCHMES4TbKly/vm1k5bmoPJ0+e7JepXbu2n27LiIjsKQpwIumVswDXtm1bX/NkqI0jwDVu3NiPxwGuRo0aSdOihaly5col88QBDsxHOMSkSZOSkEZtFk2fNg/CADd+/HjfdIkhQ4b4JtI4wIXbfuONN9wVV1zhunTpkpTZ/Icccojv0xxsAe6LL77ImAePPPKIr6VbtmxZ8nwg+zhx4sTt5hUR2RMU4ETSK2cBDhdddJEPJnwAgefACHDHHHOMnxYHuN9++83PW716df+8G8IQRTMmNXShVq1aZYREmi5BbRnratq0qd8ex8F6YUGOmkDm6datmx8fMGBAEqJo6rzyyiv9sGEatYT0aVq1faTZlzLm//DDD13fvn2TpuAVK1b4aXT2/B61eozzjCCo1WN8ypQpf25IRGQPUYATSa+cBjgRESk+CnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6aUAJyKSUgpwIumV8wDHF9jyhbaLFi1Sp06dOnWF6Ph1mDVr1sSX0yJTgBNJr5wGOIKb/WSViIgUHqGLILc7FOBE0itnAS78iSsREdk11MjtKgU4kfTKWYBbvHhxXCQiIkVE+Nq0aVNcXCgKcCLplbMAt7tV/yIi8iceR9kVCnAi6aUAJyKS55YvXx4XFYoCnEh6KcCJiOQ5BTgRiSnAiYjkOQU4EYkpwImI5DkFOBGJlZoAt23btrgoqz15oSvsNveGVatW+Qu52Z1929myK1eujIu8bMtlKysOhX3dt27d6o+Pv4/QnvjSVZGCKMCJSCwvAlyZMmVclSpV3IgRI+JJCeYpW7asO+ecc5KymjVruooVK/rOPPbYY65cuXLugAMO8OPz5s1zFSpUcA0aNHCHHnqoL+MmzDzhssy3zz77uMaNG7t77rnHlxF6mjRp4o4//vg/V/6/2BfKd+Syyy5zxx13nJ+Xiy9faMxwvL933XWXH2ea6devX8a44Rji74Rivl9++SWjLNa/f3930003uQ8//NCP16tXzx199NGuTp06GfOxrvXr12eUPfnkk65Ro0bJOPOwH5w/NG/e3J9fjmHZsmXJPDHK2C59OwaGDz74YF8ez7tx48aMstA111zjatWq5Q488EA3cODApJzlKlWq5N5++20/zvHF59swr4VH3nucD46J9wG/HhK+Vu+//36yXPny5d3dd9+93etw0kkn+X79+vWT5ew88F6pVq2aH+/Vq5cv+/rrr/32wv246KKL3F/+8peM88f55TiznVMpPRTgRCRW7AGud+/erkuXLj6E2E3q008/TaZ/9tlnvm/Tunbt6m677TY/TIAL8V1JFiyy2XfffX2fAPfCCy9kTDvssMPclClT/LBtizA4derU7QIcN/zwhrpw4UL33HPPuV9//TUps+k///yzvzET4Owmb7i41q1bN6MM+++/v583rMl68803XefOnTOCw8cff+zOPffcJMBxkSZsvPfee8k8nEv2l/6sWbP8PLZvHTt2TMIOofGDDz5wLVq0SJYlWBAoLMARAGfMmJFMBwEjfq1ZP98DGAYf89133/l1ho499tjk3PHacN55nQ3reuKJJ9y0adOSMmPH8sgjj/jAzTkj6IMAl+3G1aFDB1e7du0kOB1zzDG+P2fOHB8MCXCcsxjnkKBHf+3atb6M12DUqFHbvbY444wzfD8M+7a/BDy+7Jr3F4E0fF2GDx/u7r33Xj9s/4gQDNu2bfvnSqTUUYATkVixBzgLVQQobmDc1L766itfe3Xeeee5d955x0+3m9u6detc1apV/TABjlozOowdO9YvR0CwmzgIUSeccIK7/vrr/TghgZoU1mk3bwJW9erV3ZlnnpkRgBAGuGHDhrk+ffr4mpShQ4f6MgsWL7/8suvZs6cfJuw0a9bMBwHWbTVw7Cu1RHjmmWd8eGnYsKGvoTHUuHCchAkQLKjRI2BagOPCfNZZZ7lWrVolAY5j4nXjgh0GzP322y8ZDoPCnXfemZwTlkW4HDVrsAB3xRVX+H0n/Bx11FG+jABntUsWahh+5ZVXfPCKa78uuOACN2bMmIwy5rcmSWrkrAwPPfSQu//++/0wwc7mu/LKK92RRx6Z1NpyLmw5W5YAV6NGjYxjGj16tF8PIdkC3B133OGaNm3qj42mUKuBY5xu9uzZyfK8P8whhxzi/vWvf/l9CrcBAj3rAQGO9xbzEM7AMNN5r1qgtXXwPiLY81p16tTJ799PP/203Tak9FCAE5FYXgQ4ghehym5qOOWUU3xth7GbFyHBQp8hEHBj/eijj3zzHrhgEbbAjZqmwWy1c9RsEK6uvvpq16NHD7d69eokuJgwwLEfrHvBggXJ/l144YVJk5nVDhKICAPdu3ffruakW7duvk+Asxovwgi1W+zLU0895cvsmNlvthkGOCsLA5yFlzDEIAxwOOigg3y4ISC3a9cuI9RxPnDdddf54AsLcIRIa9rMFiasLJwWDj/77LMZTeCgefef//xnMm7zs3/cfAhJ4TH9+OOPfjpBn9fKAuLZZ5/tgzCvdbZ9430RHmcY4AhX1N6xL9RoFlQDhzDAheE0bGZGuA9WAxfuG317H1uAu/TSS33gZBtW83b77bcn/2RkOy4pHRTgRCRW7AHu5JNPTmqf7AbFxYaaKmrRLNDZtG+++caddtppfy78v3j2iho2asJOPfXUpJzAECKczJ07N6OMmyO1XXHosO0iDnA33nij78KbMah1u+WWWzLKOIfxM14jR470fZrieDYNLVu29M2Lr776arL+ypUr+9eBsBZ2sGHOEX0u0nbTj8UBzlC7NXjwYF/L89e//tVv8+KLL3ZLly71Yci2wbHwLJzVhCFbmAjPRxz0xo8f78NYiOBt4cTwurMfvMbUZvJMYvhaxGz9hGRqvcKyEDVaBL7wmOhzfq0WEvbaFybAhfNYrSp4/1KLauImVM4v/YkTJ/oyao1D/EPTunVrP8x8rI8wbTXNUvoowIlIrNgDHAgh1D4QHkBwAbVtYdMetTfUetjFiJuyPfBvnwKkeZXgZqGFJitqyB5//PHkxj558mT3wAMP+Fo3q21jnJqQt956KwmU1PJcddVVvoaGPsLnt+xmzv6/8cYbfjkLcPahDI6FWjieN7v55pt9aAoDBsfzj3/8IyP8mM8//9wHUxPWwJmwBo6mTZpFX3/99eS8IQ5w1MBR82bnmeXs/FETSu1byGqXeMaQmkKCkjVRE1xokuQDIoRrcAxs48QTT0ye5aKMJljr4jICSps2bfy+w5qBeQ3o06xttZvsAx80IVBajSGhi31g3+15NI7r6aef9q8LNWyhsAaO9VNbS/MtHyqxJlTbN15bEwY43lu8N3gPhk32bM9qCkGAI5RSY2uhj9DIM3Ksz5515HzxoYzwPcD8AwYM2K5WWEoXBTgRieVFgBMRkYIpwIlITAFORCTPKcCJSEwBTkQkzynAiUhMAU5EJM8pwIlITAFORCTPKcCJSEwBTkQkzynAiUhMAU5EJM8RxHaFApxIeuUswMXfVyYiIkXHdzPaT8gVlQKcSHrlLMDZl6SKiMiu251/hhXgRNIrZwEONKPu6n+OIiKl3eLFi+OiIlGAE0mvnAY48JuYBDn+i1SnTp06dTvvCG78xvPuUoATSa+cBzgRESkeCnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6aUAJyKSUgpwIumlACciklIKcCLppQAnIpJSCnAi6ZXTAPfDDz+4xo0bu/r167vu3bvHk/eYxYsXu9NPPz0u9o455piMcS5oAwcOzCgTEUkjBTiR9MpZgFu/fr27/fbbk/FVq1a5Xr16BXNkt2LFiozxrVu3ZoxnU6ZMGXfttdfGxR7TzLJly9ySJUtc165dkzK7sHGRC1G+bdu2jPGNGzcGc4iI5DcFOJH0ylmA69evX1zkKlSo4Fq1auXmzZvnWrdu7fbdd19fTsjq0aOHq1y5snv33XeT0EW/T58+7sADD3S//fabD3fVq1d3559/frJOAh7rWb58uXvttdd82VtvveXq1q3rLrvssmRdVatWdV999ZUfJ8Cxztq1a7sLL7zQHXfccW7MmDHurLPOcv379/frZ7sM16tXz/fbtm3rBg8enNOaRBGRPUkBTiS9chbgWrRoERe58uXLuzlz5rhrrrnGBykCHQhSBDhCFJhGMNtvv/3c6NGj3YgRI9yhhx66Xe0caKL9+uuv3bRp01y1atV82RFHHOG2bNnih1kXNWkEOsycOTMJcKtXr07mYTt0DN90002uYcOG7tNPP/UXvhdffNHVqVPHjRw50s8vIlISKMCJpFfOAhxNpl26dEnG//jjj6TpkpDUvn17d8stt/jaLi4wBLjvvvsumc72CXBg+pAhQ7IGuLCJtGnTpu7jjz92xx9/fNIkatMrVark++PHj08CnLF5uMg99dRT7uWXX/bb5xiY9vbbb/smYbpweyIi+UwBTiS9chbgQC0WTZBHH310RvChhuvnn3/2FxYrjwMcaN6kho2m1enTp28X4Khle+mll5LxqVOnuho1ari1a9f6dbB9W1ebNm1cy5YtfXNrHOAeeeQRd/bZZ/taOsIbIY7pzZs3dwcddJAbO3asq1Wrlq9VvO+++5LlRETymQKcSHrlNMCB9WzatCkuLjSW35WLT7Zl4g8qhAiD4YcW2K41w4JpmzdvTsZFRPKdApxIeuU8wImISPFQgBNJLwU4EZGUUoATSS8FOBGRlFKAE0kvBTgRkZRSgBNJLwU4EZGUUoATSS8FOBGRlFKAE0kvBTgRkZRSgBNJr70S4PhZLH4IXp06derU7bzjuzP3ROhSgBNJr5wGOJbn56dERKRoCF1LliyJi4tEAU4kvXIW4LhgUPMmIiK7bndCnAKcSHrlLMAtXrw4LhIRkSLiJ/x2NYApwImkV84C3O781ygiIv9nxYoVcVGhKMCJpJcCnIhInlu+fHlcVCgKcCLppQAnIpLnFOBEJKYAJyKS5xTgRCSmACcikucU4EQkpgAnIpLnFOBEJJYXAe6ZZ55xZ599tv+4/M6ce+65yfCll17qx8OyoUOHun322ce1b98+KbN56AYPHpyUx+bMmZOxrqI477zz/Dkzd911lytTpowbMGBAUsaXGl9zzTVu5cqVfpwLa8uWLf189rUrGzZscDVr1nQHHnhgcg5t31l2y5YtvoxtnXbaae6QQw7xyxj24/XXX0/GMWjQIDd79uxknIv55Zdf7tauXevH6Z9++ul+P959911f9sknn7hHHnkkWQZff/11xrkE2z7iiCN8Z66//vpkHm4gYH979+7t98XccsstfpusNzR37tztXod4/Mknn/Svs33XYLhvbD/EsRbGwoUL3dVXXx0XF+iSSy5JzmGI46xSpUrG9yAOHz7c3XDDDcl48+bNk/299tprk/LYiy++6M/RQw89FE+SUkQBTkRixR7g5s2b5w499FD3+++/u+rVq8eTM8yYMcPfzAxBJ8T0/fff3w/feOONSXm4zI6wTN26dePiQiFM3Hnnncn4zz//7Psnnniie+WVV/zP47Du/fbbzy1atMhPmzRpkps1a5Yftn0kiHCxZX4rsz7hzYYPPvhgN2rUKL8uK9u2bZurXLlyxjEw7Y477nA//PBDRlm5cuWScEVos2E7p9kC3AcffJDsu6lQoYIPXIQVAg0IlfENg/n+9re/uXbt2iVln332me8TdsLvDeQYwteMsHb44Ye77777zo9/9dVXrlGjRn64Tp06vv/+++9n/dUPlqlfv35cnNWeCHAff/yxO+qoo/xr0aBBA1/297//3XXs2NG/9objK8wXXbMuEPi+//77aKqUFgpwIhIr9gBngYEAxE2NC02zZs38jXDChAnuzDPP9NO5CHETjwMcQcaC0zvvvOO6du3qh1nPyJEj/TDL9OjRw3eGsrfeesvXVtlNmLLp06e7X3/91Y9zg2W/vvzyS19ThjPOOMPv23PPPeeDJ7755hsfTJg3RHioUaNGsj4ceeSR24UgZAuZYYB74oknXOfOnV2rVq18GeGKGixqL6l1w7Bhw3w5tXdr1qxJ1rNgwYKMAIeqVasmoS3EsiDAsd3PP//clS1b1pcR4Dp16uT69OnjO4T7bcMEOILHddddl3HjYF1hgDOcI3uvjRkzxi8TrpftE84sEJ188sn+hkbNms1HgOP14L1jQY51nnLKKe7hhx9O1nXxxRf7QNulS5ekVo/XjX0jYFmAo0by5ptv9jW606ZN82Xsx8SJE31AXrZsmQ9wlSpVcuPHj0/2g31k/1u0aLHdaxoHOPaL8/jqq6/6ssMOO8y/fldeeaXv8/6zfSfgxuuT0kMBTkRixR7guHlzw6U2ihvpunXrfDk3K26Ohpsf+xTexGbOnOkvTISF7t27+wsV06lRItw99dRTfj7KCDAWYliGJs7Q/PnzfTMuaJoFN9GXXnopnM0vS20K89i+UAtEjQv7aM2j4OZbvnz5jItvtgD37bff+qAQOuGEE5IaKtt/Am3t2rV9GbVv1DZy0yfY2Xzsx9NPP50cOwob4AhPFpIIcG3btvXDRx99tFu6dKkPcB9++KGvCbLaoLPOOsvPx/m380FtKmgatMCJbAGOIETTsKFmENmCofVprmV/OHYrs/cqNZ/U9qFWrVq+WT4McMzPa2evH68ngQ7jxo1LAlwcllgvry/L0XRNkyYBzpp/+/fv7/uEO36InH884nXEAY7XnfM4derUJLTavlltdMWKFd17773nX694fVJ6KMCJSKzYAxw3NUIOwhsUN3ILcIQSphGUrB8iADZu3NgP80zWL7/84m/cv/32my+Lb3zUbPTs2TOj7JxzzvEBkpu/zX/33Xf72rYQ0zgvFhatzJYLn70Dz55RK2TiAEdwjPfviiuucL169UrGw+nVqlXbrizeD86dnVMUJsARIsIaRAIcQRXUVNE8na0JFTQ9Eqji40BYFgc4gk44/fnnn/fHZ69zvXr13D333JNxftG0adOMY45ZGeeBddFEa+8ZpvHaWcf73Gptf/rpJx/geL+F/zyA4Erot+V4fxHgOC8gNHOTpBawoH2LA1zYhMr6qOEL9w28t3kfx+dKShcFOBGJFXuAAzeuNm3aJE1aPAMFmgHDIILwJnbQQQf5pkzKVq1a5cu4uT/66KMZ82W78XFz5wFxbrw0oYbz8NwaQcWCI7UsDRs29NMYp6nWbtQ0w9qzXzYd1ADy7Bvjo0eP9mU8Y0eYoOmPGz/rYTpNjXSgSfekk07KKGMeaokuvPDC5NxQw0No5YF91okwPFrT9K233uoDIU3A/fr182X2AYvWrVv7mroHH3xwu/0gwPG6UAtowY4Ad9lll2XMR7M0Hww54IADkqZoQpgdO6EINPfy+nIe7fnEcJsWto2dR/p286EZkdfMwgxNxjRpg9pTzh01uvbcmAlr4NgPmkf5UEG4DcIlx2k1cDS18joQKq1GkfcMz9+x/9QY87oTLKkZtWZme3aRZlHOlWEZatPCY+eZQI79tttu82U0DVNrSa0v4RU8+9a3b99kX6V0UoATkVheBDjsygWK5lZupKHVq1cnoWFn+AAFtUc7wzNu4SdMuYnvDPPzvFQuL5wca1HPc1HxTODOTJ48Ofl0LKhN4rnBXB47aIIMEbSt5mpHqPmKj2vKlCkZ4+A4eI+EeL/FH1zItmy2ssJg/+fOnZuM8zdIjbKUbrtyfYQCnEh65U2AExGR7BTgRCSmACcikucU4EQkpgAnIpLnFOBEJKYAJyKS5xTgRCSmACcikucU4EQkpgAnIpLn4i/dLiwFOJH0ylmAC3/bUkREdg3hiy8o3xUKcCLplbMAt6sXHBER+T/8ysmuUoATSa+cBTjwO5ciIrJr+NJofnlkVynAiaRXTgMcuHjQnMpPU6lTp06dusJ1e+I5YgU4kfTKeYATEZHioQAnkl4KcCIiKaUAJ5JeCnAiIimlACeSXgpwIiIppQAnkl4KcCIiKaUAJ5JeCnAiIimlACeSXgpwIiIppQAnkl4KcCIiKaUAJ5JeCnAiIimlACeSXjkPcPwmqn6JQZ06deqK1nHd3F0KcCLpldMAxwWI9YiISNHt7s9pKcCJpFfOApyCm4jI7qM2blcpwImkV84C3O5cdERE5E9ci7du3RoXF4oCnEh65SzA7W7Vv4iI/IkgtisU4ETSSwFORCTPLV++PC4qFAU4kfRSgBMRyXMKcCISU4ATEclzCnAiElOAExHJcwpwIhJTgBMRyXMKcCISK/YAd+KJJ2Z0N954YzxLkZ100kmuUaNGcfFeccYZZ8RF3rp169yWLVvi4gyc77vuuisu3utuueUWd/DBB8fF3rfffusGDx7sFi5cGE9yHTp08NNEZM9SgBORWLEHOHPxxRdnjIcXrAULFgRT/hSGoW3btvkO8+fPdzfffHMyLb7wFeZCxrHH861fvz4Z3rhxYzAlc/+qVKmSDM+bNy8ZPuGEE/zPiplwGHPnznVLly51LVu2zChHvL0Y+7pp06aM8TVr1gRz/HmOQvH2w/nLlCkTTMn08ccfu4cfftjNmjUrnuQuu+wy17t377hYRHZTfB0rLAU4kfTKywBHgDj99NN9oKlZs6YbO3asK1u2rL8IMe2+++7zNV2dOnVy9evXd08//bQvY77nn3/eNWvWzIeqcuXKuQkTJriqVau62bNnuzp16rgaNWq4s846K9lW+/bt3SGHHOLXR/B78cUXXdeuXd1tt93mlwPbHjJkiNtnn31cu3bt3Mknn+y3TYipXLmy+/nnn/08sABXqVIlN2XKFN8nLLGfw4cP91/IyX698cYbSVBq2LCh30/WFQe4ChUquEGDBiXz9u/f3/cnTZrkHn/8cXfFFVe4iy66yHXr1s29+uqrrk+fPr4G8sknn3QPPPCA++GHH1y9evXcvffe60499VS/LOt67bXXknUSLj/44AM/vnbtWt/nXB577LE+PBL+DjjgAD9vGOD+8pe/+DJel/Lly/t9GzFihC8TkT1HAU5EYnkZ4AglZtWqVe6TTz5x1apV8+GnVq1avpwauMMPP9w1bdrUHXXUUb5pD9TAEbJAsPv888/dsGHD3CWXXOIDXIyAGF7cwtonG77jjjt8v0mTJr5PsLzgggt8iKHmDAQmEOBWrlzpGjRo4Lc9dOhQd/nllyc1cKeddpobPXq0n0agImjadvjt2DjAMY3jt29ijwNcXFuWbZxt0dk0wuaHH37oNm/enMzzzjvvJDV9Nt/OAhzHPmPGDNe9e3c3fvx4v42ZM2f6+URkz1GAE5FYXga4fv36+T41SH379vXDFuAsSOCwww5zL7/8sh8mVDVv3jwjwL377ru+z0Xso48+yhrg9t13Xx9QON42bdr47RgLMh07dvT9bAFu6tSpvoxlQYCjuZVaL3AOCTYW4Fhu2rRpftqbb77pmy5tOwSiMMARXt977z3//BzzsJ9dunTx0zjuOMDx/CDjdrFu1apVshwGDhzoa9io/aPJlWnsK8+zcfyMc45tnccdd5zfZ24A2QIcCKo2/67+3I+I7JgCnIjE8jrAERZq167tjjnmGFe9enVfGxQHuM6dO/sQ0aJFCx92wgBHsKB5kWbMOXPmZA1w48aN882qPLRPrRTNnoQtap8efPBBP8+OApxtg6ZOWBPqoYce6i699FI/nYsoYYqaQlB29tln+2PDo48+6qdTMxbXwFHGubHjZtlzzz3XHXnkkT7AvfDCC74JmGZhAiBNsfvvv78777zz3MSJE/3rULFiRX8Ozz//fL8OmoLZN8IrmM7za9YMbIGMplv2kXNfUIA78MADfQ0c7rzzTn2IQSQHFOBEJJY3Aa4gO/vkJqj5KWg+apAKc/EKH/Lf0fpChBgCY/gBhxA1Z6FwnVxUQ/G8ofhDDOEHFsC+W3MoON54mXA6wu0zf0HHwPtgRwjP8bpFZM9SgBORWN4HuHxmAa604utGrrrqqrhYRPYwBTgRiSnAiYjkOQU4EYkpwImI5DkFOBGJKcCJiOQ5BTgRiSnAiYjkOQU4EYkpwImI5LkVK1bERYWiACeSXjkLcPyqgIiI7B7C165+VY8CnEh65SzAFeZ71EREZMcWLVoUFxWaApxIeuUswIHfBN3RF9SKiEh2hK7dfRRFAU4kvXIa4GDr4b9IderUqVO3847gVtCvoxSFApxIeuU8wImISPFQgBNJLwU4EZGUUoATSS8FOBGRlFKAE0kvBTgRkZRSgBNJLwU4EZGUUoATSS8FOBGRlFKAE0kvBTgRkZRSgBNJLwU4EZGUUoATSa8dBjh+SWHr1q3xJBERKQGWLVvmNm7cqAAnkkIFBrht27b5n8FasWJFPElEREoAftFh8+bNcbGIpECBAY7/2DZt2rTbv8UnIiJ736pVq3xHa4qIpE+BAQ40n65Zs8Z3IiJSMnDtXrx4sX/+jdYUEUmfHQY4auG2bNnim1H5gWU9RyEikt/Wr1/vli5dqvAmknI7DHCwplQ+0PDHH3/4JtUNGzb45yrUqVOnTl1+dPaPtoU3mk71T7dIeu00wIH/4qiJ4z87vlqETzYR5NSpU6dOXX50fGUIj7vwqVOu2QpvIulWqAAHLgZcFHi2gv/2qJVTp06dOnX50fFPtmrdREqPQgc4EREREckPCnAiIiIiJYwCnIiIiEgJowAnIiIiUsIowImIiIiUMP8fqxw0Blqxt7AAAAAASUVORK5CYII=)

### Step 1: Setup your development environment[​](#step-1-setup-your-development-environment "Direct link to Step 1: Setup your development environment")

*   **Install Node.js and npm:** Download from [nodejs.org](https://nodejs.org) and [npmjs.com](https://npmjs.com).

### Step 2: Create a new Next.js project[​](#step-2-create-a-new-nextjs-project "Direct link to Step 2: Create a new Next.js project")

```rust
npx create-next-app@latest circle-paymaster-wallet --typescript --tailwind --eslint

cd circle-paymaster-wallet

npx shadcn@latest init -d
```

### Step 3: Install required dependencies[​](#step-3-install-required-dependencies "Direct link to Step 3: Install required dependencies")

```rust
npm install @radix-ui/react-label @radix-ui/react-slot @radix-ui/react-tabs @tanstack/query-core @tanstack/react-query class-variance-authority clsx lucide-react next permissionless react react-dom tailwind-merge tailwindcss-animate viem
```

### Step 4: Configure blockchain interaction[​](#step-4-configure-blockchain-interaction "Direct link to Step 4: Configure blockchain interaction")

*   **Setup a Smart Contract Interaction Service:**

lib/transfer-service.ts

```rust
   import { createPublicClient, http, getContract, encodeFunctionData,   encodePacked, parseAbi, parseErc6492Signature, formatUnits, hexToBigInt } from 'viem'
   import { createBundlerClient } from 'viem/account-abstraction'
   import { arbitrumSepolia } from 'viem/chains'
   import { toEcdsaKernelSmartAccount } from 'permissionless/accounts'
   import { privateKeyToAccount } from 'viem/accounts'
   import { eip2612Permit, tokenAbi } from './permit-helpers'

const ARBITRUM_SEPOLIA_USDC = '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d'
const ARBITRUM_SEPOLIA_PAYMASTER = '0x31BE08D380A21fc740883c0BC434FcFc88740b58'
const ARBITRUM_SEPOLIA_BUNDLER = `https://public.pimlico.io/v2/${arbitrumSepolia.id}/rpc`

const MAX_GAS_USDC = 1000000n // 1 USDC

export async function transferUSDC(
privateKey: `0x${string}`,
recipientAddress: string,
amount: bigint
) {
// Create clients
const client = createPublicClient({
chain: arbitrumSepolia,
transport: http()
})
const bundlerClient = createBundlerClient({
client,
transport: http(ARBITRUM_SEPOLIA_BUNDLER)
})
// Create accounts
const owner = privateKeyToAccount(privateKey)
const account = await toEcdsaKernelSmartAccount({
client,
owners: [owner],
version: '0.3.1'
})
// Setup USDC contract
const usdc = getContract({
client,
address: ARBITRUM_SEPOLIA_USDC,
abi: tokenAbi,
})
// Verify USDC balance first
const balance = await usdc.read.balanceOf([account.address])
if (balance < amount) {
throw new Error(`Insufficient USDC balance. Have: ${formatUnits(balance, 6)}, Need: ${formatUnits(amount, 6)}`)
}
// Construct and sign permit
const permitData = await eip2612Permit({
token: usdc,
chain: arbitrumSepolia,
ownerAddress: account.address,
spenderAddress: ARBITRUM_SEPOLIA_PAYMASTER,
value: MAX_GAS_USDC
})
const signData = { ...permitData, primaryType: 'Permit' as const }
const wrappedPermitSignature = await account.signTypedData(signData)
const { signature: permitSignature } = parseErc6492Signature(wrappedPermitSignature)
// Prepare transfer call
const calls = [{
to: usdc.address,
abi: usdc.abi,
functionName: 'transfer',
args: [recipientAddress, amount]
}]
// Specify the USDC Token Paymaster
const paymaster = ARBITRUM_SEPOLIA_PAYMASTER
const paymasterData = encodePacked(
['uint8', 'address', 'uint256', 'bytes'],
[
0, // Reserved for future use
usdc.address, // Token address
MAX_GAS_USDC, // Max spendable gas in USDC
permitSignature // EIP-2612 permit signature
]
)
// Get additional gas charge from paymaster
const additionalGasCharge = hexToBigInt(
(
await client.call({
to: paymaster,
data: encodeFunctionData({
abi: parseAbi(['function additionalGasCharge() returns (uint256)']),
functionName: 'additionalGasCharge'
})
}) ?? { data: '0x0' }
).data
)
// Get current gas prices
const { standard: fees } = await bundlerClient.request({
method: 'pimlico_getUserOperationGasPrice' as any
}) as { standard: { maxFeePerGas: `0x${string}`, maxPriorityFeePerGas: `0x${string}` } }
const maxFeePerGas = hexToBigInt(fees.maxFeePerGas)
const maxPriorityFeePerGas = hexToBigInt(fees.maxPriorityFeePerGas)
// Estimate gas limits
const {
callGasLimit,
preVerificationGas,
verificationGasLimit,
paymasterPostOpGasLimit,
paymasterVerificationGasLimit
} = await bundlerClient.estimateUserOperationGas({
account,
calls,
paymaster,
paymasterData,
paymasterPostOpGasLimit: additionalGasCharge,
maxFeePerGas: 1n,
maxPriorityFeePerGas: 1n
})
// Send user operation
const userOpHash = await bundlerClient.sendUserOperation({
account,
calls,
callGasLimit,
preVerificationGas,
verificationGasLimit,
paymaster,
paymasterData,
paymasterVerificationGasLimit,
paymasterPostOpGasLimit: BigInt(Math.max(
Number(paymasterPostOpGasLimit),
Number(additionalGasCharge)
)),
maxFeePerGas,
maxPriorityFeePerGas
})
// Wait for receipt
const userOpReceipt = await bundlerClient.waitForUserOperationReceipt({
hash: userOpHash
})
return userOpReceipt
}

```

*   **Setup Permit Helper for EIP-2612 Integration:**

lib/permit-helpers.ts

```rust
import { Address, Chain, TypedDataDomain, getContract } from 'viem'
export const eip2612Abi = [
  {
    constant: false,
    inputs: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'deadline', type: 'uint256' },
      { name: 'v', type: 'uint8' },
      { name: 'r', type: 'bytes32' },
      { name: 's', type: 'bytes32' },
    ],
    name: 'permit',
    outputs: [],
    payable: false,
    stateMutability: 'nonpayable',
    type: 'function',
  },
] as const
export const tokenAbi = [
  ...eip2612Abi,
  {
    inputs: [{ name: 'owner', type: 'address' }],
    name: 'nonces',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'name',
    outputs: [{ name: '', type: 'string' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'version',
    outputs: [{ name: '', type: 'string' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [
      { name: 'recipient', type: 'address' },
      { name: 'amount', type: 'uint256' }
    ],
    name: 'transfer',
    outputs: [{ name: '', type: 'bool' }],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  }
] as const
export async function eip2612Permit({
  token,
  chain,
  ownerAddress,
  spenderAddress,
  value,
}: {
  token: ReturnType<typeof getContract>
  chain: Chain
  ownerAddress: Address
  spenderAddress: Address
  value: bigint
}) {
  const [nonce, name, version] = await Promise.all([
    token.read.nonces([ownerAddress]),
    token.read.name(),
    token.read.version(),
  ])
  const domain: TypedDataDomain = {
    name,
    version,
    chainId: chain.id,
    verifyingContract: token.address,
  }
  const types = {
    Permit: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'deadline', type: 'uint256' },
    ],
  }
  const message = {
    owner: ownerAddress,
    spender: spenderAddress,
    value,
    nonce,
    deadline: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'),
  }
  return {
    domain,
    types,
    message,
  }
}
```

### Step 5: Build the frontend[​](#step-5-build-the-frontend "Direct link to Step 5: Build the frontend")

*   **Update Main Component:**

app/page.tsx

```rust
'use client'
import { useState, useEffect } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { Loader2 } from 'lucide-react'
import { createPublicClient, http, formatUnits } from 'viem'
import { generatePrivateKey, privateKeyToAccount } from 'viem/accounts'
import { arbitrumSepolia } from 'viem/chains'
import { toEcdsaKernelSmartAccount } from 'permissionless/accounts'
import { tokenAbi } from '@/lib/permit-helpers'
import { transferUSDC } from '@/lib/transfer-service'

const ARBITRUM_SEPOLIA_USDC = '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d'

export default function SmartWallet() {
  const [loading, setLoading] = useState(false)
  const [account, setAccount] = useState<any>(null)
  const [recipientAddress, setRecipientAddress] = useState('')
  const [amount, setAmount] = useState('')
  const [status, setStatus] = useState('')
  const [usdcBalance, setUsdcBalance] = useState<string>('0.00')
  useEffect(() => {
    const fetchBalance = async () => {
      if (!account?.address) return

      const client = createPublicClient({
        chain: arbitrumSepolia,
        transport: http()
      })
      const balance = await client.readContract({
        address: ARBITRUM_SEPOLIA_USDC,
        abi: [{
          inputs: [{ name: 'account', type: 'address' }],
          name: 'balanceOf',
          outputs: [{ name: '', type: 'uint256' }],
          stateMutability: 'view',
          type: 'function'
        }],
        functionName: 'balanceOf',
        args: [account.address]
      })
      const formattedBalance = Number(formatUnits(balance as bigint, 6)).toFixed(2)
      setUsdcBalance(formattedBalance)
    }
    fetchBalance()
    // Set up polling interval
    const interval = setInterval(fetchBalance, 10000) // Poll every 10 seconds
    return () => clearInterval(interval)

}, [account?.address])
const createAccount = async () => {
try {
setLoading(true)
setStatus('Creating smart account...')
// Create RPC client
const client = createPublicClient({
chain: arbitrumSepolia,
transport: http()
})
// Generate private key and create owner account
const privateKey = generatePrivateKey()
const owner = privateKeyToAccount(privateKey)
// Create smart account
const smartAccount = await toEcdsaKernelSmartAccount({
client,
owners: [owner],
version: '0.3.1'
})
setAccount({
address: smartAccount.address,
owner: owner.address,
privateKey: `0x${privateKey.slice(2)}`
})
setStatus('Smart account created successfully!')
} catch (error) {
setStatus('Error creating smart account: ' + (error as Error).message)
} finally {
setLoading(false)
}
}
const transfer = async () => {
try {
setLoading(true)
setStatus('Checking balance...')
// Create client for balance check
const client = createPublicClient({
chain: arbitrumSepolia,
transport: http()
})
// Check balance before transfer
const balance = await client.readContract({
address: ARBITRUM_SEPOLIA_USDC,
abi: tokenAbi,
functionName: 'balanceOf',
args: [account.address]
}) as bigint
// Convert input amount to USDC decimals (6 decimals)
const amountInWei = BigInt(Math.floor(parseFloat(amount) \* 1_000_000))
// Required gas buffer (2 USDC to be safe)
const gasBuffer = BigInt(2_000_000) // 2 USDC in wei
const totalNeeded = amountInWei + gasBuffer
// Check if balance is sufficient including gas buffer
if (balance < totalNeeded) {
const currentBalance = Number(formatUnits(balance, 6))
const requestedAmount = Number(amount)
const availableForTransfer = Math.max(0, currentBalance - 2) // Leave 2 USDC for gas
throw new Error(
`Insufficient balance for this transfer. ` +
`\nCurrent balance: ${currentBalance} USDC` +
`\nRequested transfer: ${requestedAmount} USDC` +
`\nGas buffer needed: 2 USDC` +
`\nMaximum you can transfer: ${availableForTransfer.toFixed(2)} USDC` +
`\n\nPlease reduce your transfer amount or get more USDC from the faucet.`
)
}
setStatus('Initiating transfer...')
const receipt = await transferUSDC(
account.privateKey,
recipientAddress,
amountInWei
)
if (receipt.success) {
setStatus('Transfer completed successfully!')
setRecipientAddress('')
setAmount('')
} else {
setStatus('Transfer failed. Please try again.')
}
} catch (error: any) {
// Check for specific error signatures
if (error.message.includes('0x65c8fd4d')) {
setStatus('Error: Insufficient USDC balance for transfer and gas fees (need ~2 USDC for gas)')
} else {
setStatus(error.message)
}
} finally {
setLoading(false)
}
}
return (

<>
  {account && (
    <div className="fixed top-4 right-4 bg-card rounded-lg border shadow p-3">
      <span className="text-sm font-medium">USDC Balance: </span>
      <span className="font-mono">${usdcBalance}</span>
    </div>
  )}
  <div className="container max-w-2xl mx-auto p-4">
    <Card>
      <CardHeader>
        <CardTitle>Smart Wallet Interface</CardTitle>
        <CardDescription>
          Create and manage your smart account with Circle's USDC Paymaster
        </CardDescription>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="create" className="space-y-4">
          <TabsList>
            <TabsTrigger value="create">Create Account</TabsTrigger>
            <TabsTrigger value="transfer" disabled={!account}>
              Transfer
            </TabsTrigger>
          </TabsList>
          <TabsContent value="create" className="space-y-4">
            {!account ? (
              <Button onClick={createAccount} disabled={loading} className="w-full">
                {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Create Smart Account
              </Button>
            ) : (
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label>Smart Wallet Address</Label>
                  <Alert>
                    <AlertDescription className="font-mono break-all">
                      {account.address}
                    </AlertDescription>
                  </Alert>
                </div>
                <div className="space-y-2">
                  <Label>Owner Address</Label>
                  <Alert>
                    <AlertDescription className="font-mono break-all">
                      {account.owner}
                    </AlertDescription>
                  </Alert>
                </div>
              </div>
            )}
          </TabsContent>
          <TabsContent value="transfer" className="space-y-4">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="recipient">Recipient Address</Label>
                <Input
                  id="recipient"
                  placeholder="0x..."
                  value={recipientAddress}
                  onChange={(e) => setRecipientAddress(e.target.value)}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="amount">Amount (USDC)</Label>
                <Input
                  id="amount"
                  type="number"
                  placeholder="0.00"
                  value={amount}
                  onChange={(e) => setAmount(e.target.value)}
                />
              </div>
              <Button
                onClick={transfer}
                disabled={loading || !recipientAddress || !amount}
                className="w-full"
              >
                {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Transfer USDC
              </Button>
            </div>
          </TabsContent>
        </Tabs>
        {status && (
          <Alert className="mt-4">
            <AlertDescription>{status}</AlertDescription>
          </Alert>
        )}
      </CardContent>
    </Card>
  </div>
</>
) }

```

*   **Update Root Layout for Application:** **File:** `app/layout.tsx`

```rust
'use client';

import './globals.css';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

*   **Setup UI Components:**  
    Create reusable components in `components/ui/` (e.g., `button.tsx`, `card.tsx`, `input.tsx`).

```rust
mkdir -p components/ui
```

components/ui/button.tsx

```rust
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
{
variants: {
variant: {
default:
"bg-primary text-primary-foreground shadow hover:bg-primary/90",
destructive:
"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
outline:
"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
secondary:
"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
ghost: "hover:bg-accent hover:text-accent-foreground",
link: "text-primary underline-offset-4 hover:underline",
},
size: {
default: "h-9 px-4 py-2",
sm: "h-8 rounded-md px-3 text-xs",
lg: "h-10 rounded-md px-8",
icon: "h-9 w-9",
},
},
defaultVariants: {
variant: "default",
size: "default",
},
}
)
export interface ButtonProps
extends React.ButtonHTMLAttributes<HTMLButtonElement>,
VariantProps<typeof buttonVariants> {
asChild?: boolean
}
const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
({ className, variant, size, asChild = false, ...props }, ref) => {
const Comp = asChild ? Slot : "button"
return (

<Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />) } )
Button.displayName = "Button" export {(Button, buttonVariants)}

```

components/ui/card.tsx

```rust
import * as React from "react"
import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"
const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"
const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"
const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"
const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"
const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"
export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
```

components/ui/input.tsx

```rust
import * as React from "react"
import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
({ className, type, ...props }, ref) => {
return (

<input
  type={type}
  className={cn(
    'flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
    className,
  )}
  ref={ref}
  {...props}
/>
) } ) Input.displayName = "Input" export {Input}

```

components/ui/label.tsx

```rust
"use client"
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)
const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName
export { Label }
```

components/ui/tabs.tsx

```rust
"use client"
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"
import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root
const TabsList = React.forwardRef<
React.ElementRef<typeof TabsPrimitive.List>,
React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>

> (({ className, ...props }, ref) => (

  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName
const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName
const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName
export { Tabs, TabsList, TabsTrigger, TabsContent }
```

components/ui/alert.tsx

```rust
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const alertVariants = cva(
"relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
{
variants: {
variant: {
default: "bg-background text-foreground",
destructive:
"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
},
},
defaultVariants: {
variant: "default",
},
}
)
const Alert = React.forwardRef<
HTMLDivElement,
React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>

> (({ className, variant, ...props }, ref) => (

  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"
const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"
const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"
export { Alert, AlertTitle, AlertDescription }
```

### Step 6: Start development server[​](#step-6-start-development-server "Direct link to Step 6: Start development server")

```rust
npm run dev
```

Once the development server is running, visit **[http://localhost:3000](http://localhost:3000)** in your browser. Follow these steps to test the application:

1\. Click on the **Create Smart Account** button to generate a smart wallet address.

2\. Deposit testnet USDC into the smart wallet address. You can source testnet USDC from [https://faucet.circle.com](https://faucet.circle.com).

3\. Navigate to the **Transfer** tab.

4\. Input the recipient address and the amount of USDC to transfer.

5\. Click on the **Transfer USDC** button to initiate the transfer.

This process demonstrates the functionality of the smart wallet and gas fee management using Circle Paymaster.

---

# USDC quick start guide | Arbitrum Docs

## USDC quick start guide

USDC provides the ability to transfer dollars over the Arbitrum network using a smart contract. The smart contract enables users to send, receive, and store dollars on-chain with a wallet.

This guide will walk you through using the [viem](https://viem.sh/) framework to build a simple app that enables a user to connect their wallet and interact with the blockchain by sending a USDC transaction from their address.

Prerequisites[​](#prerequisites "Direct link to Prerequisites")
---------------------------------------------------------------

Before you start building the sample app to perform a USDC transfer, ensure you meet the following prerequisites:

1.  **Node.js and npm**: Ensure that you have Node.js and npm installed on your machine. You can download and install Node.js from [nodejs.org](https://nodejs.org). npm comes with Node.js.
    
2.  [**MetaMask**](https://metamask.io/): Install the MetaMask browser extension and set up your wallet. Ensure that your wallet is funded with:
    
    *   Some native gas tokens (e.g., ETH on the Sepolia network) to cover transaction fees.
    *   USDC tokens for the transfer. ([USDC Testnet Faucet](https://faucet.circle.com/))
3.  **Project Setup**: Create a new project directory and initialize it with npm:
    

```rust
mkdir usdc-transfer-app
cd usdc-transfer-app
npm init -y
```

4.  **Dependencies**: Install the required dependencies using the following command:

```rust
   npm install react@^18.2.0 react-dom@^18.2.0 @types/react@^18.0.27 @types/react-dom@^18.0.10 @vitejs/plugin-react@^3.1.0 typescript@^5.0.3 vite@^4.4.5
```

This will set up your development environment with the necessary libraries and tools for building a React application with TypeScript and Vite.

Installation[​](#installation "Direct link to Installation")
------------------------------------------------------------

To install viem run the following command.

```rust
npm i viem
```

Setup public client[​](#setup-public-client "Direct link to Setup public client")
---------------------------------------------------------------------------------

The public client is used to interact with your desired blockchain network.

```rust
import { http, createPublicClient } from 'viem';
import { arbitrumSepolia } from 'viem/chains';

const publicClient = createPublicClient({
  chain: arbitrumSepolia,
  transport: http(),
});
```

Setup wallet client[​](#setup-wallet-client "Direct link to Setup wallet client")
---------------------------------------------------------------------------------

The wallet client is used to interact with Arbitrum accounts to retrieve accounts, execute transactions, and sign messages.

```rust
import { createWalletClient } from 'viem';
import { arbitrumSepolia } from 'viem/chains';

const walletClient = createWalletClient({
  chain: arbitrumSepolia,
  transport: custom(window.ethereum!),
});
```

Define USDC contract details[​](#define-usdc-contract-details "Direct link to Define USDC contract details")
------------------------------------------------------------------------------------------------------------

Define the USDC contract address and ABI (Application Binary Interface). The ABI specifies the functions available in the contract. (The USDC Token Contract Address referenced in the code is on Ethereum Sepolia)

```rust
const USDC_CONTRACT_ADDRESS = '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d';
const USDC_ABI = [
  {
    constant: false,
    inputs: [
      { name: '_to', type: 'address' },
      { name: '_value', type: 'uint256' },
    ],
    name: 'transfer',
    outputs: [{ name: '', type: 'bool' }],
    type: 'function',
  },
];
```

Connect wallet[​](#connect-wallet "Direct link to Connect wallet")
------------------------------------------------------------------

Create a function to connect the user's wallet and retrieve their account address.

```rust
const connect = async () => {
  const [address] = await walletClient.requestAddresses();
  setAccount(address);
};
```

Send transaction[​](#send-transaction "Direct link to Send transaction")
------------------------------------------------------------------------

Create a function to send the USDC transfer transaction. This function encodes the transfer function data and sends the transaction using the wallet client.

```rust
const data = encodeFunctionData({
  abi: USDC_ABI,
  functionName: 'transfer',
  args: [to, valueInWei],
});

const hash = await walletClient.sendTransaction({
  account,
  to: USDC_CONTRACT_ADDRESS,
  data,
});
```

Wait for transaction receipt[​](#wait-for-transaction-receipt "Direct link to Wait for transaction receipt")
------------------------------------------------------------------------------------------------------------

Use the public client to wait for the transaction receipt, which confirms that the transaction has been mined.

```rust
useEffect(() => {
  (async () => {
    if (hash) {
      const receipt = await publicClient.waitForTransactionReceipt({ hash });
      setReceipt(receipt);
    }
  })();
}, [hash]);
```

Final step: build your USDC transfer sample app[​](#final-step-build-your-usdc-transfer-sample-app "Direct link to Final step: build your USDC transfer sample app")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Now that you understand the core components for programmatically performing your first USDC transaction, create the following **index.tsx** and **index.html** files to build a sample app. This app will enable you to send USDC from one wallet to another. Ensure that your wallet is funded with both the native gas token and USDC.

index.tsx

```rust
import React, { useEffect, useState } from 'react';
import ReactDOM from 'react-dom/client';
import {
  http,
  type Address,
  type Hash,
  type TransactionReceipt,
  createPublicClient,
  createWalletClient,
  custom,
  stringify,
  encodeFunctionData,
} from 'viem';
import { arbitrumSepolia } from 'viem/chains';
import 'viem/window';

const publicClient = createPublicClient({
  chain: arbitrumSepolia,
  transport: http()
});

const walletClient = createWalletClient({
  chain: arbitrumSepolia,
  transport: custom(window.ethereum!)
});

const USDC_CONTRACT_ADDRESS = '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d';
const USDC_ABI = [
  {
    constant: false,
    inputs: [
      { name: '_to', type: 'address' },
      { name: '_value', type: 'uint256' },
    ],
    name: 'transfer',
    outputs: [{ name: '', type: 'bool' }],
    type: 'function',
  },
];

function Example() {
  const [account, setAccount] = useState<Address>();
  const [hash, setHash] = useState<Hash>();
  const [receipt, setReceipt] = useState<TransactionReceipt>();

  const addressInput = React.createRef<HTMLInputElement>();
  const valueInput = React.createRef<HTMLInputElement>();

  const connect = async () => {
    const [address] = await walletClient.requestAddresses();
    setAccount(address);
  };

  const sendTransaction = async () => {
    if (!account) return;
    const to = addressInput.current!.value as Address;
    const value = valueInput.current!.value as `${number}`;
    const valueInWei = BigInt(value) * BigInt(10 ** 6); // Assuming USDC has 6 decimals

    const data = encodeFunctionData({
      abi: USDC_ABI,
      functionName: 'transfer',
      args: [to, valueInWei],
    });

    const hash = await walletClient.sendTransaction({
      account,
      to: USDC_CONTRACT_ADDRESS,
      data,
    });
    setHash(hash);
  };

  useEffect(() => {
    (async () => {
      if (hash) {
        const receipt = await publicClient.waitForTransactionReceipt({ hash });
        setReceipt(receipt);
      }
    })();
  }, [hash]);

  if (account) {
    return (
      <>
        <div>Connected: {account}</div>
        <input ref={addressInput} placeholder="address" />
        <input ref={valueInput} placeholder="value (USDC)" />
        <button onClick={sendTransaction}>Send</button>
        {receipt && (
          <div>
            Receipt: <pre><code>{stringify(receipt, null, 2)}</code></pre>
          </div>
        )}
      </>
    );
  }
  return <button onClick={connect}>Connect Wallet</button>;
}

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
<Example />
);
```

index.html

```rust
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>USDC Transfer Sample App</title>
  </head>
  <body>
    <h1>USDC Transfer Sample App</h1>
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
  </body>
</html>
```

By combining these **index.tsx** and **index.html** files, you will have a complete setup that allows you to perform a USDC transfer from your wallet. Simply connect your wallet, input the recipient's address and the amount of USDC to transfer, and click the “Send” button to execute the transaction. You will receive a transaction receipt once the transaction is confirmed on the blockchain.

---

# Contribute third-party docs | Arbitrum Docs

## Contribute third-party docs

**Third-party docs** are documents that help readers of Arbitrum docs use other products, services, and protocols (like the ones listed in the [Arbitrum portal](https://portal.arbitrum.io/)) with Arbitrum products.

These documents are usually authored by partner teams, but can be authored by anyone. They follow the same general process that [core docs](/for-devs/contribute#add-a-new-core-document) follow, in addition to the following guidelines:

1.  **Eligibility**
    *   Third-party docs are intended to support products listed in the [Arbitrum portal](https://portal.arbitrum.io/), or infrastructure and services that those products use.
    *   To submit your project to the Arbitrum portal, [apply using this Google form](https://docs.google.com/forms/d/e/1FAIpQLSc_v8j7sc4ffE6U-lJJyLMdBoIubf7OIhGtCqvK3cGPGoLr7w/viewform).
2.  **Purpose**
    *   The purpose of our `Third-party docs` sections is to **_meet Arbitrum developer (or user) demand for guidance that helps them use non-Arbitrum products with Arbitrum products_**.
    *   It's _not_ meant to drive traffic to your product (although that may happen); it's meant to solve problems that our readers are actually facing, which are directly related to Arbitrum products.
3.  **Maintenance expectations**
    *   Offchain Labs can't commit to maintaining third-party docs, but we make it easy for you to maintain them.
    *   Ensure that your document's YAML frontmatter contains a `third_party_content_owner` property, with the Github username of the designated maintainer. This person will be assigned to your document's issues and PRs, and will be expected to resolve them in a timely manner.
4.  **Organization**
    *   Third-party docs are organized within the `Third-party content` node located at the bottom of each documentation section's sidebar.
    *   This node's content is grouped by third-party product. If/when this becomes unwieldy, we'll begin grouping products by [portal](https://portal.arbitrum.io/) category.
5.  **Limited document types**
    *   To manage our team's limited capacity, third-party documents must be either **_Quickstarts_**, **_How-tos_**, or **_Concepts_**. See [document types](/for-devs/contribute#document-type-conventions).
6.  **Incremental contributions: One document at a time, procedures first**
    *   Third-party document PRs should contain at most one new document.
    *   Any given product's first docs contribution should be a **_Quickstart_** or **_How-to_**.
    *   Additional documents will be merged only if we can verify that our readers are deriving value from your initial contribution.
    *   The way that we verify this isn't yet formally established, and it isn't publicly disclosed. Our current approach combines a number of objective and subjective measures.
7.  **Policy acknowledgment**
    *   Before merging third-party documentation PRs, we ask contributors to acknowledge that they've read, understood, and agree with the following policies:
        1.  **Content ownership**: As the author, you retain ownership of and responsibility for the content you contribute. You're free to use your content in any way you see fit outside of Arbitrum's docs. Remember that when contributing content to our documentation, you must ensure you have the necessary rights to do so, and that the content doesn't infringe on the intellectual property rights of others.
        2.  **License for use**: By contributing your content to our documentation, you grant Offchain Labs a non-exclusive, royalty-free license to use, reproduce, adapt, translate, distribute, and display the content in our documentation. This allows us to integrate your content into our docs and make it available to all users.
        3.  **Right to modify or remove**: Offchain Labs reserves the right to modify or remove third-party content from our documentation at any time. This might be necessary due to a range of reasons, such as content becoming outdated, receiving very low pageviews over an extended period, or misalignment with our guidelines or goals.

---

# Quickstart - Covalent Indexing and Querying API | Arbitrum Docs

[Covalent](https://www.covalenthq.com/?utm_source=arbitrum&utm_medium=partner-docs) is a hosted blockchain data solution providing access to historical and current onchain data for [200+ supported blockchains](https://www.covalenthq.com/docs/networks/?utm_source=arbitrum&utm_medium=partner-docs), including Arbitrum One, Nova and Orbit chains.

Covalent maintains a full replica of every supported blockchain, meaning you have access to:

*   Current and historical account balances
*   Full transaction histories
*   Every contract log event
*   All NFTs including assets and metadata

**Use Covalent if you need:**

*   Wallet, Transactions, NFT, DEX, Staking or core blockchain data (log events, blocks)
*   Normalized, aggregated and enhanced multichain data, well beyond what you get from RPC providers
*   Enterprise-grade performance

> **[Sign up to start building on Arbitrum](https://www.covalenthq.com/platform/?utm_source=arbitrum&utm_medium=partner-docs)**

## APIs

The Covalent APIs enables developers to quickly and easily access structured onchain data. This means consistent response schemas regardless of the blockchain. Available APIs and corresponding use cases include:

### Wallet API[​](#wallet-api "Direct link to Wallet API")

*   **Features:** All token balances (ERC20, 721, 1155, native), token transfers and prices (spot & historical) for a wallet.
*   **Use cases:** [Wallets, portfolio trackers](https://goldrush-wallet-portfolio-ui.vercel.app/?utm_source=arbitrum&utm_medium=partner-docs), token gating, airdrop snapshots.

### NFT API[​](#nft-api "Direct link to NFT API")

*   **Features:** Media assets, metadata, sales, owners, trait & attribute filters, thumbnails & previews.
*   **Use cases:** [NFT galleries & marketplaces](https://goldrush-nft-gallery-ui.vercel.app/?utm_source=arbitrum&utm_medium=partner-docs), real world asset (RWA) tracking, token gating.

### DEX API[​](#dex-api "Direct link to DEX API")

*   **Features:** Positions, rewards, pool and token details for major DEX protocols.
*   **Use cases:** [Analytics dashboards](https://goldrush-uniswap-dex-dashboard.vercel.app/?utm_source=arbitrum&utm_medium=partner-docs), leaderboards, reward calculators.

### Cross-Chain Activity API[​](#cross-chain-activity-api "Direct link to Cross-Chain Activity API")

*   **Features:** Single API call to fetch a list of active chains and the latest transaction date on each for an address.
*   **Use cases:** [App onboarding](https://goldrush-wallet-portfolio-ui.vercel.app/activity/0xfc43f5f9dd45258b3aff31bdbe6561d97e8b71de/?utm_source=arbitrum&utm_medium=partner-docs).

### Transactions API[​](#transactions-api "Direct link to Transactions API")

*   **Features:** All historical transactions with human-readable log events. Includes gas usage/spend summaries.
*   **Use cases:** [Accounting and tax tools](https://bit.ly/crypto-tax-tool), branded in-app [transaction receipts](https://goldrush-dfk-tx-receipt-ui.vercel.app/tx/defi-kingdoms-mainnet/0x4e5c0af28b2cea27d06677fae1f573572e0ff863c43ae42d2959ca67b90c4390/?utm_source=arbitrum&utm_medium=partner-docs).

### Security API[​](#security-api "Direct link to Security API")

*   **Features:** NFT and ERC20 token allowances, including value-at-risk.
*   **Use cases:** Revoke features in wallets, security applications.

### Blockchain API[​](#blockchain-api "Direct link to Blockchain API")

*   **Features:** Block details, log events by contract address or topic hash, gas prices.
*   **Use cases:** Custom block explorers.

Developer Tools[​](#developer-tools "Direct link to Developer Tools")
---------------------------------------------------------------------

There are 3 primary developer tools for using the APIs:

1.  [**Unified API**](https://www.covalenthq.com/docs/api/?utm_source=arbitrum&utm_medium=partner-docs) - enterprise-grade endpoints to use with any programming language. Switch blockchains with one path parameter.
    
    ```rust
    curl -X GET https://api.covalenthq.com/v1/arbitrum-mainnet/address/0xf977814e90da44bfa03b6295a0616a897441acec/balances_v2/ \
        -H 'Content-Type: application/json' \
        -u YOUR_API_KEY:
    ```
    
2.  [**Client SDKs**](https://www.covalenthq.com/docs/unified-api/sdk/?utm_source=arbitrum&utm_medium=partner-docs) - official client libraries including TypeScript, Go and Python.
    
    TypeScript example:
    
    ```rust
    npm install @covalenthq/client-sdk
    ```
    
    or:
    
    ```rust
    yarn add @covalenthq/client-sdk
    ```
    
    ```rust
    import { CovalentClient } from "@covalenthq/client-sdk";
    
    (async () => {
    try {
        const client = new CovalentClient("YOUR_API_KEY");
        const transactions = client.TransactionService.getAllTransactionsForAddress("arbitrum-mainnet", "0xf977814e90da44bfa03b6295a0616a897441acec");
    
        for await (const tx of transactions) {
        console.log("tx", tx);
        }
    } catch (error) {
        console.log(error.message);
    }
    })();
    ```
    
3.  [**GoldRush Kit**](https://github.com/covalenthq/goldrush-kit/?utm_source=arbitrum&utm_medium=partner-docs) - beautifully designed React components for your dApp frontend [![GoldRush Component Example](https://www.datocms-assets.com/86369/1711147954-goldrush_wallet_ui_example.png)](https://goldrush-wallet-portfolio-ui.vercel.app/dashboard/balance/0xfc43f5f9dd45258b3aff31bdbe6561d97e8b71de/transfers/eth-mainnet/0xf8c3527cc04340b208c854e985240c02f7b7793f)
    

Get started[​](#get-started "Direct link to Get started")
---------------------------------------------------------

*   **[API Key](https://www.covalenthq.com/platform/auth/register/?utm_source=arbitrum&utm_medium=partner-docs)** - sign up for free
*   [**Docs**](https://www.covalenthq.com/docs/unified-api/?utm_source=arbitrum&utm_medium=partner-docs) - comprehensive knowledge base for all things Covalent
*   **[Guides](https://www.covalenthq.com/docs/unified-api/guides/?utm_source=arbitrum&utm_medium=partner-docs)** - learn how to build for various use cases and expand your onchain knowledge

---

# How to deploy an NFT smart contract and enable credit card and cross-chain payments with no-code | Arbitrum Docs

## How to deploy an NFT smart contract and enable credit card and cross-chain payments with no-code

Community member contribution

Shoutout to [@rohit-710](https://github.com/rohit-710) for contributing the following [third-party document](/for-devs/third-party-docs/contribute)!

**[Crossmint](http://crossmint.com/?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum)** is an enterprise-grade web3 development platform that lets you deploy smart contracts, create email wallets, enable credit-card and cross chain payments, and use APIs to create, distribute, sell, store, and edit NFTs.

By abstracting away the core complexities of the Blockchain, Crossmint allows you to build NFT applications without requiring any blockchain experience or holding cryptocurrency, and making the blockchain invisible to end users.

Crossmint enables you to provide a Web2 experience for for your Web3 apps.

Check out **[Crossmint's Docs](https://docs.crossmint.com/?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum)** to get started.

Crossmint Console[​](#crossmint-console "Direct link to Crossmint Console")
---------------------------------------------------------------------------

What you can achieve using Crossmint Console:

*   Create and deploy NFT Collections.
*   Create and airdrop NFTs.
*   Generate No-code Storefront and No-code claims page.
*   Accept credit card and cross-chain payments for your NFT Collections.
*   Create and configure API Keys for Wallets and Minting.
*   Create Webhooks to listen to your Crossmint collections's endpoint URL's triggered events.
*   Whitelist domains and set up Redirect URls for your NFT Collections' checkout.

Crossmint Console

Please check out the [docs](https://docs.crossmint.com/docs/create-developer-account) to learn more. Click [here](https://www.crossmint.com/console/overview?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum) to use Crossmint's Production Console and click [here](https://staging.crossmint.com/console/overview?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum) to use Crossmint's Staging Console.

How to deploy an NFT smart contract on Arbitrum and enable credit card and cross-chain payments with no-code[​](#how-to-deploy-an-nft-smart-contract-on-arbitrum-and-enable-credit-card-and-cross-chain-payments-with-no-code "Direct link to How to deploy an NFT smart contract on Arbitrum and enable credit card and cross-chain payments with no-code")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Please checkout the step-by-step tutorial on the docs [here](https://docs.crossmint.com/docs/create-an-nft-collection?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum) and [here](https://docs.crossmint.com/docs/storefronts).

Video Tutorial

You can find a YouTube video for the same [here](https://youtu.be/pq2TVCkfBDI).

Connect with Crossmint![​](#connect-with-crossmint "Direct link to Connect with Crossmint!")
--------------------------------------------------------------------------------------------

Need further help? We got you! Check out all the ways you can reach Crossmint for further questions and support:

*   Visit Crossmint's official website at [crossmint.com](http://crossmint.com/?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum)
*   Read developer [Docs](https://docs.crossmint.com/?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum)
*   For assistance, contact the Crossmint team via the [Support forum](https://help.crossmint.com/hc/en-us?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum)
*   Follow Crossmint on [Twitter](https://twitter.com/crossmint?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum)
*   Join the official [Discord server](https://discord.gg/crossmint?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum)
*   Check out Crossmint on [Youtube](https://www.youtube.com/@crossmint?utm_source=backlinks&utm_medium=docs&utm_campaign=arbitrum)

---

# Quickstart: Blazing-fast indexing and data analytics using Envio | Arbitrum Docs

## Envio HyperIndex

[Envio](https://envio.dev/) HyperIndex is a feature-rich indexing solution that provides developers with a seamless and efficient way to index and aggregate real-time or historical blockchain data for any EVM. The indexed data is easily accessible through custom GraphQL queries, providing developers with the flexibility and power to retrieve specific information.

Envio offers native support for Arbitrum One (testnet & mainnet), Aribitrum Nova (testnet & mainnet), and Arbitrum Orbit chains, and has been designed to support high-throughput blockchain applications that rely on real-time data for their business requirements.

Designed to optimize the user experience, Envio offers automatic code generation, flexible language support, quickstart templates, and a reliable cost-effective [hosted service](https://docs.envio.dev/docs/hosted-service).

Indexers on Envio can be written in JavaScript, TypeScript, or ReScript.

Envio HyperSync[​](#envio-hypersync "Direct link to Envio HyperSync")
---------------------------------------------------------------------

Envio supports [HyperSync](https://docs.envio.dev/docs/hypersync) on Arbitrum.

HyperSync is an accelerated data query layer for the Arbitrum networks, providing APIs that bypass JSON-RPC for 20-100x faster syncing of historical data. HyperSync is used by default in Envio HyperIndex, with the use of RPC being optional. Using HyperSync, application developers do not need to worry about RPC URLs, rate-limiting, or managing infrastructure and can easily sync large datasets in a few minutes, something that would usually take hours or days via RPC.

HyperSync is also available as a standalone API for data analytic use cases. Data analysts can interact with the HyperSync API using JavaScript, Python, or Rust clients and extract data in JSON, Arrow, or Parquet formats. For more information, visit the HyperSync documentation [here](https://docs.envio.dev/docs/overview-hypersync).

HyperIndex key features[​](#hyperindex-key-features "Direct link to HyperIndex key features")
---------------------------------------------------------------------------------------------

*   Contract Import: Autogenerate the key boilerplate for an entire Indexer project off a single or multiple smart contracts. Deploy within minutes.
    
*   Multi-chain Support: Aggregate data across multiple networks into a single database. Query all your data with a unified GraphQL API.
    
*   Asynchronous Mode: Fetch data from off-chain storage such as IPFS, or contract state (e.g. smart contract view functions).
    
*   Quickstart Templates: Use pre-defined indexing logic for popular OpenZeppelin contracts (e.g. ERC-20).
    

Getting started[​](#getting-started "Direct link to Getting started")
---------------------------------------------------------------------

Users can choose whether they want to start from a quickstart template, perform a subgraph migration, or use the contract import feature to get started with Envio HyperIndex.

The following files are required to run the Envio indexer:

*   Configuration (defaults to `config.yaml`)
*   GraphQL Schema (defaults to `schema.graphql`)
*   Event Handlers (defaults to `src/EventHandlers.*` depending on the language chosen)

These files are auto-generated according to the template and language chosen by running the `envio init` command.

### Contract import tutorial[​](#contract-import-tutorial "Direct link to Contract import tutorial")

This walkthrough explains how to initialize an indexer using a single or multiple contracts that are already deployed on Arbitrum. This process allows a user to quickly and easily start up a basic indexer and a queryable GraphQL API for their application in less than 3 minutes.

### Initialize your indexer[​](#initialize-your-indexer "Direct link to Initialize your indexer")

`cd` into the folder of your choice and run

```rust
envio init
```

Name your indexer

```rust
? Name your indexer:
```

Choose the directory where you would like to setup your project (default is the current directory)

```rust
? Set the directory:  (.) .
```

Select `Contract Import` as the initialization option.

```rust
? Choose an initialization option
  Template
> ContractImport
  SubgraphMigration
[↑↓ to move, enter to select, type to filter]
```

```rust
? Would you like to import from a block explorer or a local abi?
> Block Explorer
  Local ABI
[↑↓ to move, enter to select, type to filter]
```

`Block Explorer` option only requires user to input the contracts address and chain of the contract. If the contract is verified and deployed on one of the supported chains, this is the quickest setup as it will retrieve all needed contract information from a block explorer.

`Local ABI` option will allow you to point to a JSON file containing the smart contract ABI. The Contract Import process will then populate the required files from the ABI.

#### Select the blockchain that the contract is deployed on[​](#select-the-blockchain-that-the-contract-is-deployed-on "Direct link to Select the blockchain that the contract is deployed on")

```rust
? Which blockchain would you like to import a contract from?
  ethereum-mainnet
  goerli
> arbitrum-one
  arbitrum-nova
  bsc
  gnosis
v polygon
[↑↓ to move, enter to select, type to filter]
```

#### Enter the address of the contract to import[​](#enter-the-address-of-the-contract-to-import "Direct link to Enter the address of the contract to import")

```rust
? What is the address of the contract?
[Use the proxy address if your abi is a proxy implementation]
```

Note if you are using a proxy contract with an implementation, the address should be for the proxy contract.

#### Choose which events to include in the `config.yaml` file[​](#choose-which-events-to-include-in-the-configyaml-file "Direct link to choose-which-events-to-include-in-the-configyaml-file")

```rust
? Which events would you like to index?
> [x] ClaimRewards(address indexed from, address indexed reward, uint256 amount)
  [x] Deposit(address indexed from, uint256 indexed tokenId, uint256 amount)
  [x] NotifyReward(address indexed from, address indexed reward, uint256 indexed epoch, uint256 amount)
  [x] Withdraw(address indexed from, uint256 indexed tokenId, uint256 amount)
[↑↓ to move, space to select one, → to all, ← to none, type to filter]
```

#### Select the continuation option[​](#select-the-continuation-option "Direct link to Select the continuation option")

```rust
? Would you like to add another contract?
> I'm finished
  Add a new address for same contract on same network
  Add a new network for same contract
  Add a new contract (with a different ABI)
[Current contract: BribeVotingReward, on network: arbitrum-one]
```

The `Contract Import` process will prompt the user whether they would like to finish the import process or continue adding more addresses for same contract on same network, addresses for same contract on different network or a different contract.

For more information on contract import feature, visit the documentation [here](https://docs.envio.dev/docs/contract-import).

Envio examples[​](#envio-examples "Direct link to Envio examples")
------------------------------------------------------------------

Click [here](https://docs.envio.dev/docs/example-uniswap-v3) for Envio HyperIndex examples. Click [here](https://docs.envio.dev/docs/hypersync-clients) for Envio HyperSync examples.

Getting help[​](#getting-help "Direct link to Getting help")
------------------------------------------------------------

Indexing can be a rollercoaster, especially for more complex use cases. Our engineers are available to help you with your data availability needs.

Join our growing community of elite builders, and find peace of mind with Envio.

*   [Discord](https://discord.gg/mZHNWgNCAc)
*   Email: [hello@envio.dev](mailto:hello@envio.dev)

---

# Quickstart: Indexing Arbitrum custom data via Flair | Arbitrum Docs

## Quickstart: Indexing Arbitrum custom data via Flair

[Flair](https://flair.dev), Real-time and historical custom data indexing for any evm chain.

Flair offers reusable **indexing primitives** (such as fault-tolerant RPC ingestors, custom processors, re-org aware database integrations) to make it easy to receive, transform, store and access your on-chain data.

[![flair architecture](https://imgur.com/0q5bHZK.png)](https://docs.flair.dev/)

Why Flair?[​](#why-flair "Direct link to Why Flair?")
-----------------------------------------------------

Compared to other alternatives the main reasons are:

*   🚀 Adopting **parallel and distributed processing** paradigm means high scalability and resiliency for your indexing stack. Instead of constrained sequential processing (e.g Subgraph).
*   🧩 Focused on **primitives**, which means on the left you plug-in an RPC and on the right you output the data to any destination database.
*   🚄 Native **real-time stream processing** for certain data workload (such as aggregations, rollups) for things like total volume per pool, or total portfolio per user wallet.
*   ☁️ **Managed** cloud services avoid DevOps and irrelevant engineering costs for dApp developers.
*   🧑‍💻 Avoid decentralization **overhead** (consensus, network hops, etc) since we believe to enable best UX for dApps reading data must be as close to the developers as possible.

### Features[​](#features "Direct link to Features")

*   ✅ Listen to **any EVM chain** with just an RPC URL.
    *   Free managed RPC URLs for +8 popular chains already included.
    *   Works with both websocket and https-only RPCs.
*   ✅ Track and ingest **any contract** for **any event topic.**
    *   Auto-track new contracts deployed from factory contracts.
*   ✅ **Custom processor scripts** with Javascript runtime (with **Typescript** support)
    *   Make external API or Webhook calls to third-party or your backend.
    *   Get current or historical USD value of any ERC20 token amount of any contract address on any chain.
    *   Use any external NPM library.
*   ✅ **Stream** any stored data to your destination database (Postgres, MongoDB, MySQL, Kafka, Elasticsearch, Timescale, etc).

Getting Started[​](#getting-started "Direct link to Getting Started")
---------------------------------------------------------------------

1️⃣ Clone the [starter boilerplate](https://github.com/flair-sdk/starter-boilerplate) template and follow the instructions

```rust
git clone https://github.com/flair-sdk/starter-boilerplate.git
# ... follow instructions in README.md
```

info

Boilerplate instructions will create a **new cluster**, generate **an API Key**, and set up a manifest.yml to index your **first contract** with **sample custom processor** scripts.

Learn more about the [structure of manifest.yml](https://docs.flair.dev/reference/manifest.yml).

2️⃣ Configure Arbitrum RPC nodes

Set a unique namespace, Arbitrum chainId and RPC endpoint in your config. Remember that you can add up to 10 RPC endpoints for resiliency.

```rust
{
  'cluster': 'dev',
  'namespace': 'my-awesome-arbitrum-indexing-dev',
  'indexers':
    [
      {
        'chainId': 42161,
        'enabled': true,
        'ingestionFilterGroup': 'default',
        'processingFilterGroup': 'default',
        'sources': [
            # Highly-recommended to have at least 1 websocket endpoint
            'wss://arbitrum-one.publicnode.com',
            # You can put multiple endpoints for failover
            'https://arbitrum.llamarpc.com',
          ],
      },
    ],
}
```

3️⃣ Sync some historical data using [backfill command](https://docs.flair.dev/reference/backfilling). Remember that `enabled: true` flag in your `config` enabled your indexer to capture data in real-time already.

```rust
# backfill certain contracts or block ranges
pnpm flair backfill --chain 42161 --address
0x22dc069183f85a8473553e32b59efc9fec506baf -d backward --max-blocks 10000
# backfill for a specific block number, if you have certain events you wanna test with
pnpm flair backfill --chain 42161 -b 132763420
# backfill for the recent data in the last X minute
pnpm flair backfill --chain 42161 --min-timestamp="30 mins ago" -d backward
```

4️⃣ [Query](https://docs.flair.dev/#getting-started) your custom indexed data.

5️⃣ Stream the data to your [own database](https://docs.flair.dev/reference/database#your-own-database).

Examples[​](#examples "Direct link to Examples")
------------------------------------------------

Explore real-world usage of Flair indexing primitives for various use-cases.

### DeFi[​](#defi "Direct link to DeFi")

*   [Aggregate protocol fees in USD across multiple chains](https://github.com/flair-sdk/examples/tree/main/aggregate-protocol-fees-in-usd)
*   [Calculate "Health Factor" of positions with contract factory tracking](https://github.com/flair-sdk/examples/tree/main/health-factor-with-factory-tracking)
*   [Index Uniswap v2 swaps with USD price for all addresses](https://github.com/flair-sdk/examples/tree/main/uniswap-v2-events-from-all-contracts-with-usd-price)

### NFT[​](#nft "Direct link to NFT")

*   [Index ERC721 and ERC1155 NFTs on any EVM chain with an RPC URL](https://github.com/flair-sdk/examples/tree/main/erc721-and-erc1155-nft-indexing)

Need help?[​](#need-help "Direct link to Need help?")
-----------------------------------------------------

[Our engineers](https://docs.flair.dev/talk-to-an-engineer) are available to help you at any stage.

---

# Getting Started with Gelato VRF | Arbitrum Docs

## What is Gelato VRF?

Gelato VRF offers real randomness for blockchain applications on Arbitrum by leveraging Drand, a trusted decentralized source for random numbers. With Gelato VRF, developers on Arbitrum get random values that are both genuine and can be checked for authenticity. Explore Gelato VRF's support for all supported networks [here](https://docs.gelato.network/web3-services/vrf/supported-networks).

Applications of Gelato VRF[​](#applications-of-gelato-vrf "Direct link to Applications of Gelato VRF")
------------------------------------------------------------------------------------------------------

The potential applications of a reliable and transparent random number generator on the blockchain are vast. Here are just a few use cases:

*   Gaming and Gambling: Determine fair outcomes for online games or decentralized gambling applications.
*   Decentralized Finance (DeFi): Use in protocols where random selections, like lottery systems, are required.
*   NFT Generation: Randomly generate traits or characteristics for unique digital assets.
*   Protocol Decision Making: In protocols where decisions need to be randomized, such as selecting validators or jurors.

How does Gelato VRF work?
=========================

Gelato VRF (Verifiable Random Function) provides trustable randomness on EVM-compatible blockchains. Here's a brief overview:

Core Components:

*   Drand: Gelato VRF utilizes Drand, a decentralized randomness beacon ensuring unpredictability and unbiased randomness.

Top-level Flow:

*   Contract Deployment: Use GelatoVRFConsumerBase.sol as an interface for requesting random numbers.
*   Requesting Randomness: Emit the RequestedRandomness event to signal the need for a random number.
*   Processing: Web3 functions fetch the random number from Drand.
*   Delivery: The fulfillRandomness function delivers the random number to the requesting contract.

Quick start guide
=================

In order to get your VRF up and running with Gelato, you need to make your contract VRF Compatible.

Step 1: Setup your development environment[​](#step-1-setup-your-development-environment "Direct link to Step 1: Setup your development environment")
-----------------------------------------------------------------------------------------------------------------------------------------------------

Ensure you have either [Foundry](https://book.getfoundry.sh/getting-started/installation) or [Hardhat](https://hardhat.org/) set up in your development environment.

Step 2: Install the Gelato VRF contracts[​](#step-2-install-the-gelato-vrf-contracts "Direct link to Step 2: Install the Gelato VRF contracts")
-----------------------------------------------------------------------------------------------------------------------------------------------

*   For hardhat users:

```rust
 npm install --save-dev @gelatodigital/vrf-contracts
```

*   For Foundry users:

```rust
 forge install gelatodigital/vrf-contracts --no-commit
```

Step 3: Inherit `GelatoVRFConsumerBase` in your contract[​](#step-3-inherit-gelatovrfconsumerbase-in-your-contract "Direct link to step-3-inherit-gelatovrfconsumerbase-in-your-contract")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

```rust
// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import {GelatoVRFConsumerBase} from "./GelatoVRFConsumerBase.sol";

contract YourContract is GelatoVRFConsumerBase {
    // Your contract's code goes here
}
```

Step 4: Request randomness[​](#step-4-request-randomness "Direct link to Step 4: Request randomness")
-----------------------------------------------------------------------------------------------------

```rust
function requestRandomness(bytes memory data) external {
        require(msg.sender == ...);
        uint64 requestId = _requestRandomness(data);
    }
```

Step 5: Implement the `fulfillRandomness` function

```rust
 function _fulfillRandomness(
        bytes32 randomness,
        uint64 requestId,
        bytes memory data,
    ) internal override {
    }
}
```

Step 6: Pass dedicated msg.sender[​](#step-6-pass-dedicated-msgsender "Direct link to Step 6: Pass dedicated msg.sender")
-------------------------------------------------------------------------------------------------------------------------

When you're ready to deploy your Gelato VRF-compatible contract, an important step is to include the dedicated `msg.sender` as a constructor parameter. This ensures your contract is set up to work with the correct operator to fulfill the randomness requests. It's crucial to ensure that only authorized requests are processed.

```rust
// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import {GelatoVRFConsumerBase} from "./GelatoVRFConsumerBase.sol";

contract YourContract is GelatoVRFConsumerBase {
    constructor(address operator)
        GelatoVRFConsumerBase(operator) {
        // Additional initializations
    }

    // The rest of your contract code
}
```

Once your contract is ready & deployed, grab the address and [Deploy your VRF instance](https://docs.gelato.network/web3-services/vrf/quick-start/deploying-your-vrf-instance)!

---

# LayerZero | Arbitrum Docs

## LayerZero

[LayerZero](https://layerzero.network) is an **omnichain interoperability protocol** that enables smart contracts to seamlessly communicate between different blockchain networks. With LayerZero V2, applications deployed on Arbitrum can connect and interact with 100+ supported blockchains through secure, configurable messaging channels.

Key Features[​](#key-features "Direct link to Key Features")
------------------------------------------------------------

LayerZero enables powerful cross-chain capabilities for builders on Arbitrum:

1.  **Cross-chain Messaging** - Send arbitrary messages and data between contracts on different chains
2.  **Omnichain Tokens** - Deploy tokens (fungible `OFT` and non-fungible `ONFT`) that work seamlessly across multiple chains
3.  **External Chain Data Access** (`lzRead`) - Fetch and compute on-chain state from other networks
4.  **Composed Messages** - Chain multiple cross-chain operations together

How it works[​](#how-it-works "Direct link to How it works")
------------------------------------------------------------

1.  **DVNs** independently verify that a message is valid, waiting for a configured number of block confirmations on the source chain.
2.  When the message is verified, **Executors** on the destination chain deliver the message to the target contract, paying for the destination gas automatically in the background. The user only pays for gas on the source chain.

Because each application can configure its own DVN sets, your security is not locked into a single aggregator or middlechain. For more details, check out the [LayerZero docs](https://docs.layerzero.network/).

To run your own DVN as part of your security set, check out the [DVN docs](https://docs.layerzero.network/v2/developers/evm/off-chain/build-dvns).

Arbitrum Integration[​](#arbitrum-integration "Direct link to Arbitrum Integration")
------------------------------------------------------------------------------------

When integrating with LayerZero, there are two key aspects to understand:

1.  The [LayerZero Endpoint](https://docs.layerzero.network/v2/home/protocol/layerzero-endpoint)
    *   Immutable smart contract that serves as the entry and exit point for messages
    *   Allows applications to configure security and execution parameters
    *   Provides interfaces for sending, receiving and reading cross-chain data
2.  [Security Stack](https://docs.layerzero.network/v2/home/modular-security/security-stack-dvns)
    *   Configurable set of Decentralized Verifier Networks (DVNs) that validate messages
    *   Allows applications to customize security and cost tradeoffs
    *   Ensures message integrity across chains

### Contract Addresses[​](#contract-addresses "Direct link to Contract Addresses")

Chain

Chain Id

Endpoint Id

Endpoint Address

Arbitrum Mainnet

42161

30110

[

0x1a44076050125825900e736c501f859c50fE728c

](https://layerzeroscan.com/api/explorer/arbitrum/address/0x1a44076050125825900e736c501f859c50fE728c)

Arbitrum Nova Mainnet

42170

30175

[

0x1a44076050125825900e736c501f859c50fE728c

](https://layerzeroscan.com/api/explorer/nova/address/0x1a44076050125825900e736c501f859c50fE728c)

Arbitrum Sepolia Testnet

421614

40231

[

0x6EDCE65403992e310A62460808c4b910D972f10f

](https://layerzeroscan.com/api/explorer/arbitrum-sepolia/address/0x6EDCE65403992e310A62460808c4b910D972f10f)

Once a transaction is submitted, you can trace it on [LayerZero Scan](https://layerzeroscan.com/), which shows cross-chain message flow from source to destination in real time.

Getting Started[​](#getting-started "Direct link to Getting Started")
---------------------------------------------------------------------

Developers should:

1.  Deploy contracts on each chain: [Quickstart - Create Your First Omnichain App](https://docs.layerzero.network/v2/developers/evm/create-lz-oapp/start)
2.  Configure a Security Stack by selecting DVNs & block confirmations (optional).
3.  Optionally configure an Executor or use defaults to deliver messages.
4.  Send messages, send tokens (OFT, ONFT), or read state on any chain, using LayerZero.

Example Use Cases[​](#example-use-cases "Direct link to Example Use Cases")
---------------------------------------------------------------------------

LayerZero powers various cross-chain applications across different categories:

1.  **Omnichain Tokens (OFTs)** (e.g., [Ethena's USDe](https://ethena.fi/), Wrapped Bitcoin)
    *   Unified token supply across chains
    *   Native bridging without intermediary tokens
    *   Real-world examples include USDe, sUSDe, ENA tokens, and WBTC
2.  **Cross-chain DEXs** (e.g., [Trader Joe](https://traderjoexyz.com/))
    *   Unified liquidity pools across chains
    *   Cross-chain swaps and trading
3.  **Omnichain Lending** (e.g., [Radiant Capital](https://radiant.capital/))
    *   Supply assets on any chain
    *   Borrow against cross-chain collateral
4.  **Cross-chain Governance** (e.g., [Stargate DAO](https://stargate.finance/))
    *   Vote on one chain, execute on many
    *   Unified governance across deployments
5.  **Chain Data Oracles**
    *   Read and verify external chain state
    *   Make decisions based on cross-chain data

Resources[​](#resources "Direct link to Resources")
---------------------------------------------------

1.  [LayerZero Developer Documentation](https://docs.layerzero.network/v2)
2.  [LayerZero Scan](https://layerzeroscan.com/) - Message explorer and debugging
3.  [Discord Community](https://discord.gg/layerzero)
4.  [GitHub](https://github.com/LayerZero-Labs/)

---

# Moralis Quickstart - Crypto Data APIs for Arbitrum | Arbitrum Docs

## Moralis Quickstart - Crypto Data APIs for Arbitrum

**[Moralis](https://moralis.io/?utm_source=arbitrum-docs&utm_medium=partner-docs)** is a blockchain data platform that provides developers with all the data they need to build better blockchain applications. From NFT data, token data and price data, through to raw blockchain data and RPC nodes, Moralis offers a wide range of products that cover all major crypto and blockchain use cases, and it supports Arbitrum together with all other major EVM chains.

Quickstart Guide[​](#quickstart-guide "Direct link to Quickstart Guide")
------------------------------------------------------------------------

Get started with Moralis APIs on Arbitrum by checking out our [Get Started Guide](https://docs.moralis.io/web3-data-api/evm/get-your-api-key/?utm_source=arbitrum-docs&utm_medium=partner-docs), or watch some of our popular [Youtube tutorials](https://www.youtube.com/@MoralisWeb3/featured).

Moralis APIs[​](#moralis-apis "Direct link to Moralis APIs")
------------------------------------------------------------

All Moralis APIs have support for Arbitrum and across all other major EVM blockchains. All endpoints have powerful filtering capabilities.

Endpoints

Please check out the [Moralis API Reference](https://docs.moralis.io/?utm_source=arbitrum-docs&utm_medium=partner-docs) to see all the available API endpoints.

### Wallet API[​](#wallet-api "Direct link to Wallet API")

With Moralis [Wallet API](https://moralis.io/api/wallet/?utm_source=arbitrum-docs&utm_medium=partner-docs) you can get Wallet balances for tokens, NFTs and native assets, get full wallet history, net worth and a lot more.

### NFT API[​](#nft-api "Direct link to NFT API")

With Moralis [NFT API](https://moralis.io/api/nft/?utm_source=arbitrum-docs&utm_medium=partner-docs) you can get NFT data like collections, owners, prices, images and metadata.

### Token API[​](#token-api "Direct link to Token API")

With Moralis [Token API](https://moralis.io/api/token/?utm_source=arbitrum-docs&utm_medium=partner-docs) you can get ERC20 token data like prices, ownership, metadata, transfers, approvals, liquidity, mints and burns.

### RPC Nodes[​](#rpc-nodes "Direct link to RPC Nodes")

Get access to powerful RPC nodes on all major chains with [Moralis Nodes](https://moralis.io/nodes/?utm_source=arbitrum-docs&utm_medium=partner-docs).

---

# OKX - Crypto exchange, app, and wallet | Arbitrum Docs

## OKX - Crypto exchange, app, and wallet

[OKX](https://www.okx.com/) is an innovative and reliable cryptocurrency exchange with advanced financial services. OKX relies on blockchain technology to provide everything you need for wise trading and investment. With OKX, you can trade with confidence, knowing that your assets are in safe hands.

Users can enjoy hundreds of tokens and trading pairs. With OKX, you can join one of the leading crypto exchanges by trading volume. OKX serves millions of users in over 100 countries, and it’s not just about trading. OKX provides a comprehensive suite of services including spot, margin, expiry, options, perpetual futures trading, DeFi, lending, and mining.

Wallet API[​](#wallet-api "Direct link to Wallet API")
------------------------------------------------------

The OKX [wallet API](https://www.okx.com/web3/build/docs/waas/walletapi-introduction) offers a flexible, non-custodial wallet technology solution to build on-chain services and applications.

*   Web3 multi-chain support
*   DApp embedded wallet
*   Multi-chain Web3 apps
*   Exchange wallet

DEX API[​](#dex-api "Direct link to DEX API")
---------------------------------------------

The [DEX API](https://www.okx.com/web3/build/docs/waas/dex-introduction) is a comprehensive trading aggregator for multi-chain and cross-chain transactions. You can use it to create Web3 trading services and applications for various scenarios, including wallets, DApp projects, and DeFi projects.

*   Multi-chain support
*   Aggregation over multiple cross-chain bridges and DEXs
*   Stability and high availability

NFT marketplace API[​](#nft-marketplace-api "Direct link to NFT marketplace API")
---------------------------------------------------------------------------------

The [OKX NFT Marketplace](https://www.okx.com/web3/build/docs/waas/marketplace-introduction) is an extensive decentralized platform that supports multi-chain NFT creations and cross-platform transactions. It provides real-time on-chain data for both users and developers.

*   NFT aggregator
*   Issuance and secondary marketplace

Defi API[​](#defi-api "Direct link to Defi API")
------------------------------------------------

OKX Web3 DeFi is the only all-in-one DeFi investment solution available on the market. OKX’s multi-chain DeFi aggregator provides users with a comprehensive platform to discover and access various investment opportunities in DeFi, making it easy to find products that meet their needs.

OKX Web3 DeFi connects to over 80 protocols, including Aave, Compound, Curve, Yearn, and Uniswap. OKX supports over 15 networks like Arbitrum, Ethereum, and Polygon. By integrating the [OKX Web3 DeFi Open API](https://www.okx.com/web3/build/docs/waas/defi-introduction) into your application, users can quickly and easily access all DeFi protocols and enjoy the benefits of DeFi investment.

---

# How to onboard users in your game and make a gasless transaction | Arbitrum Docs

## How to onboard users in your game and make a gasless transaction

Community member contribution

The following document was contributed by [@joalavedra](https://github.com/joalavedra). Give them a shoutout if you find it useful!

**[Openfort](https://www.openfort.xyz/)** is a headless wallet solution that helps developers integrate authentication, private key management, and account abstraction into their dApps. By abstracting away the complexities of blockchain interactions, Openfort allows you to build Web3 applications with a Web2-like user experience without requiring end users to manage private keys or hold cryptocurrency.

Openfort enables you to:

*   Implement secure authentication and key management
*   Create and manage smart contract wallets
*   Enable gasless and sponsored transactions

Check out **[Openfort's Documentation](https://www.openfort.xyz/docs)** to get started.

Openfort dashboard[​](#openfort-dashboard "Direct link to Openfort dashboard")
------------------------------------------------------------------------------

The Openfort dashboard allows you to:

*   Create and manage projects
*   Generate API keys
*   Configure authentication providers
*   Monitor transactions and analytics
*   Set up webhooks for real-time notifications

Openfort Dashboard

Please check out the [docs](https://www.openfort.xyz/docs/) to learn more about using the Openfort Dashboard. Click [here](https://dashboard.openfort.xyz) to access the Openfort Dashboard.

How to implement a gasless transaction on Arbitrum using Openfort[​](#how-to-implement-a-gasless-transaction-on-arbitrum-using-openfort "Direct link to How to implement a gasless transaction on Arbitrum using Openfort")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

With Openfort, you can sponsor transactions for your users, meaning that in-game wallets don't need native tokens to execute transactions, such as minting an NFT. This guide will walk you through the process of implementing a gasless transaction to mint an NFT on Arbitrum.

### 1\. Import the NFT Contract[​](#1-import-the-nft-contract "Direct link to 1. Import the NFT Contract")

First, you need to import the smart contract you'll be interacting with. In this case, we'll use an NFT contract with a 'mint' function.

```rust
curl https://api.openfort.xyz/v1/contracts \
  -u "$YOUR_SECRET_KEY:" \
  -d 'name=NFT Contract' \
  -d 'chainId=42161' \
  -d 'address=YOUR_CONTRACT_ADDRESS'
```

Replace `YOUR_CONTRACT_ADDRESS` with the address of your NFT contract on Arbitrum.

### 2\. Set up the Gas Policy[​](#2-set-up-the-gas-policy "Direct link to 2. Set up the Gas Policy")

Create a new policy to sponsor gas fees for users:

```rust
curl https://api.openfort.xyz/v1/policies \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d chainId=42161 \
  -d name="Arbitrum NFT Sponsor" \
  -d "strategy[sponsorSchema]=pay_for_user"
```

Then, add a policy rule for the NFT contract:

```rust
curl https://api.openfort.xyz/v1/policies/:id/policy_rules \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d type="contract_functions" \
  -d functionName="mint" \
  -d contract="con_..."
```

Replace `:id` with the policy ID returned from the previous step, and `con_...` with your contract ID.

### 3\. Create a gasless transaction[​](#3-create-a-gasless-transaction "Direct link to 3. Create a gasless transaction")

Now, let's create a transaction to mint an NFT without the user paying for gas:

```rust
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const policyId = 'pol_...'; // Your policy ID from step 2

const transactionIntent = await openfort.transactionIntents.create({
  chainId: 42161, // Arbitrum One
  policy: policyId,
  optimistic: true,
  interactions: {
    contract: 'con_....', // Your NFT contract ID
    functionName: 'mint',
    functionArgs: ['0x...'], // Address to receive the NFT
  },
});
```

### 4\. Optional: specify the player[​](#4-optional-specify-the-player "Direct link to 4. Optional: specify the player")

If you want to associate the transaction with a specific player:

```rust
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const playerId = 'pla_...'; // Your player ID
const policyId = 'pol_...'; // Your policy ID from step 2

const transactionIntent = await openfort.transactionIntents.create({
  player: playerId,
  chainId: 42161, // Arbitrum One
  policy: policyId,
  optimistic: true,
  interactions: {
    contract: 'con_....', // Your NFT contract ID
    functionName: 'mint',
    functionArgs: [playerId], // Minting to the player's address
  },
});
```

By following these steps, you've created a gasless transaction on Arbitrum using Openfort. The user can now mint an NFT without needing to hold ETH for gas fees. Remember to handle the response from the `transactionIntents.create` call in your application to provide feedback to the user about the minting process.

Detailed tutorial

For a more detailed tutorial, please refer to the [Openfort Quick Start Guide](https://www.openfort.xyz/docs/guides/getting-started).

Connect with Openfort[​](#connect-with-openfort "Direct link to Connect with Openfort")
---------------------------------------------------------------------------------------

Need further assistance? Reach out to Openfort for support and stay updated:

*   Visit Openfort's official website at [openfort.xyz](https://www.openfort.xyz)
*   Read the [Documentation](https://www.openfort.xyz/docs)
*   For support, contact the Openfort team via [Discord](https://discord.gg/t7x7hwkJF4)
*   Follow Openfort on [Twitter](https://twitter.com/openfortxyz)
*   Check out Openfort on [GitHub](https://github.com/openfort-xyz)

---

# Quickstart: PARSIQ (blockchain data API & SDK) | Arbitrum Docs

## Quickstart: PARSIQ (blockchain data API & SDK)

**[PARSIQ](https://www.parsiq.net/)** is a reliable, fully customizable blockchain data indexer, helping developers to seamlessly access, process and utilize Web3 data - both raw and custom.

PARSIQ API allows querying blockchain data such as transactions, token transfers, events, internal function calls, blocks, etc.

PARSIQ SDK allows accumulating, processing, and storing this data according to the developer-specified logic, as well as building your own API endpoints.

Check out **[this introduction video](https://www.youtube.com/watch?v=kQJYJGt62hc)** to get started.

PARSIQ Tsunami API[​](#parsiq-tsunami-api "Direct link to PARSIQ Tsunami API")
------------------------------------------------------------------------------

PARSIQ Tsunami API is a highly efficient API to fetch raw Web3 data:

*   Events, calls, transactions (internal included), transfers, contracts, blocks - you name it. Possibility to use unlimited blockrange makes Tsunami a hard-to-beat solution for reliably getting large amounts of data from the blockchain. CSV Export is available.
*   Get decoded, human readable data right out of the box.
*   Need an up to date feeds of data streamed to you in real time? Give our low latency Real Time Streaming service a try.

Endpoints

Please check out our [PARSIQ API Reference](https://docs.parsiq.net/reference/introduction) to see all the available endpoints.

PARSIQ SDK[​](#parsiq-sdk "Direct link to PARSIQ SDK")
------------------------------------------------------

Some more complicated cases where custom data needs to be stored, accumulated, and calculated, cannot be covered by an API. In that cases, use PARSIQ SDK or go for a Custom Data Lake. They allow you to set up data bases and data processing logic to solve your specific use case.

SDK Documentation

Please see [PARSIQ SDK documentation](https://docs.parsiq.net/reference/your-own-web3-api) for more details.

---

# How to implement Particle Connect for AA-enabled social logins | Arbitrum Docs

## How to implement Particle Connect for AA-enabled social logins

Community member contribution

Shoutout to [@TABASCOatw](https://github.com/TABASCOatw) for contributing the following [third-party document](/for-devs/third-party-docs/contribute)!

[Particle Network](https://particle.network) enables one-click onboarding into smart accounts through its Wallet Abstraction stack, providing social logins and wallet connection kits compatible with Arbitrum.

By integrating customizable Externally Owned Account (EOA) and Account Abstraction (AA) modules, Particle enables fast 2-click onboarding via social login options like Google, email, and phone, along with traditional Web3 options.

This approach lets developers implement embedded wallets, bypassing the need for conventional wallet management and provides users with a seamless and tailored Web3 interaction experience, very akin to that of Web2.

Arbitrum was one of the first blockchains supported by Particle Network. Because of this, Particle Network has extensive support for:

*   Arbitrum One, through:
    *   EOA (non-AA social login)
    *   SimpleAccount
    *   Biconomy (V1 and V2)
    *   Light Account
    *   Cyber Account
*   Arbitrum Nova, through:
    *   EOA (non-AA social login)
    *   SimpleAccount
    *   Biconomy (V1 and V2)

Alongside a similar degree of support for Arbitrum Sepolia.

Given its modular architecture, developers have the liberty to choose which of the above smart account implementations they onboard a user into after the social login process.

The user flow with Particle Network begins with social logins (using either a custom authentication or preset login methods provided by Particle Network), which leads to the generation of an EOA through MPC-TSS. This EOA is then used as a Signer for a smart account implementation that best fits the needs of the application in question (natively, this means a choice between SimpleAccount, Biconomy V1/V2, Light Account, and Cyber Account). A visualization of this process can be found below:

![Particle Network User Flow](https://i.imgur.com/qfEpjgz.png)

* * *

This document outlines the high-level steps for building a demo application on Arbitrum Sepolia using the [Particle Connect SDK](https://developers.particle.network/api-reference/connect/desktop/web) — Particle's flagship onboarding SDK. The Particle Connect SDK enables unified onboarding with social and Web3 login options within a single modal. In this demo, we'll onboard users through a SimpleAccount instance of a smart account via social login and execute a gasless (sponsored) transaction.

Getting started[​](#getting-started "Direct link to Getting started")
---------------------------------------------------------------------

This tutorial uses a [Next.js app](https://nextjs.org/docs/getting-started/installation) with TypeScript and Tailwind CSS to showcase wallet creation on Arbitrum through social logins.

With the Particle Connect SDK, wallet creation, user login, and blockchain interactions are simplified into a cohesive interface. Supporting both social logins and traditional Web3 wallets.

### Dependencies[​](#dependencies "Direct link to Dependencies")

You'll need only a few dependencies to integrate Particle Connect into your Arbitrum application. Particle Connect offers built-in Account Abstraction (AA) support; however, in this example, we'll install the Particle AA SDK to use an EIP-1193 providers, such as ethers.

```rust
yarn add @particle-network/connectkit viem@^2 @particle-network/aa ethers
```

### Setting up the Particle dashboard[​](#setting-up-the-particle-dashboard "Direct link to Setting up the Particle dashboard")

Before jumping into the configuration process, you'll need to go to the [Particle dashboard](https://dashboard.particle.network) to retrieve three values required for your project.

When using any SDK offered by Particle Network, you'll routinely need a `projectId`, `clientKey`, and `appId`. These exist to authenticate your project and create a connection between your instance of Particle Auth and the Particle dashboard (which allows you to customize the application-embedded modals, track users, fund your Paymaster, and so on).

Once you've navigated to the Particle dashboard, follow the process below:

1.  Create a new project through **Add New Project**.
2.  Click **Web** under **Your Apps** (if you intend to use an alternative platform, take a look at the [platform-specific guides on Particle's documentation](https://developers.particle.network/reference/introduction-to-api-sdk-reference))
3.  Choose a name and domain for your application (if you have yet to deploy or decide on a domain where you intend to deploy, feel free to use any filler one).
4.  Copy the **Project ID**, **Client Key** and **App ID**.

Given the nature of these values, it's recommended that you store them within a `.env` file with this format:

```rust
NEXT_PUBLIC_PROJECT_ID='PROJECT_ID'
NEXT_PUBLIC_CLIENT_KEY='CLIENT_KEY'
NEXT_PUBLIC_APP_ID='APP_ID'
NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID='WALLETCONNECT_PROJECT_ID'
```

Configuring Particle Connect[​](#configuring-particle-connect "Direct link to Configuring Particle Connect")
------------------------------------------------------------------------------------------------------------

To get started, we'll configure and initialize Particle Connect. Create a new `ConnectKit.tsx` file in your `src` directory. Here, we'll set up the `ParticleConnectKit` component, a wrapper for the configured `ConnectKitProvider` instance, which will serve as the central interface for configuration.

```rust
'use client';

import React from 'react';
import { ConnectKitProvider, createConfig } from '@particle-network/connectkit';
import { authWalletConnectors } from '@particle-network/connectkit/auth';
import { evmWalletConnectors } from '@particle-network/connectkit/evm';
import { arbitrumSepolia } from '@particle-network/connectkit/chains';
import { wallet, EntryPosition } from '@particle-network/connectkit/wallet';
import { aa } from '@particle-network/connectkit/aa';

const config = createConfig({
  projectId: process.env.NEXT_PUBLIC_PROJECT_ID!,
  clientKey: process.env.NEXT_PUBLIC_CLIENT_KEY!,
  appId: process.env.NEXT_PUBLIC_APP_ID!,

  walletConnectors: [
    authWalletConnectors({}), // Social logins

    // Default Web3 logins
    evmWalletConnectors({
      walletConnectProjectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID, // optional, retrieved from https://cloud.walletconnect.com
    }),
  ],

  plugins: [
    wallet({
      entryPosition: EntryPosition.BR, // Positions the modal button at the bottom right on login
      visible: true, // Determines if the wallet modal is displayed
    }),
    aa({
      name: 'SIMPLE',
      version: '2.0.0',
    }),
  ],
  chains: [arbitrumSepolia],
});

export const ParticleConnectkit = ({ children }: React.PropsWithChildren) => {
  return <ConnectKitProvider config={config}>{children}</ConnectKitProvider>;
};
```

This code sets up Particle Connect with a configuration for wallet authentication and blockchain interactions on Arbitrum Sepolia. It includes social logins and traditional Web3 options through WalletConnect and enables Account Abstraction (AA) with a `SimpleAccount` instance version 2.0.0. The configured `ConnectKitProvider` component then wraps the app's content, making this configuration available.

Integrate Particle Connect in Your App[​](#integrate-particle-connect-in-your-app "Direct link to Integrate Particle Connect in Your App")
------------------------------------------------------------------------------------------------------------------------------------------

Once configured, wrap your application with the `ParticleConnectKit` component to make the Particle Connect SDK accessible throughout the app. Update the `layout.tsx` file in the `src` directory as shown below:

```rust
import { ParticleConnectkit } from '@/components/Connectkit';
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Particle Connectkit App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ParticleConnectkit>{children}</ParticleConnectkit>
      </body>
    </html>
  );
}
```

Building the Application[​](#building-the-application "Direct link to Building the Application")
------------------------------------------------------------------------------------------------

With your project set up, dependencies installed, and Particle Connect configured, you can start building in the `page.tsx` file.

In `page.tsx`, you'll define the core features: login flow, data visualization, transaction handling, and the UI.

### Connecting the Wallet[​](#connecting-the-wallet "Direct link to Connecting the Wallet")

With `layout.tsx` configured, the next step is to add a primary **Connect Wallet** button to facilitate user login. Import `ConnectButton` from `@particle-network/connectkit` and add it to the interface. After the user logs in, the `ConnectButton` component will throw a unified login modal upon clicking, an example of this modal is viewable [here](https://demo.particle.network).

```rust
'use client';
import { ConnectButton, useAccount } from '@particle-network/connectkit';

const HomePage = () => {
  const { address, isConnected, chainId } = useAccount();

  return (
    <div className="flex justify-center items-center h-screen">
      <div className="text-center">
        <ConnectButton />
        {isConnected && (
          <>
            <h2>Address: {address}</h2>
            <h2>Chain ID: {chainId}</h2>
          </>
        )}
      </div>
    </div>
  );
};

export default HomePage;
```

### Sending Transactions with an EIP-1193 Provider[​](#sending-transactions-with-an-eip-1193-provider "Direct link to Sending Transactions with an EIP-1193 Provider")

Particle Connect includes AA features out of the box, but using it with the Particle AA SDK allows you to work with EIP-1193 providers, like `ethers`. This approach is especially helpful if you're already familiar with these providers or are integrating Particle Connect into an existing app.

To implement this, wrap the smart account provided by Particle Connect in an instance of `ethers` to create a `customProvider`. With this setup, you can use `ethers` as usual, with the smart account handling the signing of transactions in the background.

```rust
import { useSmartAccount } from '@particle-network/connectkit';
import { AAWrapProvider, SendTransactionMode } from '@particle-network/aa';

const smartAccount = useSmartAccount();

// Init custom provider with gasless transaction mode
const customProvider = smartAccount
  ? new ethers.BrowserProvider(
      new AAWrapProvider(smartAccount, SendTransactionMode.Gasless) as Eip1193Provider,
      'any',
    )
  : null;

/**
 * Sends a transaction using the ethers.js library.
 * This transaction is gasless since the customProvider is initialized as gasless
 */
const executeTxEthers = async () => {
  if (!customProvider) return;

  const signer = await customProvider.getSigner();
  const tx = {
    to: recipientAddress,
    value: parseEther('0.01').toString(),
  };

  const txResponse = await signer.sendTransaction(tx);
  const txReceipt = await txResponse.wait();
  console.log(txReceipt?.hash);
};
```

This transaction will be gasless because it meets two key conditions:

1.  **Gasless Mode Configuration**: By setting `SendTransactionMode.Gasless` within `AAWrapProvider`, we've specified that the transaction should be gasless and sponsored.
2.  **Funding Requirements**: On a Testnet like Arbitrum Sepolia, all transactions are automatically sponsored, meaning you don't need to deposit USDT to cover transaction fees. However, on mainnets like Arbitrum One or Arbitrum Nova, the Paymaster (configurable in the [Particle dashboard](https://dashboard.particle.network)) would need sufficient funds to sponsor these transactions.

This example demonstrates how to use an existing EIP-1193 provider, but you can also construct a `userOp` directly with Particle Connect. For an example, refer to the [starter repository](https://github.com/Particle-Network/connectkit-aa-usage/blob/2017262daf297624362d51f3d50cccd3b4606ef9/app/page.tsx#L117).

Full app example[​](#full-app-example "Direct link to Full app example")
------------------------------------------------------------------------

With the setup complete, Particle Connect can now be leveraged, as demonstrated in the example application below.

In this example, the application creates a smart account on Arbitrum Sepolia using a social login or a Web3 login and sends a gasless transaction of 0.01 ETH via the `ethers` provider.

```rust
'use client';
import React, { useEffect, useState } from 'react';

// Particle imports
import {
  ConnectButton,
  useAccount,
  usePublicClient,
  useSmartAccount,
} from '@particle-network/connectkit';

// Eip1193 and AA Provider
import { AAWrapProvider, SendTransactionMode } from '@particle-network/aa'; // Only needed with Eip1193 provider
import { ethers, type Eip1193Provider } from 'ethers';
import { formatEther, parseEther } from 'viem';

export default function Home() {
  const { isConnected, chain } = useAccount();
  const publicClient = usePublicClient();
  const smartAccount = useSmartAccount();

  const [userAddress, setUserAddress] = useState<string>('');
  const [balance, setBalance] = useState<string | null>(null);
  const [recipientAddress, setRecipientAddress] = useState<string>('');
  const [transactionHash, setTransactionHash] = useState<string | null>(null);

  // Init custom provider with gasless transaction mode
  const customProvider = smartAccount
    ? new ethers.BrowserProvider(
        new AAWrapProvider(smartAccount, SendTransactionMode.Gasless) as Eip1193Provider,
        'any',
      )
    : null;

  /**
   * Fetches the balance of a given address.
   * @param {string} address - The address to fetch the balance for.
   */
  const fetchBalance = async (address: string) => {
    try {
      const balanceResponse = await publicClient?.getBalance({
        address: address as `0x${string}`,
      });
      if (balanceResponse) {
        const balanceInEther = formatEther(balanceResponse).toString();
        setBalance(balanceInEther);
      } else {
        setBalance('0.0');
      }
    } catch (error) {
      console.error('Error fetching balance:', error);
      setBalance('0.0');
    }
  };

  /**
   * Loads the user's account data, including address and balance.
   */
  useEffect(() => {
    const loadAccountData = async () => {
      if (isConnected && smartAccount) {
        try {
          const address = await smartAccount.getAddress();
          setUserAddress(address);
          await fetchBalance(address);
        } catch (error) {
          console.error('Error loading account data:', error);
        }
      }
    };
    loadAccountData();
  }, [isConnected, smartAccount]);

  /**
   * Sends a transaction using the ethers.js library.
   * This transaction is gasless since the customProvider is initialized as gasless
   */
  const executeTxEthers = async () => {
    if (!customProvider) return;

    const signer = await customProvider.getSigner();
    try {
      const tx = {
        to: recipientAddress,
        value: parseEther('0.01').toString(),
      };

      const txResponse = await signer.sendTransaction(tx);
      const txReceipt = await txResponse.wait();

      setTransactionHash(txReceipt?.hash || null);
    } catch (error) {
      console.error('Failed to send transaction using ethers.js:', error);
    }
  };

  return (
    <div className="container min-h-screen flex flex-col justify-center items-center mx-auto gap-4 px-4 md:px-8">
      <div className="w-full flex justify-center mt-4">
        <ConnectButton label="Click to login" />
      </div>
      {isConnected && (
        <>
          <div className="border border-purple-500 p-6 rounded-lg w-full">
            <h2 className="text-lg font-semibold mb-2 text-white">
              Address: <code>{userAddress || 'Loading...'}</code>
            </h2>
            <h2 className="text-lg font-semibold mb-2 text-white">
              Balance: {balance || 'Loading...'} {chain?.nativeCurrency.symbol}
            </h2>
            <input
              type="text"
              placeholder="Recipient Address"
              value={recipientAddress}
              onChange={(e) => setRecipientAddress(e.target.value)}
              className="mt-4 p-3 w-full rounded border border-gray-700 bg-gray-900 text-white focus:outline-none"
            />
            <button
              className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded mt-4"
              onClick={executeTxEthers}
              disabled={!recipientAddress}
            >
              Send 0.001 {chain?.nativeCurrency.name}
            </button>
            {transactionHash && (
              <p className="text-green-500 mt-4">Transaction Hash: {transactionHash}</p>
            )}
          </div>
        </>
      )}
    </div>
  );
}
```

### Available Particle Connect Hooks[​](#available-particle-connect-hooks "Direct link to Available Particle Connect Hooks")

This example illustrates a basic use of Particle Connect. For a complete list of available hooks, refer to the [Particle Connect documentation](https://developers.particle.network/api-reference/connect/desktop/web#key-react-hooks-for-particle-connect).

Conclusion[​](#conclusion "Direct link to Conclusion")
------------------------------------------------------

Building an application on Arbitrum that takes advantage of social logins and smart accounts simultaneously only takes a few lines of code, and is even more succinct if you're already using Ethers, Web3.js, or any other standard library that supports EIP-1193 providers.

To view the complete demo application leveraging the code snippets covered throughout this document, take a look at the [GitHub repository](https://github.com/Particle-Network/connect-arbitrum-tutorial).

Additionally, to learn more about Particle Network, explore the following resources:

*   Website: [https://particle.network](https://particle.network)
*   Blog: [https://blog.particle.network](https://blog.particle.network)
*   Documentation: [https://developers.particle.network](https://developers.particle.network)

---

# QuickNode Backfill Templates | Arbitrum Docs

## QuickNode Backfill Templates

What are Backfill Templates?[​](#what-are-backfill-templates "Direct link to What are Backfill Templates?")
-----------------------------------------------------------------------------------------------------------

Backfill Templates are pre-built solutions within [Streams](https://www.quicknode.com/streams) (our ETL/streaming tool) designed to simplify the process of acquiring historical blockchain data. With just one click, users can backfill extensive datasets across various chains, including blocks, transactions, receipts, traces, and more.

Key Benefits[​](#key-benefits "Direct link to Key Benefits")
------------------------------------------------------------

*   **Speed**: Start backfilling in less than 10 minutes.
*   **Transparency**: Immediate cost and time estimates for your selected datasets.
*   **Reliability**: Guaranteed data delivery to platforms like Snowflake, Amazon S3, Webhooks, etc.

Available Backfill Templates[​](#available-backfill-templates "Direct link to Available Backfill Templates")
------------------------------------------------------------------------------------------------------------

Below is a table of available Backfill Templates for the Arbitrum network:

Template Name

Description

Link

Backfill Blocks and Transactions

Backfill historical Arbitrum blocks and transactions data.

[Use template](https://dashboard.quicknode.com/streams/new?dataset=block&network=arbitrum_mainnet&start=1&utm_source=arbitrum_backfill_template_click)

Backfill Blocks, Transactions, and Receipts

Backfill historical Arbitrum blocks, transactions, and receipts data.

[Use template](https://dashboard.quicknode.com/streams/new?dataset=block_with_receipts&network=arbitrum_mainnet&start=1&utm_source=arbitrum_backfill_template_click)

Backfill Receipts

Backfill historical Arbitrum receipts data.

[Use template](https://dashboard.quicknode.com/streams/new?dataset=receipts&network=arbitrum_mainnet&start=1&utm_source=arbitrum_backfill_template_click)

Backfill Traces (debug\_trace)

Backfill historical Arbitrum traces (debug\_trace) data.

[Use template](https://dashboard.quicknode.com/streams/new?dataset=debug_trace&network=arbitrum_mainnet&start=1&utm_source=arbitrum_backfill_template_click)

Backfill Blocks, Transactions, Receipts, Traces

Backfill historical Arbitrum blocks, transactions, receipts, and traces (debug\_trace).

[Use template](https://dashboard.quicknode.com/streams/new?dataset=block_with_receipts_debug_trace&network=arbitrum_mainnet&start=1&utm_source=arbitrum_backfill_template_click)

Backfill all ERC20/721/1155 Transfers

Backfill historical Arbitrum ERC20/721/1155 transfers data.

[Use template](https://dashboard.quicknode.com/streams/new?network=arbitrum_mainnet&dataset=block_with_receipts&start=1&filter=ZnVuY3Rpb24gc3RyaXBQYWRkaW5nKGxvZ1RvcGljKSB7CiAgICByZXR1cm4gbG9nVG9waWMgPyAnMHgnICsgbG9nVG9waWMuc2xpY2UoLTQwKS50b0xvd2VyQ2FzZSgpIDogJyc7Cn0KCmZ1bmN0aW9uIHBhcnNlU2luZ2xlRGF0YShkYXRhKSB7CiAgICBpZiAoIWRhdGEgfHwgZGF0YSA9PT0gJzB4JykgcmV0dXJuIHsgdG9rZW5JZDogMCwgdmFsdWU6IDAgfTsKICAgIGNvbnN0IGlkSGV4ID0gZGF0YS5zbGljZSgyLCA2NikucmVwbGFjZSgvXjArLywgJycpIHx8ICcwJzsKICAgIGNvbnN0IHZhbHVlSGV4ID0gZGF0YS5zbGljZSg2NikucmVwbGFjZSgvXjArLywgJycpIHx8ICcwJzsKICAgIGNvbnN0IGlkID0gaWRIZXggPT09ICcwJyA_IDAgOiBCaWdJbnQoJzB4JyArIGlkSGV4KTsKICAgIGNvbnN0IHZhbHVlID0gdmFsdWVIZXggPT09ICcwJyA_IDAgOiBCaWdJbnQoJzB4JyArIHZhbHVlSGV4KTsKICAgIHJldHVybiB7IHRva2VuSWQ6IGlkLCB2YWx1ZTogdmFsdWUgfTsKfQoKZnVuY3Rpb24gcGFyc2VCYXRjaERhdGEoZGF0YSkgewogICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoIDwgMTMwKSByZXR1cm4geyBpZHM6IFtdLCB2YWx1ZXM6IFtdIH07CiAgICBjb25zdCBpZHNBcnJheU9mZnNldCA9IHBhcnNlSW50KGRhdGEuc2xpY2UoMiwgNjYpLCAxNikgKiAyICsgMjsKICAgIGNvbnN0IHZhbHVlc0FycmF5T2Zmc2V0ID0gcGFyc2VJbnQoZGF0YS5zbGljZSg2NiwgMTMwKSwgMTYpICogMiArIDI7CiAgICBjb25zdCB0b2tlbkNvdW50ID0gKHZhbHVlc0FycmF5T2Zmc2V0IC0gaWRzQXJyYXlPZmZzZXQpIC8gNjQ7CgogICAgY29uc3QgaWRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdG9rZW5Db3VudCB9LCAoXywgaSkgPT4gewogICAgICAgIGNvbnN0IGlkSGV4ID0gZGF0YS5zbGljZShpZHNBcnJheU9mZnNldCArIGkgKiA2NCwgaWRzQXJyYXlPZmZzZXQgKyAoaSArIDEpICogNjQpLnJlcGxhY2UoL14wKy8sICcnKSB8fCAnMCc7CiAgICAgICAgcmV0dXJuIGlkSGV4ID09PSAnMCcgPyAwIDogQmlnSW50KCcweCcgKyBpZEhleCk7CiAgICB9KTsKCiAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0b2tlbkNvdW50IH0sIChfLCBpKSA9PiB7CiAgICAgICAgY29uc3QgdmFsdWVIZXggPSBkYXRhLnNsaWNlKHZhbHVlc0FycmF5T2Zmc2V0ICsgaSAqIDY0LCB2YWx1ZXNBcnJheU9mZnNldCArIChpICsgMSkgKiA2NCkucmVwbGFjZSgvXjArLywgJycpIHx8ICcwJzsKICAgICAgICByZXR1cm4gdmFsdWVIZXggPT09ICcwJyA_IDAgOiBCaWdJbnQoJzB4JyArIHZhbHVlSGV4KTsKICAgIH0pOwoKICAgIHJldHVybiB7IGlkcywgdmFsdWVzIH07Cn0KCmZ1bmN0aW9uIG1haW4oZGF0YSkgewogICAgdHJ5IHsKICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuc3RyZWFtRGF0YSkgewogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CgogICAgICAgIGNvbnN0IHN0cmVhbURhdGEgPSBBcnJheS5pc0FycmF5KGRhdGEuc3RyZWFtRGF0YSkgPyBkYXRhLnN0cmVhbURhdGEgOiBbZGF0YS5zdHJlYW1EYXRhXTsKICAgICAgICBjb25zdCBlcmMyMFRyYW5zZmVycyA9IFtdOwogICAgICAgIGNvbnN0IGVyYzcyMVRyYW5zZmVycyA9IFtdOwogICAgICAgIGNvbnN0IGVyYzExNTVUcmFuc2ZlcnMgPSBbXTsKCiAgICAgICAgc3RyZWFtRGF0YS5mb3JFYWNoKHN0cmVhbSA9PiB7CiAgICAgICAgICAgIGlmICghc3RyZWFtIHx8ICFzdHJlYW0uYmxvY2sgfHwgIXN0cmVhbS5yZWNlaXB0cykgewogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICBjb25zdCBibG9ja1RpbWVzdGFtcCA9IHN0cmVhbS5ibG9jay50aW1lc3RhbXAgPyBwYXJzZUludChzdHJlYW0uYmxvY2sudGltZXN0YW1wLCAxNikgKiAxMDAwIDogRGF0ZS5ub3coKTsKCiAgICAgICAgICAgIHN0cmVhbS5yZWNlaXB0cy5mb3JFYWNoKHJlY2VpcHQgPT4gewogICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0IHx8ICFyZWNlaXB0LmxvZ3MpIHJldHVybjsKCiAgICAgICAgICAgICAgICByZWNlaXB0LmxvZ3MuZm9yRWFjaChsb2cgPT4gewogICAgICAgICAgICAgICAgICAgIGlmICghbG9nIHx8ICFsb2cudG9waWNzIHx8IGxvZy50b3BpY3MubGVuZ3RoID09PSAwKSByZXR1cm47CgogICAgICAgICAgICAgICAgICAgIGlmIChsb2cudG9waWNzWzBdID09PSAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJykgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9nLnRvcGljcy5sZW5ndGggPT09IDMgJiYgbG9nLmRhdGEgJiYgbG9nLmRhdGEgIT09ICcweCcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlSGV4ID0gbG9nLmRhdGEuc2xpY2UoMikucmVwbGFjZSgvXjArLywgJycpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUhleCA_IEJpZ0ludCgnMHgnICsgdmFsdWVIZXgpLnRvU3RyaW5nKCkgOiAnMCc7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcmMyMFRyYW5zZmVycy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRVJDMjAnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlcjogc3RyaXBQYWRkaW5nKGxvZy50b3BpY3NbMV0pLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyOiBzdHJpcFBhZGRpbmcobG9nLnRvcGljc1syXSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBsb2cuYWRkcmVzcywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eEhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhJbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUaW1lc3RhbXA6IGJsb2NrVGltZXN0YW1wCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2cudG9waWNzLmxlbmd0aCA9PT0gNCAmJiAoIWxvZy5kYXRhIHx8IGxvZy5kYXRhID09PSAnMHgnKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IEJpZ0ludChsb2cudG9waWNzWzNdKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJjNzIxVHJhbnNmZXJzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdFUkM3MjEnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlcjogc3RyaXBQYWRkaW5nKGxvZy50b3BpY3NbMV0pLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyOiBzdHJpcFBhZGRpbmcobG9nLnRvcGljc1syXSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5JZDogdG9rZW5JZCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdDogbG9nLmFkZHJlc3MsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhIYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4SW5kZXg6IGxvZy50cmFuc2FjdGlvbkluZGV4LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGltZXN0YW1wOiBibG9ja1RpbWVzdGFtcAogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvZy50b3BpY3NbMF0gPT09ICcweGMzZDU4MTY4YzVhZTczOTc3MzFkMDYzZDViYmYzZDY1Nzg1NDQyNzM0M2Y0YzA4MzI0MGY3YWFjYWEyZDBmNjInKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5JZCwgdmFsdWUgfSA9IHBhcnNlU2luZ2xlRGF0YShsb2cuZGF0YSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGVyYzExNTVUcmFuc2ZlcnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRVJDMTE1NV9TaW5nbGUnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHN0cmlwUGFkZGluZyhsb2cudG9waWNzWzFdKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlcjogc3RyaXBQYWRkaW5nKGxvZy50b3BpY3NbMl0pLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXI6IHN0cmlwUGFkZGluZyhsb2cudG9waWNzWzNdKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuSWQ6IHRva2VuSWQudG9TdHJpbmcoKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b1N0cmluZygpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3Q6IGxvZy5hZGRyZXNzLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhIYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhJbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RpbWVzdGFtcDogYmxvY2tUaW1lc3RhbXAKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2cudG9waWNzWzBdID09PSAnMHg0YTM5ZGMwNmQ0YzBkYmM2NGI3MGFmOTBmZDY5OGEyMzNhNTE4YWE1ZDA3ZTU5NWQ5ODNiOGMwNTI2YzhmN2ZiJykgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlkcywgdmFsdWVzIH0gPSBwYXJzZUJhdGNoRGF0YShsb2cuZGF0YSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5mb3JFYWNoKChpZCwgaW5kZXgpID0-IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyYzExNTVUcmFuc2ZlcnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0VSQzExNTVfQmF0Y2gnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBzdHJpcFBhZGRpbmcobG9nLnRvcGljc1sxXSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogc3RyaXBQYWRkaW5nKGxvZy50b3BpY3NbMl0pLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBzdHJpcFBhZGRpbmcobG9nLnRvcGljc1szXSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5JZDogaWQudG9TdHJpbmcoKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2luZGV4XS50b1N0cmluZygpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBsb2cuYWRkcmVzcywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eEhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhJbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUaW1lc3RhbXA6IGJsb2NrVGltZXN0YW1wCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0pOwogICAgICAgIH0pOwoKICAgICAgICBpZiAoIWVyYzIwVHJhbnNmZXJzLmxlbmd0aCAmJiAhZXJjNzIxVHJhbnNmZXJzLmxlbmd0aCAmJiAhZXJjMTE1NVRyYW5zZmVycy5sZW5ndGgpIHsKICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4geyAKICAgICAgICAgICAgZXJjMjA6IGVyYzIwVHJhbnNmZXJzLCAKICAgICAgICAgICAgZXJjNzIxOiBlcmM3MjFUcmFuc2ZlcnMsIAogICAgICAgICAgICBlcmMxMTU1OiBlcmMxMTU1VHJhbnNmZXJzCiAgICAgICAgfTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBtYWluIGZ1bmN0aW9uOicsIGUpOwogICAgICAgIHJldHVybiB7IGVycm9yOiBlLm1lc3NhZ2UgfTsKICAgIH0KfQo)

Backfill all Uniswap V2/V3 Swaps

Backfill historical Arbitrum Uniswap V2/V3 swaps data.

[Use template](https://dashboard.quicknode.com/streams/new?dataset=receipts&network=arbitrum_mainnet&start=169&filter=Ly8gVXNlIHJlY2VpcHRzIGRhdGFzZXQKLy8gc3RhcnQgYXQgYmxvY2sgMTY5CgpmdW5jdGlvbiBtYWluKGRhdGEpIHsKICAgIHRyeSB7CiAgICAgICAgdmFyIHN0cmVhbURhdGEgPSBkYXRhLnN0cmVhbURhdGE7CiAgICAgICAgdmFyIGZpbHRlcmVkUmVjZWlwdHMgPSBbXTsKICAgICAgICAKICAgICAgICAvLyBTd2FwIHRvcGljcyBmb3IgVW5pc3dhcCBWMiBhbmQgVjMKICAgICAgICBjb25zdCB1bmlzd2FwVjJTd2FwVG9waWMgPSAiMHhkNzhhZDk1ZmE0NmM5OTRiNjU1MWQwZGE4NWZjMjc1ZmU2MTNjZTM3NjU3ZmI4ZDVlM2QxMzA4NDAxNTlkODIyIjsKICAgICAgICBjb25zdCB1bmlzd2FwVjNTd2FwVG9waWMgPSAiMHhjNDIwNzlmOTRhNjM1MGQ3ZTYyMzVmMjkxNzQ5MjRmOTI4Y2MyYWM4MThlYjY0ZmVkODAwNGUxMTVmYmNjYTY3IjsKICAgICAgICAKICAgICAgICAvLyBLbm93biBVbmlzd2FwIFJvdXRlciBhZGRyZXNzZXMKICAgICAgICBjb25zdCB1bmlzd2FwVjJSb3V0ZXJzID0gWwogICAgICAgICAgICAiMHg0NzUyYmE1ZGJjMjNmNDRkODc4MjYyNzZiZjZmZDZiMWMzNzJhZDI0Ii50b0xvd2VyQ2FzZSgpIC8vIFVuaXN3YXAgVjIgUm91dGVyCiAgICAgICAgXTsKICAgICAgICAKICAgICAgICBjb25zdCB1bmlzd2FwVjNSb3V0ZXJzID0gWwogICAgICAgICAgICAiMHhFNTkyNDI3QTBBRWNlOTJEZTNFZGVlMUYxOEUwMTU3QzA1ODYxNTY0Ii50b0xvd2VyQ2FzZSgpIC8vIFVuaXN3YXAgVjMgUm91dGVyCiAgICAgICAgXTsKCiAgICAgICAgY29uc3QgdW5pdmVyc2FsUm91dGVycyA9IFsKICAgICAgICAgICAgIjB4NjhiMzQ2NTgzM2ZiNzJBNzBlY0RGNDg1RTBlNEM3YkQ4NjY1RmM0NSIudG9Mb3dlckNhc2UoKSwKICAgICAgICAgICAgIjB4NUUzMjVlREE4MDY0YjQ1NmY0NzgxMDcwQzA3MzhkODQ5YzgyNDI1OCIudG9Mb3dlckNhc2UoKSAvLyBVbml2ZXJzYWwgJiBvdGhlciBSb3V0ZXJzCiAgICAgICAgXTsKCiAgICAgICAgY29uc3QgYWxsUm91dGVycyA9IG5ldyBTZXQoWy4uLnVuaXN3YXBWMlJvdXRlcnMsIC4uLnVuaXN3YXBWM1JvdXRlcnMsIC4uLnVuaXZlcnNhbFJvdXRlcnNdKTsKICAgICAgICBjb25zdCBzd2FwVG9waWNzID0gbmV3IFNldChbdW5pc3dhcFYyU3dhcFRvcGljLCB1bmlzd2FwVjNTd2FwVG9waWNdKTsKCiAgICAgICAgc3RyZWFtRGF0YS5mb3JFYWNoKHJlY2VpcHQgPT4gewogICAgICAgICAgICBjb25zdCB0b0FkZHJlc3MgPSByZWNlaXB0LnRvLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgIGlmIChhbGxSb3V0ZXJzLmhhcyh0b0FkZHJlc3MpKSB7CiAgICAgICAgICAgICAgICBsZXQgaGFzUmVsZXZhbnRMb2cgPSByZWNlaXB0LmxvZ3Muc29tZShsb2cgPT4gCiAgICAgICAgICAgICAgICAgICAgc3dhcFRvcGljcy5oYXMobG9nLnRvcGljc1swXSkKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBpZiAoaGFzUmVsZXZhbnRMb2cpIHsKICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFJlY2VpcHRzLnB1c2gocmVjZWlwdCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKCiAgICAgICAgcmV0dXJuIGZpbHRlcmVkUmVjZWlwdHMubGVuZ3RoID4gMCA_IHsgZmlsdGVyZWRSZWNlaXB0cyB9IDogbnVsbDsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICByZXR1cm4geyBlcnJvcjogZS5tZXNzYWdlIH07CiAgICB9Cn0)

For detailed pricing and timing information, visit our [Streams Backfills - Arbitrum](https://www.quicknode.com/streams/backfills/arbitrum) page.

Additional Resources[​](#additional-resources "Direct link to Additional Resources")
------------------------------------------------------------------------------------

*   [QuickNode - Arbitrum Chain Page](https://www.quicknode.com/chains/arb)
*   [QuickNode - Arbitrum Documentation](https://www.quicknode.com/docs/arbitrum)
*   [QuickNode Builders Guide - Arbitrum Orbits](https://www.quicknode.com/builders-guide/tools/arbitrum-orbits-by-arbitrum-foundation)
*   [QuickNode - Arbitrum Faucet](https://faucet.quicknode.com/arbitrum)

---

# The Graph | Arbitrum Docs

## The Graph

Getting historical data on a smart contract can be frustrating when building a dApp. [The Graph](https://thegraph.com/) provides an easy way to query smart contract data through APIs known as subgraphs, which utilize `GraphQL`.  The Graph's infrastructure relies on a decentralized network of indexers, enabling your dApp to become truly decentralized.

Quick start[​](#quick-start "Direct link to Quick start")
---------------------------------------------------------

These subgraphs only take a few minutes to set up and get running. To get started, follow these three steps:

1.  [Initialize your subgraph project](#1-initialize-your-subgraph-project)
2.  [Deploy & publish](#2-deploy--publish)
3.  [Query from your dApp](#sample-query)

Pricing: **All developers receive 100K free monthly queries on the decentralized network**. After these free queries, you only pay based on usage at $4 for every 100K queries.

Here's a step by step walkthrough:

1\. Initialize your subgraph project[​](#1-initialize-your-subgraph-project "Direct link to 1. Initialize your subgraph project")
---------------------------------------------------------------------------------------------------------------------------------

### Create a subgraph on Subgraph Studio⁠[​](#create-a-subgraph-on-subgraph-studio "Direct link to Create a subgraph on Subgraph Studio⁠")

Go to the [Subgraph Studio](https://thegraph.com/studio/) and connect your wallet. Once your wallet is connected, you can begin by clicking "Create a Subgraph". Please choose a good name for the subgraph: this name can't be edited later. It is recommended to use Title Case: "Subgraph Name Chain Name."

![Create a Subgraph](https://lh7-us.googleusercontent.com/docsz/AD_4nXf8OTdwMxlKQGKzIF_kYR7NPKeh9TmWnZBYxb7ft_YbdOdx_VVtbp6PslN7N1KGUzNpIDCmaXppdrllM1cw_J4L8Na03BXOWzJTK1POCve0nkRjQYgWJ60QHAdtQ4Niy83SMM8m0F0f-N-AJj4PDqDPlA5M?key=fnI6SyFgXU9SZRNX5C5vPQ)

You will then land on your subgraph's page. All the CLI commands you need will be visible on the right side of the page:

![CLI commands](https://lh7-us.googleusercontent.com/docsz/AD_4nXe3YvCxiOH_LupSWe8zh9AmP-VrV4PlOq3f7Ix6hNlBUYcANUFuLuVIWR74OGiBs0nrugTyT0v3o6RPmTsgHONdv_ZJNWtcDWEkRntXPHlQGFcqmEBa-D6j4aoIPzUKYdOJMVUPu8O3fwjdZ4IaXXZoTzY?key=fnI6SyFgXU9SZRNX5C5vPQ)

### Install the Graph CLI⁠[​](#install-the-graph-cli "Direct link to Install the Graph CLI⁠")

On your local machine, run the following:

```rust
npm install -g @graphprotocol/graph-cli
```

### Initialize your Subgraph⁠[​](#initialize-your-subgraph "Direct link to Initialize your Subgraph⁠")

You can copy this directly from your subgraph page to include your specific subgraph slug:

```rust
graph init --studio <SUBGRAPH_SLUG>
```

You'll be prompted to provide some info on your subgraph like this:

![cli sample](https://lh7-us.googleusercontent.com/docsz/AD_4nXdTAUsUb5vbs3GtCrhKhuXM1xYoqqooYTxw6lfJfYtLJNP8GKVOhTPmjxlM1b6Qpx-pXNVOzRuc8BL12wZXqy4MIj8ja0tp15znfuJD_Mg84SSNj3JpQ4d31lNTxPYnpba4UOzZx8pmgOIsbI7vCz70v9gC?key=fnI6SyFgXU9SZRNX5C5vPQ)

Simply have your contract verified on the block explorer, and the CLI will automatically obtain the ABI and set up your subgraph. The default settings will generate an entity for each event.

2\. Deploy & publish[​](#2-deploy--publish "Direct link to 2. Deploy & publish")
--------------------------------------------------------------------------------

### Deploy to Subgraph Studio⁠[​](#deploy-to-subgraph-studio "Direct link to Deploy to Subgraph Studio⁠")

First, run these commands in your terminal

```rust
graph codegen
graph build
```

Then, invoke these commands to authenticate and deploy your subgraph. You can copy these commands directly from your subgraph's page in Studio to include your specific deploy key and subgraph slug:

```rust
graph auth --studio <DEPLOY_KEY>
graph deploy --studio <SUBGRAPH_SLUG>
```

You will be asked for a version label. You can enter something like `V0.0.1`, but you're free to choose the format.

### Test your subgraph⁠[​](#test-your-subgraph "Direct link to Test your subgraph⁠")

You can test your subgraph by making a sample query in the playground section. The Details tab will show you an API endpoint. You can use that endpoint to test from your dApp.

![Playground](https://lh7-us.googleusercontent.com/docsz/AD_4nXf3afwSins8_eO7BceGPN79VvwolDxmFNUnkPk0zAJCaUA-3-UAAjVvrMzwr7q9vNYWdrEUNgm2De2VfQpWauiT87RkFc-cVfoPSsQbYSgsmwhyY1-tpPdv2J1H4JAMq70nfWBhb8PszZBFjsbDAaJ5eto?key=fnI6SyFgXU9SZRNX5C5vPQ)

### Publish your subgraph to The Graph's decentralized network[​](#publish-your-subgraph-to-the-graphs-decentralized-network "Direct link to Publish your subgraph to The Graph's decentralized network")

Once your subgraph is ready for production, you can publish it to the decentralized network. On your subgraph's page in Subgraph Studio, click on the Publish button:

![publish button](https://edgeandnode.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fa7d6afae-8784-4b15-a90e-ee8f6ee007ba%2F2f9c4526-123d-4164-8ea8-39959c8babbf%2FUntitled.png?table=block&id=37005371-76b4-4780-b044-040a570e3af6&spaceId=a7d6afae-8784-4b15-a90e-ee8f6ee007ba&width=1420&userId=&cache=v2)

Before you can query your subgraph, Indexers need to begin serving queries on it. In order to streamline this process, you can curate your own subgraph using `$GRT`.

When publishing, you'll see the option to curate your subgraph. As of May 2024, it is recommended that you curate your own subgraph with at least 3,000 `$GRT` to ensure that it is indexed and available for querying as soon as possible.

![Publish screen](https://lh7-us.googleusercontent.com/docsz/AD_4nXerUr-IgWjwBZvp9Idvz5hTq8AFB0n_VlXCzyDtUxKaCTANT4gkk-2O77oW-a0ZWOh3hnqQsY7zcSaLeCQin9XU1NTX1RVYOLFX9MuVxBEqcMryqgnGQKx-MbDnOWKuMoLBhgyVWQereg3cdWtCPcTQKFU?key=fnI6SyFgXU9SZRNX5C5vPQ)

3\. Query your Subgraph[​](#3-query-your-subgraph "Direct link to 3. Query your Subgraph")
------------------------------------------------------------------------------------------

Congratulations! You can now query your subgraph on the decentralized network!

You can start querying any subgraph on the decentralized network by passing a `GraphQL` query into the subgraph's query URL, which can be found at the top of its Explorer page.

Here's an example from the [CryptoPunks Ethereum subgraph](https://thegraph.com/explorer/subgraphs/HdVdERFUe8h61vm2fDyycHgxjsde5PbB832NHgJfZNqK) by Messari:

![Query URL](https://lh7-us.googleusercontent.com/docsz/AD_4nXebivsPOUjPHAa3UVtvxoYTFXaGBao9pQOAJvFK0S7Uv0scfL6TcTVjmNCzT4DgsIloAQyrPTCqHjFPtmjyrzoKkfSeV28FjS32F9-aJJm0ILAHey2gqMr7Seu4IqPz2d__QotsWG3OKv2dEghiD74eypzs?key=fnI6SyFgXU9SZRNX5C5vPQ)

The query URL for this subgraph is:

```rust
https://gateway-arbitrum.network.thegraph.com/api/**[api-key]**/subgraphs/id/HdVdERFUe8h61vm2fDyycHgxjsde5PbB832NHgJfZNqK
```

Now, you simply need to  fill in your own API Key to start sending `GraphQL` queries to this endpoint.

### Getting your own API key[​](#getting-your-own-api-key "Direct link to Getting your own API key")

![API keys](https://lh7-us.googleusercontent.com/docsz/AD_4nXdz7H8hSRf2XqrU0jN3p3KbmuptHvQJbhRHOJh67nBfwh8RVnhTsCFDGA_JQUFizyMn7psQO0Vgk6Vy7cKYH47OyTq5PqycB0xxLyF4kSPsT7hYdMv2MEzAo433sJT6VlQbUAzgPnSxKI9a5Tn3ShSzaxI?key=fnI6SyFgXU9SZRNX5C5vPQ)

In Subgraph Studio, you'll see the "API Keys" menu at the top of the page. Here, you can create API Keys.

Appendix[​](#appendix "Direct link to Appendix")
------------------------------------------------

### Sample query[​](#sample-query "Direct link to Sample query")

This query shows the most expensive CryptoPunks sold.

```rust
{
  trades(orderBy: priceETH, orderDirection: desc) {
    priceETH
    tokenId
  }
}
```

Passing this into the query URL returns this result:

```rust
{
  "data": {
    "trades": [
      {
        "priceETH": "124457.067524886018255505",
        "tokenId": "9998"
      },
      {
        "priceETH": "8000",
        "tokenId": "5822"
      },
//      ...
```

💡 Trivia: Looking at the top sales on [CryptoPunks website](https://cryptopunks.app/cryptopunks/topsales) it looks like the top sale is Punk #5822, not #9998. Why? Because they censored the flash-loan sale that happened.

### Sample code[​](#sample-code "Direct link to Sample code")

```rust
const axios = require('axios');

const graphqlQuery = `{
  trades(orderBy: priceETH, orderDirection: desc) {
    priceETH
    tokenId
  }
}`;
const queryUrl =
  'https://gateway-arbitrum.network.thegraph.com/api/[api-key]/subgraphs/id/HdVdERFUe8h61vm2fDyycHgxjsde5PbB832NHgJfZNqK';

const graphQLRequest = {
  method: 'post',
  url: queryUrl,
  data: {
    query: graphqlQuery,
  },
};

// Send the `GraphQL` query
axios(graphQLRequest)
  .then((response) => {
    // Handle the response here
    const data = response.data.data;
    console.log(data);
  })
  .catch((error) => {
    // Handle any errors
    console.error(error);
  });
```

### Additional resources:[​](#additional-resources "Direct link to Additional resources:")

*   To explore all the ways you can optimize & customize your subgraph for better performance, read more about [creating a subgraph here](https://thegraph.com/docs/en/developing/creating-a-subgraph/).
*   You can find more information in our article about [querying data from your subgraph](https://thegraph.com/docs/en/querying/querying-the-graph/).

---

# Venly Tools <> Arbitrum | Arbitrum Docs

## Venly Tools <> Arbitrum

[Venly](https://venly.io/)[​](#venly "Direct link to venly")
------------------------------------------------------------

Venly stands out as a cutting-edge developer platform, designed to streamline digital asset management and foster the creation of innovative blockchain solutions. Known for its exceptional performance and strong security features, Venly’s non-custodian model ensures you retain complete ownership and control of your assets, distinguishing it from other platforms.

At Venly, the core principles guide their commitment to you:

*   **Security First**: Venly prioritizes the highest level of security for your assets and operations.
*   **Developer-Centric**: Venly's intuitive tools and resources are designed to empower developers to achieve success.
*   **Optimal Performance**: Venly guarantees consistent high performance with a focus on efficiency and reliability.
*   **Innovation**: They are dedicated to providing cutting-edge solutions, staying at the forefront of technology.

The [Venly](https://venly.io/) platform is anchored by three main pillars: **Digital Wallets, Digital Assets, and Payments**, each seamlessly integrated to enhance your blockchain experience.

```rust
Venly Tools
│
├── Digital Wallets: Secure & scalable SSS-based wallets.
│
├── Digital Assets: API solutions for digital assets.
│
├── Payments: Customizable payment forms for fiat.
│
├── Gaming SDK:
│    │
│    ├── Unity: C# SDK
│    │
│    └── Unreal Engine: C++ SDK
│
└── Integrations:
    │
    ├── Zapier: no-code NFT minting with zaps.
    │
    ├── Shopify: Selling NFTs made easy.
    │
    └── SiteManager: Create mint pages in minutes, all no-code.
```

### [Digital Wallets](https://docs.venly.io/docs/wallet-api-overview)[​](#digital-wallets "Direct link to digital-wallets")

Secure and scalable SSS-based wallets with robust key management custody digital assets. The Venly security protocol redefines private key security, never gathering a private key as one whole, eliminating risk. Venly customers use their wallets for a range of operations, such as treasury, trading, cold storage, royalties, NFTs, smart contracts, user wallets, and other digital assets.

### [Digital Assets](https://docs.venly.io/docs/nft-api-overview)[​](#digital-assets "Direct link to digital-assets")

Robust tokenization is based on industry standards and is secured by several code and security audits. The Venly platform facilitates no-code and API solutions to manage, transfer, and gather information on different token asset classes, such as ERC20, ERC721, and ERC1155, which customers use in industries such as Finance, E-commerce, and Gaming.

### [Payments](https://docs.venly.io/docs/pay-api-overview)[​](#payments "Direct link to payments")

With PAY, the Venly platform offers a low-code payment integration that creates a customizable form for collecting payments. You can embed Pay directly on your website or redirect customers to a hosted payment page. It offers a wide range of payment methods, from credit cards to PayPal, Apple Pay, Google Pay, instant bank transfers, and more, enabling customers to choose their preferred option.

Product Specific Documentation[​](#product-specific-documentation "Direct link to Product Specific Documentation")
------------------------------------------------------------------------------------------------------------------

Category

Product

Documentation

Digital Wallets

Widget

[API Reference](https://venly.readme.io/docs/product-overview)

Digital Wallets

Wallet API

[API Reference](https://venly.readme.io/reference/viewwallet)

Digital Assets

NFT API

[API Reference](https://docs.venly.io/reference/getcontracts-1)

Digital Assets

Shopify NFT Minting Application

[App Store](https://apps.shopify.com/partners/arkane-network1)

Digital Assets

Zapier Integration

[Documentation](https://docs.venly.io/docs/zapier-integration)

Digital Assets

SiteManager

[Documentation](https://docs.venly.io/docs/sitemanager)

Payments

Venly PAY

[API Reference](https://docs.venly.io/docs/pay-api-overview)

Gaming SDK

Unity

[Documentation](https://docs.venly.io/docs/getting-started-with-unity)

Gaming SDK

Unreal Engine

[Documentation](https://docs.venly.io/docs/getting-started-with-unreal-engine)

[Venly](https://venly.io/) - Arbitrum
=====================================

Venly supports the Arbitrum chain on its Wallet API which allows you to create wallets on the Arbitrum chain. You can send and receive funds to/from Arbitrum wallets directly through the Wallet API, enabling seamless integration with applications using the Arbitrum blockchain.

Wallet API
==========

The Wallet API allows developers to interact with blockchain networks and offer wallet functionality to their users without having to build everything from scratch. This can include features like account creation, transaction management, balance inquiries, and more.

*   Welcome your users with custom wallet branding. You can customize the user interface to your requirements.
*   You are completely in charge of the wallet user experience to optimize user conversion. Get total freedom with regard to UX and asset management with the Venly Wallet API.
*   You and your users have complete control over digital assets without any third-party interference. Securely manage wallets with complete autonomy and privacy.
*   In the event of loss of login credentials, you and your users can recover access to wallets with a security code or biometric verification.

Key features[​](#key-features "Direct link to Key features")
------------------------------------------------------------

Features

Description

Wallet management

Developers can use the API to create, manage, and secure wallets for their users.

Transaction services

The API can enable the initiation and monitoring of blockchain transactions.

Token support

It may allow the handling of various tokens and assets on supported blockchain networks.

Blockchain interactions

Developers can integrate functionalities like reading data from the blockchain or writing data to it, along with creating and interacting with smart contracts.

Security features

The API might offer features to enhance the security of user funds and transactions.

User experience enhancement

It can contribute to a smoother and more user-friendly interaction with blockchain applications.

Multi-blockchain support

Venly supports multiple blockchain networks, allowing developers to offer wallets for different cryptocurrencies.

Creating an Arbitrum wallet[​](#creating-an-arbitrum-wallet "Direct link to Creating an Arbitrum wallet")
---------------------------------------------------------------------------------------------------------

### Prerequisites[​](#prerequisites "Direct link to Prerequisites")

1.  You need a Venly business account. If you don't have one, click to register [Developer Portal](https://portal.venly.io), or follow the [Getting Started with Venly](https://venly.readme.io/docs/getting-started) guide.
    
2.  You need your client ID and client secret which can be obtained from the [Portal](https://portal.venly.io/).
    
3.  You need a bearer token to authenticate API calls. Click [here](https://docs.venly.io/docs/authentication) to read how to authenticate.
    

### Request Endpoint: [reference](https://docs.venly.io/reference/createwallet)[​](#request-endpoint-reference "Direct link to request-endpoint-reference")

```rust
POST /api/wallets
```

#### Header params[​](#header-params "Direct link to Header params")

Parameter

Param type

Value

Description

`Signing-Method`

Header

`id:value`

`id`: This is the ID of the signing method. `value`: This is the value of the signing method.

#### Body params[​](#body-params "Direct link to Body params")

Parameter

Param type

Description

Data type

Mandatory

`secretType`

Body

The blockchain on which to create the wallet

String

✅

`userId`

Body

The ID of the user who you want to link this wallet to

String

❌

### Request body[​](#request-body "Direct link to Request body")

```rust
{
  "secretType": "ARBITRUM",
  "userId": "9cf9228e-1f2b-4940-9508-4335064cbc76"
}
```

### Response body[​](#response-body "Direct link to Response body")

> Wallet created! The wallet has been created and linked to the specified user (`userId`).

```rust
{
  "success": true,
  "result": {
    "id": "590f7276-2886-475c-a2d6-a28421f8f367",
    "address": "0xADc25e8A385213Fd820bc17Aa799076688f9fBd5",
    "walletType": "API_WALLET",
    "secretType": "ARBITRUM",
    "createdAt": "2024-06-05T11:19:12.038340492",
    "archived": false,
    "description": "Elegant Moose",
    "primary": false,
    "hasCustomPin": false,
    "userId": "9cf9228e-1f2b-4940-9508-4335064cbc76",
    "custodial": false,
    "balance": {
      "available": true,
      "secretType": "ARBITRUM",
      "balance": 0,
      "gasBalance": 0,
      "symbol": "ETH",
      "gasSymbol": "ETH",
      "rawBalance": "0",
      "rawGasBalance": "0",
      "decimals": 18
    }
  }
}
```

Transferring Arbitrum Tokens[​](#transferring-arbitrum-tokens "Direct link to Transferring Arbitrum Tokens")
------------------------------------------------------------------------------------------------------------

### Request Endpoint: [reference](https://docs.venly.io/reference/executetransaction_1)[​](#request-endpoint-reference-1 "Direct link to request-endpoint-reference-1")

```rust
POST /api/transactions/execute
```

#### Header params[​](#header-params-1 "Direct link to Header params")

Parameter

Param type

Value

Description

`Signing-Method`

Header

`id:value`

`id`: This is the ID of the signing method. `value`: This is the value of the signing method.

#### Body params[​](#body-params-1 "Direct link to Body params")

Parameter

Param Type

Description

Data Type

Mandatory

`transactionRequest`

Body

This object includes the transaction information

Object

✅

transactionRequest.`type`

Body

This will be **TRANSFER**

String

✅

transactionRequest.`walletId`

Body

The `id` of the wallet that will initiate the tx

String

✅

transactionRequest.`to`

Body

Destination Address (can be a blockchain address or email address)

String

✅

transactionRequest.`secretType`

Body

On which blockchain the tx will be executed

String

✅

transactionRequest.`value`

Body

The amount you want to transfer

Integer

✅

### Request Body:[​](#request-body-1 "Direct link to Request Body:")

```rust
{
  "transactionRequest": {
    "type": "TRANSFER",
    "walletId": "590f7276-2886-475c-a2d6-a28421f8f367",
    "to": "0x1588aCD59c9baF27C1b777eAa71A67d6b6024077",
    "value": "0.0005",
    "secretType": "ARBITRUM"
  }
}
```

### Response Body:[​](#response-body-1 "Direct link to Response Body:")

> The coins were successfully transferred!

```rust
{
  "success": true,
  "result": {
    "id": "34d51bb3-c963-486d-856e-1e3f12638e3d",
    "transactionHash": "0x804d14bcda10628e61e7ae9085ecad63eafea09d3fdb3cb4ec8cb8dc312dc5b7"
  }
}
```

### Next Steps[​](#next-steps "Direct link to Next Steps")

> Ready to try it out? Click to read the [getting started guide for Wallet API.](https://docs.venly.io/docs/wallet-api-getting-started)

---

# What is the Webacy Risk Data Network? | Arbitrum Docs

## What is the Webacy Risk Data Network?

[Webacy](https://webacy.com/) is a risk data network that helps wallets & applications protect their users against scams, hacks, and mistakes across the blockchain.

Wallets, protocols, & applications use Webacy throughout their user experience:

### Address trust and safety[​](#address-trust-and-safety "Direct link to Address trust and safety")

*   Assess the safety of interacting with a given address (any address: EOA, smart contract, token, etc.). Screen for blocklists, sanctioned addresses, malicious behavior, and other potential flags
*   Analyze smart contract code in real-time
*   Filter spam and sybil addresses

### Connected wallets[​](#connected-wallets "Direct link to Connected wallets")

*   Block sanctioned addresses and wallets involved in malicious behavior
*   Educate users with a Wallet Safety Score
*   Delight users by enabling additional features or providing additional value
*   Display open approvals and the risks associated

### Before a transaction[​](#before-a-transaction "Direct link to Before a transaction")

*   Block harmful dApps and links
*   Review address trust and safety prior to signature
*   Protect users from interacting with malicious smart contracts

### Monitoring and Notifications[​](#monitoring-and-notifications "Direct link to Monitoring and Notifications")

*   Monitor all on-chain activity associated with your protocol or smart contracts
*   Enable wallet monitoring and flag for risky transactions
*   Proactively notify users (or be notified) of any potentially risk activity involved with a given address

Get started with Webacy[​](#get-started-with-webacy "Direct link to Get started with Webacy")
---------------------------------------------------------------------------------------------

Start building in minutes:

*   Reach out to [info@webacy.com](mailto:info@webacy.com) for an API key
*   Check out the [Quick Start Integration Guide](https://docs.webacy.com/api-embedded-safety/quick-start-integration-guide)

APIs[​](#apis "Direct link to APIs")
------------------------------------

[Webacy’s APIs](https://www.webacy.com/safetyscore) are REST-based APIs that expose your platform to Webacy's Risk Engine and Wallet Watch Notifications Platform.

With over 15+ data providers, along with their data analytics and algorithms, Webacy has the broadest risk coverage across the blockchain ecosystem. From compliance and regulatory data to social engineering scams and crowdsourced reports, they process millions of monthly signals, updating their models with the latest and most up-to-date information.

For detailed technical documentation and to begin testing the APIs directly, visit their [technical documentation](https://webacy.readme.io/reference/webacy-api-overview-pre-release). Available APIs and corresponding use cases include:

### Threat risks API[​](#threat-risks-api "Direct link to Threat risks API")

This API indicates if a given address is a risk or a threat to others. It returns risk data associated with the supplied address. It flags if the address appears in any sanctioned databases, has been historically flagged as malicious, is associated with a scam smart contract, and so on. It also includes filtering for spam/sybil signals.

Some common use cases for this endpoint include:

*   Filtering addresses for spam
*   Blocking high-risk addresses from utilizing your service
*   Presenting high-risk addresses to others as potentially risky to interact with
*   Protecting your platform by restricting high-risk addresses

### Approval risks API[​](#approval-risks-api "Direct link to Approval risks API")

This API returns a list of approvals for a given address and the associated risk of the spender for that approval. Approvals are commonplace in crypto - now you know which ones put you at risk. Check out your open approvals [here](https://dapp.webacy.com/?mode=approvals).

If you're a wallet interested in native revoke and approval risk scoring, [reach out to Webacy](https://docs.webacy.com/other/contact-us).

### Transaction risks API[​](#transaction-risks-api "Direct link to Transaction risks API")

This API returns risk data for a given transaction. Pass in any transaction hash, and the API will return a risk score result that incorporates counterparty EOA risk profiles, address risk, involved asset smart contract risk, and more.

Some common use cases for this endpoint include:

*   Understanding the historical behavior of an address
*   Providing data to give recommendations about on-chain activity
*   Gaining insight into a particular transaction or action
*   Flagging previously unknown activity that was potentially at risk

### Exposure risk API[​](#exposure-risk-api "Direct link to Exposure risk API")

The original Webacy Safety Score, this API returns a 'risk profile' or 'exposure risk' of a given address.

This indicates the exposure the address has to risky activity through historical transactions, behavior, and owned assets. This endpoint **does not** assess whether the supplied address is a risk to others (Threat Risk). Instead, it assesses whether the supplied address is **at risk** from others.

Some common use cases for this endpoint include:

*   Gaining a holistic understanding of a client or personal wallet
*   Enabling recommendations and analysis on past behavior
*   Assessing common traits of a user base
*   Determining types of users to better serve them
*   Triggering warnings to internal teams or external users based on changes in risk profile based on ongoing activity
*   Understanding the behavioral activity of a user base

Check out your risk exposure [here](https://dapp.webacy.com/risk-score).

### Contract risk API[​](#contract-risk-api "Direct link to Contract risk API")

This API returns a contract risk analysis for a given contract address.

The on-demand analysis leverages multiple techniques, such as fuzzing, static analysis, and dynamic analysis, for real-time smart contract scanning.

Some common use cases for this endpoint include:

*   Scanning contracts before listing them on your site
*   Verifying that you are not promoting malicious contracts
*   Checking a contract before interacting with it
*   Reviewing code as you build
*   Assessing your contracts before submitting them for a formal audit process

### URL risk[​](#url-risk "Direct link to URL risk")

Given a URL, this endpoint analyzes its safety. It helps you determine if a given link is a phishing scam, sending you to a dangerous place, or is otherwise malicious.

Some common use cases for this endpoint include:

*   Assessing the safety of a dapp/website
*   Warning your end-users from interacting with a potentially malicious website
*   Blocking websites

### Wallet watch API[​](#wallet-watch-api "Direct link to Wallet watch API")

These APIs enable you to register users to Webacy's real-time notification infrastructure.

If you're interested in setting up your own private instance with custom messaging and triggers, [contact us](https://docs.webacy.com/other/contact-us).

---

# Troubleshooting: Building Arbitrum dApps | Arbitrum Docs

## Troubleshooting: Building Arbitrum dApps

### How does gas work on Arbitrum?[​](#how-does-gas-work-on-arbitrum "Direct link to How does gas work on Arbitrum?")

Fees on Arbitrum chains are collected on L2 in the chains' native currency (ETH on both Arbitrum One and Nova).

A transaction fee is comprised of both an L1 and an L2 component:

The L1 component is meant to compensate the Sequencer for the cost of posting transactions on L1 (but no more). (See [L1 Pricing](https://developer.arbitrum.io/arbos/l1-pricing).)

The L2 component covers the cost of operating the L2 chain; it uses Geth for gas calculation and thus behaves nearly identically to L1 Ethereum. One difference is that unlike on Ethereum, Arbitrum chains enforce a gas price floor; currently 0.1 gwei on Arbitrum One and 0.01 gwei on Nova (See [Gas](https://docs.arbitrum.io/arbos/gas)).

L2 Gas price adjusts responsively to chain congestion, ala EIP 1559.

### I tried to create a retryable ticket but the transaction reverted on L1. How can I debug the issue?[​](#i-tried-to-create-a-retryable-ticket-but-the-transaction-reverted-on-l1--how-can-i-debug-the-issue "Direct link to I tried to create a retryable ticket but the transaction reverted on L1.  How can I debug the issue?")

Creation of retryable tickets can revert with one of these custom errors:

1.  **InsufficientValue**: not enough gas included in your L1 transaction's callvalue to cover the total cost of your retryable ticket; i.e., `msg.value < (maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas)`. Note that your L1 transaction's callvalue must cover this full cost. See [Retryable Tickets Lifecycle](https://docs.arbitrum.io/arbos/l1-to-l2-messaging#submission) for more information.
2.  **InsufficientSubmissionCost:** provided submission cost isn't high enough to create your retryable ticket.
3.  **GasLimitTooLarge:** provided gas limit is greater than 2^64
4.  **DataTooLarge**: provided data is greater than 117.964 KB (90% of Geth's 128 KB transaction size limit).

To figure out which error caused your transaction to revert, we recommend using etherscan's Parity VM trace support (Tenderly is generally a very useful debugging tool; however, it can be buggy when it comes to custom Geth errors).

Use the following link to view the Parity VM trace of your failed transaction (replacing the tx-hash with your own, and using the appropriate etherscan root url):

[](https://etherscan.io/vmtrace?txhash=0x51a8088c9b319bbad649c36d9cf2b4e9b61a6099a158181676c8e79dbce2df58&type=parity#raw)[https://etherscan.io/vmtrace?txhash=0x51a8088c9b319bbad649c36d9cf2b4e9b61a6099a158181676c8e79dbce2df58&type=parity#raw](https://etherscan.io/vmtrace?txhash=0x51a8088c9b319bbad649c36d9cf2b4e9b61a6099a158181676c8e79dbce2df58&type=parity#raw)

To find out the reversion error signature, go to the "Raw Traces" tab, and scroll down to find the last "subtrace" in which your transaction is reverted. Then find "output" field of that subtrace.

(In the above example the desirable "output" is:

  

`0xfadf238a0000000000000000000000000000000000000000000000000000c4df7e2903b00000000000000000000000000000000000000000000000000000a39a1d002808`)

The first four bytes of the output is the custom error signature; in our example it's `0xfadf238a` .

  

To let's find out which is custom error this signature represents, we can use this handy tool by Samzcsun: [](https://sig.eth.samczsun.com/)[https://sig.eth.samczsun.com/](https://sig.eth.samczsun.com/)

Checking `0xfadf238a` gives us `InsufficientSubmissionCost(uint256,uint256)`.

  

### How is the L1 portion of an Arbitrum transaction's gas fee computed?[​](#how-is-the-l1-portion-of-an-arbitrum-transactions-gas-fee-computed "Direct link to How is the L1 portion of an Arbitrum transaction's gas fee computed?")

The L1 fee that a transaction is required to pay is determined by compressing its data with brotli and multiplying the size of the result (in bytes) by ArbOS's current calldata price; the latter value can be queried via the `getPricesInWei`method of the `ArbGasInfo`precompile. You can find more information about gas calculations in [Understanding Arbitrum: 2-Dimensional Fees](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9) and [How to estimate gas in Arbitrum](https://developer.arbitrum.io/devs-how-tos/how-to-estimate-gas).

### What is a retryable ticket's "submission fee"? How can I calculate it? What happens if I the fee I provide is insufficient?[​](#what-is-a-retryable-tickets-submission-fee-how-can-i-calculate-it-what-happens-if-i-the-fee-i-provide-is-insufficient "Direct link to What is a retryable ticket's \"submission fee\"? How can I calculate it? What happens if I the fee I provide is insufficient?")

A [retryable's](https://developer.arbitrum.io/arbos/l1-to-l2-messaging) submission fee is a special fee a user must pay to create a retryable ticket. The fee is directly proportional to the size of the L1 calldata the retryable ticket uses. The fee can be queried using the `Inbox.calculateRetryableSubmissionFee`method. If insufficient fee is provided, the transaction will revert on L1, and the ticket won't get created.

### Which method in the Inbox contract should I use to submit a retryable ticket (aka L1 to L2 message)?[​](#which-method-in-the-inbox-contract-should-i-use-to-submit-a-retryable-ticket-aka-l1-to-l2-message "Direct link to Which method in the Inbox contract should I use to submit a retryable ticket (aka L1 to L2 message)?")

The method you should (almost certainly) use is `Inbox.createRetryableTicket`. There is an alternative method, `Inbox.unsafeCreateRetryableTicket`, which, as the name suggests, should only be used by those who fully understand its implications.

There are two differences between `createRetryableTicket` and `unsafeCreateRetryableTicket`:

1.  Method `createRetryableTicket` will check that provided L1 callvalue is sufficient to cover the costs of creating and executing the retryable ticket (at the specified parameters) and otherwise [revert directly at L1](https://docs.arbitrum.io/for-devs/troubleshooting-building#i-tried-to-create-a-retryable-ticket-but-the-transaction-reverted-on-l1--how-can-i-debug-the-issue). `unsafeCreateRetryableTicket`, in contrast, will allow a retryable ticket to be created that is guaranteed to revert on L2.
2.  Method `createRetryableTicket` will check if either the provided `excessFeeRefundAddress` or the `callValueRefundAddress` are contracts on L1; if they are, to prevent the situation where refunds are _guaranteed_ to be irrecoverable on L2, it will convert them to their [address alias](https://developer.arbitrum.io/arbos/l1-to-l2-messaging#address-aliasing), providing a _potential_ path for fund recovery. `unsafeCreateRetryableTicket` will allow the creation of a retryable ticket with refund addresses that are L1 contracts; since no L1 contract can alias to an address that is also itself an L1 contract, refunds to these addresses on L2 will be irrecoverable.

(Astute observers may note a third ticket creation method, `createRetryableTicketNoRefundAliasRewrite`; this is included only for backwards compatibility, but should be considered deprecated in favor of `unsafeCreateRetryableTicket`)

### Why do I get "custom tx type" errors when I use hardhat?[​](#why-do-i-get-custom-tx-type-errors-when-i-use-hardhat "Direct link to Why do I get \"custom tx type\" errors when I use hardhat?")

In Arbitrum, we use a number of non-standard [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) typed transactions. See [here](https://developer.arbitrum.io/arbos/geth#transaction-types) for the full list and the rationale.

Note that if you're using Hardhat, [v2.12.2](https://github.com/NomicFoundation/hardhat/releases/tag/hardhat%402.12.2) added support for forking networks like Arbitrum with custom transaction types (find more information [here](https://github.com/NomicFoundation/hardhat/issues/2995)).

### Why does it look like two identical transactions consume a different amount of gas?[​](#why-does-it-look-like-two-identical-transactions-consume-a-different-amount-of-gas "Direct link to Why does it look like two identical transactions consume a different amount of gas?")

Calling an Arbitrum node's `eth_estimateGas` RPC returns a value sufficient to cover both the L1 and L2 components of the fee for the current gas price; this is the value that, e.g., will appear in users' wallets in the "gas limit" field.

Thus, if the L1 calldata price changes over time, it will appear (in e.g., a wallet) that a transaction's gas limit is changing. In fact, the L2 gas limit isn't changing, merely the total gas required to cover the transaction's L1 + L2 fees.

See [2-D fees](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9) and [How to estimate gas in Arbitrum](https://developer.arbitrum.io/devs-how-tos/how-to-estimate-gas) for more.

### Why am I getting error "429 Too Many Requests" when using one of Offchain Labs' Public RPCs?[​](#why-am-i-getting-error-429-too-many-requests-when-using-one-of-offchain-labs-public-rpcs "Direct link to Why am I getting error \"429 Too Many Requests\" when using one of Offchain Labs' Public RPCs?")

Offchain Labs offers public RPCs for free, but limits requests to prevent DOSing. Hitting the rate limit could come from your request frequency and/or the resources required to process the requests. If you are hitting our rate limit, we recommend [running your own node](https://developer.arbitrum.io/node-running/how-tos/running-a-full-node) or [using a third party node provider](https://developer.arbitrum.io/node-running/node-providers).

### How do block.number and block.timestamp work on Arbitrum?[​](#how-do-blocknumber-and-blocktimestamp-work-on-arbitrum "Direct link to How do block.number and block.timestamp work on Arbitrum?")

Solidity calls to `block.number` on Arbitrum will return the block number/ timestamp of the underlying L1 on a slight delay; i.e., updated every few minutes. Note that L2 block numbers (i.e., as seen in block explorers / returned by RPCs) are different, and are typically updated roughly every second.

Solidity calls to `block.timestamp` on Arbitrum are not linked to the timestamp of the L1 block. It is updated every L2 block based on the sequencer's clock. Furthermore, for transactions that are force-included from L1 (bypassing the Sequencer) `block.timestamp` will be equal to the L1 timestamp when the transaction was put in the delayed inbox on L1 (not force-included), or the L2 timestamp of the previous L2 block (whichever is greater of the two timestamps).

For more info, see [block numbers and time](https://docs.arbitrum.io/for-devs/concepts/differences-between-arbitrum-ethereum/block-numbers-and-time).

### Do I need to download any special npm libraries in order to use web3.js, ethers.js or viem on Arbitrum?[​](#do-i-need-to-download-any-special-npm-libraries-in-order-to-use-web3js-ethersjs-or-viem-on-arbitrum "Direct link to Do I need to download any special npm libraries in order to use web3.js, ethers.js or viem on Arbitrum?")

Nope, web3.js, ethers.js and viem will work out of the box just like they do on L1 Ethereum.

Once upon a time, Arbitrum developers were required to download supplemental packages with names like "arb-provider-ethers" and "arb-ethers-web3-bridge", but these packages are deprecated and no longer required! Any guide that directs devs to use them should be considered outdated.

### How many block numbers must we wait for in Arbitrum before we can confidently state that the transaction has reached finality?[​](#how-many-block-numbers-must-we-wait-for-in-arbitrum-before-we-can-confidently-state-that-the-transaction-has-reached-finality "Direct link to How many block numbers must we wait for in Arbitrum before we can confidently state that the transaction has reached finality?")

Arbitrum's block intervals fluctuate with throughput, so relying on block numbers for finality isn't recommended. However, Arbitrum nodes support Ethereum's JSON RPC, enabling the use of `[eth_getBlockByNumber()](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber)` to determine block finality. Here, we provide additional details on how to achieve this.

You can use `[eth_getBlockByNumber()](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber)` with the string `"latest"`, `"safe"`, or `"finalized"`, each offering varying degrees of finality:

*   `latest`: Provides you with the most recent Arbitrum block number, also known as the tip of the chain. This block is typically the last sequenced block and may not yet be posted on L1. As long as you trust the Sequencer to eventually post this information on L1, relying on the `latest` block should be fine.
*   `safe`: Provides you with the most recent Arbitrum block number that has achieved attestations from a two-thirds majority of Ethereum's validator set. This occurs when the Sequencer's batch is posted as an L1 block on Ethereum and then the batch transactions achieve `safe` finality there. While safe blocks are typically resistant to re-orgs, they can still be re-orged in the event of a significant L1 re-org.
*   `finalized`: Provides you with the most recent Arbitrum block number that is finalized on Ethereum. This means that the Sequencer's batch has been published as an L1 block on the Ethereum network and has reached a substantial depth, making it eligible for hard finality. Unlike `safe` blocks, `finalized` blocks are highly improbable to undergo re-orgs.

To learn more about the different phases of an Arbitrum transaction, from client initiation to Layer 1 confirmation, check out [The Lifecycle of an Arbitrum Transaction](https://docs.arbitrum.io/tx-lifecycle).

### How can I list my token on the Arbitrum Bridge?[​](#how-can-i-list-my-token-on-the-arbitrum-bridge "Direct link to How can I list my token on the Arbitrum Bridge?")

The L2 token list used in the Arbitrum bridge is generated from the L1 tokens that are part of the token list of [Uniswap](https://tokenlists.org/token-list?url=https%3A%2F%2Ftokens.uniswap.org), [Gemini](https://tokenlists.org/token-list?url=https%3A%2F%2Fwww.gemini.com%2Funiswap%2Fmanifest.json) , [Coinmarketcap](https://api.coinmarketcap.com/data-api/v3/uniswap/all.json) or [Coingecko](https://tokens.coingecko.com/uniswap/all.json). This is valid for L1-native tokens that have been bridged over to L2, and for L2-native tokens that have been bridged over to L1 as long as they are part of any of those lists.

Currently, there isn't any L2-only token list.

### What is a testnet or a devnet?[​](#what-is-a-testnet-or-a-devnet "Direct link to What is a testnet or a devnet?")

Testnets (or devnets) primarily serve developers who want to test out the applications they're building without having to use any real mainnet funds.

Arbitrum Sepolia is a testnet that has the same full feature-set as the mainnet network. It is also a "true" L2 that runs on top of the Sepolia testnet (L1), using it for security and settlement.

Users can bridge any asset from the Sepolia testnet (L1) into the Arbitrum Sepolia testnet (and back!), using the official [bridge](https://bridge.arbitrum.io/).

### Is there any testnet available on Arbitrum?[​](#is-there-any-testnet-available-on-arbitrum "Direct link to Is there any testnet available on Arbitrum?")

Yes, there's an Arbitrum Sepolia testnet (421614) that uses the Nitro tech stack and runs on top of Ethereum Sepolia. You can find more information [here](https://developer.arbitrum.io/public-chains).

### When was Arbitrum One upgraded from Classic to Nitro?[​](#when-was-arbitrum-one-upgraded-from-classic-to-nitro "Direct link to When was Arbitrum One upgraded from Classic to Nitro?")

Arbitrum One [was upgraded](https://medium.com/offchainlabs/its-nitro-time-86944693bf29) on August 31st, 2022 (block [22207818](https://arbiscan.io/block/22207818)), from the Classic stack to the improved [Nitro](https://developer.arbitrum.io/inside-arbitrum-nitro/) tech stack, maintaining the same state.

### Do Arbitrum chains support precompiles that are present on Ethereum?[​](#do-arbitrum-chains-support-precompiles-that-are-present-on-ethereum "Direct link to Do Arbitrum chains support precompiles that are present on Ethereum?")

Yes, all Arbitrum chains support all precompiles that Ethereum supports, as well as others that are not present on Ethereum. Check the [precompiles reference page](https://docs.arbitrum.io/for-devs/dev-tools-and-resources/precompiles) for more information about Arbitrum specific precompiles.

### What's the contract code size limit in Arbitrum chains?[​](#whats-the-contract-code-size-limit-in-arbitrum-chains "Direct link to What's the contract code size limit in Arbitrum chains?")

As specified in [EIP-170](https://eips.ethereum.org/EIPS/eip-170), contracts of up to 24KB are deployable on Arbitrum chains.

### How can I find the L2 block(s) that corresponds to a given L1 block?[​](#how-can-i-find-the-l2-blocks-that-corresponds-to-a-given-l1-block "Direct link to How can I find the L2 block(s) that corresponds to a given L1 block?")

First of all, you should be familiar with how block numbers behave on Arbitrum. You can find information about it in [Block numbers and time](https://docs.arbitrum.io/for-devs/concepts/differences-between-arbitrum-ethereum/block-numbers-and-time).

When you query an RPC node for a transaction receipt or a block information, you obtain as part of the result the property `l1BlockNumber`, which is the L1 block number that the sequencer viewed when it processed the transaction.

With that, although it might be computationally complex, you can binary search the L1 block number you are looking for, and get all L2 blocks that have that `l1BlockNumber`.

If you want a more specific result, you can perform the same operation with the timestamp from the L1 block, instead of the actual block number.

### Why do some old transactions have extremely high gas prices when querying them?[​](#why-do-some-old-transactions-have-extremely-high-gas-prices-when-querying-them "Direct link to Why do some old transactions have extremely high gas prices when querying them?")

When Arbitrum One was running under the Arbitrum Classic stack (before Nitro), the gas price was an unbounded bid, so when requesting those transactions via RPC, you may obtain a very high amount in the `gasPrice` property.

Instead of that, it is recommended to look at the `effectiveGasPrice` property from the transaction receipt.

### What is the WASM module root?[​](#what-is-the-wasm-module-root "Direct link to What is the WASM module root?")

The WASM module root is a 32 byte hash, which is a merkelization of the Go replay binary and its dependencies.

The replay binary is much too large to post on-chain, so this hash is set in the L1 rollup contract to determine the correct replay binary during fraud proofs.

You can find more information in [How to customize your Orbit chain's behavior](https://docs.arbitrum.io/launch-orbit-chain/how-tos/customize-stf#step-4-enable-fraud-proofs).

### Why do I get a "gas required exceeds allowance" when trying to estimate the gas costs of a request?[​](#why-do-i-get-a-gas-required-exceeds-allowance-when-trying-to-estimate-the-gas-costs-of-a-request "Direct link to Why do I get a \"gas required exceeds allowance\" when trying to estimate the gas costs of a request?")

During an `eth_estimateGas` call the actual request will be simulated on the node, so if the transaction reverts or if there aren't enough funds in the wallet that's making the call (usually the `from` parameter), the eth\_estimateGas request will return the error `gas required exceeds allowance`.

Make sure you have enough funds in your wallet, and the gas fields of the request (if you're using them) are correctly set.

### How can I verify that an L2 block has been processed as part of a specific assertion?[​](#how-can-i-verify-that-an-l2-block-has-been-processed-as-part-of-a-specific-assertion "Direct link to How can I verify that an L2 block has been processed as part of a specific assertion?")

If you want to verify that the latest confirmed (or created) assertion has processed a specific L2 block, you can follow these steps:

1.  From the rollup contract, obtain the latest confirmed (or created) assertion through the function `latestConfirmed` (or `latestNodeCreated`). In this context, we refer to assertions as "nodes".
2.  Obtain the node information through `getNode`
3.  Find the `NodeCreated` event that was emitted when that node was created.
4.  In that NodeCreated event, there's an `assertion` property that contains the state of the chain before processing the specified blocks, and after processing them. Get the `afterState.globalState` property
5.  That value contains a bytes32Vals array with the latest L2 block hash processed in the first element.

You can find an example script in our [arbitrum-tutorials](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/l2-block-verification-in-assertion) repository.

### Why is the fee of some Classic transactions slightly different than the multiplication of gasLimit and effectiveGasPrice?[​](#why-is-the-fee-of-some-classic-transactions-slightly-different-than-the-multiplication-of-gaslimit-and-effectivegasprice "Direct link to Why is the fee of some Classic transactions slightly different than the multiplication of gasLimit and effectiveGasPrice?")

Gas prices in Classic transactions worked a bit differently than in Nitro transactions. Classic transactions handled four different prices: L1 fixed, L1 calldata, L2 computation and L2 storage. You can see all those prices in the Advanced TxInfo of Arbiscan (here's an [example](https://arbiscan.io/tx/0xecfe992adc408d1458d97b6e066ea7f4169bf048e84cb7a4beaea6e9c54f07da#txninfo)).

When querying the receipt of a Classic transaction on a Nitro node, there's some calculation done to get an effectiveGasPrice that is close to (but not exactly) what those four prices represent. That's why if you multiply the gasLimit by the effectiveGasPrice you might end up with a transaction fee that is slightly different than the actual fee paid.

To get the exact fees paid, you can query a Classic node, which will return all the accurate information in an object called `feeStats`. That object will contain all the information split into the four different gas fields: `prices`, `unitsUsed` and `paid` (which is price \* unitsUsed).

### How can I update the information of my bridged token on Arbiscan?[​](#how-can-i-update-the-information-of-my-bridged-token-on-arbiscan "Direct link to How can I update the information of my bridged token on Arbiscan?")

If you have a native-L1 token that was bridged to L2 via the standard gateway, you might find that you can't claim ownership of the L2 contract of your token as it was generated by another contract.

To update its information on Arbiscan (logo, socials, etc.), you can open a ticket through [Arbiscan support system](https://arbiscan.io/contactus) and request them to replicate the information of your token on L1 to L2.

### Why does my transaction revert with InvalidFEOpcode when using Foundry?[​](#why-does-my-transaction-revert-with-invalidfeopcode-when-using-foundry "Direct link to Why does my transaction revert with InvalidFEOpcode when using Foundry?")

Foundry and other similar development tools that enable chain forking, do not support Arbitrum precompiles. If your transaction is calling a precompile, it is likely that it will revert with `InvalidFEOpcode`.

To rule out that possibility, it is recommended to send the transaction with a different tool.

### Why do I receive an "intrinsic gas too low" error when sending a transaction even with a high gas price?[​](#why-do-i-receive-an-intrinsic-gas-too-low-error-when-sending-a-transaction-even-with-a-high-gas-price "Direct link to Why do I receive an \"intrinsic gas too low\" error when sending a transaction even with a high gas price?")

The error `intrinsic gas too low` usually refers to not providing enough gas to pay for the L1 component of the transaction fees. This is usually a problem related to not setting a high enough gas limit (instead of gas price), due to how Arbitrum handles gas. You can find more information in the article [Understanding Arbitrum: 2-dimensional fees](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9) and the page [How to estimate gas](https://docs.arbitrum.io/devs-how-tos/how-to-estimate-gas).

### How can I interpret Arbitrum transaction traces?[​](#how-can-i-interpret-arbitrum-transaction-traces "Direct link to How can I interpret Arbitrum transaction traces?")

In Arbitrum, every block contains a system transaction of type `[ArbitrumInternalTxType](https://docs.arbitrum.io/arbos/geth#ArbitrumInternalTx)`, which is created by the ArbOS itself for specific state updates, such as the L1 base fee and the block number. These transactions are distinct from typical Ethereum transactions and are exclusively generated by the ArbOS state transition function, not by external entities like externally owned accounts (EOAs) or smart contracts. Despite having an `INVALID` opcode, these transactions are represented in the trace API to signify their presence in the block, even though they're not triggered by an opcode within EVM execution.

One of the key functionalities of `ArbitrumInternalTxType` involves managing value transfers related to acknowledging batch postings. When batches of transactions are submitted to Layer 1, a special cross-chain message is produced as a receipt, confirming the successful posting of the batch. The function `ApplyInternalTxUpdate` is responsible for processing and updating the system's state based on these cross-chain messages, ensuring consistency and integrity across the Arbitrum network.

Another functionality of `ArbitrumInternalTxType` transactions is handling the value held in retryables when they are discarded. Retryable transactions are essentially transactions that can be retried if they fail to execute on the destination chain. However, in certain scenarios, these retryable transactions might get discarded, for instance, due to expiration or other conditions.

In such cases, the escrowed call value, which is the value associated with the retryable transaction, will be paid out to a specified `callValueRefundAddress` account. This address is designated during the initial submission of the transaction on the parent chain. The purpose of this mechanism is to ensure that funds associated with retryable transactions are not lost in case they cannot be successfully executed, thereby maintaining the integrity and reliability of the Arbitrum network.

To accurately reflect value transfers associated with these transactions, we employ a unique `callType` parameter: `invalid`. Unlike conventional EVM calls (such as `delegatecall`, `call`, etc.), this designation signifies a different system transaction. Essentially, it denotes a straightforward value transfer from one account to another, with no inherent invocation of smart contract logic. While technically feasible to conduct this transfer within a conventional call type, our deliberate choice of `invalid` aims to enhance the clarity and distinctiveness of this transaction type within the EVM ecosystem.

Notably, the sender account remains consistent across all instances of this transaction type for the batch posting receipt version. However, it's important to note that for retryable transactions, the sender account differs as each retryable transaction escrows its value in a unique vault specific to that transaction. This ensures that funds associated with each retryable transaction are securely held until either successful execution or eventual refund.

  
**Note that:**

*   All pre-Nitro transactions are labeled as `ArbitrumLegacyTxType` by Nitro.
*   Traces are not available for pre-Nitro (Classic) transactions.

### Why do some blocks have a total gas limit that's over the standard block gas limit?[​](#why-do-some-blocks-have-a-total-gas-limit-thats-over-the-standard-block-gas-limit "Direct link to Why do some blocks have a total gas limit that's over the standard block gas limit?")

The execution gas block limit of Arbitrum chains is 32 million. However, when querying a block, we might find a `gasLimit` value that exceeds that number.

This happens because this gasLimit field accounts for both execution gas and the correspondent gas limit of the L1 costs (you can find more information about the role of the L1 costs in a transaction's gas limit on [this article](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9)). The gas limit corresponding to L1 costs is practically unlimited, so we might find very high values on the gasLimit field of a block.

The effective block gas limit (32 million) only accounts for execution gas limit. We can check the actual gas used for execution on a specific block, by checking the `gasUsed` field.

---

# Contribute docs | Arbitrum Docs

## Contribute docs

Thank you for considering to contribute to the Arbitrum documentation! We're excited to have you on board.

The [`docs.arbitrum.io`](https://docs.arbitrum.io/) docs portal is the **single source of truth** for documentation that supports Offchain Labs' product portfolio. Contributions are welcome from the entire Ethereum community.

This document shows you how to craft and publish Arbitrum documentation. Familiarity with [Markdown](https://www.markdownguide.org/basic-syntax/) syntax, Github, and [Docusaurus](https://docusaurus.io/docs) is expected.

### Add a new core document[​](#add-a-new-core-document "Direct link to Add a new core document")

If a document isn't in a `Third-party content` sidebar node, it's a **core document**. To contribute a new core doc:

1.  Begin by creating a branch (internal) or fork (external) of the [Arbitrum docs repo](https://github.com/OffchainLabs/arbitrum-docs).
2.  Issue a `Draft` pull request into `master`. Pull requests into `master` generate a preview of your changes via a PR-specific Docusaurus deployment; this preview will update as you push commits to your remote.
3.  Include answers to the following questions in your PR description:
    
    ```rust
    1. Audience: Who am I writing for?
    2. Problem: What specific problem are they trying to solve?
    3. Discovery: How are they looking for a solution to this problem? What search terms are they using?
    4. Document type: Which document type is most suitable?
    5. Policy acknowledgment (Third-party docs only): Do you agree to the third-party content policy outlined within "Contribute docs"?
    ```
    
4.  As you craft your contribution, refer to the [document types](#document-type-conventions), [Style guidance](#style-conventions), and other conventions below.
5.  Mark your PR as `Open` when it's ready for review.

### Add a new third-party document[​](#add-a-new-third-party-document "Direct link to Add a new third-party document")

**Third-party docs** are documents that help readers of Arbitrum docs use other products, services, and protocols (like the ones listed in the [Arbitrum portal](https://portal.arbitrum.io/)) with Arbitrum products.

See [Contribute third-party docs](/for-devs/third-party-docs/contribute) for detailed instructions.

### Request an update[​](#request-an-update "Direct link to Request an update")

If you'd like to request an update or share a suggestion related to an **existing document** without submitting a pull request to implement the improvement yourself, click the `Request an update` button located at the top of each published document. This button will lead you to a prefilled Github issue that you can use to elaborate on your request or suggestion.

### Add a new translation page[​](#add-a-new-translation-page "Direct link to Add a new translation page")

If you would like to participate in translating the Arbitrum docs, you can:

1.  Check whether `/website/i18n` has a corresponding language (currently there are `ja` and `zh`). If not, you can use the following command to add it (we take adding French as an example):

```rust
cd ./website
npm run write-translations -- --locale fr
```

It will help generate folder `website/i18n/fr`.

2.  Create the folders `current` and `translated` under the newly generated folder `website/i18n/fr/docusaurus-plugin-content-docs`:

```rust
mkdir i18n/{Your_language}/docusaurus-plugin-content-docs/current && mkdir i18n/{Your_language}/docusaurus-plugin-content-docs/translated
```

3.  Translate one of more docs files located in `/arbitrum-docs`.
    
4.  Place the translated document into the folder `i18n/{Your_language}/docusaurus-plugin-content-docs/translated` according to its relative path in `arbitrum-docs`. For example, if you translated `/arbitrum-docs/how-arbitrum-works/arbos/introduction.md`, then its path in i18n should be `i18n/{Your_language}/docusaurus-plugin-content-docs/translated/how-arbitrum-works/arbos/introduction.md`.
    

Test run:

1.  Check that the i18n settings in `website/docusaurus.config.js` have included your new language:

```rust
i18n: {
    defaultLocale: 'en',
    // locales: ['en', 'ja', 'zh'],
    locales: ['en'], // You can add your new language to this array
  },
```

2.  Check whether the `locale Dropdown` component exists in navbar, if not, add it:

```rust
navbar: {
    title: 'Arbitrum Docs',
    logo: {
        alt: 'My Site Logo',
        src: 'img/logo.svg',
        href: '/welcome/arbitrum-gentle-introduction',
    },
    items: [
        // note:  we can uncomment this when we want to display the locale dropdown in the top navbar
        //        if we enable this now, the dropdown will appear above every document; if `ja` is selected for a document that isn't yet translated, it will 404
        //        there may be a way to show the dropdown only on pages that have been translated, but that's out of scope for the initial version
        {
        type: 'localeDropdown',
        position: 'right',
        }
    ],
},
```

2.  Build translation and docs:

```rust
yarn build_translation && yarn build
```

6.  Start docs:

```rust
npm run serve
```

  

* * *

### Document type conventions[​](#document-type-conventions "Direct link to Document type conventions")

Every document should be a specific _type_ of document. Each type of document has its own purpose:

Document type

Purpose

Gentle introduction

Onboard a specific reader audience with tailored questions and answers

Quickstart

Onboard a specific reader audience with step-by-step "learn by doing" instructions

| How-to | Provide task-oriented procedural guidance | | Concept | Explain what things are and how they work | | FAQ | Address frequently asked questions | | Troubleshooting | List common troubleshooting scenarios and solutions | | Reference | Lists and tables of things, such as API endpoints and developer resources |

This isn't an exhaustive list, but it includes most of the document types that we use.

### Style conventions[​](#style-conventions "Direct link to Style conventions")

The following style guidelines provide a number of loose recommendations that help us deliver **a consistent content experience** across our docs:

1.  **Casing**
    *   Sentence-case "content labels": document titles, sidebar titles, menu items, section headers, etc.
2.  **Linking**
    *   Avoid anchoring links to words like "here" or "this". Descriptive anchor text can help set expectations for readers who may hesitate to click on ambiguous links. When linking to docs, try to link to the document's title verbatim.
3.  **Titling**
    *   Titles should balance brevity with precision - _Node running overview_ is preferred to _Overview_. This helps with SEO and reader UX.
4.  **Separate procedural from conceptual (most of the time)**
    *   Within procedural docs like how-tos and quickstarts, avoid including too much conceptual content. Provide only the conceptual information that the target reader _needs_ in order to complete the task at hand. Otherwise, organize conceptual information within conceptual docs, and link to them "just in case" from other docs.
5.  **Voice**
    *   Address the reader as "you".
    *   Write like you'd speak to a really smart friend who's in a rush.
    *   Opt for short, clear sentences that use translation-friendly, plain language.
    *   Use contractions wherever it feels natural - this can help convey a friendly and conversational tone.
6.  **Formality**
    *   Don't worry too much about formality. The most valuable writing is writing that provides value to readers, and readers generally want to "flow" through guidance.
    *   Aim at "informal professionalism" that prioritizes **audience-tailored problem-solving** and **consistent style and structure**.
7.  **Targeting**
    *   Don't try to write for everyone; write for a _specific reader persona_ (also referred to as "audience" in this document) who has a _specific need_.
    *   Make assumptions about prior knowledge (or lack thereof) and make these assumptions explicit in the beginning of your document.
8.  **Flow**
    *   **Set expectations**: Begin documents by setting expectations. Who is the document for? What value will it provide to your target audience? What assumptions are you making about their prior knowledge? Are there any prerequisites?
    *   **Value up front**: Lead with what matters most to the reader persona you're targeting. Then, progressively build a bridge that carries them towards task completion as efficiently as possible.
9.  **Cross-linking**
    *   We want to maintain both **high discoverability** and **high relevance**. As a general rule of thumb, links to other docs should be "very likely to be useful for most readers". Every link is a subtle call to action; we want to avoid CTA overload.
10.  **Things to avoid**
    *   **Symbols where words will do**: Minimize usage of `&` and `/` - spell out words like "_and_" and "_or_".
    *   **Jargon**: Using precise technical terminology is ok, as long as your target audience is likely to understand the terminology. When in doubt, opt for clear, unambiguous, _accessible_ language.

Don't stress too much about checking off all of these boxes; we periodically review and edit our most heavily-trafficked docs, bringing them up to spec with the latest style guidelines.

Some important disclaimers:

*   **This isn't an exhaustive list**. These are just the min-bar guidelines that will be applied to all new content moving forward.
*   **Many of our docs don't yet follow this guidance**. Our small-but-mighty team is working on it! If you notice an obvious content bug, feel free to submit an [issue](https://github.com/OffchainLabs/arbitrum-docs/issues) or [PR](https://github.com/OffchainLabs/arbitrum-docs/pulls).

### Banner conventions[​](#banner-conventions "Direct link to Banner conventions")

You can use banners (Docusaurus refers to them as ["admonitions"](https://docusaurus.io/docs/markdown-features/admonitions)) to set expectations for your readers and to emphasize important callouts. Use these conservatively, as they interrupt the flow of the document.

#### Under construction banner[​](#under-construction-banner "Direct link to Under construction banner")

Example:

UNDER CONSTRUCTION

The following steps are under construction and will be updated with more detailed guidance soon. Stay tuned, and don't hesitate to click the `Request an update` at the top of this document if you have any feedback along the way.

Usage:

```rust
:::caution[UNDER CONSTRUCTION]

The following steps are under construction and will be updated with more detailed guidance soon. Stay tuned, and don't hesitate to click the `Request an update` at the top of this document if you have any feedback along the way.

:::
```

  

#### Community member contribution banner[​](#community-member-contribution-banner "Direct link to Community member contribution banner")

Example:

Community member contribution

The following document was contributed by @todo-twitter-handle. Give them a shoutout if you find it useful!

Usage:

```rust
:::info[Community member contribution]

The following document was contributed by @todo-twitter-handle. Give them a shoutout if you find it useful!

:::
```

### Frequently asked questions[​](#frequently-asked-questions "Direct link to Frequently asked questions")

#### Can I point to my product from core docs? For example - if my product hosts a public RPC endpoint, can I add it to your [RPC endpoints and providers](/build-decentralized-apps/reference/node-providers) page?[​](#can-i-point-to-my-product-from-core-docs-for-example---if-my-product-hosts-a-public-rpc-endpoint-can-i-add-it-to-your-rpc-endpoints-and-providers-page "Direct link to can-i-point-to-my-product-from-core-docs-for-example---if-my-product-hosts-a-public-rpc-endpoint-can-i-add-it-to-your-rpc-endpoints-and-providers-page")

These types of contributions are generally **not merged** unless they're submitted by employees of Offchain Labs.

Instead of opening a PR for this type of contribution, click the `Request an update` button at the top of the published document to create an issue. Generally, third-party services are included in core docs only if we can confidently assert that the services are "**trustworthy, highly relevant to the core document at hand, and battle-tested by Arbitrum developers**" under a reasonable scrutiny.

#### How long does it take for my third-party content contribution to be reviewed?[​](#how-long-does-it-take-for-my-third-party-content-contribution-to-be-reviewed "Direct link to How long does it take for my third-party content contribution to be reviewed?")

Our small-but-mighty team is continuously balancing competing priorities, so we can't guarantee a specific turnaround time for third-party docs PRs. They're processed in the order in which they're received, generally within a week or two.

#### Is there any way to expedite third-party content contribution reviews?[​](#is-there-any-way-to-expedite-third-party-content-contribution-reviews "Direct link to Is there any way to expedite third-party content contribution reviews?")

The most effective way to expedite processing is to ensure that your PR incorporates the conventions outlined in this document. Please don't ask for status updates - if you've submitted a PR, it's on our radar!

---

# A gentle introduction | Arbitrum Docs

## A gentle introduction

info

This page gives a high-level overview. It explains , its purpose, and a brief "how it works." As you progress through the articles in this section, the content will get more technical and dive deeper into each component(s) and function(s) of the Arbitrum technology stack.

Arbitrum is a technology suite designed to improve Ethereum. You can use Arbitrum chains for the same things you do on Ethereum, like using Web3 apps and deploying smart contracts. The difference is that your transactions will be cheaper and faster. Our main product, Arbitrum Rollup, is an Optimistic Rollup protocol that offers the same security as Ethereum.

### But why?[​](#but-why "Direct link to But why?")

Ethereum is awesome, but it has its limitations. The Ethereum  can handle only about 20 to 40 transactions per second (TPS) for all users. Once it reaches this limit, users must compete for space to have their transactions included, increasing fees.

Arbitrum Rollup solves this issue! Here's how it works: an  acts as a submodule within Ethereum. Unlike regular Ethereum transactions, we don't need Ethereum nodes to handle every Arbitrum transaction. Instead, Ethereum takes an ["innocent until proven guilty"](https://insights.deribit.com/market-research/making-sense-of-rollups-part-2-dispute-resolution-on-arbitrum-and-optimism/) stance with Arbitrum. Initially, the  assumes that actions on Arbitrum follow the rules. If there is a rule violation (like someone claiming, "Now I have all of your money"), that claim is challengeable on the parent chain. In this case, we can prove fraud, disregard the invalid claim, and penalize the guilty party. This ability to investigate and confirm fraud on the parent chain is Arbitrum's main feature and explains why it benefits from Ethereum's security.

### How do these fraud proofs work?[​](#how-do-these-fraud-proofs-work "Direct link to How do these fraud proofs work?")

People who help manage the  on the parent chain are called validators. They make claims about the chain's state, dispute others' claims, and more. Most Arbitrum users are unlikely to run a , just as most Ethereum users do not operate their parent chain staking node. However, anyone can become a validator; you don't need special permission ([once the allowlist gets lifted](https://docs.arbitrum.foundation/state-of-progressive-decentralization)). You only need to run the [open source validator software](https://github.com/OffchainLabs/nitro) and stake Ether if required.

The chain stays secure if there is at least one honest validator. It only takes one trustworthy fraud prover to catch many bad actors. These features make the system "." Users do not depend on any specific group to keep their funds safe.

### Who does this fraud proofing?[​](#who-does-this-fraud-proofing "Direct link to Who does this fraud proofing?")

This step is where the "Rollup" part comes in. Arbitrum Rollup chains handle user  data by posting it directly on Ethereum. This setup means that as long as Ethereum is secure, anyone can see what happens on Arbitrum. They can also spot and prove any fraud that occurs.

Validators are the nodes that help move the Arbitrum  forward on the parent chain. They make claims about the chain's state and can dispute claims made by others. Most Arbitrum users are unlikely to want to run a validator, just as most Ethereum users typically don't run their parent chain staking nodes. However, anyone can become a validator. Once the allowlist gets removed, users only need to run the open-source validator software and stake Ether if they need to take action.

The network stays secure if there is at least one honest validator, which means that just one trustworthy fraud prover can catch any number of bad actors. This setup makes the system "trustless"; users do not have to rely on any specific person to keep their funds safe.

### The game[​](#the-game "Direct link to The game")

It's not as complicated as it seems. If two validators disagree, only one is telling the truth. In the event of a dispute, the two validators engage in an interactive game, where they respond to each other in a call-and-response format. This process allows them to narrow their disagreement to a single computational step—something straightforward, like multiplying two numbers. This step executes on the parent chain, which shows which party is honest. For a more detailed explanation, see here.

Users only experience delays when they withdraw funds from Arbitrum back to Ethereum. When withdrawing directly from Arbitrum to Ethereum, users usually wait one week to receive their funds on the parent chain. However, users can skip this waiting period if they use a fast  application, often for a small fee. Other activities do not have this delay, like depositing funds from Ethereum to Arbitrum or using a decentralized application () on the Arbitrum chain.

### How is it cheaper?[​](#how-is-it-cheaper "Direct link to How is it cheaper?")

Arbitrum helps lower user transaction costs by reducing the strain on the parent chain. The primary way it does this is by processing transactions in batches. A  can contain several hundred  transactions and gets submitted as one parent chain transaction. This batching makes interacting with the parent chain cheaper since you save on overhead costs compared to submitting each transaction individually.

Additionally, Arbitrum posts transaction data on the parent chain in a compressed format. It only decompresses this data within the child chain environment, reducing the amount of information that needs storing on the parent chain.

### How does it all work together?[​](#how-does-it-all-work-together "Direct link to How does it all work together?")

At the most basic level, an Arbitrum chain works like this:

![Original napkin sketch drawn by Arbitrum co-founder Ed Felten](https://lh4.googleusercontent.com/qwf_aYyB1AfX9s-_PQysOmPNtWB164_qA6isj3NhkDnmcro6J75f6MC2_AjlN60lpSkSw6DtZwNfrt13F3E_G8jdvjeWHX8EophDA2oUM0mEpPVeTlMbsjUCMmztEM0WvDpyWZ6R)Original napkin sketch drawn by Arbitrum co-founder Ed Felten

Users and contracts put messages into the inbox. The chain reads the messages one at a time and processes each one. This processing updates the state of the chain and produces some outputs.

If you want an Arbitrum chain to process a transaction for you, you need to put that transaction into the chain's inbox. Then, the chain will see your transaction, execute it, and produce some outputs: a transaction receipt and any withdrawals that your transaction initiated.

Execution is deterministic, meaning that the contents of its inbox uniquely determine the chain's behavior. Because of this, the result of your transaction is knowable as soon as it gets put in the inbox. Any Arbitrum node will be able to tell you the result. (And you can run an Arbitrum node yourself if you want.)

All of the technical details in this document connect to this diagram. To get from this diagram to a complete description of Arbitrum, we'll need to answer questions like these:

*   Who keeps track of the inbox, Chain state, and outputs?
*   How does Arbitrum make sure that the chain state and outputs are correct?
*   How can Ethereum users and contracts interact with Arbitrum?
*   How does Arbitrum support Ethereum-compatible contracts and transactions?
*   How are ETH and tokens transferred into and out of Arbitrum chains, and how are they managed while on the chain?
*   How can I run my own Arbitrum node or validator?

### Nitro's Design: The Four Big Ideas[​](#nitros-design-the-four-big-ideas "Direct link to Nitro's Design: The Four Big Ideas")

The essence of Nitro and its key innovations lie in four big ideas. We'll list them here with a quick summary of each. We will unpack them in more detail in later sections.

**Big Idea: Sequencing, Followed by Deterministic Execution**: Nitro processes transactions with a two-phase strategy. First, the transactions get organized into a single-ordered sequence, and Nitro commits to that sequence. Then, the transactions get processed in that sequence by a deterministic .

**Big Idea:  at the Core**: Nitro supports Ethereum's data structures, formats, and virtual machine by compiling in the core code of the popular go-ethereum ("Geth") Ethereum node software. Using Geth as a library in this way ensures a very high degree of compatibility with Ethereum.

**Big Idea: Separate Execution from Proving**: Nitro takes the same source code and compiles it twice, once to native code for execution in a Nitro node, optimized for speed, and again to  for use in proving, optimized for portability and security.

**Big Idea: Optimistic Rollup with Interactive Fraud Proofs**: Nitro settles transactions to the parent Ethereum chain using an Optimistic Rollup protocol, including the interactive fraud proofs pioneered by Arbitrum. Now that we have covered the foundational concepts, the big picture, and the four big ideas of , we will begin a journey following a transaction through the Arbitrum protocol. In the next section, the transaction lifecycle begins.

---

# AnyTrust Protocol | Arbitrum Docs

## AnyTrust Protocol

AnyTrust is a variant of  Nitro technology that lowers costs by accepting a mild trust assumption.

The Arbitrum protocol requires that all Arbitrum nodes, including validators (nodes that verify correctness of the chain and are prepared to stake on correct results), have access to the data of every child chain  in the 's inbox. An Arbitrum rollup provides data access by posting the data (in batched, compressed form) on parent chain Ethereum as calldata. The Ethereum gas to pay for this is the largest component of cost in Arbitrum.

AnyTrust relies instead on an external Data Availability Committee (hereafter, "the Committee") to store data and provide it on demand. The Committee has `N` members, of which AnyTrust assumes at least two are honest. This means that if `N - 1` Committee members promise to provide access to some data, at least one of the promising parties must be honest. Since there are two honest members, and only one failed to make the promise, it follows that at least one of the promisers must be honest — and that honest member will provide data when it is needed to ensure the chain can properly function.

Keysets[​](#keysets "Direct link to Keysets")
---------------------------------------------

A Keyset specifies the BLS public keys of Committee members and the number of signatures required for a  to be valid. Keysets make Committee membership changes possible and provide Committee members the ability to change their keys.

A Keyset contains:

*   the number of Committee members, and
*   for each Committee member, a BLS public key, and
*   the number of Committee signatures required.

Keysets are identified by their hashes.

An parent chain KeysetManager contract maintains a list of currently valid Keysets. The child chain chain's Owner can add or remove Keysets from this list. When a Keyset becomes valid, the KeysetManager contract emits an parent chain Ethereum event containing the Keyset's hash and full contents. This allows the contents to be recovered later by anyone, given only the Keyset hash.

Although the API does not limit the number of Keysets that can be valid at the same time, normally only one Keyset will be valid.

Data Availability Certificates[​](#data-availability-certificates "Direct link to Data Availability Certificates")
------------------------------------------------------------------------------------------------------------------

A central concept in AnyTrust is the Data Availability Certificate (hereafter, a "DACert"). A DACert contains:

*   the hash of a data block, and
*   an expiration time, and
*   proof that `N-1` Committee members have signed the (hash, expiration time) pair, consisting of
    *   the hash of the Keyset used in signing, and
    *   a bitmap saying which Committee members signed, and
    *   a BLS aggregated signature (over the BLS12-381 curve) proving that those parties signed.

Because of the `2-of-N` trust assumption, a DACert constitutes proof that the block's data (i.e., the preimage of the hash in the DACert) will be available from at least one honest Committee member, at least until the expiration time.

In ordinary (non-AnyTrust) Nitro, the Arbitrum  posts data blocks on the parent chain chain as calldata. The hashes of the data blocks are committed by the parent chain Inbox contract, allowing the data to be reliably read by the child chain code.

AnyTrust gives the sequencer two ways to post a data block on parent chain: it can post the full data as above, or it can post a DACert proving availability of the data. The parent chain inbox contract will reject any DACert that uses an invalid Keyset; the other aspects of DACert validity are checked by the child chain code.

The child chain code that reads data from the inbox reads a full-data block as in ordinary Nitro. If it sees a DACert instead, it checks the validity of the DACert, with reference to the Keyset specified by the DACert (which is known to be valid because the parent chain Inbox verified that). The child chain code verifies that

*   the number of signers is at least the number required by the Keyset, and
*   the aggregated signature is valid for the claimed signers, and
*   the expiration time is at least two weeks after the current child chain timestamp.

If the DACert is invalid, the child chain code discards the DACert and moves on to the next data block. If the DACert is valid, the child chain code reads the data block, which is guaranteed to be available because the DACert is valid.

Data Availability Servers[​](#data-availability-servers "Direct link to Data Availability Servers")
---------------------------------------------------------------------------------------------------

Committee members run Data Availability Server (DAS) software. The DAS exposes two APIs:

*   The Sequencer API, which is meant to be called only by the Arbitrum chain's Sequencer, is a JSON-RPC interface allowing the Sequencer to submit data blocks to the DAS for storage. Deployments will typically block access to this API from callers other than the Sequencer.
*   The REST API, which is meant to be available to the world, is a RESTful HTTP(S) based protocol that allows data blocks to be fetched by hash. This API is fully cacheable, and deployments may use a caching proxy or CDN to increase scale and protect against DoS attacks.

Only Committee members have reason to support the Sequencer API. We expect others to run the REST API, and that is helpful. (More on that below.)

The DAS software, based on configuration options, can store its data in local files, or in a Badger database, or on Amazon S3, or redundantly across multiple backing stores. The software also supports optional caching in memory (using Bigcache) or in a Redis instance.

Sequencer-Committee Interaction[​](#sequencer-committee-interaction "Direct link to Sequencer-Committee Interaction")
---------------------------------------------------------------------------------------------------------------------

When the Arbitrum sequencer produces a data  that it wants to post using the Committee, it sends the batch's data, along with an expiration time (normally three weeks in the future) via RPC to all Committee members in parallel. Each Committee member stores the data in its backing store, indexed by the data's hash. Then the member signs the (hash, expiration time) pair using its BLS key, and returns the signature with a success indicator to the sequencer.

Once the Sequencer has collected enough signatures, it can aggregate the signatures and create a valid DACert for the (hash, expiration time) pair. The Sequencer then posts that DACert to the parent chain inbox contract, making it available to the AnyTrust chain software at the child chain.

If the Sequencer fails to collect enough signatures within a few minutes, it will abandon the attempt to use the Committee, and will "fall back to rollup" by posting the full data directly to the parent chain chain, as it would do in a non-AnyTrust chain. The child chain software can understand both data posting formats (via DACert or via full data) and will handle each one correctly.

---

# Economics of Disputes in Arbitrum BoLD | Arbitrum Docs

## Economics of Disputes in Arbitrum BoLD

_The following document explains the economics and denial-of-service protection mechanisms built into  . It covers trade-offs Arbitrum has to make to enable permissionless validation, explaining the key problems in an accessible way._

Background[​](#background "Direct link to Background")
------------------------------------------------------

[Arbitrum One](https://arbitrum.io/) is currently one of the most widely used Ethereum scaling solutions, with [~$14bn USD in total-value-locked](https://l2beat.com/scaling/projects/arbitrum) at the time of writing. Not only do its scaling properties, such as its 250ms block times, make it popular, but so do its security properties and approach to decentralization. Currently,  is governed by the Arbitrum DAO, one of the most active and robust on-chain organizations.

However, Arbitrum technology has not yet achieved its [full promise of being fully decentralized](https://docs.arbitrum.foundation/state-of-progressive-decentralization). Currently,  to  messaging from Arbitrum One back to Ethereum are verified by a permissioned list of validators. These validators can still  invalid withdrawals, but the system prevents anyone outside this list from holding them accountable. This permissioned list of validators limits Arbitrum One and  to being categorized as a `Stage 1 Rollup` on the [L2Beat website](https://l2beat.com/scaling/summary), meaning it still has training wheels preventing it from reaching its full potential.

The rollup technology powering Arbitrum One is called "optimistic" because claims about its state settled to and confirmed on Ethereum after a period of approximately seven days. During those seven days, the claimed states can be disputed. To make an analogy, a check can be cashed immediately but can be taken to court to dispute if there is a problem within a specific time frame. Because Arbitrum's state is deterministic, a  that is running a node and following the chain will always know if a posted claim is invalid. A key decentralization property allows **anyone** who knows the correct claim to challenge invalid claims and **_win_** the challenge. This preserves the accurate history of Arbitrum settling to Ethereum and protects the integrity of users' funds and withdrawals using a "single honest party" property. As long as there is a single entity following the chain and willing to dispute a claim, Arbitrum's security guarantees are maintained.

Before the deployment of BoLD, Arbitrum One's security properties were defined by the size of its permissioned set of validators. Validators could collude or finalize/confirm an incorrect state, and users have no recourse aside from the Arbitrum One security council stepping in. Elevating Arbitrum One's decentralization requires a different approach.

In the Fall of 2023,  announced [Arbitrum BoLD](https://medium.com/offchainlabs/bold-permissionless-validation-for-arbitrum-chains-9934eb5328cc), a new dispute resolution protocol built from the ground up that will bring Arbitrum chains to the next level of decentralization. BoLD, which is an acryonym for **Bo**unded **L**iquidity **D**elay, allows permissionless validation of Arbitrum chains. This means that chain owners can remove the list of permissioned validators for their chains to allow anyone to challenge invalid claims made about Arbitrum states on their parent chain and win.

In this document, we'll explore the economics and trade-offs enabling permissionless validation.

Settling Arbitrum states to Ethereum[​](#settling-arbitrum-states-to-ethereum "Direct link to Settling Arbitrum states to Ethereum")
------------------------------------------------------------------------------------------------------------------------------------

We frequently state that "Arbitrum chains settle their states to a parent chain", and we'll elaborate on what that means. All Arbitrum One transactions can be recreated by reading data from Ethereum L1, as compressed batches of all L2 transactions are frequently posted to Ethereum. Once a batched  is included in a finalized block on Ethereum, its history will likely never be reverted on Arbitrum One. However, when Ethereum receives a  of transactions, it does not know what the correct result of executing those transactions is. To verify the correct result, there is a separate process that confirms batch correctness on Ethereum: it is called the "."

For Arbitrum One specifically, approximately every hour, entities known as validators check the correctness of batches by following the . Validators can choose to become proposers and propose something called an "assertion", which attests to the validity of a batch, saying, "I have verified this batch". As Ethereum does not know what is correct on Arbitrum One, it allows about seven days for anyone to dispute one of these assertions. Prior to the deployment of BoLD, there was a permissioned list of proposers who could post assertions and challenge assertions for all Arbitrum chains. Arbitrum BoLD enables any , such as the ArbitrumDAO, to remove this permissioned list. Note that validators who opt to post assertions are otherwise known as "assertion proposers".

### Withdrawing assets back to Ethereum from Arbitrum[​](#withdrawing-assets-back-to-ethereum-from-arbitrum "Direct link to Withdrawing assets back to Ethereum from Arbitrum")

Users of Arbitrum One that have bridged assets from Ethereum can initiate the process of withdrawing said assets at any time. However, for this withdrawal to be fully executed, its corresponding claim must match a confirmed assertion on Ethereum. For instance, if Alice starts a withdrawal transaction on Arbitrum One, it gets posted in a batch on Ethereum. Then, a validator will post an assertion about that batch on Ethereum an hour later. The assertion has a seven-day window in which anyone can dispute it. After that window passes, the assertion is confirmed by the protocol and Alice will receive her withdrawn assets on Ethereum and is free to use them as she pleases.

"Settling states" and having a seven-day dispute window is crucial to ensuring assets can be withdrawn safely. Allowing anyone to dispute invalid claims and win keeps withdrawals protected by strong security guarantees without needing to trust a group of validators. This "permissionless validation" separates optimistic rollups from side chains.

### The dispute period[​](#the-dispute-period "Direct link to The dispute period")

The reason there is a dispute window for assertions about Arbitrum One on Ethereum is because Ethereum itself **has no knowledge about what is correct** on Arbitrum One. The two blockchains are different domains with different states. Ethereum, however, can be used as a neutral referee for parties to dispute claims about Arbitrum One. The dispute period is seven days because it is seen as the maximum period of time an adversary could delay Ethereum before social intervention, originally proposed by Vitalik Buterin. This window gives enough time for parties to catch invalid claims and challenge them accordingly.

### Dispute resolution times[​](#dispute-resolution-times "Direct link to Dispute resolution times")

An actual dispute occurs if an honest party disagrees with an assertion on Ethereum and posts an assertion they know to be correct as a counter-claim, or if a dishonest party decides to post to Ethereum a spurious assertion they know to be wrong, after another assertion has already been posted. This creates a "fork" in the chain of assertions, requiring a resolution process. We'll get into the high-level details of how disputes are resolved later in this document.

Once an actual dispute is ongoing, it will also take time to resolve, as, once again, Ethereum has no knowledge of the correctness of Arbitrum One states. Ethereum must then give sufficient time for parties to submit their proofs and declare a winner. The new Arbitrum BoLD protocol **guarantees that a dispute will be resolved within seven days** so long as an honest party or parties are present to defend against invalid claims, and have access to enough resources to pay for the costs of participating in the protocol, for details see the [Preventing Spam](#preventing-spam) section below.

As assertions have a dispute window of seven days, and disputes require an additional seven days to resolve, a dispute made at the last second would **delay assertion  to a maximum of 14 days**, or two weeks. BoLD is the only dispute protocol we are aware of that guarantees this bound.

### The cost of delaying withdrawals[​](#the-cost-of-delaying-withdrawals "Direct link to The cost of delaying withdrawals")

Delaying withdrawals incurs opportunity costs and impacts user experience for users who want to withdraw their assets. In the happy case of no disputes, withdrawals already have a baked-in, seven-day delay. A dispute adds seven days to that delay. The problem is that disputes delay _all_ pending withdrawals from Arbitrum One back to Ethereum, not just a single claim. As such, **disputing a claim must have a cost for the initiator** proportional to the opportunity cost they impose on Arbitrum users.

#### Requiring a bond to become a validator[​](#requiring-a-bond-to-become-a-validator "Direct link to Requiring a bond to become a validator")

By default, all Arbitrum nodes act as validators, monitoring the chain to verify assertions posted to the parent chain and flagging any invalid assertions. On Arbitrum One, running a validator, known as a “watchtower” node, is permissionless and requires no additional cost other than the infrastructure for the node.

Another type of validator, called a "proposer," performs additional tasks on top of their regular duties as a regular validator. Proposers compute Arbitrum states and propose assertions to the parent chain. To prevent abuse and delays in withdrawals, proposers must make a security deposit or "bond" to gain the privilege of proposing assertions. This bond can be withdrawn once their latest assertion is confirmed, ending their responsibilities as a proposer.

Arbitrum BoLD allows validators to become proposers and challengers without permission. Proposers must bond `ETH` to propose state assertions to the parent chain. Only one proposer is needed for chain progress, allowing most validators to simply verify assertions. In case of disputes over state assertions, BoLD enables anyone to put up a "challenge bond" of `ETH` to dispute invalid assertions, acting as a challenger in defense of an Arbitrum chain.

For more details on different strategies validators can use refer to [How to run a validator](/run-arbitrum-node/more-types/run-validator-node).

#### Pricing bonds[​](#pricing-bonds "Direct link to Pricing bonds")

Ensuring assertions are frequently posted is a requirement for Arbitrum, but at the same time, it should not be a privilege that is easily obtained, which is why the pricing of this "security deposit" is based on opportunity cost.

To be highly conservative, we want to account for a "bank run"-like scenario, in which everyone wants to withdraw their assets from Arbitrum One at the same time. The [Arbitrum One bridge](https://etherscan.io/address/0x8315177ab297ba92a06054ce80a67ed4dbd7ed3a) contains approximately $3.4B USD worth of assets at the time of writing on Oct 23rd, 2024. Assuming funds could earn a 5% APY if invested elsewhere, the opportunity cost of 1 extra week of delay in withdrawing them from Arbitrum One is approximately $3.27M USD. Given this scenario, we recommend a bond for assertion posters to be greater than $3.7M USD.

Honest proposers can always withdraw their bond once their assertions are confirmed. However, adversaries stand to lose the entirety of their bond if they propose invalid assertions. A large bond size drastically improves the economic security of the system based on these two axes by making the cost to propose high and by guaranteeing that malicious actors will lose their entire bond when they are proven wrong by the protocol.

Given that participation in BoLD is permissionless, we recommend that the size of bonds required to participate be high enough to disincentivize malicious actors from attacking Arbitrum One and to mitigate against spam (that would otherwise delay confirmations up to one ). High bonding values do not harm decentralization because (1)  bonding (or staking) pools can be deployed permissionlessly to open challenges and post assertions, and (2) any number of honest parties of unknown identities can emerge to bond their funds to the correct assertion and participate in the defense of Arbitrum at any time within a challenge. As with the current dispute resolution protocol, there are no protocol level incentives for parties who opt in to participate in validating Arbitrum One with BoLD.

While both of these bonds can be any ERC-20 token and be set to any size, we recommend the use of the `WETH` ERC-20 token & the following bond sizes for Arbitrum One:

*   Assertion bonds: 3600 `ETH` - required from validators to bond their funds to an assertion in the eventual hopes of having that assertion be confirmed by the rollup protocol. This is a one-time bond required to be able to start posting assertions. This bond can be withdrawn once a validator’s assertion is confirmed and can alternatively be put together via a trustless bonding pool.
    
*   Challenge-bonds, per level: 555 `WETH` at the "big-step" level; 79 `WETH` at the "small-step" level - required from validators to open challenges against an assertion observed on the parent chain (Ethereum, in the case of Arbitrum One), for each level. Note that “level” corresponds to the level of granularity over which the interactive bisection game gets played, starting at the block level, moving on to a range of  execution steps, and then finally to the level of a single execution step. For more details on the concept of "levels" in BoLD challenges, see [Challenge resolution](/bold/concepts/bold-technical-deep-dive#challenge-resolution) section in the Technical deep dive.
    

These values were carefully calculated to optimize for the resource ratio (explained later) and gas costs in the event of an attack, as explained in [BoLD whitepaper](https://arxiv.org/abs/2404.10491). This effectively means that an entity that has already put up a bond to propose an assertion does not need to put up a separate assertion bond to challenge an invalid state assertion that they observe. To be explicitly clear, the validator would still require 555 `ETH` and 79 `ETH` for ongoing challenges. These additional challenge bond amounts are needed to participate in the interactive dispute game (back and forth) and narrows down the disagreement to a single step of execution that is then proven on Ethereum. The 555 `ETH` and 79 `ETH` challenge bonds can be put together via a trustless bonding pool, and do not all have to be put up by the validator that opened the challenge. These bonds can be refunded at the end of a challenge and can also alternatively be put together by the community using a trustless bonding pool.

#### Centralization concerns[​](#centralization-concerns "Direct link to Centralization concerns")

Requiring a high bond to post assertions about Arbitrum seems centralizing, as we are replacing an allowlist of validators with a system that requires substantial funds to participate. However, **BoLD ships with a trustless bonding pool** for assertion posting. That is, any group of honest parties can pool funds into a simple contract that will post an assertion to Ethereum without needing to trust each other. We believe that making it easy to pool the funds to become an assertion poster without needing trust to dispute invalid claims does not affect the safety or decentralization of BoLD.

We claim optimizing for the unhappy case is more important than the happy case. As there only needs to be one honest assertion poster, we believe it falls into the security budget of the chain to set a high bond fee in order to become a proposer. It _should_ be expensive to delay Arbitrum One withdrawals, and it should also have a high barrier to entry to perform a key responsibility. As long as disputes can be made in a trustless manner, and trustless pools are available in production, we claim the security properties of assertion posting hold equally.

Resolving disputes[​](#resolving-disputes "Direct link to Resolving disputes")
------------------------------------------------------------------------------

One of the core properties BoLD achieves is providing a fixed upper bound for dispute resolution times. This section will discuss the constraints required to achieve this from first principles.

### Dispute game overview[​](#dispute-game-overview "Direct link to Dispute game overview")

Every game between adversarial parties needs a referee: a neutral party that can enforce the rules to declare a fair winner. Arbitrum BoLD relies on Ethereum as its referee because of its properties as the most decentralized, censorship-resistant  chain in the world.

When a dispute happens about Arbitrum One assertions on Ethereum, there is a protocol for resolving them. At its core, a dispute is about the blockhash of an Arbitrum One block at a given height. Ethereum does not know which claim is correct and, instead, relies on a dispute game to be played out. The game involves different parties making claims with proof to eventually narrow down their disagreement to a single step of execution within the execution of a block, called a one-step proof (OSP). Ethereum can then verify this OSP by itself and, as the neutral referee, declare a winner.

The "rules" of the dispute involve parties making claims with proof to reach the single point of disagreement. Parties "narrow down" their claims via moves called bisections. After a party has made a bisection, there is nothing else left to do until another party comes in and counters it. The core of the system is that an honest party winning a one-step proof leaves the malicious party with no other moves to make. Once the honest party has accumulated enough time without being countered, it is declared the winner.

Compared to other dispute protocols, however, BoLD is **not** a dispute between two specific Ethereum addresses, such as Alice and Bob. Instead, it is a dispute between an absolute, correct history vs. an incorrect one. Claims in BoLD are not attached to a particular address or validator but instead to Merkle commitments of an Arbitrum chain's history. If Alice and Charlie are both honest, and Bob is malicious, Alice and Charlie can play the game as part of a single "team". If Alice goes offline in the middle of a dispute-game, Charlie can continue resolving the game on behalf of the honest team because Charlie and Alice claim and make moves on the correct history. This is why we say BoLD enables "trustless cooperation," as there is no need for communication between honest parties. We believe committing a set of chain history hashes instead of a specific hash at a moment in time is crucial for securing dispute protocols.

For more technical details on the BoLD dispute protocol, see the [Technical deep dive](/bold/concepts/bold-technical-deep-dive) or the [BoLD research whitepaper](https://arxiv.org/abs/2404.10491).

### Spamming the dispute game[​](#spamming-the-dispute-game "Direct link to Spamming the dispute game")

BoLD is a dispute game in which the assertion that has accumulated seven days "not-countered" wins. That is, parties are incentivized to counter any new claims as soon as they appear to "block" their rivals from increasing their timers. For honest parties, responding to claims may sometimes require offchain computational work and, therefore, resources such as CPUs. However, malicious parties can make claims that are eventually found to be junk while making honest parties do actual work.

Because malicious parties can submit incorrect claims that make honest parties do work, there has to be an economic cost associated with making moves in the dispute-game. Said differently, we need a way to prevent **spam attacks** in dispute games.

#### The cost of moves[​](#the-cost-of-moves "Direct link to The cost of moves")

When pricing the bonds required to make claims within disputes, we consider the marginal costs that the honest party incurs for each claim a malicious party makes. The BoLD research paper includes information such as the number of adversary moves multiplied by the gas cost of making bisections and claims and some estimates of the offchain computational costs. We deem this the **marginal cost** of a party in a dispute.

With BoLD, the space of disagreements between parties is of max size 2^69. As such, the dispute game has to be played at different levels of granularity to make it computationally feasible.

Let's use an analogy: say we have two one-meter sticks that seem identical, and we want to determine where they differ. They appear identical at the centimeter level, so we need to go down to the millimeter level, then the micrometer level, and then figure out where they differ at the nanometer level.

This is what BoLD does over the space of disputes. Parties play the same game at different levels of granularity. At the centimeter level, each centimeter could trigger a millimeter dispute, and each millimeter dispute could have many micrometer disputes, etc. This dispute pattern could be abused unless spam is discouraged.

#### Preventing spam[​](#preventing-spam "Direct link to Preventing spam")

Since Ethereum knows nothing about which claims are honest or malicious until a one-step proof is provided, how can the protocol detect and discourage spam? A key insight is that honest parties only need to make one honest claim. Honest parties will never spam and create thousands of conflicting claims with themselves. Given this, we can put a price tag on making moves by looking at something called the "resource ratio" between honest and malicious parties, as defined in the BoLD research paper.

This ratio is computed as gas plus staking (or bonding) marginal costs of the adversary to the honest party. This means that certain values input into the equations can lead to **different ratios**. For instance, we can say the adversary has to pay **10x** the marginal costs of the honest party. However, aiming to increase this ratio significantly by plugging in different values leads to higher costs for all parties.

#### Dispute mini-bonds[​](#dispute-mini-bonds "Direct link to Dispute mini-bonds")

We require parties to lock up some capital called a "mini-bond" when making big claims in a dispute. These bonds are not needed when making bisection moves but are critical for posting an initial claim. Pricing these mini-bonds helps achieve a high resource ratio of dishonest parties to honest parties.

note

"Mini-bonds" is another term for "challenge-bonds" mentioned above in [Pricing bonds](#pricing-bonds).

It is clear that if we can multiply the cost to the malicious party by some multiplier of the honest party, we will get significant security benefits. For instance, imagine if a 1 billion dollar attack can be defended by simply pooling together 10 million dollars. Is it possible to achieve such a ratio?

Let's explore the limitations of making the cost to malicious parties higher than the honest parties'.

If we aim to have a constant resource ratio > 1, we have to do the following: if the adversary makes `N` stakes at any level, they can force the honest party to make `N` stakes at the next level down, where the adversary can choose not to place any stakes at all. Regarding resource ratio, to make the adversary always pay 10x in staking, we need to make the bond amount at one level 10x more than the next (as we go "upward" from subchallenges towards the assertion-level challenge). As there are multiple levels, the equations for the bond size include an exponential factor on the desired constant resource ratio > 1.

Below, we plot the bond size vs. the resource ratio of malicious to honest costs. The source for these equations can be found in the research paper and is [represented in this calculator](https://www.desmos.com/calculator/digjlq4vly).

If we desire a constant resource ratio of malicious to honest costs > 1, the required bond size in `ETH` increases as a polynomial at a particular challenge level.

#### Trade-offs[​](#trade-offs "Direct link to Trade-offs")

Having a 1000x resource ratio would be nice in theory, but it would, unfortunately, require a bond of 1M `ETH` ($2.56B USD at time of writing) to open a challenge in the first place, which is unreasonable. Instead, we can explore a more feasible ratio.

The resource ratio will drive the price of disputes claims, impacting both honest and malicious parties. However, claims can **always be made** through a **trustless pool**. Honest parties can pool together funds to participate in disputes.

#### The sweet spot[​](#the-sweet-spot "Direct link to The sweet spot")

So, now that we've established that a higher resource ratio is better but comes with some trade-offs, what is the sweet spot?

We propose a resource ratio of 6.46 for Arbitrum One. While odd, this resource ratio was calculated taking the initial "bond" to become a proposer (mentioned earlier) and a worst-case scenario of 500 gwei/gas on L1 for posting assertions and making subchallenge moves (i.e., if an attack were to happen, the malicious actor could choose to perform their attack during a period of elevated gas prices). Again, we should emphasize that the ratio of malicious to honest cost should be high to sufficiently deter attacks. Under our current assumptions (500gwei/gas) and proposed parameters (bond sizes, etc.), for every $6.46 spent by malicious parties attacking, only $1 is needed to defend it successfully in BoLD. Here's a [direct link to the calculations](https://www.desmos.com/calculator/usmdcuopme) where the X-axis is L1 gas costs in gwei and the Y-axis is the resource ratio.

Unfortunately, there is no "one size fits all" framework for choosing the resource ratio for your chain. Therefore, we recommend teams learn and understand the benefits and trade-offs of operating BoLD in a permissionless format - including performing the same type of economic risk analyses we have performed for Arbitrum One.

Thinking about incentives[​](#thinking-about-incentives "Direct link to Thinking about incentives")
---------------------------------------------------------------------------------------------------

Although we have made claims with hard numbers about how to price disputes and withdrawal delays in Arbitrum BoLD, we also took a step back and considered the theoretical assumptions we were making. Arbitrum One is a complex protocol used by many groups of people with different incentives. The research team at Offchain Labs has spent considerable effort studying the game theory of validators in optimistic rollup. Honest parties represent everyone with funds onchain, and they have a significant amount to gain by winning the challenge - as they can prevent the loss of their assets rather than losing them.

A more complex model is proposed, which considers all parties staking and their associated costs paper ["Incentive Schemes for Rollup Validators"](https://arxiv.org/abs/2308.02880). The paper examines the incentives needed to get parties to check whether assertions are correct. It finds that there is no pure strategy, Nash equilibrium, and only a mixed equilibrium if there is no incentive for honest validators. However, the research showed a pure strategy equilibrium can be reached if honest parties are incentivized to **check** results. The problem of honest validators' "free riding" and not checking is well-documented as the [verifier's dilemma](https://www.smithandcrown.com/glossary/verifiers-dilemma). We believe future iterations of BOLD could include "attention challenges" that reward honest validators for also doing their job.

### Service fee for “Active” proposers[​](#service-fee-for-active-proposers "Direct link to Service fee for “Active” proposers")

For Arbitrum BoLD's initial launch, we believe that chain owners should pay a service fee to active, top-level proposers as a way of removing the disincentive for participation by honest parties who bond their own capital and propose assertions for Arbitrum One. The fee should be denominated in `ETH` and should correlate to the annualized income that Ethereum mainnet validators receive, over the same time period. At the time of writing, the estimated annual income for Ethereum mainnet validators is approximately 3% to 4% of their stake (based on [CoinDesk Indices Composite Ether Staking Rate (CESR) benchmark](https://www.coindesk.com/indices/ether/cesr) and [Rated.Network](https://explorer.rated.network/network?network=mainnet&timeWindow=7d&rewardsMetric=average&geoDistType=all&hostDistType=all&soloProDist=stake)).

This service fee can be paid out upon an active proposer’s top-level assertion being confirmed on Ethereum and will be calculated using the duration of time that the proposer was considered active by the protocol. The procedure that calculates this will be handled off-chain, using a procedure that will be published at a later date. BoLD makes it permissionless for any validator to become a proposer and also introduces a way to pay a service fee to honest parties for locking up capital to do so. Validators are not considered active proposers until they successfully propose an assertion with a bond.

note

We envision the Arbitrum Foundation (AF) running its own proposer. This proposer's bonding capital will be funded by the AF and/or the DAO, and (unlike other proposers) will not earn a service fee since it is being run as a public good using the community's own money.

In order to become an active proposer for an Arbitrum chain, post-BoLD, a validator has to propose a state assertion to its parent chain. For Arbitrum One and Nova, the state assertion is posted onto L1 Ethereum. If they do not have an active bond on L1, they then need to attach a bond to their assertion in order to successfully post the assertion. Subsequent assertions posted by the same address will simply move the already-supplied bond to their latest proposed assertion. Meanwhile, if an entity, say Bob, has posted a successor assertion to one previously made by another entity, Alice, then Bob would be considered by the protocol to be the current active proposer. Alice would no longer be considered by the protocol as the active proposer and once Alice’s assertion is confirmed, then Alice gets her assertion bond refunded. There can only be 1 “active” proposer at any point in time.

For Arbitrum One specifically, all eligible entities who wish to be paid this service fee from the Arbitrum Foundation must undergo the Arbitrum Foundation’s KYC process as no AIP "may be in violation of applicable laws, in particular sanctions-related regulations". This is also written in the [ArbitrumDAO's Constitution](https://docs.arbitrum.foundation/dao-constitution#section-2-dao-proposals-and-voting-procedures).

### Rewards and Reimbursements for Defenders[​](#rewards-and-reimbursements-for-defenders "Direct link to Rewards and Reimbursements for Defenders")

The service fee described above is meant to incentivize or reimburse an honest, active proposer for locking up their capital to propose assertions and advance the chain. Similarly, in the event of an attack, a bounty is proposed to be paid out to honest defenders using confiscated funds from malicious actors (in the event of a challenge).

For Arbitrum One specifically, 1% (called the “defender’s bounty”) of the confiscated funds from a malicious actor is to be rewarded to honest parties who deposit a challenge bond and post assertions as part of a subchallenge, proportional to the amount that a defender has put up to defend a correct state assertion during the challenge. This bounty applies to all challenges (block challenges, sub challenges and one-step challenges). Note that any gas costs spent by honest parties to defend Arbitrum One during a challenge are 100% refundable by the Arbitrum Foundation. In this model, honest defenders and proposers of Arbitrum One are incentivized to participate while malicious actors stand to lose everything they spent attacking Arbitrum One. We believe chain owners who are interested in adopting BoLD for their own chain should follow a similar approach, described above for Arbitrum One, to incentivize challenge participation (but not necessarily assertion proposing).

In this design, defenders are only eligible for the defender's bounty if they deposit a challenge bond (for Arbitrum One, this is either 555 or 79 `ETH`, depending on the level), posted to an on-chain assertion as part of a subchallenge (i.e., not the top-level assertion), and have had their on-chain subchallenge assertion get confirmed by the protocol. For Arbitrum One, the calculation for the defender's bounty is conducted off-chain by the Arbitrum Foundation, and payment will be made via an ArbitrumDAO governance vote (since confiscated funds go to an ArbitrumDAO-controlled address). Honest parties are not automatically rewarded with all the funds seized from malicious actors to avoid creating a situation where honest parties wastefully compete to be the first to make each honest move in the interactive fraud-proof game. Additionally, BoLD resolves disputes by determining which top-level assertion is correct, without necessarily being able to classify every move as “honest” or “malicious” as part of the interactive fraud-proof game without off-chain knowledge.

Once all of a validator’s proposed assertions are confirmed, a validator can withdraw their bond in full. Additionally, the protocol will automatically handle refunds of challenge bonds for honest parties and confiscation of bonds from malicious parties in the event of a challenge. In other words, bonds put up by honest parties will always be returned and bonds put up by malicious parties will always be confiscated. For Arbitrum One specifically, parent chain gas costs for honest parties defending a challenge will be reimbursed by the Arbitrum Foundation using a procedure that will be published at a later date. The chain owner could therefore consider the cost of incentivizing or lending the assets to a single honest proposer in the happy case as the **security budget of the chain**.

For Arbitrum One specifically, all eligible entities who wish to be paid the defender's bounty from the ArbitrumDAO must undergo the Arbitrum Foundation’s KYC process as no AIP "may be in violation of applicable laws, in particular sanctions-related regulations". This is also written in the [ArbitrumDAO's Constitution](https://docs.arbitrum.foundation/dao-constitution#section-2-dao-proposals-and-voting-procedures).

Conclusion[​](#conclusion "Direct link to Conclusion")
------------------------------------------------------

This page summarizes the rationale behind choosing bond sizes and the cost of spam prevention in optimistic rollup dispute protocols. We recommend that bond sizes be high enough to discourage challenges from being opened, as malicious parties will always stand to lose when playing the game. As Arbitrum BoLD does not tie disputes to specific addresses, honest parties can have trustless cooperation to resolve disputes if desired. We posit that making the cost of the malicious parties 10x that of the honest party leads to nice economic properties that help us reason about how to price bonds. We describe how a 6.46x ratio (which BoLD as deployed will achieve) represents a pragmatic point in the design space that strikes a balance between concerns about staking costs against concerns about spam. Finally, we look at a high-level game theory discussion of optimistic rollups and argue that solving the verifier's dilemma by incentives to honest validators is an important addition to work towards.

The topic of further improvements and new economic and incentive models for BoLD are valuable and we believe it deserves the full focus and attention of the community in future proposals and discussions. Details around additional or new proposed economic or incentive models for BoLD will need continued research and development work. Still, the deployment of BoLD as-is represents a substantial improvement to the security of Arbitrum even without all economic-related concerns being fully resolved.

---

# A gentle introduction: BoLD | Arbitrum Docs

## A gentle introduction: BoLD

This introduction is for those who want to learn about : a new dispute protocol for optimistic rollups that enables **permissionless validation for  chains**. BoLD stands for Bounded Liquidity Delay and is currently deployed on a , , and Arbitrum Sepolia.

This next-generation dispute protocol technology is now available for any  to upgrade to and is live in production on Arbitrum One, Nova, and Arbitrum Sepolia.

BoLD replaces the previous, permissioned  protocol for Arbitrum One and Arbitrum Nova, as well as for any Arbitrum chain (who wishes to adopt BoLD).

In a nutshell:[​](#in-a-nutshell "Direct link to In a nutshell:")
-----------------------------------------------------------------

*   Validation for Arbitrum One and Arbitrum Nova is a privileged action currently limited to an [allow-listed set of parties, maintained by the Arbitrum DAO](https://docs.arbitrum.foundation/state-of-progressive-decentralization#allowlisted-validators) to reduce the risks of _[delay attacks](https://medium.com/offchainlabs/solutions-to-delay-attacks-on-rollups-434f9d05a07a)_. _Delay attacks_ are a class of attacks where malicious entities can open as many disputes as they are willing to forfeit bonds during the  period to delay confirmations of assertions (equal to the time needed to resolve those disputes one by one).
*   BoLD, an acronym for Bounded Liquidity Delay, is a new challenge resolution protocol for Arbitrum chains that enables permissionless validation by mitigating the risks of delay attacks against [Optimistic rollups like Arbitrum](/how-arbitrum-works/optimistic-rollup). This is possible because BoLD's design ensures disputes will be resolved within a fixed time window, currently set to equal one  (~6.4 days) for Arbitrum One and Arbitrum Nova. If there is a dispute, BoLD guarantees the maximum total time to be equal to two challenge periods (one for raising disputes, one for resolving disputes), a two day grace period for the Security Council to intervene if necessary, and a small delta for computing challenges.
*   Enabling permissionless validation is key milestone on [Arbitrum’s journey to becoming a Stage 2 Rollup](https://docs.arbitrum.foundation/state-of-progressive-decentralization) - the most advanced and mature rollup technology categorization, according to [L2Beat](https://medium.com/l2beat/introducing-stages-a-framework-to-evaluate-rollups-maturity-d290bb22befe). With BoLD, **any honest party can validate and bond their funds to post a correct L2 state assertions to win disputes against malicious entities.**

What _exactly_ is BoLD?[​](#what-exactly-is-bold "Direct link to what-exactly-is-bold")
---------------------------------------------------------------------------------------

BoLD, an acronym for Bounded Liquidity Delay Protocol, is an upgrade to Arbitrum's existing dispute protocol. Specifically, BoLD changes some of the rules used by validators to open and resolve disputes about Arbitrum’s state to ensure only valid states get confirmed on an Arbitrum chain’s , such as Ethereum.

The current dispute protocol has working fraud proofs and is used in production today by Arbitrum chains. The changes BoLD brings enable anyone to participate in the validation of the state of the chain and enhance security around all L2 to L1 messages (including withdrawals).

Under BoLD, a bonded validator’s responsibilities are to:

*   Post claims about an Arbitrum chain’s state to its parent chain (for Arbitrum One, the parent chain is Ethereum),
*   Open challenges to dispute invalid claims made by other validators, and
*   Confirm valid claims by participating in and winning challenges.

The goal of BoLD is to unlock permissionless validation by ensuring that disputes are resolved within a fixed period (currently equivalent to two challenge periods, plus a two-day grace period for the Security Council to intervene if necessary and a small delta for computation), effectively removing the risk of delay attacks and making withdrawals to a parent chain more secure. BoLD accomplishes this by introducing a new dispute system that lets any single entity defend Arbitrum against malicious parties - effectively allowing anyone to validate, propose, and defend an Arbitrum chain’s state without needing permission to do so.

Why does Arbitrum need a new dispute protocol?[​](#why-does-arbitrum-need-a-new-dispute-protocol "Direct link to Why does Arbitrum need a new dispute protocol?")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

While Arbitrum chains today benefit from working fraud proofs, BoLD introduces a few subtle but innovative changes that let _anyone_ challenge and win disputes - all within a fixed time period. In other words, Arbitrum chains will continue to be secured with an interactive proving game between validators using fraud proofs, but with the added benefit of this game being completely permissionless and time-bounded to the same length as one challenge period (or 6.4 days, by default).

Under the hood, the reason why BoLD can offer time-bound, permissionless validation is because a correct Arbitrum state  is **not tied to the entity that bonds their capital to a claim**. This property, coupled with the fact that the  states are completely deterministic and can be proven on Ethereum, means that **any number of honest parties** can rely on BoLD to prove that their claim is correct. Lastly, a property that will not change with BoLD is the fact that there needs to only be one honest party defending Arbitrum.

### BoLD brings Arbitrum closer to being recognized as a Stage 2 rollup[​](#bold-brings-arbitrum-closer-to-being-recognized-as-a-stage-2-rollup "Direct link to BoLD brings Arbitrum closer to being recognized as a Stage 2 rollup")

Inspired by [Vitalik’s proposed milestones](https://ethereum-magicians.org/t/proposed-milestones-for-rollups-taking-off-training-wheels/11571), the team over at L2Beat has assembled a widely recognized framework for evaluating the development Ethereum Rollups. Both Vitalik and the [L2Beat framework](https://medium.com/l2beat/introducing-stages-a-framework-to-evaluate-rollups-maturity-d290bb22befe) refer to the final stage of rollup development as _“Stage 2 - No Training Wheels”_. A critical criterion for being considered a Stage 2 rollup is to allow anyone to validate the child  and post fraud proofs to Ethereum without restraints. This is considered a key requirement for Stage 2 because it ensures _[“that the system is not controlled by a limited set of entities and instead is subject to the collective scrutiny of the entire community”](https://medium.com/l2beat/introducing-stages-a-framework-to-evaluate-rollups-maturity-d290bb22befe)._

BoLD enables permissionless validation by allowing _anyone_ to challenge incorrect Arbitrum state assertions and therefore unlocks new avenues for participation in securing the network, fostering greater inclusivity and resilience. This is made possible because BoLD guarantees that a single, honest entity who has their capital bonded to the correct Arbitrum state assertion will always win against malicious adversaries. The research and work to bring BoLD to life underscores Arbitrum's commitment to scaling Ethereum without compromising on security.

![Pie slice](/img/bold-l2beat-pie-chart.png)

With BoLD at its core, Arbitrum charts a course towards being recognized as a Stage 2 rollup by addressing the currently yellow (above) State Validation wedge in [L2Beat's risk analysis pie chart](https://l2beat.com/scaling/summary). BoLD contributes to a more permissionless, efficient, and robust rollup ecosystem. Additionally, BoLD will be available as an upgrade for all Orbit chains who wish to adopt it to reap the aforementioned benefits.

### BoLD makes withdrawals to parent chain Ethereum safer[​](#bold-makes-withdrawals-to-parent-chain-ethereum-safer "Direct link to BoLD makes withdrawals to parent chain Ethereum safer")

Today, there is a period of time, following a state assertion, called the “challenge period,” where any validator can open a dispute over the validity of a given the child chain state root. If there are no disputes during the challenge period, the protocol confirms the state root and considers it to be valid - this property is what makes Arbitrum an optimistic rollup. This challenge period is why you must wait ~1 week (6.4 days to be exact) to withdraw assets from Arbitrum One, for example. While this design is secured with working fraud proofs, it is susceptible to [delay attacks](https://medium.com/offchainlabs/solutions-to-delay-attacks-on-rollups-434f9d05a07a), where malicious actors continuously open disputes to extend that challenge period for as long as they’re willing to sacrifice bonds - effectively extending the challenge period indefinitely by an amount equal to the time it takes to resolve each dispute, one by one. This risk is not ideal nor safe, and is why validation for Arbitrum One and Nova is confined to a permissioned set of entities overseen by the Arbitrum DAO.

![BoLD safer withdrawals](/img/bold-safer-withdrawals-with-bold-2.png)

BoLD addresses these challenges head-on by introducing a time limit on the existing rollup protocol for resolving disputes, effectively ensuring that challenges conclude within a 6.4-day window (this window can changed by the DAO for Arbitrum One and Nova). This is possible due to two reasons: (1) BoLD’s design allows for challenges between the honest party and any number of malicious adversaries to happen in parallel, and (2) the use of a time limit that will automatically confirm the honest party’s claims if the challenger fails to respond.

To summarize with an analogy and the diagram below: Arbitrum’s current dispute protocol assumes that any assertion that gets challenged must be defended against each unique challenger sequentially, like in a _“1v1 tournament”_. BoLD, on the other hand, enables any single honest party to defend the correct state and be guaranteed to win, similar to an _“all-vs-all battle royale”_ where there must and will always be a single winner in the end.

![Before and after with BoLD](/img/bold-before-vs-after-with-bold.png)

note

The timer/clocks above are arbitrary and instead represent the duration of challenges and how challenges are sequential today but can take place in parallel with BoLD. The duration of challenges are independent from one another.

How is this possible?[​](#how-is-this-possible "Direct link to How is this possible?")
--------------------------------------------------------------------------------------

The BoLD protocol provides the guardrails and rules for how validators challenge claims about the state of an Arbitrum chain. Since Arbitrum’s state is deterministic, there will always be only one correct state for a given input of on-chain operations and transactions. The beauty of BoLD’s design guarantees that disputes will be resolved within a fixed time window, removing the risk of delay attacks and ultimately enabling anyone to bond their funds to and successfully defend that singular correct state of Arbitrum.

Let’s dive in to an overview of how BoLD actually works.

1.  **An assertion is made:** Validators begin by taking the most recent confirmed [assertion](/how-arbitrum-works/optimistic-rollup#the-rollup-chain), called `Block A`, and assert that some number of transactions afterward, using Nitro’s deterministic  (STF), will result in an end state, `Block Z`. If a validator claims that the end state represented by `Block Z` is correct, they will bond their funds to `Block Z` and propose that state to it's parent chain. (For more details on how bonding works, see [Bold technical deep dive](/bold/concepts/bold-technical-deep-dive)). If nobody disagrees after a certain amount of time, known as the challenge period, then the state represented by the assertion `Block Z` is confirmed as the correct state of an Arbitrum chain. However, if someone disagrees with the end state `Block Z`, they can submit a challenge. This is where BoLD comes into play.
2.  **A challenge is opened:** When another validator observes and disagrees with the end state represented by `Block Z`, they can permissionlessly open a challenge by asserting and bonding capital to a claim on a different end state, represented by an assertion `Block Y`. At this point in time, there are now 2 asserted states: `Block A → Block Z` and `Block A → Block Y`. Each of these asserted states, at this point in time now that there's a challenge, are referred to _edges_ while a Merkle tree of asserted states from some start to endpoint (e.g., `Block A → Block Z`) is more formally known as a _history commitment._ It is important to note that Ethereum at this point in time has no notion of which edge(s) is correct or incorrect - edges are simply a portion of a claim made by a validator about the history of the chain from some end state all the way back to some initial state. Also note that because a bond put up by a validator is tied to an assertion rather than the party who put up that bond, there can be any number of honest, anonymous parties that can open challenges against incorrect claims. It is important to note that the bonds put up to open challenges are held in the rollup contract. There is a prescribed procedure for what the Arbitrum Foundation is expected to do with these funds; see Step 5 below for a summary.
3.  **Multi-level, interactive  begins:** To resolve the dispute, the disagreeing entities will need to come to an agreement on what the _actual, correct_ asserted state should be. [It would be tremendously expensive to re-execute](/how-arbitrum-works/optimistic-rollup#why-interactive-proving-is-better) and compare everything from `Block A → Block Z` and `Block A → Block Y`, especially since there could be potentially millions of transactions in between `A`, `Z`, and `Y`. Instead, entities take turns bisecting their respective _history commitments_ until they arrive at a single step of instruction where an arbiter, like Ethereum, can declare a winner. Note that [this system is very similar to how challenges are resolved on Arbitrum chains today](/how-arbitrum-works/interactive-fraud-proofs) - BoLD only changes some minor, but important, details in the resolution process. Let’s dive into what happens next:
    *   **Block challenges**: when a challenge is opened, the edges are called _level-zero edges_ since they are at the granularity of Arbitrum blocks. The disputing parties take turns bisecting their history commitments until they identify the specific block that they disagree on.
    *   **Big-step challenge:** Now that the parties have narrowed down their dispute to a single block, the back-and-forth bisection exercise continues within that block. Note that this block is agreed by all parties to be some state after the initial state, but before the final states. This time, however, the parties will narrow down on a specific _range_ of instructions for the State Transition Function within the block - essentially working towards identifying a set of instructions within which their disagreement lies. This range is currently defined as 2^20 steps of `WASM` instructions, which is the assembly of choice for validating Arbitrum chains.
    *   **One-step challenge:** Within that range of 2^20 instructions, the back-and-forth bisecting continues until all parties arrive at a single step of instruction that they disagree on. At this point in time, parties agree on the initial state of Arbitrum before the step but disagree on the end state one step immediately after. Remember that since Arbitrum’s state is entirely deterministic, there is only one correct end state.
4.  **One-step proof:** Once a challenge is isolated down to a dispute about a single step, both parties run that step to produce, and then submit, a one-step proof to the OneStepProof  on the parent chain (e.g. Ethereum). A one-step proof is a proof that a single step of computation results in a particular state. The smart contract on the parent chain will execute the disputed step to validate the correctness of a submitted proof from the two parties. It is at this point that the honest party's proof will be deemed valid and its tree of edges will be confirmable by time, while the dishonest party will have their edges rejected by timeout.
5.  **:** Once the honest one-step edge is confirmed, the protocol will work on confirming or rejecting the parent edges until it reaches the level-zero edge of the honest party. With the honest party’s level-zero edge now confirmed, the honest party’s assertion bond can be withdrawn. Meanwhile, the dishonest party has their bonds taken away to ensure the dishonest party is always punished.
    *   There is another way that a level-zero edge can get confirmed: time. At each of the mini-stages of the challenge (block challenge, big-step challenge, one-step challenge), a timer increments upwards towards some challenge period, _T_ defined by BoLD. This timer begins ticking for a party when they submit their bisected history commitment until their challenger submits their bisected history commitment in response. An edge is automatically confirmed if the timer reaches _T._
6.  Reimbursements for the honest party's L1 gas costs and mini-bonds made at the other challenge levels are handled by the Arbitrum Foundation.

That’s it! We’ve now walked through each of the steps that validators will take to dispute challenges with the BoLD protocol. One final note here is that each of the steps explained above can take place concurrently and this is one of the reasons why BoLD can guarantee that disputes are resolved within a fixed time frame.

Frequently asked questions about BoLD (FAQ):[​](#frequently-asked-questions-about-bold-faq "Direct link to Frequently asked questions about BoLD (FAQ):")
---------------------------------------------------------------------------------------------------------------------------------------------------------

#### Q: How does bonding work?[​](#q-how-does-bonding-work "Direct link to Q: How does bonding work?")

The entities responsible for posting assertions about Arbitrum state to Ethereum are called validators. If posting assertions were free, anyone could create conflicting assertions to always delay withdrawals by 14 days instead of 7. As such, Arbitrum requires validators to put in a “security deposit”, known as a bond, to be allowed to post assertions. Validators can withdraw their bond as soon as their latest posted assertion has been confirmed, and end their responsibilities. These bonds can be any ERC-20 token and should be set to a large enough value (e.g., 200 WETH) to make it economically infeasible for an adversary to attack an Arbitrum chain and to mitigate against spam (that would otherwise delay confirmations). Requiring a high bond to post assertions about Arbitrum seems centralizing, as we are replacing a whitelist of validators with instead a system that requires a lot of money to participate in. To address this, there is a [contract](https://github.com/OffchainLabs/BoLD/blob/main/contracts/src/assertionStakingPool/AssertionStakingPoolCreator.sol) that anyone can use to deploy a bonding pool as a way of crowdsourcing funds from others who wish to help defend Arbitrum but who may not individually be able to put up the large upfront bond itself. The use of bonding pools, coupled with the fact that there can be any number of honest anonymous parties ready to defend Arbitrum, means that these high bond values do not harm decentralization.

#### Q: Why are the bond sizes so high for Arbitrum One?[​](#q-why-are-the-bond-sizes-so-high-for-arbitrum-one "Direct link to Q: Why are the bond sizes so high for Arbitrum One?")

There are two types of “bonds” in BoLD: **assertion and challenge.** The below sizes are carefully calculated and set for Arbitrum One using a variety of factors, including TVL and optimizing for a balance between cost for honest parties and security of the protocol. As always, the exact bond sizes for an Orbit chain using BoLD is entirely up to the  to decide, if they choose to adopt BoLD at all.

**Assertion bond sizes**

Assertion bond sizes can be thought of as a “security deposit” that an entity puts down to fulfill the role of a proposer (i.e., a validator who proposes state assertions to the parent chain). The bond sizes are high because the role of a proposer assumes a big responsibility - their role is to ensure that the chain progresses. Accordingly, the bond also acts as a deterrence to _delay attacks_, where the attacker would sacrifice the bond in order to cause roughly a week of delay in a group of withdrawals. If the bond is too small or free, there may not be enough deterrence against this type of attack. Validators who choose to be proposers can withdraw their bond as soon as their most recent posted assertion has been confirmed by the protocol. We expect there to be very few proposers for Arbitrum One as only one is sufficient for safety and full functioning of the chain.

**Challenge bond sizes**

If someone disagrees with a posted assertion from a proposer, they can pool funds together to propose their own assertion that represents the correct history of the chain. Upon doing so, a challenge between the two claims will begin. Anyone can participate in the challenge, as it is not tied up to specific addresses. To resolve a challenge, participants will incur compute and gas costs due to the [interactive fraud proof game](https://docs.arbitrum.io/inside-arbitrum-nitro/#resolving-disputes-using-interactive-fraud-proofs), and certain moves within a challenge have an additional bond required to prevent resource exhaustion and spam from adversaries. These moves within a challenge require smaller, **challenge bonds**. The proposed challenge bonds for Arbitrum One are 1110 ETH to fully resolve a dispute, which will also get reimbursed upon the confirmation of assertions by the protocol.

The rationale behind the specific challenge bond size was made using something called a “resource ratio” - defined as the cost ratio between an adversary and an honest party when participating in the interactive fraud proof game. The value was chosen to ensure that the malicious party will pay 10x the marginal costs of the honest party. This resource ratio, coupled with the fact that an honest party will always get their bonds refunded while a malicious party loses everything, helps prevent and deter attacks to begin with.

To summarize with a scenario, this effectively means that defending against a $1B dollar attack would require ~$100M of bonds. The ~$100M would be reimbursed upon winning a challenge, where the $1B put up by an adversary would be lost. The proposal aims to send the confiscated funds to the treasury by setting the “excess state receiver” address to the [DAO’s treasury address](https://arbiscan.io/address/0xF3FC178157fb3c87548bAA86F9d24BA38E649B58). The tradeoff here is that the higher the resource ratio we want, the more expensive it is for both honest and evil parties to make claims in disputes.

**Bonding pools as a way to allow people to participate in assertion posting**

BoLD ships with  bonding pools that allow any group of participants to pool their funds together to challenge a dishonest proposer, and win. That is, any group of entities can pool funds into a simple contract that will post an assertion to Ethereum without needing to trust each other. Upon observation of an invalid assertion, validators have one challenge period (~6.4 days) to pool funds in the contract and respond with a counter assertion. We believe that making it easy to pool the funds to participate in the defense of Arbitrum trustlessly and improves decentralization and the safety of BoLD.

#### Q: Does the bond requirement only mean that whales can validate Arbitrum One?[​](#q-does-the-bond-requirement-only-mean-that-whales-can-validate-arbitrum-one "Direct link to Q: Does the bond requirement only mean that whales can validate Arbitrum One?")

Validating Arbitrum One is **free and accessible**. All Arbitrum One nodes, by default, are watchtower validators meaning they can detect and report invalid assertions posted to Ethereum.

However, becoming an assertion proposer requires a bond, as without it, anyone could delay all Arbitrum bridged assets by one week. However, BoLD allows for anyone to propose assertions and also challenge invalid assertions via pool contracts, helping keep proposers accountable for their actions.

#### Q: How does BoLD disincentivize malicious actors from attacking an Arbitrum chain?[​](#q-how-does-bold-disincentivize-malicious-actors-from-attacking-an-arbitrum-chain "Direct link to Q: How does BoLD disincentivize malicious actors from attacking an Arbitrum chain?")

Bonds put up by honest parties will always be refunded while malicious actors always stand to lose 100% of their bond. Malicious actors stand to lose everything at each challenge. BoLD delay is bounded and additional challenges would not increase the delay of a particular assertion.

#### Q: In the event of a challenge, what happens to the confiscated funds from malicious actors for Arbitrum One?[​](#q-in-the-event-of-a-challenge-what-happens-to-the-confiscated-funds-from-malicious-actors-for-arbitrum-one "Direct link to Q: In the event of a challenge, what happens to the confiscated funds from malicious actors for Arbitrum One?")

Recall that BoLD enables any validator to put up a bond to propose assertions about the child chain state. These assertions about the child chain state are deterministic and so an honest party who puts up a bond on the correct assertion will always win in disputes. In these scenarios, the honest party will eventually have their bonds reimbursed while the malicious actor will lose all of their funds.

In BoLD, all costs spent by malicious actors are confiscated and sent to the Arbitrum DAO treasury. A small reward, called the Defender's Bounty, of 1% will be awarded to entities who put down challenge bonds in defense of Arbitrum One. For the remainder of the funds, the Arbitrum DAO will have full discretion over what to do with the funds confiscated from a malicious actor. This includes, but is not limited to:

*   Using the confiscated funds to refund the parent chain gas costs to honest parties,
*   Rewarding or reimbursing the honest parties with some, or all, of the confiscated funds in excess of the 1% Defender's Bounty,
*   Burning some, or all, of the confiscated funds, or
*   Keep some, or all, of the confiscated funds within the Arbitrum DAO Treasury

As always, an Orbit chain can choose how they wish to structure and manage confiscated funds from dishonest parties.

#### Q: Why are honest parties not automatically rewarded with confiscated funds from a malicious actor?[​](#q-why-are-honest-parties-not-automatically-rewarded-with-confiscated-funds-from-a-malicious-actor "Direct link to Q: Why are honest parties not automatically rewarded with confiscated funds from a malicious actor?")

It’s tempting to think that rewarding the honest proposer in a dispute can only make the protocol stronger, but this turns out not to be true, because an adversary can sometimes profit by placing the honest stakes themselves.

This creates perverse incentives that threaten the security of BoLD. Here’s an example, from Ed Felten:

💡 _Suppose the top-level assertion bond is $5M. A delay attack, where the attacker wants to cause one week of delay at minimum cost, costs the attacker $5M. If we change the protocol to give the honest proposer 20% of the confiscated bond, then the attack only costs $4M, because the attacker can post both bonds ($10M total) and get back the honest $5M bond, plus a $1M reward. So, the protocol is weaker against delayed griefing. We can compensate by increasing the top-level assertion bond to $6.25M, so delay griefing still costs $5M, but that increases the cost, to an honest party, required to defend against other attacks. The intuition that giving bigger rewards for honest actions can only make the protocol stronger, though natural, turns out not to be correct. The reason for this is that large rewards create new strategic options for the attacker which might enable them to reduce their cost._

That said, there’s no harm in paying the honest proposer a fair interest rate on their bond, so they don’t suffer for having helped the protocol by locking up their capital in a bond.

Therefore, the BoLD AIP proposes that the honest parties be rewarded 1% of confiscated bonds from a dishonest party, in the event of a challenge. This reward applies only to entities who deposit challenge bonds and participate in defending Arbitrum against a challenge. The exact amount rewarded to honest parties will be proportional to the amount defender’s deposited into the protocol during a challenge, making bonding pool participants eligible. The process by which this reward is calculated will be done off-chain and payouts will require a DAO vote because the confiscated funds are always sent to a DAO-controlled address.

#### Q: Why is $ARB not the bonding token used in BoLD? on Arbitrum One?[​](#q-why-is-arb-not-the-bonding-token-used-in-bold-on-arbitrum-one "Direct link to Q: Why is $ARB not the bonding token used in BoLD? on Arbitrum One?")

Although BoLD supports using an ERC-20 token, Ethereum, specifically WETH, was chosen over $ARB for a few reasons:

1.  **Arbitrum One & Arbitrum Nova both inherit their security from Ethereum already,** Arbitrum One and Nova rely on Ethereum for both data availability and as the referee for determining winners during fraud-proof disputes. It follows then that Ethereum continues to be used in BoLD, which is meant to permissionlessly secure Arbitrum even further. Ethereum’s value is also relatively independent of Arbitrum, especially when compared to $ARB.
2.  Adversaries might be able to exploit the potential instability of $ARB when trying to win challenges. Suppose an adversary deposits their bond in `$ARB`, and can create an impression that they have a nontrivial chance of winning the challenge. This might drive down the value of $ARB, which would decrease the adversary's cost to create more stakes (i.e., more spam) during the challenge, which in turn could increase the adversary's chances of winning (which would drive $ARB lower, making the attack cheaper still for the adversary, etc.)
3.  **Access to liquidity**: Ethereum has greater liquidity than $ARB. In the event of an attack on Arbitrum, access and ease of pooling funds may become crucial.
4.  **Fraud proofs are submitted to, and arbitrated on, L1 Ethereum.** The bonding of capital to make assertions is done so on L1 Ethereum, since Ethereum is the arbitrator of disputes. If BoLD were to use $ARB instead of Ethereum, a large amount of $ARB must be pre-positioned on L1 which is more difficult to do when compared to pre-positioning Ethereum on L1 Ethereum.

An Orbit chain owner may choose to use any token they wish for bonding, if they adopt and use BoLD permissionless validation.

#### Q: Can the required token for the validator be set to $ARB and can network $ETH revenues be distributed for validator incentives for Arbitrum One?[​](#q-can-the-required-token-for-the-validator-be-set-to-arb-and-can-network-eth-revenues-be-distributed-for-validator-incentives-for-arbitrum-one "Direct link to Q: Can the required token for the validator be set to $ARB and can network $ETH revenues be distributed for validator incentives for Arbitrum One?")

Yes. The asset that a validator uses to become a proposer in BoLD can be set to any `ERC-20` token, including `$ARB`. For Arbitrum One, `$ETH` is used for bonds for various reasons mentioned above. The Arbitrum DAO can change this asset type at any time via a governance proposal. Should such an economic incentive model exist, the source and denomination of funds used to incentivize validators will be at the discretion of the Arbitrum DAO. Again, though, we don't see `$ARB`\-based bonding as a good idea at present; see the last question.

#### Q: How are honest parties reimbursed for bonding their capital to help secure Arbitrum One?[​](#q-how-are-honest-parties-reimbursed-for-bonding-their-capital-to-help-secure-arbitrum-one "Direct link to Q: How are honest parties reimbursed for bonding their capital to help secure Arbitrum One?")

The Arbitrum DAO reimburses “active” proposers with a fair interest rate, as a way of removing the disincentive to participate, by reimbursing honest parties who bond their own capital and propose assertions for Arbitrum One. The interest rate should be denominated in `ETH` and should be equal to the annualized yield that Ethereum mainnet validators receive, which at the time of writing, is an APR between 3% to 4% (based on [CoinDesk Indices Composite Ether Staking Rate (CESR)](https://www.coindesk.com/indices/ether/cesr) benchmark and [_Rated.Network_](https://explorer.rated.network/network?network=mainnet&timeWindow=all&rewardsMetric=average&geoDistType=all&hostDistType=all&soloProDist=stake)). This interest is considered a reimbursement because this payment reimburses the honest party for the opportunity cost of locking up their capital and should not be perceived as a “reward” - for the [same reasons why the protocol does not reward honest parties with the funds confiscated from a malicious actor](https://www.notion.so/Arbitrum-BoLD-FAQ-93210f430a6a470792496be040ac9990?pvs=21). These reimbursement payments can be paid out upon an active proposer’s honest assertion being confirmed on Ethereum and will be calculated and handled off-chain by the Arbitrum Foundation.

BoLD makes it permissionless for any validator to become a proposer and also introduces a way to pay a service fee to honest parties for locking up capital to do so. Validators are not considered active proposers until they successfully propose an assertion _with_ a bond. In order to become an active \*\*proposer for Arbitrum One, post-BoLD, a validator has to propose a child chain state assertion to Ethereum. If they do not have an active bond on the parent chain, they then need to attach a bond to their assertion in order to successfully post the assertion. Subsequent assertions posted by the same address will simply move the already-supplied bond to their latest proposed assertion. Meanwhile, if an entity, say Bob, has posted a successor assertion to one previously made by another entity, Alice, then Bob would be considered by the protocol to be the current active proposer. Alice would no longer be considered by the protocol as the active proposer and once Alice’s assertion is confirmed, then Alice gets her assertion bond refunded. There can only be one “active” proposer at any point in time.

The topic of economic and incentive models for BoLD on Arbitrum One is valuable and we believe it deserves the full focus and attention of the community via a separate proposal/discussion - decoupled from this proposal to bring BoLD to mainnet. Details around proposed economic or incentive models for BoLD will need continued research and development work, but the deployment of BoLD as-is represents a substantial improvement to the security of Arbitrum even without economic-related concerns being resolved. The DAO may choose, via governance, to fund other parties or change this reimbursement model at any time.

For Orbit chains, any economic model can be implemented alongside BoLD, if chain owners decide to adopt BoLD.

#### Q: For Arbitrum One proposers, is the service fee applied to the amount bonded? If that’s the case, the $ETH would be locked and thus unable to be used to generate yield elsewhere. So, which assets are used to generate this yield for the service fee? Would it involve some $ETH from the Arbitrum bridge?[​](#q-for-arbitrum-one-proposers-is-the-service-fee-applied-to-the-amount-bonded-if-thats-the-case-the-eth-would-be-locked-and-thus-unable-to-be-used-to-generate-yield-elsewhere-so-which-assets-are-used-to-generate-this-yield-for-the-service-fee-would-it-involve-some-eth-from-the-arbitrum-bridge "Direct link to Q: For Arbitrum One proposers, is the service fee applied to the amount bonded? If that’s the case, the $ETH would be locked and thus unable to be used to generate yield elsewhere. So, which assets are used to generate this yield for the service fee? Would it involve some $ETH from the Arbitrum bridge?")

The proposed service fee should correlate to the annualized income that Ethereum mainnet validators receive, over the same time period. At the time of writing, the estimated annual income for Ethereum mainnet validators is approximately 3% to 4% of their stake (based on [CoinDesk Indices Composite Ether Staking Rate (CESR)](https://www.coindesk.com/indices/ether/cesr) benchmark and [_Rated.Network_](https://explorer.rated.network/network?network=mainnet&timeWindow=all&rewardsMetric=average&geoDistType=all&hostDistType=all&soloProDist=stake)).

The fee is applied to the total amount bonded over the duration of time that a proposer is active. A validator will need to deposit $ETH into the contracts on the parent chain to become a proposer and so those deposited funds will indeed be unable to be used for yield in other scenarios. The decision on the source of funds for the yield is entirely up to the ArbitrumDAO to decide.

#### Q: For Arbitrum One, will the off-chain compute costs be reimbursed? (i.e., the costs for a validator computing the hashes for a challenge)[​](#q-for-arbitrum-one-will-the-off-chain-compute-costs-be-reimbursed-ie-the-costs-for-a-validator-computing-the-hashes-for-a-challenge "Direct link to Q: For Arbitrum One, will the off-chain compute costs be reimbursed? (i.e., the costs for a validator computing the hashes for a challenge)")

Reimbursement will not be made for off-chain compute costs as we view these to be costs borne by all honest operators, alongside the maintenance and infra costs that regularly arise from running a node.

Our testing has demonstrated that the cost of running a sub-challenge in BoLD, the most computationally-heavy step, on an AWS r5.4xlarge EC2 instance, costs around $2.50 USD (~$1/hour for one challenge with 2.5hour duration) using [on-demand prices for US East (N. Virginia)](https://instances.vantage.sh/aws/ec2/r5.4xlarge). Therefore, the additional costs from off-chain compute is assumed to be negligible relative to the regular infra costs of operating a node.

#### Q: How will BoLD impact Arbitrum Nova?[​](#q-how-will-bold-impact-arbitrum-nova "Direct link to Q: How will BoLD impact Arbitrum Nova?")

Although this AIP proposes that both Arbitrum One and Nova upgrade to use BoLD, we recommend for the removal of the [allowlist of validators for Arbitrum One while keeping Nova permissioned with a DAO-controlled allowlist of entities](https://docs.arbitrum.foundation/state-of-progressive-decentralization#allowlisted-validators) - unchanged from today.

This decision was made for two reasons. First, Arbitrum Nova’s TVL is much lower than Arbitrum One’s TVL, (~$17B vs. ~$46M at the time of writing, from [L2Beat](https://l2beat.com/scaling/summary)). This means that the high bond sizes necessary for preventing spam and delay attacks would make up a significant proportion of Nova’s TVL - which we believe introduces a centralization risk as very few parties would be incentivized to secure Nova. A solution here would be to lower the bond sizes, which brings us to the second reason: lower bond sizes reduce the costs of delay griefing attacks (where malicious actors delay the chain’s progress) and therefore hurt the security of the chain. We believe enabling permissionless validation for Nova is not worth the capital requirement tradeoffs, given the unique security model of AnyTrust chains.

Notably, since Arbitrum Nova's security already depends on at least one DAC member providing honest data availability, trusting the same committee to have at least one member provide honest validation does not add a major trust assumption. This requires all DAC members also to run validators. If the DAC is also validating the chain, a feature the  team has been working on, Fast Withdrawals, would allow users to withdraw assets from Nova in ~15 minutes, or the time it takes to reach parent chain finality. This is made possible by the DAC attesting to and instantly confirming an assertion. Fast Withdrawals will be the subject of future forum post and snapshot vote.

#### Q: When it comes to viewing the upfront assertion bond (to be a proposer) as the security budget for Arbitrum One, is it possible for an attacker to go above the security budget and, if yes, what happens then?[​](#q-when-it-comes-to-viewing-the-upfront-assertion-bond-to-be-a-proposer-as-the-security-budget-for-arbitrum-one-is-it-possible-for-an-attacker-to-go-above-the-security-budget-and-if-yes-what-happens-then "Direct link to Q: When it comes to viewing the upfront assertion bond (to be a proposer) as the security budget for Arbitrum One, is it possible for an attacker to go above the security budget and, if yes, what happens then?")

The upfront capital to post assertions (onchain action) is 3600 ETH, with subsequent sub-challenge assertions requiring 555/79 ETH (per level) - this applies to honest proposers as well as malicious entities. A malicious entity can post multiple invalid top level assertions and/or open multiple challenges and the honest entity can

It is critical to note that Arbitrum state transitions are entirely deterministic. An honest party bonded to the correct state assertion, the honest party will get all their costs refunded while a malicious entity stands to lose everything. Additionally, BoLD’s design ensures that any party bonded to the correct

If a malicious entity wanted to attack Arbitrum, they would need to deposit 3600 ETH to propose an invalid state assertion.

Node Running Info

*   Anyone can run an Arbitrum node (today and post-BoLD)
*   The default mode is `watchtower`, which chills out and watches the chain in action. It will alert you if it sees something wrong on chain but no action is taken. It requires **no** funds and **doesn't** take any onchain action.
*   Other "modes" that nodes can run are: `stakeLatest`, `resolveNodes`, `makeNodes`, and `defensive`. All of these modes **require** funds and **will** take onchain action.
    *   Nodes running in this mode are considered validators because they validate what they see and take onchain action.
*   Running a `watchtower` node is **not** a validator.
*   Proposers are a special role, they strictly run in `makeNodes` mode. This means a proposer is someone running an Arbitrum node in `makeNodes` mode, also making them a validator.
*   For more information about see [Running a Node](/run-arbitrum-node/overview) and [Validation strategies](/run-arbitrum-node/more-types/run-validator-node#validation-strategies).

#### Q: How do BoLD-based L3s challenge periods operate, considering the worst-case scenario?[​](#q-how-do-bold-based-l3s-challenge-periods-operate-considering-the-worst-case-scenario "Direct link to Q: How do BoLD-based L3s challenge periods operate, considering the worst-case scenario?")

To recap, both Arbitrum’s current dispute protocol and BoLD require assertions to be posted to the parent chain and employ interactive proving, which involves a back-and-forth between two entities until a single step of disagreement is reached. That single step (of disagreement) is then submitted to contracts on the parent chain. Those contracts are used to declare a winner. For L2s, like Arbitrum One, BoLD must be deployed on a credibly-neutral, censorship-resistant backend to ensure disputes are fairly resolved. Ethereum, therefore, is the perfect candidate for deployment of the BoLD protocol for L2s.

But you might now be wondering: what about L3 Orbit chains that don’t settle to Ethereum? Unlike L2s that settle to Ethereum, assertions on an L3’s state need to be posted to an L2 either via (A) the L3  or (B) the  queue managed by the L2 sequencer on L2. In the event that the parent chain (in this case, L2) is being repeatedly censored or if the L2 sequencer is offline, every block level assertion and/or sub-challenge assertion would need to wait 24 hours before they can bypass the sequencer (using the the`SequencerInbox`’s `forceInclusion` method described [here](https://docs.arbitrum.io/how-arbitrum-works/sequencer#unhappyuncommon-case-sequencer-isnt-doing-its-job)). If this were to happen, challenge resolution would be delayed by a time _t_ where _t_ = (24 hours) \* number of moves for a challenge. To illustrate with sample numbers, if a challenge takes 50 sequential moves to resolve, then the delay would be 50 days!

To mitigate the risk of this issue manifesting for Arbitrum chains, Offchain Labs has included a feature called _Delay Buffer_ as part of BoLD’s 1.0.0 release. The _Delay Buffer_ feature aims to limit the negative effects of: prolonged parent chain censorship, prolonged sequencer censorship, and/or unexpected sequencer outages. This is accomplished by implementing some time threshold that is decremented when unexpected delays occur. Once that time threshold is met, the force inclusion window is lowered - effectively enabling entities to make moves without the 24 hour delay-per-move.

Under reasonable parameterization, the sequencer could be offline / censoring for 24 hours twice, before the force inclusion window is effectively dropped from 24 hours to a minimum inclusion time. The force inclusion window gradually (over weeks) replenishes to it's original value over time as long as the sequencer is on "good behavior" - regularly sequencing messages without unexpected delays. We believe that the Delay Buffer feature provides stronger guarantees of censorship resistance for Arbitrum chains.

The methodology for calculating the parameters, specifically for L3 Orbit chains, will be made available at a later date for teams who wish to use BoLD.

#### Q: What is the user flow for using the assertion bonding pool contract?[​](#q-what-is-the-user-flow-for-using-the-assertion-bonding-pool-contract "Direct link to Q: What is the user flow for using the assertion bonding pool contract?")

warning

The autopooling feature is not available on  as of yet.

Anyone can deploy an assertion bonding pool using [`AssertionStakingPoolCreator.sol`](https://github.com/OffchainLabs/BoLD/blob/main/contracts/src/assertionStakingPool/AssertionStakingPoolCreator.sol) as a means to crowdsource funds to put up a bond for an assertion. To defend Arbitrum using a bonding pool, an entity would first deploy this pool with the assertion they believe is correct and wish to put up a bond to challenge an adversary's assertion. Then, anyone can verify that the claimed assertion is correct by running the inputs through their node's State Transition Function (STF). If other parties agree that the assertion is correct, then they can deposit their funds into the contract. When enough funds have been deposited, anyone can permissionlessly trigger the creation of the assertion on-chain to start the challenge. Finally, once the honest parties' assertion is confirmed by the dispute protocol, all involved entities can get their funds reimbursed and can withdraw. The Arbitrum Nitro node validation software also comes with an optional feature called "auto pooling," where the entire workflow of assertion bonding pool deployment and depositing funds into the said pool are automated. If "auto pooling" is activated & the private key controlling the validator has funds, a pool will be trustlessly deployed alongside an assertion with the available funds. If a validator with the "auto pooling" feature enabled sees an assertion on-chain that it agrees with _and_ a bonding pool already exists for that assertion, then the validator will automatically deposit funds into the bonding pool to "join" the others who are backing that on-chain assertion in a trustless manner.

#### Q: What type of hardware will be necessary to run a BoLD validator?[​](#q-what-type-of-hardware-will-be-necessary-to-run-a-bold-validator "Direct link to Q: What type of hardware will be necessary to run a BoLD validator?")

The minimum hardware requirements for running a BoLD validator is still being researched and finalized. The goal, however, is that regular consumer hardware (i.e., laptop) can effectively be used by an honest party to secure an Arbitrum chain using BoLD in the average case.

#### Q: How do BoLD validators communicate with one another? Is it over a P2P network?[​](#q-how-do-bold-validators-communicate-with-one-another-is-it-over-a-p2p-network "Direct link to Q: How do BoLD validators communicate with one another? Is it over a P2P network?")

BoLD validators for Arbitrum chains communicate directly with smart contracts on L1 Ethereum. This means that opening challenges, submitting bisected history commitments, one-step proofs, and confirmations are all refereed on Ethereum. There is no P2P between validators.

#### Q: For an L3 Orbit chain, secured using BoLD, that settles to Arbitrum One, does the one-step proof happen on the parent chain?[​](#q-for-an-l3-orbit-chain-secured-using-bold-that-settles-to-arbitrum-one-does-the-one-step-proof-happen-on-the-parent-chain "Direct link to Q: For an L3 Orbit chain, secured using BoLD, that settles to Arbitrum One, does the one-step proof happen on the parent chain?")

Yes; it happens on Arbitrum One.

#### Q: For Arbitrum One, does implementing BoLD reduce the scope or remove the need for the Arbitrum Security Council?[​](#q-for-arbitrum-one-does-implementing-bold-reduce-the-scope-or-remove-the-need-for-the-arbitrum-security-council "Direct link to Q: For Arbitrum One, does implementing BoLD reduce the scope or remove the need for the Arbitrum Security Council?")

BoLD can limit the scope of Arbitrum One and Nova’s reliance on the Security Council as it takes Arbitrum chains one-step closer to full decentralization.

---

# Public preview: What to expect | Arbitrum Docs

## Public preview: What to expect

BoLD, Arbitrum's new dispute protocol, is currently tagged as an `alpha` release supported by _public preview_ documentation. This concept document explains what "public preview" means, what to expect from public preview capabilities, and how to engage with our team as you tinker.

### How products are developed at Offchain Labs[​](#how-products-are-developed-at-offchain-labs "Direct link to How products are developed at Offchain Labs")

Offchain Labs builds products in a way that aligns loosely with the spirit of "building in public". We like to release things **early and often** so that we can capture feedback and iterate in service of your needs, as empirically as possible.

To do this, some of our product offerings are documented with **public preview** disclaimers that look like this:

This banner's purpose is to set expectations while inviting readers like you to express your needs so that we can incorporate them into the way that we iterate on product.

### What to expect when using public preview offerings[​](#what-to-expect-when-using-public-preview-offerings "Direct link to What to expect when using public preview offerings")

As you tinker and provide feedback, we'll be listening. Sometimes, we'll learn something non-obvious that will result in a significant change. More commonly, you'll experience incremental improvements to the developer experience as the offering grows out of its **public preview** status, towards **stable** status.

Public preview offerings are evolving rapidly, so don't expect the degree of release notes discipline that you'd expect from a stable offering. Keep your eyes open for notifications regarding patch, minor, and major changes, along with corresponding relnotes that highlight breaking changes and new capabilities.

### How to provide feedback[​](#how-to-provide-feedback "Direct link to How to provide feedback")

Our product team primarily uses three feedback channels while iterating on public preview capabilities:

1.  **Docs**: Click on the `Request an update` button located in the top-right corner of any document to provide feedback on the docs and/or developer experience. This will lead you to a prefilled Github issue that members of our product team periodically review.
2.  **Discord**: [Join the Arbitrum Discord](https://discord.gg/arbitrum) to engage with members of the Arbitrum community and product team.
3.  **Google form**: Complete [this form](http://bit.ly/3yy6EUK) to ask for support.

### What to expect when providing feedback[​](#what-to-expect-when-providing-feedback "Direct link to What to expect when providing feedback")

Our ability to respond to feedback is determined by our ever-evolving capacity and priorities. We can't guarantee responses to all feedback submissions, but our small-but-mighty team is listening, and we'll try our best to acknowledge and respond to your feedback. No guarantees though!

_PS, [our small-but-mighty team is hiring](https://jobs.lever.co/offchainlabs)._

### Thank you![​](#thank-you "Direct link to Thank you!")

Thanks for helping us build things that meet your needs! We're excited to engage with OGs and newcomers alike; please don't hesitate to reach out.

---

# Data Availability | Arbitrum Docs

## How Arbitrum data availability works

What is the general view of Arbitrum data flow?[​](#what-is-the-general-view-of-arbitrum-data-flow "Direct link to What is the general view of Arbitrum data flow?")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Arbitrum currently supports two primary data availability mechanisms:

**Rollup Mode:** In this mode, all transaction data is included in either the calldata of transactions submitted to the parent chain (e.g., Ethereum mainnet for Arbitrum One) or the blobs submitted by the transaction. This inclusion ensures that all data is readily available on-chain for anyone to download and verify.

**Anytrust Mode:** In Anytrust mode, transaction data initially gets submitted to a group of nodes known as the Data Availability Committee (DAC). The DAC stores and distributes the data. Instead of including the entire dataset on-chain, only a cryptographic proof that the data has been stored by the DAC (called a Data Availability Certificate, or DACert) is submitted to the parent chain. This proof significantly reduces the amount of data stored on-chain, reducing costs.

Because of those data availability mechanisms, Arbitrum Nitro nodes synchronize their data differently than Ethereum nodes or other layer-one network nodes. While Go-Ethereum nodes utilize a sophisticated P2P network to synchronize with the Ethereum blockchain by discovering other nodes, exchanging data, and participating in the consensus mechanism, Arbitrum nodes diverge from this traditional approach and use a trustless process.

Here's how Arbitrum data flow works:

1.  Batching and submission:
    1.  The sequencer queues transactions and batches them together.
    2.  These batches get submitted to the parent chain:
        1.  In Rollup mode, the sequencer submits the batch of transactions directly to the sequencer inbox contract on the parent chain. (Blob or calldata directly)
        2.  In Anytrust mode, the sequencer sends the batch to the Data Availability Committee (DAC) and then submits the Data Availability Certificate (DACert) which is returned and generated by the DAS to the parent chain.
2.  Node synchronization:
    1.  Upon joining the network, a full node:
        1.  In Rollup mode, data is read directly from the parent chain calldata or blobs (depending on how the sequencer posts the data).
        2.  In Anytrust mode, it checks the DACert to verify data availability and queries the data from the DAC.
    2.  The node continues to follow this process to catch up with the latest chain height.
    3.  Once caught up, the node receives updates on new sequencer-queued messages directly from the sequencer feed (we will provide details of this process in the last section).
3.  Catching up:
    1.  If a node falls behind the chain, it reverts to the process described in step 2 to resynchronize with the latest state.

In essence, Arbitrum nodes prioritize data retrieval from the parent chain and rely on the sequencer for real-time updates, deviating from the traditional P2P synchronization approach used by Ethereum nodes.

How full nodes decode the data from the parent chain[​](#how-full-nodes-decode-the-data-from-the-parent-chain "Direct link to How full nodes decode the data from the parent chain")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Arbitrum full nodes decode data received from the parent chain (and, in the case of AnyTrust chains, the DAC) to update their local state. This process involves monitoring events, parsing data, and processing messages.

1.  Event querying:
    
    1.  Full nodes subscribe to the `SequencerBatchDelivered` event emitted by the inbox contract on the parent chain. This event signifies the arrival of a new batch of transactions.
2.  Event parsing:
    
    1.  Upon receiving the `SequencerBatchDelivered` event, the node parses the event data into a `SequencerInboxBatch` struct. This struct typically includes:
        1.  `BlockHash`: The hash of the parent chain block containing the batch.
        2.  `ParentChainBlockNumber`: The block number of the parent chain block.
        3.  `SequenceNumber`: The sequence number of the batch.
        4.  `TimeBounds`: Time constraints for the batch.
        5.  `AfterDelayedAcc`: Accumulator hash after processing delayed messages.
        6.  `AfterDelayedCount`: Count of delayed messages.
        7.  `rawLog`: The raw event log data.
3.  Data serialization:
    
    1.  The `SequencerInboxBatch` struct serializes into a byte array.
    2.  The serialized data adheres to a specific format:
        1.  `TimeBounds.MinTimestamp` (8 bytes)
        2.  `TimeBounds.MaxTimestamp` (8 bytes)
        3.  `TimeBounds.MinBlockNumber` (8 bytes)
        4.  `TimeBounds.MaxBlockNumber` (8 bytes)
        5.  `AfterDelayedCount` (8 bytes)
        6.  `payload` (variable length)
            1.  The `payload` field further contains the following:
                1.  **Type:** Indicates the header of payload (e.g., DACert, blob message).
                2.  **Content:** The actual data associated with the payload header (e.g., DACert, BlobHashes, brotli compressed data).
4.  Data decoding and retrieval:
    
    1.  Based on the `payload` header:
        1.  **DAS Message header:** The node queries the Data Availability Servers (DAS) to retrieve the raw data.
        2.  **Blob message header:** The node decodes the blob message to obtain the raw data.
        3.  **Brotli Message header:** No extra steps are needed here; continue to the next step.
    2.  Data decompression: If the raw data is Brotli-compressed, the node decompresses it. It's worth noting that the raw data we get from above i and ii might also be Brotli-compressed data.
5.  Message processing:
    
    1.  After decoding and decompressing the data, the node obtains a series of batch segment messages.
        
        1.  Message Types:
            
            Batch Segment Message type
            
            What is the usage of this message
            
            BatchSegmentKindL2Message
            
            This message will contain raw data on a series of transactions. Usually, this is a single block.
            
            BatchSegmentKindL2MessageBrotli
            
            The message is the same as the above one, but this is brotli compressed data.
            
            BatchSegmentKindDelayedMessages
            
            This message contains a new delayed message read from the parent chain delayed inbox.
            
            BatchSegmentKindAdvanceTimestamp
            
            This message will notify the State Transition Function (STF) to advance a second of the timestamp state.
            
            BatchSegmentKindAdvanceL1BlockNumber
            
            This message will notify STF to advance a new parent chain block number.
            
    2.  State transition: finally, the State Transition Function (STF) processes these messages, and the STF will follow the rules to execute and update the Arbitrum node's local state.
        

How full nodes sync the data from the sequencer feed[​](#how-full-nodes-sync-the-data-from-the-sequencer-feed "Direct link to How full nodes sync the data from the sequencer feed")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Once Arbitrum full nodes have caught up with the chain, they switch from initial synchronization to a real-time update mode. This switch involves receiving data from the sequencer feed, which continuously broadcasts updates about newly queued transactions.

1.  Data acquisition:
    
    1.  Full nodes maintain a connection to the sequencer feed or your private feed. For how to run a private feed, please refer to [**How to run a feed relay**](https://docs.arbitrum.io/run-arbitrum-node/sequencer/run-feed-relay)
    2.  The sequencer feed transmits data packets containing information about the latest queued transactions.
2.  Data decoding:
    
    1.  Full nodes decode the received data packets using the methods described in [How to read the sequencer feed](https://docs.arbitrum.io/run-arbitrum-node/sequencer/read-sequencer-feed).
3.  Message processing:
    
    1.  After successful decoding, the full nodes obtain the same type of data as outlined in the previous section's Step 5.
    2.  Send the message to the State Transition Function (STF) and execute.
    
    (This step is the same as the previous section's Step 5)

---

# Gas and Fees | Arbitrum Docs

## Gas and Fees

Gas is used by  to track the cost of execution on a Nitro chain. It works the same as Ethereum gas, in the sense that every EVM instruction costs the same amount of gas that it would on Ethereum.

There are two parties a user pays when submitting a tx:

*   the poster, if reimbursable, for the parent chain resources such as the parent chain calldata needed to post the tx
*   the network fee account for the child chain resources, which include the computation, storage, and other burdens child chain nodes must bear to service the tx

The parent chain component is the product of the 's estimated contribution to its 's size — computed using Brotli on the transaction by itself — and the child chain's view of the parent chain data price, a value which dynamically adjusts over time to ensure the batch-poster is ultimately fairly compensated.

The child chain component consists of the traditional fees  would pay to stakers in a vanilla parent chain, such as the computation and storage charges applying the  entails.  charges additional fees for executing its child chain-specific [precompiles](/build-decentralized-apps/precompiles/overview), whose fees are dynamically priced according to the specific resources used while executing the call.

The following sections will detail how to calculate parent and child chain fees. If you do not need precise calculations or a technical understanding, skip to the next section, [Parent chain to child chain messaging](/how-arbitrum-works/l1-to-l2-messaging).

Parent chain gas pricing[​](#parent-chain-gas-pricing "Direct link to Parent chain gas pricing")
------------------------------------------------------------------------------------------------

ArbOS dynamically prices the parent chain gas, with the price adjusting to ensure that the amount collected in the parent chain gas fees is as close as possible to the costs that must be covered, over time.

### Parent chain costs[​](#parent-chain-costs "Direct link to Parent chain costs")

There are two types of parent chain costs: batch posting costs, and rewards.

Batch posting costs reflect the actual cost a batch poster pays to post batch data on the parent chain. Whenever a batch is posted, the parent chain contract that records the batch will send a special "batch posting report" message to child chain ArbOS, reporting who paid for the batch and what the parent chain basefee was at the time. This message is placed in the chain's , so it will be delivered to child chain ArbOS after some delay.

When a batch posting report message arrives to the child chain, ArbOS computes the cost of the referenced batch by multiplying the reported basefee by the batch's data cost. (ArbOS retrieves the batch's data from its inbox state, and computes the parent chain gas that the batch would have used by counting the number of zero bytes and non-zero bytes in the batch.) The resulting cost is recorded by the pricer as funds due to the party who is reported to have submitted the batch.

The second type of parent chain cost is an optional (per chain) per-unit reward for handling transaction calldata. In general the reward might be paid to the , or to members of the Data Availability Committee in an AnyTrust chain, or to anyone else who incurs per-calldata-byte costs on behalf of the chain. The reward is a fixed number of wei per data unit, and is paid to a single address.

The parent chain pricer keeps track of the funds due to the reward address, based on the number of data units handled so far. This amount is updated whenever a batch posting report arrives at the child chain.

### Parent chain calldata fees[​](#parent-chain-calldata-fees "Direct link to Parent chain calldata fees")

The parent chain calldata fees exist because the Sequencer, or the batch poster which posts the Sequencer's transaction batches on Ethereum, incurs costs in the parent chain gas to post transactions on Ethereum as calldata. Funds collected in the parent chain calldata fees are credited to the batch poster to cover its costs.

Every transaction that comes in through the Sequencer will pay a parent chain calldata fee. Transactions that come in through the delayed inbox do not pay this fee because they don't add to batch posting costs--but these transactions pay gas fees to Ethereum when they are put into the delayed inbox.

The parent chain pricing algorithm assigns a parent chain calldata fee to each Sequencer transaction. First, it computes the transaction's size, which is an estimate of how many bytes the transaction will add to the compressed batch it is in; the formula for this includes an estimate of how compressible the transaction is. Second, it multiplies the computed size estimate by the current price per estimated byte, to determine the transaction's parent chain calldata wei, in wei. Finally, it divides this cost by the current child chain basefee to translate the fee into the child chain gas units. The result is reported as the "poster fee" for the transaction.

The price per estimated byte is set by a dynamic algorithm that compares the total parent chain calldata fees collected to the total fees actually paid by batch posters, and tries to bring the two as close to equality as possible. If the batch posters' costs have been less than fee receipts, the price will increase, and if batch poster costs have exceeded fee receipts, the price will decrease.

### Parent chain fee collection[​](#parent-chain-fee-collection "Direct link to Parent chain fee collection")

A transaction is charged for the parent chain gas if and only if it arrived as part of a sequencer batch. This means that someone would have paid for the parent chain gas to post the transaction on the parent chain chain.

The estimated cost of posting a transaction on the parent chain is the product of the transaction's estimated size, and the current parent chain Gas Basefee. This estimated cost is divided by the current child chain gas basefee to obtain the amount of child chain gas that corresponds to the parent chain operation (more information about this can be found in [this article](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9)).

The estimated size is measured in the parent chain gas and is calculated as follows: first, compress the transaction's data using the brotli-zero algorithm, then multiply the size of the result by 16. (16 is because the parent chain charges 16 gas per byte. The parent chain charges less for bytes that are zero, but that doesn't make sense here.) Brotli-zero is used in order to reward users for posting transactions that are compressible. Ideally we would like to reward for posting transactions that contribute to the compressibility (using the brotli compressor) of the entire batch, but that is a difficult notion to define and in any case would be too expensive to compute at the child chain. Brotli-zero is an approximation that is cheap enough to compute.

Parent chain gas fee funds that are collected from transactions are transferred to a special [`L1PricerFundsPool`](https://github.com/OffchainLabs/nitro/blob/3f4939df1990320310e7f39e8abb32d5c4d8045f/arbos/l1pricing/l1pricing.go#L46) account, so that account's balance represents the amount of funds that have been collected and are available to pay for costs.

The parent chain pricer also records the total number of "data units" (the sum of the estimated sizes, after multiplying by 16) that have been received.

Child chain gas pricing[​](#child-chain-gas-pricing "Direct link to Child chain gas pricing")
---------------------------------------------------------------------------------------------

The child chain gas price on a given  has a set floor, which can be queried via [ArbGasInfo](/build-decentralized-apps/precompiles/reference#arbgasinfo)'s `getMinimumGasPrice` method (currently 0.01 gwei on  and 0.01 gwei on Nova).

### Estimating child chain gas[​](#estimating-child-chain-gas "Direct link to Estimating child chain gas")

Calling an Arbitrum Node's `eth_estimateGas` RPC gives a value sufficient to cover the full transaction fee at the given child chain gas price; i.e., the value returned from `eth_estimateGas` multiplied by the child chain gas price tells you how much total Ether is required for the transaction to succeed. Note that this means that for a given operation, the value returned by `eth_estimateGas` will change over time (as the parent chain calldata price fluctuates.) (See [2-D fees](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9) and [How to estimate gas in Arbitrum](/build-decentralized-apps/how-to-estimate-gas) for more.)

### Child chain gas fees[​](#child-chain-gas-fees "Direct link to Child chain gas fees")

Child chain gas fees work very similarly to gas on Ethereum. A transaction uses some amount of gas, and this is multiplied by the current basefee to get the child chain gas fee charged to the transaction.

The child chain basefee is set by a version of the "exponential mechanism" which has been widely discussed in the Ethereum community, and which has been shown equivalent to Ethereum's EIP-1559 gas pricing mechanism.

The algorithm compares gas usage against a parameter called the [speed limit](#the-speed-limit) which is the target amount of gas per second that the chain can handle sustainably over time. (Currently the  on Arbitrum One is 7,000,000 gas per second.) The algorithm tracks a gas backlog. Whenever a transaction consumes gas, that gas is added to the backlog. Whenever the clock ticks one second, the speed limit is subtracted from the backlog; but the backlog can never go below zero.

Intuitively, if the backlog grows, the algorithm should increase the gas price, to slow gas usage, because usage is above the sustainable level. If the backlog shrinks, the price should decrease again because usage has been below the below the sustainable limit so more gas usage can be welcomed.

To make this more precise, the basefee is an exponential function of the backlog, _F = exp(-a(B-b))_, where a and b are suitably chosen constants: _a_ controls how rapidly the price escalates with backlog, and _b_ allows a small backlog before the basefee escalation begins.

### Child chain Tips[​](#child-chain-tips "Direct link to Child chain Tips")

The sequencer prioritizes transactions on a first-come first-served basis. Because tips do not make sense in this model, they are ignored. Arbitrum users always just pay the basefee regardless of the tip they choose.

### Gas estimating retryables[​](#gas-estimating-retryables "Direct link to Gas estimating retryables")

When a transaction schedules another, the subsequent transaction's execution [will be included](https://github.com/OffchainLabs/go-ethereum/blob/d52739e6d54f2ea06146fdc44947af3488b89082/internal/ethapi/api.go#L999) when estimating gas via the node's RPC. A transaction's gas estimate, then, can only be found if all the transactions succeed at a given gas limit. This is especially important when working with retryables and scheduling redeem attempts.

Because a call to [`redeem`](/build-decentralized-apps/precompiles/reference#arbretryabletx) donates all of the call's gas, doing multiple requires limiting the amount of gas provided to each subcall. Otherwise the first will take all of the gas and force the second to necessarily fail irrespective of the estimation's gas limit.

Gas estimation for Retryable submissions is possible via the [NodeInterface](/build-decentralized-apps/nodeinterface/reference) and similarly requires the auto-redeem attempt to succeed.

### The Speed Limit[​](#the-speed-limit "Direct link to The Speed Limit")

The security of Nitro chains depends on the assumption that when one  creates an assertion, other validators will check it, and respond with a correct assertion and a  if it is wrong. This requires that the other validators have the time and resources to check each assertion quickly enough to issue a timely challenge. The Arbitrum protocol takes this into account in setting deadlines for assertions.

This sets an effective speed limit on execution of a Nitro chain: in the long run the chain cannot make progress faster than a validator can emulate its execution. If assertions are published at a rate faster than the speed limit, their deadlines will get farther and farther in the future. Due to the limit, enforced by the Rollup protocol contracts, on how far in the future a deadline can be, this will eventually cause new assertions to be slowed down, thereby enforcing the effective speed limit.

Being able to set the speed limit accurately depends on being able to estimate the time required to validate an assertion, with some accuracy. Any uncertainty in estimating validation time will force us to set the speed limit lower, to be safe. And we do not want to set the speed limit lower, so we try to enable accurate estimation.

Total fee and gas estimation[​](#total-fee-and-gas-estimation "Direct link to Total fee and gas estimation")
------------------------------------------------------------------------------------------------------------

The total fee charged to a transaction is the child chain basefee, multiplied by the sum of the child chain gas used plus the parent chain calldata charge. As on Ethereum, a transaction will fail if it fails to supply enough gas, or if it specifies a basefee limit that is below the current basefee. Ethereum also allows a "tip" but Nitro ignores this field and never collects any tips.

### Allocating funds and paying what is owed[​](#allocating-funds-and-paying-what-is-owed "Direct link to Allocating funds and paying what is owed")

When a batch posting report is processed at the child chain, the pricer allocates some of the collected funds to pay for costs incurred. To allocate funds, the pricer considers three timestamps:

*   `currentTime` is the current time, when the batch posting report message arrives at the child chain
*   `updateTime` is the time at which the reported batch was submitted (which will typically be around 20 minutes before currentTime)
*   `lastUpdateTime` is the time at which the previous reported batch was submitted

The pricer computes an allocation fraction `F = (updateTime-lastUpdateTime) / (currentTime-lastUpdateTime)` and allocates a fraction `F` of funds in the `L1PricerFundsPool` to the current report. The intuition is that the pricer knows how many funds have been collected between `lastUpdateTime` and `currentTime`, and we want to figure out how many of those funds to allocate to the interval between `lastUpdateTime` and `updateTime`. The given formula is the correct allocation, if we assume that funds arrived at a uniform rate during the interval between `lastUpdateTime` and `currentTime`. The pricer similarly allocates a portion of the total data units to the current report.

Now the pricer pays out the allocated funds to cover the rewards due and the amounts due to batch posters, reducing the balance due to each party as a result. If the allocated funds aren't sufficient to cover everything that is due, some amount due will remain. If all of the amount due can be covered with the allocated funds, any remaining allocated funds are returned to the `L1PricerFundsPool`.

### Getting parent chain fee info[​](#getting-parent-chain-fee-info "Direct link to Getting parent chain fee info")

The parent chain gas basefee can be queried via [`ArbGasInfo.getL1BaseFeeEstimate`](/build-decentralized-apps/precompiles/reference#arbgasinfo). To estimate the parent chain fee a transaction will use, the [NodeInterface.gasEstimateComponents()](/build-decentralized-apps/nodeinterface/reference) or [NodeInterface.gasEstimateL1Component()](/build-decentralized-apps/nodeinterface/reference) method can be used.

Arbitrum transaction receipts include a `gasUsedForL1` field, showing the amount of gas used on the parent chain in units of the child chain gas.

### Adjusting the parent chain gas basefee[​](#adjusting-the-parent-chain-gas-basefee "Direct link to Adjusting the parent chain gas basefee")

After allocating funds and paying what is owed, the parent chain Pricer adjusts the parent chain Gas Basefee. The goal of this process is to find a value that will cause the amount collected to equal the amount owed over time.

The algorithm first computes the surplus (funds in the `L1PricerFundsPool`, minus total funds due), which might be negative. If the surplus is positive, the parent chain Gas Basefee is reduced, so that the amount collected over a fixed future interval will be reduced by exactly the surplus. If the surplus is negative, the Basefee is increased so that the shortfall will be eliminated over the same fixed future interval.

A second term is added to the parent chain Gas Basefee, based on the derivative of the surplus (surplus at present, minus the surplus after the previous batch posting report was processed). This term, which is multiplied by a smoothing factor to reduce fluctuations, will reduce the Basefee if the surplus is increasing, and increase the Basefee if the surplus is shrinking.

---

# Geth at the core | Arbitrum Docs

## Geth at the core

The second key design idea in Nitro is " at the core." Here "geth" refers to go-ethereum, the most common node software for Ethereum. As its name would suggest, go-ethereum is written in the Go programming language, as is almost all of Nitro.

![Geth sandwich](/img/haw-geth-sandwich.svg)

The software that makes up a Nitro node can be thought of as built in three main layers, which are shown above:

*   The base layer is the core of geth--the parts of Geth that emulate the execution of EVM contracts and maintain the data structures that make up the Ethereum state. Nitro compiles in this code as a library, with a few minor modifications to add necessary hooks.
*   The middle layer, which we call , is custom software that provides additional functions associated with the child chain functionality, such as decompressing and parsing the 's data batches, accounting for parent chain gas costs and collecting fees to reimburse for them, and supporting cross-chain  functionalities such as deposits of Ether and tokens from the parent chain and withdrawals of the same back to the parent chain. We'll dig in to the details of ArbOS below.
*   The top layer consists of node software, mostly drawn from geth. This handles connections and incoming RPC requests from clients and provides the other top-level functionality required to operate an Ethereum-compatible  node.

Because the top and bottom layers rely heavily on code from geth, this structure has been dubbed a "geth sandwich." Strictly speaking, Geth plays the role of the bread in the sandwich, and ArbOS is the filling, but this sandwich is named for the bread.

The  consists of the bottom Geth layer, and a portion of the middle ArbOS layer. In particular, the STF is a designated function in the source code, and implicitly includes all of the code called by that function. The STF takes as input the bytes of a  received in the inbox, and has access to a modifiable copy of the Ethereum state tree. Executing the STF may modify the state, and at the end will emit the header of a new block (in Ethereum's block header format) which will be appended to the Nitro chain.

The rest of this section will be a deep dive into Geth and ArbOS. If deep technical knowledge does not suit you, skip to the next section [Separating Execution from Proving](/how-arbitrum-works/separating-execution-from-proving).

Geth[​](#geth "Direct link to Geth")
------------------------------------

Nitro makes minimal modifications to Geth in hopes of not violating its assumptions. This section will explore the relationship between Geth and ArbOS, which consists of a series of hooks, interface implementations, and strategic re-appropriations of Geth's basic types.

We store ArbOS's state at an address inside a Geth `statedb`. In doing so, ArbOS inherits the `statedb`'s statefulness and lifetime properties. For example, a transaction's direct state changes to ArbOS are discarded upon a revert.

**0xA4B05FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF**  
The fictional account representing ArbOS

info

Please note any links on this page may be referencing old releases of Nitro or our fork of Geth. While we try to keep this up to date and most of this should be stable, please check against latest releases for [Nitro](https://github.com/OffchainLabs/nitro/releases) and [Geth](https://github.com/OffchainLabs/go-ethereum/releases) for most recent changes.

### Hooks[​](#hooks "Direct link to Hooks")

 uses various hooks to modify Geth's behavior when processing transactions. Each provides an opportunity for ArbOS to update its state and make decisions about the transaction during its lifetime. Transactions are applied using Geth's [`ApplyTransaction`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/state_processor.go#L152) function.

Below is [`ApplyTransaction`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/state_processor.go#L152)'s callgraph, with additional info on where the various Arbitrum-specific hooks are inserted. Click on any to go to their section. By default, these hooks do nothing so as to leave Geth's default behavior unchanged, but for chains configured with [`EnableArbOS`](#enablearbos) set to true, [`ReadyEVMForL2`](#ReadyEVMForL2) installs the alternative child chain hooks.

*   `core.ApplyTransaction` ⮕ `core.applyTransaction` ⮕ `core.ApplyMessage`
    *   `core.NewStateTransition`
        *   [`ReadyEVMForL2`](#ReadyEVMForL2)
    *   `core.TransitionDb`
        *   [`StartTxHook`](#StartTxHook)
        *   `core.transitionDbImpl`
            *   if `IsArbitrum()` remove tip
            *   [`GasChargingHook`](/how-arbitrum-works/geth-at-the-core#gascharginghook)
            *   `evm.Call`
                *   `core.vm.EVMInterpreter.Run`
                    *   [`PushCaller`](#PushCaller)
                    *   `PopCaller`
            *   `core.StateTransition.refundGas`
                *   [`ForceRefundGas`](#ForceRefundGas)
                *   [`NonrefundableGas`](#NonrefundableGas)
        *   [`EndTxHook`](#EndTxHook)
    *   added return parameter: `transactionResult`

What follows is an overview of each hook, in chronological order.

#### [`ReadyEVMForL2`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbstate/geth-hook.go#L47)[​](#ReadyEVMForL2 "Direct link to ReadyEVMForL2")

A call to [`ReadyEVMForL2`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbstate/geth-hook.go#L47) installs the other transaction-specific hooks into each Geth [`EVM`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/vm/evm.go#L101) right before it performs a state transition. Without this call, the state transition will instead use the default [`DefaultTxProcessor`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/vm/evm_arbitrum.go#L42) and get exactly the same results as vanilla Geth. A [`TxProcessor`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L38) object is what carries these hooks and the associated Arbitrum-specific state during the transaction's lifetime.

#### [`StartTxHook`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L100)[​](#StartTxHook "Direct link to StartTxHook")

The [`StartTxHook`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L100) is called by Geth before a transaction starts executing. This allows ArbOS to handle two Arbitrum-specific transaction types.

If the transaction is `ArbitrumDepositTx`, ArbOS adds balance to the destination account. This is safe because the parent chain bridge submits such a transaction only after collecting the same amount of funds on the parent chain.

If the transaction is an `ArbitrumSubmitRetryableTx`, ArbOS creates a retryable based on the transaction's fields. If the transaction includes sufficient gas, ArbOS schedules a retry of the new retryable.

The hook returns `true` for both of these transaction types, signifying that the state transition is complete.

#### [`GasChargingHook`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L354)[​](#gascharginghook "Direct link to gascharginghook")

This fallible hook ensures the user has enough funds to pay their poster's parent chain calldata costs. If not, the transaction is reverted and the [`EVM`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/vm/evm.go#L101) does not start. In the common case that the user can pay, the amount paid for calldata is set aside for later reimbursement of the poster. All other fees go to the network account, as they represent the transaction's burden on validators and nodes more generally.

If the user attempts to purchase compute gas in excess of ArbOS's per-block gas limit, the difference is [set aside](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L407) and [refunded later](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/state_transition.go#L419) via [`ForceRefundGas`](#ForceRefundGas) so that only the gas limit is used. Note that the limit observed may not be the same as that seen [at the start of the block](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/block_processor.go#L176) if ArbOS's larger gas pool falls below the [`MaxPerBlockGasLimit`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/l2pricing/l2pricing.go#L86) while processing the block's previous transactions.

#### [`PushCaller`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L76)[​](#PushCaller "Direct link to PushCaller")

These hooks track the callers within the EVM callstack, pushing and popping as calls are made and complete. This provides [`ArbSys`](/build-decentralized-apps/precompiles/reference#arbsys) with info about the callstack, which it uses to implement the methods `WasMyCallersAddressAliased` and `MyCallersAddressWithoutAliasing`.

#### [`L1BlockHash`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L617)[​](#l1blockhash "Direct link to l1blockhash")

In Arbitrum, the BlockHash and Number operations return data that relies on the underlying parent chain blocks instead of child chain blocks, to accommodate the normal use-case of these opcodes, which often assume Ethereum-like time passes between different blocks. The L1BlockHash and L1BlockNumber hooks have the required data for these operations.

#### [`ForceRefundGas`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L425)[​](#ForceRefundGas "Direct link to ForceRefundGas")

This hook allows ArbOS to add additional refunds to the user's tx. This is currently only used to refund any compute gas purchased in excess of ArbOS's per-block gas limit during the [`GasChargingHook`](/how-arbitrum-works/geth-at-the-core#gascharginghook).

#### [`NonrefundableGas`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L418)[​](#NonrefundableGas "Direct link to NonrefundableGas")

Because poster costs come at the expense of the parent chain aggregators and not the network more broadly, the amounts paid for the parent chain calldata should not be refunded. This hook provides Geth access to the equivalent amount of child chain gas the poster's cost equals, ensuring this amount is not reimbursed for network-incentivized behaviors like freeing storage slots.

#### [`EndTxHook`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L429)[​](#EndTxHook "Direct link to EndTxHook")

The [`EndTxHook`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L429) is called after the [`EVM`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/vm/evm.go#L101) has returned a transaction's result, allowing one last opportunity for ArbOS to intervene before the state transition is finalized. Final gas amounts are known at this point, enabling ArbOS to credit the network and poster each's share of the user's gas expenditures as well as adjust the pools. The hook returns from the [`TxProcessor`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L38) a final time, in effect discarding its state as the system moves on to the next transaction where the hook's contents will be set afresh.

### Interfaces and components[​](#interfaces-and-components "Direct link to Interfaces and components")

#### [`APIBackend`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/arbitrum/apibackend.go#L34)[​](#apibackend "Direct link to apibackend")

APIBackend implements the [`ethapi.Backend`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/internal/ethapi/backend.go#L42) interface, which allows simple integration of the  to existing Geth API. Most calls are answered using the Backend member.

#### [`Backend`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/arbitrum/backend.go#L15)[​](#backend "Direct link to backend")

This struct was created as an Arbitrum equivalent to the [`Ethereum`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/eth/backend.go#L68) struct. It is mostly glue logic, including a pointer to the ArbInterface interface.

#### [`ArbInterface`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/arbitrum/arbos_interface.go#L10)[​](#arbinterface "Direct link to arbinterface")

This interface is the main interaction-point between geth-standard APIs and the Arbitrum chain. Geth APIs mostly either check status by working on the Blockchain struct retrieved from the [`Blockchain`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/arbitrum/arbos_interface.go#L12) call, or send transactions to Arbitrum using the [`PublishTransactions`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/arbitrum/arbos_interface.go#L11) call.

#### [`RecordingKV`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/arbitrum/recordingdb.go#L22)[​](#recordingkv "Direct link to recordingkv")

RecordingKV is a read-only key-value store, which retrieves values from an internal trie database. All values accessed by a RecordingKV are also recorded internally. This is used to record all preimages accessed during block creation, which will be needed to prove execution of this particular block. A [`RecordingChainContext`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/arbitrum/recordingdb.go#L123) should also be used, to record which block headers the block execution reads (another option would be to always assume the last 256 block headers were accessed). The process is simplified using two functions: [`PrepareRecording`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/arbitrum/recordingdb.go#L152) creates a stateDB and chaincontext objects, running block creation process using these objects records the required preimages, and [`PreimagesFromRecording`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/arbitrum/recordingdb.go#L174) function extracts the preimages recorded.

### Transaction Types[​](#transaction-types "Direct link to Transaction Types")

Nitro Geth includes a few child chain-specific transaction types. Click on any to jump to their section.

Tx Type

Represents

Last Hook Reached  

Source

[`ArbitrumUnsignedTx`](#ArbitrumUnsignedTx)

A parent chain to child chain message

[`EndTxHook`](#EndTxHook)

Bridge

[`ArbitrumContractTx`](#ArbitrumContractTx)

A nonce-less parent chain to child chain message  

[`EndTxHook`](#EndTxHook)

Bridge

[`ArbitrumDepositTx`](#ArbitrumDepositTx)

A user deposit

[`StartTxHook`](#StartTxHook)

Bridge

[`ArbitrumSubmitRetryableTx`](#ArbitrumSubmitRetryableTx)  

Creating a retryable

[`StartTxHook`](#StartTxHook)  

Bridge

[`ArbitrumRetryTx`](#ArbitrumRetryTx)

A  attempt

[`EndTxHook`](#EndTxHook)

Child chain

[`ArbitrumInternalTx`](#ArbitrumInternalTx)

ArbOS state update

[`StartTxHook`](#StartTxHook)

ArbOS

The following reference documents each type.

#### [`ArbitrumUnsignedTx`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/arb_types.go#L43)[​](#ArbitrumUnsignedTx "Direct link to ArbitrumUnsignedTx")

Provides a mechanism for a user on a parent chain to message a contract on a child chain. This uses the bridge for authentication rather than requiring the user's signature. Note, the user's acting address will be remapped on the child chain to distinguish them from a normal child chain caller.

#### [`ArbitrumContractTx`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/arb_types.go#L104)[​](#ArbitrumContractTx "Direct link to ArbitrumContractTx")

These are like an [`ArbitrumUnsignedTx`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/arb_types.go#L43) but are intended for smart contracts. These use the bridge's unique, sequential nonce rather than requiring the caller specify their own. A parent chain contract may still use an [`ArbitrumUnsignedTx`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/arb_types.go#L43), but doing so may necessitate tracking the nonce in the parent chain state.

#### [`ArbitrumDepositTx`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/arb_types.go#L338)[​](#ArbitrumDepositTx "Direct link to ArbitrumDepositTx")

Represents a user deposit from a parent chain to a child chain. This increases the user's balance by the amount deposited on the parent chain.

#### [`ArbitrumSubmitRetryableTx`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/arb_types.go#L232)[​](#ArbitrumSubmitRetryableTx "Direct link to ArbitrumSubmitRetryableTx")

Represents a retryable submission and may schedule an [`ArbitrumRetryTx`](#ArbitrumRetryTx) if provided enough gas. Please see the [retryables documentation](/how-arbitrum-works/l1-to-l2-messaging#retryable-tickets) for more info.

#### [`ArbitrumRetryTx`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/arb_types.go#L161)[​](#ArbitrumRetryTx "Direct link to ArbitrumRetryTx")

These are scheduled by calls to the `redeem` method of the [ArbRetryableTx](/build-decentralized-apps/precompiles/reference#arbretryabletx) precompile and via retryable auto-redemption. Please see the [retryables documentation](/how-arbitrum-works/l1-to-l2-messaging#retryable-tickets) for more info.

#### [`ArbitrumInternalTx`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/internal_tx.go)[​](#ArbitrumInternalTx "Direct link to ArbitrumInternalTx")

Because tracing support requires ArbOS's state-changes happen inside a transaction, ArbOS may create a transaction of this type to update its state in-between user-generated transactions. Such a transaction has a [`Type`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/arb_types.go#L387) field signifying the state it will update, though currently this is just future-proofing as there's only one value it may have. Below are the internal transaction types.

##### [`InternalTxStartBlock`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/internal_tx.go#L22)[​](#internaltxstartblock "Direct link to internaltxstartblock")

Updates the parent chain block number and the parent chain base fee. This transaction [is generated](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/block_processor.go#L181) whenever a new block is created. They are [guaranteed to be the first](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/block_processor.go#L182) in their .

### Transaction Run Modes and Underlying Transactions[​](#transaction-run-modes-and-underlying-transactions "Direct link to Transaction Run Modes and Underlying Transactions")

A [geth message](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/transaction.go#L634) may be processed for various purposes. For example, a message may be used to estimate the gas of a contract call, whereas another may perform the corresponding state transition. Nitro Geth denotes the intent behind a message by means of its [`TxRunMode`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/transaction.go#L701), [which it sets](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/internal/ethapi/api.go#L955) before processing it. ArbOS uses this info to make decisions about the transaction the message ultimately constructs.

A message [derived from a transaction](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/transaction.go#L676) will carry that transaction in a field accessible via its [`UnderlyingTransaction`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/transaction.go#L700) method. While this is related to the way a given message is used, they are not one-to-one. The table below shows the various run modes and whether each could have an underlying transaction.

Run Mode

Scope

Carries an Underlying Tx?

[`MessageCommitMode`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/transaction.go#L654)

state transition  

always

[`MessageGasEstimationMode`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/transaction.go#L655)  

gas estimation

when created via [NodeInterface](/build-decentralized-apps/nodeinterface/reference) or when scheduled

[`MessageEthcallMode`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/transaction.go#L656)

eth\_calls

never

### Arbitrum Chain Parameters[​](#arbitrum-chain-parameters "Direct link to Arbitrum Chain Parameters")

Nitro's Geth may be configured with the following [child chain-specific chain parameters](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/params/config_arbitrum.go#L25). These allow the rollup creator to customize their rollup at genesis.

#### `EnableArbos`[​](#enablearbos "Direct link to enablearbos")

Introduces [ArbOS](/how-arbitrum-works/geth-at-the-core#arbos), converting what would otherwise be a vanilla parent chain into an child chain Arbitrum rollup.

#### `AllowDebugPrecompiles`[​](#allowdebugprecompiles "Direct link to allowdebugprecompiles")

Allows access to debug precompiles. Not enabled for . When false, calls to debug precompiles will always revert.

#### `DataAvailabilityCommittee`[​](#dataavailabilitycommittee "Direct link to dataavailabilitycommittee")

Currently does nothing besides indicate that the rollup will access a data availability service for preimage resolution in the future. This is not enabled for Arbitrum One, which is a strict state-function of its parent chain inbox messages.

### Miscellaneous Geth Changes[​](#miscellaneous-geth-changes "Direct link to Miscellaneous Geth Changes")

#### ABI Gas Margin[​](#abi-gas-margin "Direct link to ABI Gas Margin")

Vanilla Geth's abi library submits txes with the exact estimate the node returns, employing no padding. This means a transaction may revert should another arriving just before even slightly change the transaction's codepath. To account for this, we've added a `GasMargin` field to `bind.TransactOpts` that [pads estimates](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/accounts/abi/bind/base.go#L355) by the number of basis points set.

#### Conservation of child chain ETH[​](#conservation-of-child-chain-eth "Direct link to Conservation of child chain ETH")

The total amount of the child chain ether in the system should not change except in controlled cases, such as when bridging. As a safety precaution, ArbOS checks Geth's [balance delta](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/state/statedb.go#L42) each time a block is created, [alerting or panicking](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/block_processor.go#L424) should conservation be violated.

#### MixDigest and ExtraData[​](#mixdigest-and-extradata "Direct link to MixDigest and ExtraData")

To aid with [](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/system_tests/outbox_test.go#L26) proof construction, the root hash and leaf count of ArbOS's [send merkle accumulator](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/merkleAccumulator/merkleAccumulator.go#L13) are stored in the `MixDigest` and `ExtraData` fields of each child chain block. The yellow paper specifies that the `ExtraData` field may be no larger than 32 bytes, so we use the first 8 bytes of the `MixDigest`, which has no meaning in a system without miners/stakers, to store the send count.

#### Retryable Support[​](#retryable-support "Direct link to Retryable Support")

Retryables are mostly implemented in [ArbOS](/how-arbitrum-works/l1-to-l2-messaging). Some modifications were required in Geth to support them.

*   Added ScheduledTxes field to ExecutionResult. This lists transactions scheduled during the execution. To enable using this field, we also pass the ExecutionResult to callers of ApplyTransaction.
*   Added gasEstimation param to DoCall. When enabled, DoCall will also also executing any retryable activated by the original call. This allows estimating gas to enable retryables.

#### Added accessors[​](#added-accessors "Direct link to Added accessors")

Added [`UnderlyingTransaction`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/state_transition.go#L69) to Message interface Added [`GetCurrentTxLogs`](https://github.com/OffchainLabs/go-ethereum/tree/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/state/statedb_arbitrum.go) to StateDB We created the AdvancedPrecompile interface, which executes and charges gas with the same function call. This is used by [Arbitrum's precompiles](/build-decentralized-apps/precompiles/overview), and also wraps Geth's standard precompiles.

#### WASM build support[​](#wasm-build-support "Direct link to WASM build support")

The  Arbitrum executable does not support file operations. We created [`fileutil.go`](https://github.com/OffchainLabs/go-ethereum/tree/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/rawdb/fileutil.go) to wrap fileutil calls, stubbing them out when building WASM. [`fake_leveldb.go`](https://github.com/OffchainLabs/go-ethereum/tree/7503143fd13f73e46a966ea2c42a058af96f7fcf/ethdb/leveldb/fake_leveldb.go) is a similar WASM-mock for leveldb. These are not required for the WASM block-replayer.

#### Types[​](#types "Direct link to Types")

Arbitrum introduces a new [`signer`](https://github.com/OffchainLabs/go-ethereum/tree/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/arbitrum_signer.go), and multiple new [`transaction types`](https://github.com/OffchainLabs/go-ethereum/tree/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/types/transaction.go).

#### ReorgToOldBlock[​](#reorgtooldblock "Direct link to ReorgToOldBlock")

Geth natively only allows reorgs to a fork of the currently-known network. In nitro, reorgs can sometimes be detected before computing the forked block. We added the [`ReorgToOldBlock`](https://github.com/OffchainLabs/go-ethereum/tree/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/blockchain_arbitrum.go#L38) function to support reorging to a block that's an ancestor of current head.

#### Genesis block creation[​](#genesis-block-creation "Direct link to Genesis block creation")

Genesis block in nitro is not necessarily block #0. Nitro supports importing blocks that take place before genesis. We split out [`WriteHeadBlock`](https://github.com/OffchainLabs/go-ethereum/blob/7503143fd13f73e46a966ea2c42a058af96f7fcf/core/genesis.go#L415) from genesis.Commit and use it to commit non-zero genesis blocks.

ArbOS[​](#arbos "Direct link to ArbOS")
---------------------------------------

ArbOS is the child chain EVM hypervisor that facilitates the execution environment of the child chain Arbitrum. ArbOS is a trusted "system glue" component that runs at the child chain as part of the State Transition Function, it accounts for and manages network resources, produces blocks from incoming messages, cross-chain messaging, and operates its instrumented instance of Geth for  execution.

In Arbitrum, much of the work that would otherwise have to be done expensively at the parent chain is instead done by ArbOS, trustlessly performing these functions at the speed and low cost of the child chain.

Supporting these functions in the child chain trusted software, rather than building them in to the parent chain-enforced rules of the architecture as Ethereum does, offers significant advantages in cost because these operations can benefit from the lower cost of computation and storage at the child chain, instead of having to manage those resources as part of a parent chain contract. Having a trusted operating system at the child chain also has significant advantages in flexibility, because the child chain code is easier to evolve, or to customize for a particular chain, than a parent chain enforced architecture would be.

### Precompiles[​](#precompiles "Direct link to Precompiles")

ArbOS provides child chain (L2)-specific precompiles with methods smart contracts can call the same way they can solidity functions. Visit the [precompiles conceptual page](/build-decentralized-apps/precompiles/overview) for more information about how these work, and the [precompiles reference page](/build-decentralized-apps/precompiles/reference) for a full reference of the precompiles available in Arbitrum chains.

A precompile consists of a solidity interface in [`contracts/src/precompiles/`](https://github.com/OffchainLabs/nitro-contracts/tree/main/src/precompiles) and a corresponding Golang implementation in [`precompiles/`](https://github.com/OffchainLabs/nitro/tree/master/precompiles). Using Geth's ABI generator, [`solgen/gen.go`](https://github.com/OffchainLabs/nitro/blob/master/solgen/gen.go) generates [`solgen/go/precompilesgen/precompilesgen.go`](https://github.com/OffchainLabs/nitro/blob/f11ba39cf91ee1fe1b5f6b67e8386e5efd147667/solgen/gen.go#L55), which collects the ABI data of the precompiles. The [runtime installer](https://github.com/OffchainLabs/nitro/blob/bc6b52daf7232af2ca2fec3f54a5b546f1196c45/precompiles/precompile.go#L379) uses this generated file to check the type safety of each precompile's implementer.

[The installer](https://github.com/OffchainLabs/nitro/blob/bc6b52daf7232af2ca2fec3f54a5b546f1196c45/precompiles/precompile.go#L379) uses runtime reflection to ensure each implementer has all the right methods and signatures. This includes restricting access to stateful objects like the EVM and statedb based on the declared purity. Additionally, the installer verifies and populates event function pointers to provide each precompile the ability to emit logs and know their gas costs. Additional configuration like restricting a precompile's methods to only be callable by chain owners is possible by adding precompile wrappers like [`ownerOnly`](https://github.com/OffchainLabs/nitro/blob/f11ba39cf91ee1fe1b5f6b67e8386e5efd147667/precompiles/wrapper.go#L58) and [`debugOnly`](https://github.com/OffchainLabs/nitro/blob/f11ba39cf91ee1fe1b5f6b67e8386e5efd147667/precompiles/wrapper.go#L23) to their [installation entry](https://github.com/OffchainLabs/nitro/blob/bc6b52daf7232af2ca2fec3f54a5b546f1196c45/precompiles/precompile.go#L403).

The calling, dispatching, and recording of precompile methods are done via runtime reflection as well. This avoids any human error manually parsing and writing bytes could introduce, and uses Geth's stable APIs for [packing and unpacking](https://github.com/OffchainLabs/nitro/blob/bc6b52daf7232af2ca2fec3f54a5b546f1196c45/precompiles/precompile.go#L438) values.

Each time a transaction calls a method of a child chain-specific precompile, a [`call context`](https://github.com/OffchainLabs/nitro/blob/f11ba39cf91ee1fe1b5f6b67e8386e5efd147667/precompiles/context.go#L26) is created to track and record the gas burnt. For convenience, it also provides access to the public fields of the underlying [`TxProcessor`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L38). Because sub-transactions could revert without updates to this struct, the [`TxProcessor`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L38) only makes public that which is safe, such as the amount of parent chain calldata paid by the top level transaction.

### Messages[​](#messages "Direct link to Messages")

An [`L1IncomingMessage`](https://github.com/OffchainLabs/nitro/blob/4ac7e9268e9885a025e0060c9ec30f9612f9e651/arbos/incomingmessage.go#L54) represents an incoming sequencer message. A message includes one or more user transactions depending on load, and is made into a [unique child chain block](https://github.com/OffchainLabs/nitro/blob/4ac7e9268e9885a025e0060c9ec30f9612f9e651/arbos/block_processor.go#L118). The child chain block may include additional system transactions added while processing the message's user transactions, but ultimately the relationship is still bijective: for every [`L1IncomingMessage`](https://github.com/OffchainLabs/nitro/blob/4ac7e9268e9885a025e0060c9ec30f9612f9e651/arbos/incomingmessage.go#L54) there is a child chain block with a unique child chain block hash, and for every child chain block after chain initialization there was an [`L1IncomingMessage`](https://github.com/OffchainLabs/nitro/blob/4ac7e9268e9885a025e0060c9ec30f9612f9e651/arbos/incomingmessage.go#L54) that made it. A sequencer  may contain more than one [`L1IncomingMessage`](https://github.com/OffchainLabs/nitro/blob/4ac7e9268e9885a025e0060c9ec30f9612f9e651/arbos/incomingmessage.go#L54).

### Retryables[​](#retryables "Direct link to Retryables")

A Retryable is a special message type for creating atomic parent chain to child chain messages; for details, see [L1 To L2 Messaging](/how-arbitrum-works/l1-to-l2-messaging).

### ArbOS State[​](#arbos-state "Direct link to ArbOS State")

ArbOS's state is viewed and modified via [`ArbosState`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/arbosState/arbosstate.go#L36) objects, which provide convenient abstractions for working with the underlying data of its [`backingStorage`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/storage/storage.go#L51). The backing storage's [keyed subspace strategy](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/storage/storage.go#L21) makes possible [`ArbosState`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/arbosState/arbosstate.go#L36)'s convenient getters and setters, minimizing the need to directly work with the specific keys and values of the underlying storage's [`stateDB`](https://github.com/OffchainLabs/go-ethereum/blob/0ba62aab54fd7d6f1570a235f4e3a877db9b2bd0/core/state/statedb.go#L66).

Because two [`ArbosState`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/arbosState/arbosstate.go#L36) objects with the same [`backingStorage`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/storage/storage.go#L51) contain and mutate the same underlying state, different [`ArbosState`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/arbosState/arbosstate.go#L36) objects can provide different views of ArbOS's contents. [`Burner`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/burn/burn.go#L11) objects, which track gas usage while working with the [`ArbosState`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/arbosState/arbosstate.go#L36), provide the internal mechanism for doing so. Some are read-only, causing transactions to revert with `vm.ErrWriteProtection` upon a mutating request. Others demand the caller have elevated privileges. While yet others dynamically charge users when doing stateful work. For safety the kind of view is chosen when [`OpenArbosState()`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/arbosState/arbosstate.go#L57) creates the object and may never change.

Much of ArbOS's state exists to facilitate its [precompiles](/build-decentralized-apps/precompiles/reference). The parts that aren't are detailed below.

#### [`arbosVersion`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/arbosState/arbosstate.go#L37), [`upgradeVersion`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/arbosState/arbosstate.go#L38) and [`upgradeTimestamp`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/arbosState/arbosstate.go#L39)[​](#arbosversion-upgradeversion-and-upgradetimestamp "Direct link to arbosversion-upgradeversion-and-upgradetimestamp")

ArbOS upgrades are scheduled to happen [when finalizing the first block](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L350) after the [`upgradeTimestamp`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/arbosState/arbosstate.go#L39).

#### [`blockhashes`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/blockhash/blockhash.go#L15)[​](#blockhashes "Direct link to blockhashes")

This component maintains the last 256 parent chain block hashes in a circular buffer. This allows the [`TxProcessor`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/tx_processor.go#L38) to implement the `BLOCKHASH` and `NUMBER` opcodes as well as support precompile methods that involve the outbox. To avoid changing ArbOS state outside of a transaction, blocks made from messages with a new parent chain block number update this info during an [`InternalTxUpdateL1BlockNumber`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/internal_tx.go#L24) [`ArbitrumInternalTx`](https://github.com/OffchainLabs/nitro/blob/8e786ec6d1ac3862be85e0c9b5ac79cbd883791c/arbos/internal_tx.go) that is included as the first transaction in the block.

#### [`l1PricingState`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/l1pricing/l1pricing.go#L16)[​](#l1pricingstate "Direct link to l1pricingstate")

In addition to supporting the [`ArbAggregator precompile`](/build-decentralized-apps/precompiles/reference#arbaggregator), the parent chain pricing state provides tools for determining the parent chain component of a transaction's gas costs. This part of the state tracks both the total amount of funds collected from transactions in parent chain gas fees, as well as the funds spent by batch posters to post data batches on the parent chain.

Based on this information, ArbOS maintains a parent chain data fee, also tracked as part of this state, which determines how much transactions will be charged for parent chain fees. ArbOS dynamically adjusts this value so that fees collected are approximately equal to batch posting costs, over time.

#### [`l2PricingState`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/l2pricing/l2pricing.go#L14)[​](#l2pricingstate "Direct link to l2pricingstate")

The child chain pricing state tracks child chain resource usage to determine a reasonable child chain gas price. This process considers a variety of factors, including user demand, the state of Geth, and the computational . The primary mechanism for doing so consists of a pair of pools, one larger than the other, that drain as child chain-specific resources are consumed and filled as time passes. Parent chain-specific resources like the parent chain `calldata` are not tracked by the pools, as they have little bearing on the actual work done by the network actors that the speed limit is meant to keep stable and synced.

While much of this state is accessible through the [`ArbGasInfo`](/build-decentralized-apps/precompiles/reference#arbgasinfo) and [`ArbOwner`](/build-decentralized-apps/precompiles/reference#arbowner) precompiles, most changes are automatic and happen during [block production](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L77) and [the transaction hooks](#hooks). Each of an incoming message's transactions removes from the pool the parent chain component of the gas it uses, and afterward the message's timestamp [informs the pricing mechanism](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L336) of the time that's passed as ArbOS [finalizes the block](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L350).

ArbOS's larger gas pool [determines](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/l2pricing/pools.go#L98) the per-block gas limit, setting a dynamic [upper limit](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L146) on the amount of compute gas a child chain block may have. This limit is always enforced, though for the [first transaction](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L237) it's done in the [GasChargingHook](/how-arbitrum-works/geth-at-the-core#gascharginghook) to avoid sharp decreases in the parent chain gas price from over-inflating the compute component purchased to above the gas limit. This improves UX by allowing the first transaction to succeed rather than requiring a resubmission. Because the first transaction lowers the amount of space left in the block, subsequent transactions do not employ this strategy and may fail from such compute-component inflation. This is acceptable because such transactions are only present in cases where the system is under heavy load and the result is that the user's transaction is dropped without charges since the state transition fails early. Those trusting the sequencer can rely on the transaction being automatically resubmitted in such a scenario.

The reason we need a per-block gas limit is that Arbitrator WAVM execution is much slower than native transaction execution. This means that there can only be so much gas -- which roughly translates to wall-clock time -- in a child chain block. It also provides an opportunity for ArbOS to limit the size of blocks should demand continue to surge even as the price rises.

ArbOS's per-block gas limit is distinct from Geth's block limit, which ArbOS [sets sufficiently high](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L166) so as to never run out. This is safe since Geth's block limit exists to constrain the amount of work done per block, which ArbOS already does via its own per-block gas limit. Though it'll never run out, a block's transactions use the [same Geth gas pool](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L199) to maintain the invariant that the pool decreases monotonically after each tx. Block headers [use the Geth block limit](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L67) for internal consistency and to ensure gas estimation works. These are both distinct from the [`gasLeft`](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L146) variable, which ephemerally exists outside of global state to both keep child chain blocks from exceeding ArbOS's per-block gas limit and to [deduct space](https://github.com/OffchainLabs/nitro/blob/faf55a1da8afcabb1f3c406b291e721bfde71a05/arbos/block_processor.go#L272) in situations where the state transition failed or [used negligible amounts](https://github.com/OffchainLabs/nitro/blob/faf55a1da8afcabb1f3c406b291e721bfde71a05/arbos/block_processor.go#L328) of compute gas. ArbOS does not need to persist [`gasLeft`](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L146) because it is its _pool_ that induces a revert and because transactions use the Geth block limit during EVM execution.

---

# Challenges: Interactive Fraud Proofs | Arbitrum Docs

## Challenges: Interactive Fraud Proofs

This document attempts to give an account of BoLD, Arbitrum's new all-vs-all challenge protocol, in terms that might be familiar to people used to studying Arbitrum's previous, 1-vs-1 challenge protocol. For another explanation of BoLD's concepts, refer to [Gentle Introduction](/how-arbitrum-works/bold/gentle-introduction), [Technical deep dive](/bold/concepts/bold-technical-deep-dive), or the BoLD [Research whitepaper](https://arxiv.org/abs/2404.10491).

Suppose the Rollup chain looks like this:

![Interactive fraud proof](/img/haw-interactive-fraud-proof.svg)

Assertions 93 and 95 are siblings (they both have 92 as predecessor). Alice is bonded on 93 and Bob is bonded on 95.

At this point we know that Alice and Bob disagree about the correctness of assertion 93, with Alice committed to 93 being correct and Bob committed to 93 being incorrect. (Bob is bonded on 95, and 95 implicitly claims that 92 is the last correct assertion before it, which implies that 93 must be incorrect.)

Whenever two (or more) proposers are bonded on sibling assertions, a challenge begins between all of them. (There can only be one bonder per assertion, but multiple assertions may participate in a challenge.) The Rollup protocol will record and referee the challenge, eventually declaring a winner and confiscating the losers' bonds. This will cause the losers to be removed as proposers.

The challenge is a game in which two or more parties make moves in an attempt to defend the correctness of assertions they (or their allies) have staked on, with an Ethereum contract as the referee. The goal of the system is to determine which assertion corresponds to the correct execution.

The game will operate in two phases: Bisection, followed by one-step proof. Bisection will narrow down the size of the dispute until it is a dispute about just one instruction of execution. Then the one-step proof will determine who is right about that one instruction.

We’ll describe the bisection part of the protocol twice. First, we’ll give a simplified version which is easier to understand. Then we’ll describe some ways in which the real version differs from the simplified one. For an even more thorough explanation, please see the [BoLD research whitepaper](https://arxiv.org/abs/2404.10491).

Bisection Protocol: Simplified Version[​](#bisection-protocol-simplified-version "Direct link to Bisection Protocol: Simplified Version")
-----------------------------------------------------------------------------------------------------------------------------------------

Alice (or one of her allies - for the sake of brevity we'll refer to this party as Alice) is defending the claim that starting with the state in the predecessor assertion, the state of the Virtual Machine can advance to the state specified in assertion A. Once a challenge starts, Alice has to provide a commitment to the entire history of the computation: that is, to the state after each step of execution.

Alice’s first move requires her to bisect her claims about intermediate states between the beginning (0 instructions executed) and the end (`N` instructions executed). So we require Alice to divide her claim in half, and post the state at the half-way point, after `N/2` instructions have been executed.

Now Alice has effectively bisected her `N`\-step  into two (`N/2`)-step assertions. Bob (or one of his allies; for brevity, Bob) needs to do the same for his assertion, also deriving two new (`N/2`)-step assertions. At most one of these will be a "rival" of one of Alice's assertions. Two assertions are "rivals" if they agree on a prefix of the state history to which they commit but disagree on the rest; this is very similar to the concept of "siblings" for assertions. Whichever of the two of Alice's assertions now has a rival, Alice will proceed to defend it.

At this point we’re effectively back in the original situation: Alice having made an assertion that Bob disagrees with. But we have cut the size of the assertion in half, from `N` to `N/2`. We can apply the same method again, with Alice bisecting and Bob choosing one of the halves, to reduce the size to `N/4`. And we can continue bisecting, so that after a logarithmic number of rounds Alice and Bob will be disagreeing about a single step of execution. That’s where the bisection phase of the protocol ends, and Alice must make a one-step proof which will be checked by the EthBridge.

Why Bisection Correctly Identifies a Cheater[​](#why-bisection-correctly-identifies-a-cheater "Direct link to Why Bisection Correctly Identifies a Cheater")
------------------------------------------------------------------------------------------------------------------------------------------------------------

Before talking about the complexities of the real , let’s stop to understand why the simplified version of the protocol is correct. Here correctness means two things: (1) if Alice’s initial claim is correct, Alice (or her ally) can always win the challenge, and (2) if Alice’s initial claim is incorrect, and there is at least one honest validator participating in the protocol, Alice and her allies never win the challenge.

To prove (1), observe that if Alice’s initial claim is correct, she can offer a truthful midpoint claim, and both of the implied half-size claims will be correct. So whichever half Bob objects to, Alice will again be in the position of defending a correct claim. At each stage of the protocol, Alice will be defending a correct claim. At the end, Alice will have a correct one-step claim to prove, so that claim will be provable and Alice can win the challenge.

To prove (2), observe that if Alice’s initial claim is incorrect, this can only be because her claimed endpoint after `N` steps is incorrect. Now when Alice offers her midpoint state claim, that midpoint claim is either correct or incorrect. If it’s incorrect, then Bob can force Alice to defend her first-half claim, which will be incorrect. If Alice’s midpoint state claim is correct, then her second-half claim must be incorrect, and Bob can force her to defend that. So whatever Alice does, Bob will be able to challenge an incorrect half-size claim. At each stage of the protocol, Bob can identify an incorrect claim to challenge. At the end, Alice will have an incorrect one-step claim to prove, which she will be unable to do, so Bob can win the challenge.

note

If you’re a stickler for mathematical precision, we invite you to read the [BoLD research whitepaper](https://arxiv.org/abs/2404.10491). Formalizing these and other arguments pertaining to BoLD is quite tricky and subtle!

The real bisection protocol[​](#the-real-bisection-protocol "Direct link to The real bisection protocol")
---------------------------------------------------------------------------------------------------------

The real bisection protocol is conceptually similar to the simplified one described above, but with several changes that improve efficiency or deal with necessary corner cases. Here is a list of the differences.

\*\*Bisection over L2 blocks, then over "big steps" of many instructions, then over single instructions: \*\*Alice's assertion is over an assertion, which asserts the result of creating some number of Layer 2 Nitro blocks. Bisection first occurs over these Layer 2 blocks, to narrow the dispute down to a dispute about a single Layer 2 Nitro block. Next, the dispute transforms into a dispute about executing a "big step" of 2^26 instructions (this intermediate level is needed to reduce the workload on the validator). At this point, the dispute transforms into a dispute about a single execution of the  or in other words about the execution of a sequence of WAVM instructions. The protocol then executes the recursive bisection sub-protocol again, this time over WAVM instructions, to narrow the dispute to a single instruction. For details about how these "subchallenges" work, see [BoLD: Technical deep dive](/bold/concepts/bold-technical-deep-dive) **Time Limits:** The protocol can be seen as tracking a timer for each assertion, counting (essentially) how much time has passed while that assertion could be seen as the presumptive winner of the game (that is, the amount of time during which the onus is on parties opposing the assertion to act.) Think of the time allowance as being about a week. Once an assertion's timer reaches this time allowance, it can be confirmed. The time allowance is designed to give the honest parties in the protocol enough time to act, including the time needed to calculate, submit, and process moves, as well as to account for possible censorship on L1.

It should be clear that these changes don’t affect the basic correctness of the challenge protocol. They do, however, improve its efficiency and enable it to handle all of the cases that can come up in practice.

Efficiency[​](#efficiency "Direct link to Efficiency")
------------------------------------------------------

The challenge protocol is designed to resolve the dispute with a minimum of work required by the protocol (via its parent chain contracts) in its role as referee. The protocol needs to track information for the assertions created by parties in the challenge, including their history commitments and timers that can be used to calculate how long they have gone without a rival. The protocol doesn’t need to pay attention to whether those claims are correct in any way; it only needs to know whether Alice’s move “has the right shape”. For more information on what the protocol needs to keep track of, see [BoLD: Technical deep dive](/bold/concepts/bold-technical-deep-dive)

The only point where the protocol needs to evaluate a move “on the merits” is at the one-step proof, where it needs to look at Alice’s proof and determine whether the proof that was provided does indeed establish that the virtual machine moves from the before state to the claimed after state after one step of computation.

ChallengeManager[​](#challengemanager "Direct link to ChallengeManager")
------------------------------------------------------------------------

This section is a technical deep dive into the `ChallengeManager` and will walk through the arbitration of a challenge game in great detail. The `ChallengeManager` plays the role of the arbiter of challenge games. Here's a diagram of the challenge state machine:

![Challenge manager](/img/haw-challenge-manager.svg)

### Block challenge[​](#block-challenge "Direct link to Block challenge")

The challenge begins by bisecting over global states (including block hashes). Before actual machine execution is disputed, the dispute is narrowed down to an individual block. Once the challenge has been bisected down to an individual block, `challengeExecution` can be called by the current responder. This operates similarly to a bisection in that the responder must provide a competing global state and machine state, but it uses that information to transition to the execution challenge phase.

### "Big-Step" execution challenge[​](#big-step-execution-challenge "Direct link to \"Big-Step\" execution challenge")

Once narrowed down to an individual block, the actual machine execution can be bisected. We begin by bisecting the machine execution until we reach a "chunk" of 2^26 `WASM` instructions. Once the disagreement has reached this granularity, we can proceed with a "small-step" execution challenge ([see below](#small-step-execution-challenge)). For more detail on why we use two levels of execution challenges ("big step" and "small-step"), see "[Challenge Resolution](/bold/concepts/bold-technical-deep-dive#challenge-resolution)" in the BoLD technical deep dive.

### "Small-Step" Execution challenge[​](#small-step-execution-challenge "Direct link to \"Small-Step\" Execution challenge")

After reaching a "chunk" of 2^26 instructions, we begin a new challenge level, bisecting this chunk until we reach a dispute over a single instruction. Once the execution has been bisected down to an individual step, `oneStepProveExecution` can be called by any player to resolve the one-step dispute. That player must provide proof data to execute a step of the machine. This proof is checked on L1. If it is correct, the one-step edge to which the one-step proof is applied and considered confirmed.

### Winning the challenge[​](#winning-the-challenge "Direct link to Winning the challenge")

Note that for the time being, winning the challenge isn't instant.

This is done as a precaution, so that if a challenge is resolved incorrectly, there is time to diagnose and fix the error with a contract upgrade.

One Step Proof Assumptions[​](#one-step-proof-assumptions "Direct link to One Step Proof Assumptions")
------------------------------------------------------------------------------------------------------

The  (OSP) implementation makes certain assumptions about the cases that can arise in a correct execution. This documents those assumptions about what's being executed.

If a case is "unreachable", that is, the case is assumed to never arise in correct execution, then the OSP can implement any instruction semantics in that case.

*   In a challenge between malicious assertions, that start from an unreachable machine state, any case can arise. The challenge protocol must do something safe in every case. But the instruction semantics can be weird in such cases because no honest party ever needs to try to refute an assertion that starts from an unreachable state. All assertions engaging in a dispute starting from an unreachable state must be malicious, and the protocol doesn't need to care which one wins. In particular, it is OK for the onchain one-step proof contract to differ in its behavior from the node software's execution engine in this case (and _only_ in this case).
*   In a challenge with one honest party, the honest party will never need to one-step prove an unreachable case. The honest party will only assert correct executions, so it will only have to prove reachable cases.
*   In a challenge with an honest party, a dishonest party could assert an execution that transitions into an unreachable case, but such an execution must include an invalid execution of a reachable case earlier in the assertion. Because a challenge involving an honest party will eventually require an OSP over the first instruction where the parties disagree, the eventual OSP will be over the earlier point of divergence, and not over the later execution from an unreachable case.

In general, some unreachable cases will be detectable by the OSP checker and some will not. For safety, the detectable unreachable cases should be defined by transition the machine into an error state, allowing governance to eventually push an upgrade to recover from the error. An undetectable unreachable case, if such a case were reached in correct execution, could lead to a security failure.

The following assumptions, together, must prevent an unreachable case from arising in correct execution.

### The WAVM code is generated by Arbitrator from valid WASM[​](#the-wavm-code-is-generated-by-arbitrator-from-valid-wasm "Direct link to The WAVM code is generated by Arbitrator from valid WASM")

WAVM is the name of the custom instruction set similar to  used for proving. Arbitrator transpiles WASM code into WAVM. It also invokes wasm-validate from [wabt](https://github.com/WebAssembly/wabt) (the WebAssembly Binary Toolkit) to ensure the input WASM is valid. WAVM produced otherwise may not be executable, as it may try to close a non-existent block, mismatch types, or do any other number of invalid things which are prevented by WASM validation.

WAVM code generated from by Arbitrator from valid WASM is assumed to never encounter an unreachable case.

### Inbox messages must not be too large[​](#inbox-messages-must-not-be-too-large "Direct link to Inbox messages must not be too large")

The current method of inbox hashing requires the full inbox message be available for proving. That message must not be too large as to prevent it from being supplied for proving, which is enforced by the inboxes.

The current length limit is 117,964 bytes, which is 90% of the [max transaction size Geth will accept](https://github.com/ethereum/go-ethereum/blob/356bbe343a30789e77bb38f25983c8f2f2bfbb47/core/tx_pool.go#L53), leaving 13,108 bytes for other proving data.

### Requested preimages must be known and not too large[​](#requested-preimages-must-be-known-and-not-too-large "Direct link to Requested preimages must be known and not too large")

WAVM has an opcode which resolves the preimage of a Keccak-256 hash. This can only be executed if the preimage is already known to all nodes, and can only be proven if the preimage isn't too long. Violations of this assumption are undetectable by the OSP checker.

The current length limit is 117,964 bytes for the reasons mentioned above. Here's a list of which preimages may be requested by Nitro, and why they're known to all parties, and not too large:

#### Block headers[​](#block-headers "Direct link to Block headers")

Nitro may request up to the last 256  headers. The last block header is required to determine the current state, and blocks before it are required to implement the `BLOCKHASH` EVM instruction.

This is safe as previous block headers are a fixed size, and are known to all nodes.

#### State trie access[​](#state-trie-access "Direct link to State trie access")

To resolve state, Nitro traverses the state trie by resolving preimages.

This is safe as validators retain archive state of unconfirmed blocks, each trie branch is of a fixed size, and the only variable sized entry in the trie is contract code, which is limited by EIP-170 to about 24KB.

WASM to WAVM[​](#wasm-to-wavm "Direct link to WASM to WAVM")
------------------------------------------------------------

Not all WASM instructions are 1:1 with WAVM opcodes. This document lists those which are not, and explains how they're expressed in WAVM. Many of the WAVM representations use opcodes not in WASM, which are documented in [`wavm-custom-opcodes`](#wavm-custom-opcodes-not-in-wasm).

### `block` and `loop`[​](#block-and-loop "Direct link to block-and-loop")

In WASM, a block contains instructions. Branch instructions exit a fixed number of blocks, jumping to their destination. A normal `block`'s destination is the end of the block, whereas a `loop`'s destination is the start of the loop.

In WAVM, instructions are flat. At transpilation time, any branch instructions are replaced with jumps to the corresponding block's destination. This means that WAVM interpreters don't need to track blocks, and thus block instructions are unnecessary.

### `if` and `else`[​](#if-and-else "Direct link to if-and-else")

These are translated to a block with an `ArbitraryJumpIf` as follows:

```rust
begin block with endpoint end
  conditional jump to else
  [instructions inside if statement]
  branch
  else: [instructions inside else statement]
end
```

### `br` and `br_if`[​](#br-and-br_if "Direct link to br-and-br_if")

`br` and `br_if` are translated into `ArbitraryJump` and `ArbitraryJumpIf` respectively. The jump locations can be known at transpilation time, making blocks obsolete.

### `br_table`[​](#br_table "Direct link to br_table")

`br_table` is translated to a check for each possible branch in the table, and then if none of the checks hit, a branch of the default level.

Each of the non-default branches has a conditional jump to a section afterwards, containing a `drop` for the selector, and then a jump to the target branch.

### `local.tee`[​](#localtee "Direct link to localtee")

`local.tee` is translated to a WAVM `Dup` and then a `LocalSet`.

### `return`[​](#return "Direct link to return")

To translate a return, the number of return values must be known from the function signature. A WAVM `MoveFromStackToInternal` is added for each return value. Then, a loop checks `IsStackBoundary` (which implicitly pops a value) until it's true and the stack boundary has been popped. Next, a `MoveFromInternalToStack` is added for each return value to put the return values back on the stack. Finally, a WAVM `Return` is added, returning control flow to the caller.

### Floating point instructions[​](#floating-point-instructions "Direct link to Floating point instructions")

A floating point library module must be present to translate floating point instructions. They are translated by bitcasting `f32` and `f64` arguments to `i32`s and `i64`s, then a cross module call to the floating point library, and finally bitcasts of any return values from `i32`s and `i64`s to `f32`s and `f64`s.

WAVM custom opcodes not in WASM[​](#wavm-custom-opcodes-not-in-wasm "Direct link to WAVM custom opcodes not in WASM")
---------------------------------------------------------------------------------------------------------------------

In addition to the MVP WASM specification, WAVM implements the multi value and sign extension ops WASM proposals.

WAVM also implements the following unique opcodes, which are not part of WASM nor any WASM proposal.

### Invariants[​](#invariants "Direct link to Invariants")

Many of these opcodes have implicit invariants about what's on the stack, e.g., "Pops an i32 from the stack" assumes that the top of the stack has an i32. If these conditions are not satisfied, execution is generally not possible. These invariants are maintained by WASM validation and Arbitrator codegen. (See [One Step Proof Assumptions](#one-step-proof-assumptions).)

### Codegen internal[​](#codegen-internal "Direct link to Codegen internal")

These are generated when breaking down a WASM instruction that does many things into many WAVM instructions which each do one thing. For instance, a WASM `local.tee` is implemented in WAVM with `dup` and then `local.set`, the former of which doesn't exist in WASM.

Other times, these opcodes help out an existing WASM opcode by splitting out functionality. For instance, the WAVM `return` opcode by itself does not clean up the stack, but its WASM->WAVM codegen includes a loop that utilizes `IsStackBoundary` to perform the stack cleanup specified for WASM's `return`.

Opcode

Name

Description

0x8000

EndBlock

Pops an item from the block stack.

0x8001

EndBlockIf

Peeks the top value on the stack, assumed an i32. If non-zero, pops an item from the block stack.

0x8002

InitFrame

Pops a caller module index i32, then a caller module internals offset i32, and finally a return InternalRef from the stack. Creates a stack frame with the popped info and the locals merkle root in proving argument data.

0x8003

ArbitraryJumpIf

Pops an i32 from the stack. If non-zero, jumps to the program counter in the argument data.

0x8004

PushStackBoundary

Pushes a stack boundary to the stack.

0x8005

MoveFromStackToInternal

Pops an item from the stack and pushes it to the internal stack.

0x8006

MoveFromInternalToStack

Pops an item from the internal stack and pushes it to the stack.

0x8007

IsStackBoundary

Pops an item from the stack. If a stack boundary, pushes an i32 with value 1. Otherwise, pushes an i32 with value 0.

0x8008

Dup

Peeks an item from the stack and pushes another copy of that item to the stack.

The above opcodes eliminate the need for the following WASM opcodes (which are transpiled into other WAVM opcodes):

*   loop
*   if/else
*   br\_table
*   local.tee

### Linking[​](#linking "Direct link to Linking")

This is only generated to link modules together. Each import is replaced with a local function consisting primarily of this opcode, which handles the actual work needed to change modules.

Opcode

Name

Description

0x8009

CrossModuleCall

Pushes the current program counter, module number, and module's internals offset to the stack. Then splits its argument data into the lower 32 bits being a function index, and the upper 32 bits being a module index, and jumps to the beginning of that function.

### Host calls[​](#host-calls "Direct link to Host calls")

These are only used in the implementation of "host calls". Each of these has an equivalent host call method, which can be invoked from libraries. The exception is `CallerModuleInternalCall`, which is used for the implementation of all of the `wavm_caller_*` host calls. Those calls are documented in `wavm-modules.mdx`.

For these instruction descriptions, all pointers and offsets are represented as WASM i32s.

Opcode

Name

Description

0x800A

CallerModuleInternalCall

Pushes the current program counter, module number, and module's internals offset (all i32s) to the stack. Then, it retrieves the caller module internals offset from the current stack frame. If 0, errors, otherwise, jumps to the caller module at function (internals offset + opcode argument data) and instruction 0.

0x8010

GetGlobalStateBytes32

Pops a pointer and then an index from the stack. If the index is greater than or equal to the number of global state bytes32s, errors. If the pointer mod 32 is not zero, errors. If the pointer + 32 is outside the programs memory, errors. Otherwise, writes the global state bytes32 value of the specified index to the specified pointer in memory.

0x8011

SetGlobalStateBytes32

Pops a pointer and then an index from the stack. If the index is greater than or equal to the number of global state bytes32s, errors. If the pointer mod 32 is not zero, errors. If the pointer + 32 is outside the programs memory, errors. Otherwise, reads a bytes32 from the specified pointer in memory and sets the global state bytes32 value of the specified index to it.

0x8012

GetGlobalStateU64

Pops a pointer and then an index from the stack. If the index is greater than or equal to the number of global state u64s, errors. If the pointer mod 32 is not zero, errors. If the pointer + 8 is outside the programs memory, errors. Otherwise, writes the global state u32 value of the specified index to the specified pointer in memory.

0x8013

SetGlobalStateU64

Pops a pointer and then an index from the stack. If the index is greater than or equal to the number of global state u64s, errors. If the pointer mod 32 is not zero, errors. If the pointer + 8 is outside the programs memory, errors. Otherwise, reads a u64 from the specified pointer in memory and sets the global state u64 value of the specified index to it.

0x8020

ReadPreImage

Pops an offset and then a pointer from the stack. If the pointer mod 32 is not zero, errors. If the pointer + 32 is outside the programs memory, errors. Reads a 32 byte Keccak-256 hash from the specified pointer in memory. Writes up to 32 bytes of the preimage to that hash, beginning with the `offset` byte of the preimage. If `offset` is greater than or equal to the number of bytes in the preimage, writes nothing. Pushes the number of bytes written to the stack as an i32.

0x8021

ReadInboxMessage

Pops an offset, then a pointer, and then an i64 message number from the stack. If the pointer mod 32 is not zero, errors. If the pointer + 32 is outside the programs memory, errors. Attempts to read an inbox message from the inbox identifier contained in the argument data (0 for the  inbox, 1 for the ) at the specified message number. If this exceeds the machine's inbox limit, enters the "too far" state. Otherwise, writes up to 32 bytes of the specified inbox message, beginning with the `offset` byte of the message. If `offset` is greater than or equal to the number of bytes in the preimage, writes nothing. Pushes the number of bytes written to the stack as an i32.

0x8022

HaltAndSetFinished

Sets the machine status to finished, halting execution and marking it as a success.

WAVM Floating point implementation[​](#wavm-floating-point-implementation "Direct link to WAVM Floating point implementation")
------------------------------------------------------------------------------------------------------------------------------

Implementing correct, consistent, and deterministic floating point operations directly in WAVM (meaning both a Rust Arbitrator implementation and Solidity OSP implementation) would be an extremely tricky endeavor. WASM specifies floating point operations as being compliant to IEEE 754-2019, which is not deterministic, and full of edge cases.

Instead, floating point operations (apart from trivial bit-casts like i32 <-> f32) are implemented using the C Berkeley SoftFloat-3e library running inside WAVM. Arbitrator links other WAVM guests against this, by replacing float point operations with cross module calls to the library.

Berkeley SoftFloat does not implement all necessary floating point operations, however. Most importantly, it does not provide a min function, despite IEEE 754-2019 specifying one. The implementation of these operations, along with the export of convenient APIs for WASM opcode implementations, are contained in bindings32.c for 32 bit integers and bindings64.c for 64 bit integers.

This ensures that floating point operations are deterministic and consistent between Arbitrator and the OSP, as they are implemented exclusively using operations already known to be deterministic and consistent. However, it does not ensure that the floating point operations are perfectly compliant to the WASM specification. Go uses floating points in its JS<->Go WASM interface, and floating points may be used outside core state transition code for imprecise computations, but the former is well exercised as used in Nitro, and the latter generally doesn't rely on details like the minimum of NaN and infinity.

### Known divergences from the WASM specification[​](#known-divergences-from-the-wasm-specification "Direct link to Known divergences from the WASM specification")

Floating point to integer truncation will saturate on overflow, instead of erroring. This is generally safer, because on x86, overflowing simply produces an undefined result. A WASM proposal exists to add new opcodes which are defined to saturate, but it's not widely adopted.

WAVM Modules[​](#wavm-modules "Direct link to WAVM Modules")
------------------------------------------------------------

WASM natively has a notion of modules. Normally, in WASM, a module is the entire program. A `.wasm` file represents one module, and generally they aren't combined. An exception to this is C compiled via Clang, where wasm files are also used as object files, but [its linking scheme](https://github.com/WebAssembly/tool-conventions/blob/main/Linking.mdx) is not supported in other languages.

In WAVM this is extended to make the executing program composed of multiple modules. These may call each other, and library modules may write to their caller's memory to return results.

### The entrypoint module[​](#the-entrypoint-module "Direct link to The entrypoint module")

The entrypoint module is where execution begins. It calls modules' `start` functions if specified, and then calls the main module's main function, which is language specific. For Go it sets argv to `["js"]` to match the JS environment, and calls `run`. For Rust it calls `main` with no arguments.

### Library exports[​](#library-exports "Direct link to Library exports")

Libraries may export functions with the name pattern `module__name`, which future libraries or the main module can import as `"module" "name"`.

For instance, this is used for wasi-stub to provide functions Rust imports according to the WebAssembly System Interface.

### Floating point operations[​](#floating-point-operations "Direct link to Floating point operations")

To provide floating point operations for future libraries, the soft float library exports functions which perform floating point ops. These have the same name as the WASM instruction names, except `.` is replaced with `_`. Their type signature is also the same, except all `f32`s and `f64`s are bitcasted to `i32`s and `i64`s.

Future modules can implicitly use these by using WASM floating point operations, which are replaced at the WASM->WAVM level with bitcasts and cross module calls to these functions.

### WAVM guest calls[​](#wavm-guest-calls "Direct link to WAVM guest calls")

Libraries may call the main module's exports via `"env" "wavm_guest_call__*"`.

For instance, go-stub calls Go's resume function when queueing async events via `wavm_guest_call_resume()`, and then retrieves the new stack pointer with `wavm_guest_call_getsp()`.

### Caller module internals call[​](#caller-module-internals-call "Direct link to Caller module internals call")

Every stack frame retains its caller module and its caller module's "internals offset", which is the first internal function index. WAVM appends 4 "internal" functions to each module, which perform a memory load or store of 1 or 4 bytes.

Via `wavm_caller_{load,store}{8,32}`, a library may access its caller's memory, which is implemented by calling these internal functions of the caller's module. Only libraries can access their caller's memory; the main module cannot.

For instance, this is used to read arguments from and write return values to the Go stack, when Go calls into go-stub.

---

# Bridging from a parent chain to a child chain | Arbitrum Docs

## Bridging from a parent chain to a child chain

In the [Bypassing the Sequencer](/how-arbitrum-works/transaction-lifecycle#bypassing-the-sequencer) section, we introduced an alternative way for users to submit transactions to a  by going through the 's  contract instead of sending them directly to the . This approach is one example of a parent-to-child messaging path. More broadly, parent-to-child chain messaging covers all ways to:

*   Submit child chain bound  from a parent chain
*   Deposit `ETH` or native tokens from a parent chain to a child chain
*   Send arbitrary data or instructions from a parent chain to a child chain

We generally categorize these parent-to-child chain messaging methods as follows:

1.  **Native token bridging**: Refers to depositing a child chain's native token from the parent chain to the child chain. Depending on the type of  chain, this can include:

*   **ETH Bridging**: For Arbitrum chains that use `ETH` as their gas token, users can deposit `ETH` onto a child chain via the delayed inbox.
*   **Custom gas token bridging**: For Arbitrum chains that use a custom gas token, users can deposit that chain's native token to a child chain using the same mechanism.

2.  **Transaction via the delayed inbox**: As described in the [Bypassing the Sequencer](/how-arbitrum-works/transaction-lifecycle#bypassing-the-sequencer) section, this method allows users to send transactions through the parent chain. It includes two sub-types of messages:

*   **Unsigned messages**: General arbitrary data or function calls
*   **Signed messages**: Messages that include a signature, enabling certain authenticated actions

3.  **Retryable tickets** are Arbitrum's canonical mechanism for creating parent-to-child messages–transactions initiated on a parent chain that trigger execution on a child chain. This method contains the following functionality:

*   **General retryable messaging**: For sending arbitrary data or calls from a parent-to-child chain.
*   **Customized feature messaging** (e.g., token bridging): Leveraging retryable tickets (and other messaging constructs) for specialized actions, such as bridging tokens from a parent-to-child chain.

This section will explore these categories in detail and explain how they work. The diagram below illustrates the various paths available for parent-to-child chain communication and asset transfers.

![Parent to child messaging](/img/haw-l1-to-l2.svg)

Native token bridging[​](#native-token-bridging "Direct link to Native token bridging")
---------------------------------------------------------------------------------------

Arbitrum chains can use `ETH` or any other `ERC-20` tokens as their gas fee currency.  and Nova use `ETH` as their native token, while some Orbit chains opt for a custom gas token. For more details about chains that use custom gas tokens, refer to the [Custom gas token SDK](/launch-orbit-chain/concepts/custom-gas-token-sdk).

Whether a chain uses `ETH` or a custom gas token, users can deposit the token from a parent chain (for Arbitrum One, it is Ethereum) to a child chain. Below, we describe how to deposit `ETH` on chains that use `ETH` as the native gas token. The process for depositing custom gas tokens follows the same steps, except it uses the chain's delayed inbox contract.

### Depositing ETH[​](#depositing-eth "Direct link to Depositing ETH")

A special message type exists for simple `ETH` deposits from parent-to-child chains. You can deposit `ETH` by calling the `Inbox` contract's `depositEth` method, for example:

```rust
function depositEth(address destAddr) external payable override returns (uint256)
```

warning

Depositing `ETH` directly via `depositEth` to a contract on a child chain **will not** invoke that contract's fallback function.

#### Using retryable tickets instead[​](#using-retryable-tickets-instead "Direct link to Using retryable tickets instead")

While `depositEth` is often the simplest path, you can also use _retryable tickets_ to deposit `ETH`. This method may be preferable if you need additional flexibility–for example, specifying an alternative destination address or triggering a fallback function on a child chain.

#### How deposits work[​](#how-deposits-work "Direct link to How deposits work")

When you call `Inbox.depositEth`, the `ETH` is sent to the  contract on the parent chain. This contract then "credits" the deposited amount to the specified address on the child chain. As far as the parent chain is concerned, the deposited `ETH` remains held by Arbitrum's bridge contract on your behalf.

A diagram illustrating this deposit process is below:

*   **If the parent chain caller is an Externally Owned Account (EOA)**:
    *   The deposited `ETH` will appear in the same EOA address on the child chain.
*   **If the parent chain caller is a contract**:
    *   The `ETH` will be deposited to the contract's aliased address on the child chain. In the next section, we will cover [Address aliasing](#address-aliasing).

![Address aliasing](/img/haw-aliasing.svg)

### Address aliasing[​](#address-aliasing "Direct link to Address aliasing")

All unsigned messages submitted through the delayed inbox have their sender addresses "aliased" when executed on the child chain. Instead of returning the parent chain sender's address as `msg.sender`, the child chain sees the "child alias" of that address. Formally, the child alias calculation is:

```rust
Child_Alias = Parent_Contract_Address + 0x1111000000000000000000000000000000001111
```

#### Why aliasing?[​](#why-aliasing "Direct link to Why aliasing?")

Address aliasing in Arbitrum is a security measure that prevents cross-chain exploits. Without it, a malicious actor could impersonate a contract on a child chain by simply sending a message from that contract's parent chain address. By introducing an offset, Arbitrum ensures that child-chain contracts can distinguish between parent-chain contract calls and those from child-chain-native addresses.

#### Computing the original parent chain address[​](#computing-the-original-parent-chain-address "Direct link to Computing the original parent chain address")

If you need to recover the original parent chain address from an aliased child chain address onchain, you can use Arbitrum's `AddressAliasHelper` library. This library allows you to translate between the aliased child address and the original parent address in your contract logic.

```rust
modifier onlyFromMyL1Contract() override {
    require(AddressAliasHelper.undoL1ToL2Alias(msg.sender) == myL1ContractAddress, "ONLY_COUNTERPART_CONTRACT");
    _;
}
```

Transacting via the delayed inbox[​](#transacting-via-the-delayed-inbox "Direct link to Transacting via the delayed inbox")
---------------------------------------------------------------------------------------------------------------------------

Arbitrum provides a _delayed inbox_ contract on the parent chain that can deliver arbitrary messages to the child chain. This functionality is important for two reasons:

1.  **General cross-chain messaging**: Allows parent chain EOAs or parent chain contracts to send messages or transactions to a child chain. This functionality is critical for bridging assets (other than the chain's native token) and performing cross-chain operations.
2.  **Censorship resistance**: It ensures the  remains censorship-resistant, even if the Sequencer misbehaves or excludes certain transactions; refer to [Bypassing the Sequencer](/how-arbitrum-works/transaction-lifecycle#bypassing-the-sequencer) for more details.

Users can send child chain transactions through the delayed inbox in two primary ways:

1.  [General child chain messaging](#general-child-chain-messaging)
2.  [Retryable tickets](#retryable-tickets)

### General child chain messaging[​](#general-child-chain-messaging "Direct link to General child chain messaging")

Any message sent via the delayed inbox can ultimately produce a transaction on the child chain. These messages may or may not include a signature.

*   **Signed messages**: Signed by an EOA on the parent chain. This signature proves the sender is an EOA rather than a contract, preventing certain cross-chain exploits and bypassing the need for aliasing.
*   **Unsigned messages**: These do not include a signature from an EOA. For security reasons, the sender's address on the child chain must be _aliased_ when the message gets executed; see the [Address aliasing](#address-aliasing) section for details.

Below, we describe the delayed inbox methods for each scenario.

### Signed messages[​](#signed-messages "Direct link to Signed messages")

Signed messages let a parent chain EOA prove ownership of an address, ensuring the child chain transaction will execute with `msg.sender` equal to the _signer's_ address on the child chain (rather than an alias). This mechanism is beneficial for bypassing the Sequencer if:

*   You want to force-include a transaction on a child chain in case of Sequencer downtime or censorship.
*   You need an operation on a child chain that explicitly requires EOA authorization (e.g., a withdrawal).

#### How signed messages work[​](#how-signed-messages-work "Direct link to How signed messages work")

When submitting through the delayed inbox, a child chain transaction signature gets included in the message's calldata. Because it matches the EOA's signature, the child chain can safely treat the signer's address as the sender.

Example use case: [Withdraw Ether tutorial](https://github.com/OffchainLabs/arbitrum-tutorials/blob/a1c3f64a5abdd0f0e728cb94d4ecc2700eab7579/packages/delayedInbox-l2msg/scripts/withdrawFunds.js#L61-L65)

#### Delayed inbox methods for signed messages[​](#delayed-inbox-methods-for-signed-messages "Direct link to Delayed inbox methods for signed messages")

There are two primary methods for sending signed messages:

1.  `sendL2Message`

*   It can be called by either an EOA or a contract
*   The complete signed transaction data is emitted in an event log so that nodes can reconstruct the transaction without replaying it
*   More flexible

```rust
function sendL2Message(
    bytes calldata messageData
) external whenNotPaused onlyAllowed returns (uint256)
```

2.  `sendL2MessageFromOrigin`

*   Only an EOA with no deployed code can call this ("codeless origin")
*   The signed transaction is retrieved directly from calldata, so emitting a large event log is unnecessary
*   Offers lower gas costs (cheaper)

```rust
function sendL2MessageFromOrigin(
    bytes calldata messageData
) external whenNotPaused onlyAllowed returns (uint256);
```

### Unsigned messages[​](#unsigned-messages "Direct link to Unsigned messages")

Unsigned messages allow a parent chain sender to specify transaction parameters without an EOA signature. Because there is no signature, **the sender's address must be aliased on the child chain** (see the [Address aliasing](#address-aliasing) section for the rationale). The delayed inbox provides four main methods for unsigned messages, divided based on whether the sender is an EOA or a contract and whether it includes parent chain funds:

1.  **Unsigned from EOA's**: These methods incorporate a nonce for replay protection, similar to standard EOA-based transactions on Ethereum.

*   `sendL1FundedUnsignedTransaction`
    *   Transfers value from a parent chain to a child chain along with the transaction
    *   Parameters: gas limit, fee, nonce, destination address, and calldata

```rust
function sendL1FundedUnsignedTransaction(
    uint256 gasLimit,
    uint256 maxFeePerGas,
    uint256 nonce,
    address to,
    bytes calldata data
) external payable returns (uint256);
```

*   `sendUnsignedTransaction`
    *   No value transfers from the parent chain
    *   Transaction fees and value on a child chain come from the child chain balance

```rust
function sendUnsignedTransaction(
    uint256 gasLimit,
    uint256 maxFeePerGas,
    uint256 nonce,
    address to,
    uint256 value,
    bytes calldata data
) external whenNotPaused onlyAllowed returns (uint256);
```

2.  **Unsigned from contracts**: Contracts typically rely on standard Ethereum replay protection using their contract address.

*   `sendContractTransaction`
    *   Sends a transaction from a parent chain with no new funds; uses the contract's existing child chain balance.

```rust
function sendContractTransaction(
    uint256 gasLimit,
    uint256 maxFeePerGas,
    address to,
    uint256 value,
    bytes calldata data
) external whenNotPaused onlyAllowed returns (uint256);
```

*   `sendL1FundedContractTransaction`
    *   Sends the transaction _and_ transfers additional funds from a parent to child chain

```rust
function sendL1FundedContractTransaction(
    uint256 gasLimit,
    uint256 maxFeePerGas,
    address to,
    bytes calldata data
) external payable returns (uint256);
```

In these methods, a "delayed message" is created and passed to the parent chain bridge contract, which then arranges its inclusion on a child chain.

### Messages types[​](#messages-types "Direct link to Messages types")

 defines various **message types** to distinguish between the categories described above (signed vs. unsigned, EOAs vs. contracts, etc.). These message types help the protocol route and process each incoming message securely.

You can find additional details on message types in the next section of this documentation.

note

Please refer to the [Address aliasing](#address-aliasing) discussion for more background on address aliasing. This mechanism ensures that a parent chain contract can't impersonate a child chain address unless it provides a vlaid signature as an EOA.

Retryable tickets[​](#retryable-tickets "Direct link to Retryable tickets")
---------------------------------------------------------------------------

Retryable tickets are Arbitrum's canonical method for creating parent-to-child chain messages, i.e., parent-chain transactions that initiate a message to get executed on a child chain. A retryable is submittable for a fixed-cost (dependent only on its calldata size) paid at the parent chain; its _submission_ on the parent chain is separable/asynchronous with its _execution_ on the child chain. Retryables provide atomicity between the cross-chain operations; if the parent chain transaction to request submission succeeds (i.e., does not revert), then the execution of the retryable on the child chain has a strong guarantee to succeed.

### Retryable ticket lifecycle[​](#retryable-ticket-lifecycle "Direct link to Retryable ticket lifecycle")

Here, we walk through the different stages of the lifecycle of a : (1) submission, (2) auto-redemption, and (3) manual redemption.

#### Submission[​](#submission "Direct link to Submission")

1.  Creating a retryable ticket is initiated with a call (direct or internal) to the `createRetryableTicket` function of the [`inbox` contract](https://github.com/OffchainLabs/nitro-contracts/blob/67127e2c2fd0943d9d87a05915d77b1f220906aa/src/bridge/Inbox.sol). A ticket is guaranteed to get created if this call succeeds. Here, we describe parameters that need adjusting with care. Note that this function forces the sender to provide _a reasonable_ amount of funds (at least enough for submitting and _attempting_ to execute the ticket), but that doesn't guarantee a successful auto-redemption.

Parameter

Description

`l1CallValue` (also referred to as deposit)

Not a real function parameter; it is rather the `callValue` that gets sent along with the transaction

`address to`

The destination child chain address

`uint256 l2CallValue`

The `callvalue` for the retryable child chain message that is supplied within the deposit (`l1CallValue`)

`uint256 maxSubmissionCost`

The maximum amount of `ETH` payable for submitting the ticket. This amount is (1) supplied within the deposit (`l1CallValue`) to be later deducted from the sender's child chain balance and is (2) directly proportional to the size of the retryable's data and parent chain basefee.

`address excessFeeRefundAddress`

The unused gas cost and submission cost will deposit to this address, formula is: `(gasLimit x maxFeePerGas - execution cost) + (maxSubmission - (autoredeem ? 0 : submission cost))`. (**Note**: The excess deposit will transfer to the alias address of the parent chain tx's `msg.sender` rather than this address)

`address callValueRefundAddress`

The child chain address to which the `l2CallValue` is credited if the ticket times out or gets canceled (also called the `beneficiary`, who's got a critical permission to cancel the ticket).

uint256 gasLimit

Maximum amount of gas used to cover the child chain execution of the ticket

uint256 maxFeePerGas

The gas price bid for child chain execution of the ticket supplied within the deposit (`l1CallValue`)

bytes calldata data

The calldata to the destination child chain address

2.  The sender's deposit must be enough to make the parent chain submission succeed and for child chain execution to be _attempted_. If provided correctly, a new ticket with a unique `TicketID` is created and added to the retryable buffer. Also, funds (`submissionCost` + `l2CallValue`) are deducted from the sender and placed into escrow for later use in redeeming the ticket.
    
3.  Ticket creation causes the [`ArbRetryableTx`](/build-decentralized-apps/precompiles/reference#arbretryabletx) precompile to emit a `TicketCreated` event containing the `TicketID` on the child chain.
    

**Ticket Submission**

1.  User initiates a parent-to-child message
2.  Initiating a parent-child message

*   A call to `inbox.createRetryableTicket` function that puts the message in the child chain inbox that can be re-executed for some fixed amount of time if it reverts.

3.  Check the user's deposit

*   Logic that checks if the user has enough funds to create a ticket. A process that checks if the `msg.value` provided by the user is greater than or equal to `maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas`.

4.  Ticket creation fails, and no funds get deducted from the user
5.  Ticket creation

*   A ticket is created and added to the retryable buffer on the child chain. Funds (`l2CallValue + submissionCost`) get deducted to cover the `callValue` from the user and are placed into escrow (on the child chain) for later use in redeeming the ticket.

#### Automatic redemption[​](#automatic-redemption "Direct link to Automatic redemption")

1.  It is very important to note that submitting a ticket on the parent chain is separable/asynchronous from its execution on the child chain, i.e., a successful parent chain ticket creation does not guarantee successful redemption. Upon successful ticket creation, checks validate the two following conditions:

*   if the user's child chain balance is greater than (or equal to) `maxFeePerGas * gasLimit` **and**
*   if the `maxFeePerGas` (provided by the user in the ticket submission process) is greater than (or equal to) the `l2BaseFee`. If these conditions are both met, an attempt to execute the ticket on the child chain triggers (i.e., **auto-redeem** using the supplied gas, as if the `redeem` method of the `[ArbyRetryableTx]` precompile had been called). Depending on how much gas the sender has provided in Step 1, the ticket's redemption can either (1) immediately succeed or (2) fail. We explain both situations below:

**Immediate success**

If the ticket is successfully auto-redeemed, it will execute with the original submission's sender, destination, callvalue, and calldata. The submission fee is refunded to the user on the child chain (`excessFeeRefundAddress`). Note that to ensure successful auto-`redeem` of the ticket, one could use the Arbitrum SDK, which provides a [convenience function](https://github.com/OffchainLabs/arbitrum-sdk/blob/4cedb1fcf1c7302a4c3d0f8e75fb33d82bc8338d/src/lib/message/L1ToL2MessageGasEstimator.ts#L215) that returns the desired gas parameters when sending parent-to-child messages.

**Fail**

If a `redeem` is not done at submission or the submission's initial `redeem` fails (for example, because the child chain's gas price has increased unexpectedly), the submission fee is collected on the child chain to cover the resources required to temporarily keep the ticket in memory for a fixed period (one week), and only in this case, a manual redemption of the ticket is required (see the next section).

**Automatic redemption of the `TicketManual` redemption of the ticket**

1.  Does the auto-`redeem` succeed?

*   Logic that determines if the user's child chain balance is greater than (or equal to) `maxFeePerGas * gasLimit && maxFeePerGas` is greater than (or equal to) the `l2BaseFee`.

2.  Ticket is executed

*   The actual `submissionFee` is refunded to the `excessFeeRefundAddress` because the ticket cleared from the buffer of the child chain.

3.  The ticket is deleted from the child chain retryable buffer.
4.  Refund `callValueRefundAddress`

*   Refunded with (`maxGas - gasUsed) * gasPrice`. Note that the cap amount is the `l2CallValue` in the auto-`redeem`.

#### Manual redemption[​](#manual-redemption "Direct link to Manual redemption")

1.  At this point, _anyone_ can attempt to manually redeem the ticket again by calling [`ArbRetryableTx`](/build-decentralized-apps/precompiles/reference#arbretryabletx) `redeem` precompile method, which donates the call's gas to the next attempt. Note that the amount of gas is **not** limited by the original `gasLimit` set during the ticket creation.  will [enqueue the `redeem`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L245) before moving on to the next non-`redeem` transaction in the block it's forming. In this manner, `redeem`'s are scheduled to happen as soon as possible and will always be in the same block as the tx that scheduled it. Note that the `redeem` attempt's gas comes from the call to `redeem`, so there's no chance to reach the block's gas limit before execution.
    
2.  If the fixed period (one week) elapses without a successful `redeem`, the ticket **expires** and will be [automatically discarded](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/retryables/retryable.go#L262), unless some party has paid a fee to [keep the ticket alive](https://github.com/OffchainLabs/nitro-contracts/blob/a68783436b5105a64f54efe5fbd55174704a7618/src/precompiles/ArbRetryableTx.sol#L41) for another full period. A ticket can live indefinitely as long as it continues to renew each time before it expires.
    

**Process flow**

1.  Is the ticket manually created or not redeemed within seven days?

*   Logic that determines if the ticket is manually canceled or not redeemed within seven days (i.e., it is expired).

2.  Refunding `callValueRefundAddress`

*   The `l2CallValue` is refunded to the `callValueRefundAddress`

3.  The ticket is deleted from the child chain retryable buffer.
4.  Is the ticket manually redeemed?

*   Logic that determines if the ticket is manually redeemed.

#### Avoid losing funds![​](#avoid-losing-funds "Direct link to Avoid losing funds!")

Any associated messages and values, excluding the escrowed `callValue`, may be permanently lost if a ticket is not redeemed or rescheduled within seven days.

On success, the `To` address receives the escrowed `callValue`, and any unused gas returns to ArbOS's gas pools. On failure, the `callValue` is returned to the escrow for the future `redeem` attempt. In either case, the network fee gets paid during the scheduling tx, so no fee charges or refunds get made.

During ticket redemption, attempts to cancel the same ticket or schedule another `redeem` of the same ticket will revert. In this manner, retryable tickets are not self-modifying.

If a ticket with a `callValue` is eventually discarded (canceled or expired) having never successfully run, the escrowed `callValue` will be paid out to a `callValueRefundAddress` account that was specified in the initial submission (Step 1).

Important notes

If a `redeem` is not done at submission or the submission's initial `redeem` fails, anyone can attempt to redeem the retryable again by calling [`ArbRetryableTx`](/build-decentralized-apps/precompiles/reference#arbretryabletx) `redeem` precompile method, which donates the call's gas to the next attempt.

*   One can `redeem` live tickets using the [Arbitrum Retryables Transaction Panel](https://retryable-dashboard.arbitrum.io/tx)
*   The calldata of a ticket is saved on the child chain until it is redeemed or expired
*   Redeeming the cost of a ticket will not increase over time; it only depends on the current gas price and gas required for execution.

#### Receipts[​](#receipts "Direct link to Receipts")

In the lifecycle of a retryable ticket, two types of child chain transaction receipts will emit:

*   **Ticket creation receipt**: This receipt indicates successful ticket creation; any successful parent chain call to the `Inbox`'s `createRetryableTicket` method is guaranteed to create a ticket. The ticket creation receipt includes a `TicketCreated` event (from `ArbRetryableTx`), which includes a `ticketId` field. This `ticketId` is computable via RLP encoding and hashing the transaction; see `[calculateSubmitRetryableId]`([https://github.com/OffchainLabs/arbitrum-sdk/blob/6cc143a3bb019dc4c39c8bcc4aeac9f1a48acb01/src/lib/message/L1ToL2Message.ts#L109](https://github.com/OffchainLabs/arbitrum-sdk/blob/6cc143a3bb019dc4c39c8bcc4aeac9f1a48acb01/src/lib/message/L1ToL2Message.ts#L109)).
*   **`redeem` attempt**: A `redeem` attempt receipt represents the results of an attempted child chain execution of a ticket, i.e., success/failure of that specified `redeem` attempt. It includes a `RedeemScheduled` event from `ArbRetryableTx`, with a `ticketId` field. At most, one successful `redeem` attempt can ever exist for a given ticket; if, e.g., the auto-`redeem` upon initial creation succeeds, only the receipt from the auto-`redeem` will ever get emitted for that ticket. If the auto-`redeem` fails (or was never attempted–i.e., the provided `child chain gas limit * child chain gas price = 0`), each initial attempt will emit a `redeem` attempt receipt until one succeeds.

#### Alternative "unsafe" retryable ticket creation[​](#alternative-unsafe-retryable-ticket-creation "Direct link to Alternative \"unsafe\" retryable ticket creation")

The `Inbox.createRetryableTicket` convenience method includes sanity checks to help minimize the risk of user error: the method will ensure enough funds are provided directly from a parent chain to cover the current cost of ticket creation. It also will convert the provided `callValueRefundAddress` and `excessFeeRefundAddress` to their [address alias](#address-aliasing) if either is a contract (determined by if the address has code during the call), providing a path for the parent chain contract to recover funds. A power-user may bypass these sanity-check measures via the `Inbox`'s `unsafeCreateRetryableTicket` method; as the method's name desperately attempts to warn you, only a user who knows what they are doing should access it.

Token bridging[​](#token-bridging "Direct link to Token bridging")
------------------------------------------------------------------

We can build **customized feature messaging** (for example, token bridging) using the messaging systems described in previous sections. In particular, **retryable tickets** power Arbitrum's **canonical token bridge**, which  developed. By leveraging retryable tickets under the hood, this token bridge provides a seamless user experience for transferring assets from a parent-to-child chain. An overview of how the system works is below:

### `ERC-20` token bridging[​](#erc-20-token-bridging "Direct link to erc-20-token-bridging")

The Arbitrum protocol technically has no native notion of any token standards and gives no built-in advantage or special recognition to any particular token bridge. In this page, we describe the "canonical bridge", which was implemented by Offchain Labs and should be the primary bridge most users and applications use; it is (effectively) a decentralized app () with contracts on both parent and child chains that leverages Arbitrum's [cross-chain message passing system](/build-decentralized-apps/cross-chain-messaging) to achieve basic desired token-bridging functionality. We recommend that you use it!

### Design rationale[​](#design-rationale "Direct link to Design rationale")

In our token bridge design, we use the term "gateway" as per [this proposal](https://ethereum-magicians.org/t/outlining-a-standard-interface-for-cross-domain-erc20-transfers/6151); i.e., one of a pair of contracts on two different domains (i.e., Ethereum and an Arbitrum One chain), used to facilitate cross-domain asset transfers.

We will now outline some core goals that motivated the design of our bridging system.

#### Custom gateway functionality[​](#custom-gateway-functionality "Direct link to Custom gateway functionality")

For many `ERC-20` tokens, "standard" bridging functionality is sufficient, which entails the following: a token contract on the parent chain (i.e., Ethereum) is associated with a "paired" token contract on the child chain (i.e., Arbitrum).

Depositing a token entails escrowing some of the tokens in a parent chain bridge contract and minting the same amount of the paired token contract on a child chain. On the child chain, the paired contract behaves much like a standard `ERC-20` token contract. Withdrawing entails burning some amount of the token in the child chain contract, which is claimable from the parent chain bridge contract at a later time.

Many tokens, however, require  systems, the possibilities which are hard to generalize:

*   Tokens that accrue interest to their holders must ensure that the interest is dispersed properly across layers, and doesn't simply accrue to the bridge contracts.
*   Our cross-domain `WETH` implementations require wrapping and unwrapping tokens as they move across layers.

Thus, our bridge architecture must allow the standard deposit and withdrawal functionalities, and new, custom gateways can be added dynamically over time.

#### Canonical child chain representation per parent chain token contract[​](#canonical-child-chain-representation-per-parent-chain-token-contract "Direct link to Canonical child chain representation per parent chain token contract")

Having multiple custom gateways is well and good. Still, we also want to avoid a situation in which a single parent chain token that uses our bridging system can be represented at multiple addresses/contracts on the child chain, as this adds significant friction and confusion for users and developers. Thus, we need a way to track which parent chain token uses which gateway and, in turn, to have a canonical address oracle that maps the token addresses across the parent and child chain domains.

### Canonical token bridge implementation[​](#canonical-token-bridge-implementation "Direct link to Canonical token bridge implementation")

With this in mind, we provide an overview of our token-bridging architecture.

Our architecture consists of three types of contracts:

1.  **Asset contracts**: These are the token contracts, i.e., an `ERC-20` on a parent chain and its counterpart on the child chain.
2.  **Gateways**: Pairs of contracts (one on the parent and one on the child chain) implementing a particular type of cross-chain asset bridging.
3.  **Routers**: Exactly two contracts (one on parent and one on child chain) route each asset to its designated gateway.

![Canonical bridge](/img/haw-canonical-bridge.svg)

All parent-to-child token transfers initiate via the router contract on the parent chain, the `L1GatewayRouter` contract. `L1GatewayRouter` forwards the token's deposit call to the appropriate gateway contract on the parent chain, the `L1ArbitrumGateway` contract. `L1GatewayRouter` is responsible for mapping the parent chain token addresses to L1Gateway contracts, thus acting as a parent/child address oracle and ensuring each token corresponds to only one gateway. The `L1ArbitrumGateway` then communicates to its counterpart gateway contract on the child chain, the `L2ArbitrumGateway` contract (typically/expectedly via [retryable tickets](#retryable-tickets)).

![Token gateway](/img/haw-token-gateway.svg)

For any given gateway pairing, we require that calls initiate through the corresponding router (`L1GatewayRouter`) and that the gateways conform to the [TokenGateway](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/libraries/gateway/TokenGateway.sol) interfaces; the `TokenGateway` interfaces should be flexible and extensible enough to support any bridging functionality a particular token may require.

### The standard `ERC-20` gateway[​](#the-standard-erc-20-gateway "Direct link to the-standard-erc-20-gateway")

Any `ERC-20` token on a parent chain not registered to a gateway can be permissionlessly bridged through the `StandardERC20Gateway` by default.

You can use the [bridge UI](https://bridge.arbitrum.io/) or follow the instructions in [How to bridge tokens via Arbitrum's standard ERC-20 gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-standard) to bridge a token to a child chain via this gateway.

#### Example: Standard `Arb-ERC20` deposit and withdraw[​](#example-standard-arb-erc20-deposit-and-withdraw "Direct link to example-standard-arb-erc20-deposit-and-withdraw")

To help illustrate what this all looks like in practice, let's go through the steps of what depositing and withdrawing `SomeERC20Token` via our standard `ERC-20` gateway looks like. We assume that `SomeERC20Token` has already been registered in the `L1GatewayRouter` to use the standard `ERC-20` gateway.

#### Deposits[​](#deposits "Direct link to Deposits")

1.  A user calls `L1GatewayRouter.outboundTransferCustomRefund` (with `SomeERC20Token`'s parent chain address as an argument).

warning

Please keep in mind that some older custom gateways might not have `outboundTransferCustomRefund` implemented, and `L1GatewayRouter.outboundTransferCustomRefund` does not fall to `outboundTransfer`. In those cases, please use the function `L1GatewayRouter.outboundTransfer`.

2.  `L1GatewayRouter` looks up `SomeERC20Token`'s gateway and finds its standard `ERC-20` gateway (the `L1ERC20Gateway` contract).
    
3.  `L1GatewayRouter` calls `L1ERC20Gateway.outboundTransferCustomRefund`, forwarding the appropriate parameters.
    
4.  `L1ERC20Gateway` escrows the tokens sent and creates a retryable ticket to trigger `L2ERC20Gateway`'s `finalizeInboundTransfer` method on the child chain.
    
5.  `L2ERC20Gateway.finalizeInboundTransfer` mints the appropriate token amount at the `arbSomeERC20Token` contract on the child chain.
    

Note that `arbSomeERC20Token` is an instance of [`StandardArbERC20`](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/arbitrum/StandardArbERC20.sol), which includes `bridgeMint` and `bridgeBurn` methods only callable by the `L2ERC20Gateway`.

### The Arbitrum generic-custom gateway[​](#the-arbitrum-generic-custom-gateway "Direct link to The Arbitrum generic-custom gateway")

Just because a token has requirements beyond what the standard `ERC-20` gateway offers doesn't necessarily mean that a unique gateway needs to be tailor-made for the token in question. Our  design is flexible enough to be suitable for most (but not necessarily all) custom fungible token needs.

As a general rule

Suppose your custom token can increase its supply (i.e., mint) directly on the child chain, and you want the child-chain-minted tokens to be withdrawable back to the parent chain and recognized by the parent chain contract. In that case, a special gateway is likely required. Otherwise, the generic-custom gateway is likely the solution for you!

Some examples of token features suitable for the generic-custom gateway:

*   A child chain token contract upgradable via a proxy
*   A child chain token contract that includes address whitelisting/blacklisting
*   The deployer determines the address of the child chain token contract

#### Setting up your token with the generic-custom gateway[​](#setting-up-your-token-with-the-generic-custom-gateway "Direct link to Setting up your token with the generic-custom gateway")

The following steps can set up your token for the generic-custom gateway. You can also find more detailed instructions on the page [How to bridge tokens via Arbitrum's generic-custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-generic-custom).

**Pre-requisites**

Your token on the parent chain should conform to the [ICustomToken](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/ICustomToken.sol) interface (see [`TestCustomTokenL1`](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/test/TestCustomTokenL1.sol) for an example implementation). Crucially, it must have an `isArbitrumEnabled` method in its interface.

1.  Deploy your token on the child chain

*   Your token should conform to the minimum [IArbToken](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/arbitrum/IArbToken.sol) interface, i.e., it should have `bridgeMint` and `bridgeBurn` methods only callable by the `L2CustomGateway` contract, and the address of its corresponding Ethereum token accessible via `l1Address`. For an example implementation, see [`L2GatewayToken`](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/libraries/L2GatewayToken.sol).
*   Token compatibility with available tooling
    *   If you want your token to be compatible out of the box with all the tooling available (e.g., the \[Arbitrum bridge\]), we recommend that you keep the implementation of the IArbToken interface as close as possible to the [`L2GatewayToken`](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/libraries/L2GatewayToken.sol) implementation example.
    *   For example, if an allowance check is added to the `bridgeBurn()` function, the token will not be easily withdrawable through the , as the UI does not prompt an approval transaction of tokens by default (it expects the tokens to follow the recommended `L2GatewayToken` implementation).

2.  Register your token on the parent chain to your token on the child chain via the `L1CustomGateway` contract

*   Have your parent chain token's contract make an external call to `L1CustomGateway.registerTokenToL2`. Alternatively, this registration is submittable as a chain-owner registration via an [Arbitrum DAO](https://forum.arbitrum.foundation/) proposal.

3.  Register your token on the parent chain to the `L1GatewayRouter`

*   After your token's registration to the generic-custom gateway is complete, have your parent chain token's contract make an external call to `L1GatewayRouter.setGateway`; Alternatively, this registration is submittable as a chain-owner registration via an [Arbitrum DAO](https://forum.arbitrum.foundation/) proposal.

We are here to help

If you have questions about your custom token needs, please reach out on our [Discord](https://discord.gg/arbitrum) server.

### Other flavors of gateways[​](#other-flavors-of-gateways "Direct link to Other flavors of gateways")

Note that in the system described above, one pair of gateway contracts handles the bridging of many `ERC-20`'s; i.e., many `ERC-20`'s on parent chain's are each paired with their own `ERC-20`'s on child chain's via a single gateway contract pairing. Other gateways may bear different relations with the contracts they bridge.

Take our wrapped Ether implementation; for example, a single `WETH` contract on a parent chain connects to a single `WETH` contract on a child chain. When transferring `WETH` from one domain to another, the parent/child gateway architecture unwraps the `WETH` on domain A, transfers the now-unwrapped Ether, and re-wraps it on domain B. This process ensures that `WETH` can behave on the child chain the way users are used to it behaving on the parent chain while ensuring that all `WETH` tokens are always fully collateralized on the layer in which they reside.

No matter the complexity of a particular token's bridging needs, a gateway can, in principle, be created to accommodate it within our canonical bridging system.

You can find an example of the implementation of a custom gateway on the page [How to bridge tokens via a custom gateway](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/how-to-bridge-tokens-custom-gateway).

### Demos[​](#demos "Direct link to Demos")

Our [How to bridge tokens](/build-decentralized-apps/token-bridging/bridge-tokens-programmatically/get-started) section provides examples of interacting with Arbitrum's token bridge via the [Arbitrum SDK](https://github.com/OffchainLabs/arbitrum-sdk).

### "I've got a bridge to sell you," a word of caution[​](#ive-got-a-bridge-to-sell-you-a-word-of-caution "Direct link to \"I've got a bridge to sell you,\" a word of caution")

Cross-chain bridging is an exciting design space. Alternative bridge designs can potentially offer faster withdrawals, interoperability with other chains, different trust assumptions with potentially valuable UX tradeoffs, and more. However, they can also potentially be completely insecure and/or outright scams. Users should treat other non-canonical bridge applications the same way they treat any application running on Arbitrum, exercise caution, and do their due diligence before entrusting them with their value.

---

# L2 to L1 messaging | Arbitrum Docs

## L2 to L1 messaging

's  system allows for arbitrary child chain to parent chain contract calls; i.e., messages initiated from the child chain which eventually resolve in execution on the parent chain. Child chain-to-parent chain messages (aka "outgoing" messages) bear many things in common with Arbitrum's [Parent chain-to-child chain messages](/how-arbitrum-works/l1-to-l2-messaging) (Retryables), "in reverse" though with a few differences.

### Protocol Flow[​](#protocol-flow "Direct link to Protocol Flow")

Part of the child chain state of an  — and consequently, part of every assertion — is a Merkle root of all child chain-to-parent chain messages in the chain's history. Upon an assertion being confirmed (typically ~1 week after its asserted), this Merkle root is posted on parent chain in the `Outbox` contract. The Outbox contract then lets users execute their messages — validating Merkle proofs of inclusion, and tracking which child to parent chain messages have already been spent.

### Client Flow[​](#client-flow "Direct link to Client Flow")

From a  perspective, a child to parent chain message begins with a call to the child chain [`ArbSys`](/build-decentralized-apps/precompiles/reference#arbsys) precompile contract's `sendTxToL1` method. Once the message is included in an  (typically within ~1 hour) and the assertion is confirmed (typically about ~1 week), any client can execute the message. To do this, the client first retrieves the proof data via a call to the Arbitrum chain's "virtual"/precompile-esque\*\* `NodeInterface` contract's `constructOutboxProof` method. The data returned can then be used in the `Outbox`'s `executeTransaction` method to perform the parent chain execution.

### Protocol Design Details[​](#protocol-design-details "Direct link to Protocol Design Details")

An important feature in the design of the Outbox system is that calls to `confirmNode` have constant overhead. Requiring that `confirmNode` only update the constant-sized outgoing message root hash, and that users themselves carry out the final step of execution, achieves this goal; i.e., no matter the number of outgoing messages in the root, or the gas cost of executing them on the parent chain, the cost of confirming nodes remains constant; this ensures that the assertion  processed can't be griefed.

Unlike Retryables, which have an option to provide Ether for automatic child chain execution, outgoing messages can't provide in-protocol automatic parent chain execution, for the simple reason that Ethereum itself doesn't offer scheduled execution affordances. However, application-layer contracts that interact with the Outbox could in principle be built to provide somewhat-analogous "execution market" functionality for outsourcing the final parent chain execution step.

Another difference between outgoing messages and Retryables is that Retryables have a limited lifetime before which they must be redeemed (or have their lifetime explicitly extended), whereas child to parent chain messages are stored in parent chain state, and thus persist permanently / have no deadline before which they must be executed.  
The week long delay period before outgoing messages can be executed is inherent and fundamental to the nature of Arbitrum rollup, or any optimistic rollup style child chain; the moment a  is published on-chain, any observer can anticipate its result; however, for Ethereum itself to accept its result, the protocol must give time for Arbitrum validators to detect and prove fault if need-be. For a protocol overview, see [How Arbitrum works](/how-arbitrum-works/a-gentle-introduction)

\*\* We refer to `NodeInterface` as a "virtual" contract; its methods are accessible via calls `0x00000000000000000000000000000000000000C8`, but it doesn't really live on chain. It isn't really a precompile, but behaves a lot like a precompile that can't receive calls from other contracts. This is a cute trick that let's us provide Arbitrum-specific data without having to implement a custom RPC.

---

# Optimistic Rollup | Arbitrum Docs

## Optimistic Rollup

 is an optimistic rollup. Let’s unpack that term.

_Rollup_

Arbitrum is a Rollup, which means that the inputs to the chain -- the messages that are put into the inbox -- are all recorded on a parent chain (for Arbitrum One, the Ethereum chain) as calldata or blobs (or another format, depending on the configuration of the chain). For the purposes of this article, we also refer to the parent chain as L1, and the Rollup chain as L2.

Because of this, everyone has the information they would need to determine the current correct state of the chain -- they have the full history of the inbox, and the results are uniquely determined by the inbox history, so they can reconstruct the state of the chain based only on public information, if needed.

This also allows anyone to be a full participant in the Arbitrum protocol, to run an Arbitrum node or participate as a . Nothing about the history or state of the chain is a secret.

_Optimistic_

Arbitrum chains are Optimistic, which means that Arbitrum chains advances the state of its chain by letting any party (a “proposer”) post on its parent chain an assertion that the party claims is correct (alongside a bond), and then giving everyone else a chance to  that claim (with an accompanying bond). If the  (6.4 days) passes and nobody has challenged the claimed assertion, the protocol confirms the assertion as correct. Arbitrum chains use an efficient dispute resolution protocol to identify which party is lying if the assertion is challenged during the challenge period. A brief overview of the protocol is included below; for more details, see the [Bold dispute protocol](/how-arbitrum-works/bold/gentle-introduction) section of the documentation. After the protocol finishes, any liar or liars will forfeit their bonds, and the truth-teller(s) will take part of that deposit as a reward for their efforts (most of the bond is taken away by the chain owner, guaranteeing that the liar is punished even if there's some collusion going on).

Because a party who tries to cheat will lose a deposit, attempts to cheat should be very rare, and the normal case will be a single party posting a correct assertion, and nobody challenging it.

Resolving disputes using interactive fraud proofs[​](#resolving-disputes-using-interactive-fraud-proofs "Direct link to Resolving disputes using interactive fraud proofs")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Among optimistic rollups, the most important design decision is how to resolve disputes. Suppose Alice claims that the chain will produce a certain result, and Bob disagrees. How will the protocol decide which version to accept?

There are basically two choices: interactive proving, or re-executing transactions. Arbitrum uses interactive proving, which we believe is more efficient and more flexible. Much of the design of Arbitrum follows from this fact.

note

Zero-knowledge Rollups are able to avoid this situation entirely by using ZK proofs to prove directly to the parent chain that the posted result is correct.

### Interactive proving[​](#interactive-proving "Direct link to Interactive proving")

The idea of interactive proving is that Alice (along with anyone who agrees with her assertion); Bob (along with anyone who agrees with his assertion); and possibly other parties backing other assertions will engage in an "all-vs-all" challenge game. This is a protocol, refereed by a contract on the parent chain, to resolve their dispute with minimal work required from any contract on the parent chain.

Arbitrum's approach is based on the bisection of the dispute. First, Alice posts a claim covering `N` steps of execution. If Bob disagrees with her claim, he proceeds by posting his own claim about the result of execution, which we say "rivals" Alice's. To defend her claim, Alice (or someone acting in support of her claim) posts two size `N/2` claims, which combine to yield her initial `N-step` claim. If Bob wants to continue the dispute, he (or an ally supporting his claim) must do the same. Bob (or an ally) will then pick one of Alice's `N/2`\-step claims to challenge. Now, the size of the dispute has been cut in half. This process continues, cutting the dispute in half at each stage until they disagree about a single execution step. Note that so far, the parent chain referee hasn't had to think about execution "on the merits". Only once the dispute is narrowed down to a single step does the parent chain referee need to resolve it by looking at what the instruction does and whether Alice's claim about it is correct.

note

Again, this is a very high-level overview. Please refer to the [Gentle introduction](/how-arbitrum-works/bold/gentle-introduction) and [Technical deep dive](/bold/concepts/bold-technical-deep-dive) under the **BoLD dispute protocol** section in the documentation for more details.

The key principle behind interactive proving is that if Alice and Bob are in a dispute, Alice and Bob should do as much off-chain work as possible needed to resolve their dispute, rather than putting that work onto a parent chain contract.

### Re-executing transactions[​](#re-executing-transactions "Direct link to Re-executing transactions")

The alternative to interactive proving would be to have an assertion contain a claimed machine state hash after every individual . Then in case of a dispute, the parent chain referee would emulate the execution of an entire transaction, to see whether the outcome matches Alice's claim.

### Why interactive proving is better[​](#why-interactive-proving-is-better "Direct link to Why interactive proving is better")

We believe strongly that interactive proving is the superior approach, for the following reasons.

**More efficient in the optimistic case**: Because interactive proving can resolve disputes larger than one transaction, it can allow an assertion to contain only a single claim about the end state of the chain after all of the execution covered by the block. By contrast, re-execution requires posting a state claim for each transaction within the assertion. With hundreds or thousands of transactions per assertion, there is a substantial difference in computational footprint on the parent chain, and the computational element on the parent chain is usually the main component of the cost of operating a rollup.

**More efficient in the pessimistic case**: In case of a dispute, interactive proving only requires the referee contract on the parent chain to check that Alice and Bob's actions "have the right shape". For example, that Alice has divided her `N`\-step claim into two claims half as large. (The referee doesn't need to evaluate the correctness of Alice's claims--Bob does that off-chain.) Only one instruction needs to be re-executed. By contrast, re-execution requires the parent chain referee contract to emulate the execution of an entire transaction.

**Higher per-txn gas limit:** Interactive proving can escape from Ethereum's tight per-transaction gas limit. The gas limit isn't infinite, for obvious reasons, but it can be larger than on Ethereum. As far as Ethereum is concerned, the only downside of a gas-heavy Arbitrum transaction is that it may require an interactive  with slightly more steps (and only if a fraud proof is actually needed; i.e., in the event of a dispute). By contrast, re-execution must impose a _lower_ gas limit than Ethereum, because it must be possible to emulate execution of the transaction (which is more expensive than executing it directly) within a single Ethereum transaction.

**More implementation flexibility:** Interactive proving allows more flexibility in implementation. All that is necessary is the ability to verify a one-step proof on the parent chain, Ethereum. By contrast, re-execution approaches are tethered to limitations of the Ethereum Virtual Machine (EVM).

### Interactive proving drives the design of Arbitrum[​](#interactive-proving-drives-the-design-of-arbitrum "Direct link to Interactive proving drives the design of Arbitrum")

Much of the design of Arbitrum is driven by the opportunities opened up by interactive proving. If you're reading about some feature of Arbitrum, and you're wondering why it exists, two good questions to ask are: "How does this support interactive proving?" and "How does this take advantage of interactive proving?" The answers to most "why" questions about Arbitrum relate to interactive proving.

Arbitrum Rollup protocol[​](#arbitrum-rollup-protocol "Direct link to Arbitrum Rollup protocol")
------------------------------------------------------------------------------------------------

Before diving into the Rollup protocol, there are two things we need to cover.

First, _if you’re an Arbitrum user or developer, you don’t need to understand the Rollup protocol_. You don’t ever need to think about it unless you want to. Your relationship with it can be like a train passenger’s relationship with the train’s engine: you know it exists, and you rely on it to keep working, but you don’t spend your time monitoring it or studying its internals.

You’re welcome to study, observe, and even participate in the Rollup protocol, but you don’t need to, and most people won’t. So if you’re a typical train passenger who just wants to read or talk to your neighbor, you can skip right to the [next section](#validators) of this document. If not, read on!

The second thing to understand about the Rollup protocol is that _the protocol doesn’t decide the results of transactions, it only confirms the results_. The results are uniquely determined by the sequence of messages in the chain’s inbox. So once your transaction message is in the chain’s inbox, its result is knowable, and Arbitrum nodes will report that your transaction has been completed. The role of the Rollup protocol is to confirm transaction results that, as far as Arbitrum users are concerned, have already occurred. (This is why Arbitrum users can effectively ignore the Rollup protocol.)

You might wonder why we need the Rollup protocol. If everyone knows the results of transactions already, why bother confirming them? The Rollup protocol exists for two reasons. First, somebody might lie about a result, and we need a definitive,  way to tell who is lying. Second, Ethereum doesn’t know the results. The whole point of a child chain scaling system is to run transactions without Ethereum needing to do all of the work--and indeed, Arbitrum can go fast enough that Ethereum couldn’t hope to monitor every Arbitrum transaction. However, once the result is confirmed, Ethereum knows about it and can rely on it, enabling operations on Ethereum, such as processing withdrawals of funds from Nitro back to the parent chain.

With those preliminaries behind us, let’s jump into the details of the Rollup protocol.

The parties who participate in the protocol are called _validators_. Some validators will choose to be proposers--they will place a `WETH` deposit which they’ll be able to recover if they’re not caught cheating. In the common case, it's expected that only one validator will need to play the role of a proposer, since as long as the validator is bonded to the current outcome, and there are no conflicting claims, there's no need for other parties to bond/take any action. Deployment of the BoLD dispute protocol for Arbitrum One makes these roles permissionless to perform. "Watchtower validators," who monitor the chain but don't take any on-chain actions, can also be run permissionlessly (see ["validators"](#validators) below).

The key security property of the Rollup protocol is that any one honest validator can force the correct execution of the chain to be confirmed. This means that the execution of an  is as trustless as Ethereum. You, and you alone (or someone you hire), can force your transactions to be processed correctly. And that is true, no matter how many malicious people are trying to stop you.

### The rollup Chain[​](#the-rollup-chain "Direct link to The rollup Chain")

The Rollup protocol tracks a chain of assertions. They're not the same as the parent chain Ethereum blocks, and also not the same as the child chain Nitro blocks. You can think of the assertions as forming a separate chain, which the  manages and oversees.

Validators can propose assertions. New assertions will be _unresolved_ at first. Eventually, every assertion will be _resolved_, by being either _confirmed_ or _rejected_. The confirmed assertions make up the confirmed history of the chain.

For more details on how the Rollup Chain works under BoLD, the [Gentle introduction](/how-arbitrum-works/bold/gentle-introduction) provides an overview that touches on the Rollup Chain.

note

Validators and proposers serve different roles. Validators validate transactions by computing the next Chain state using the chain's  (STF), whereas proposers can also assert and challenge the chain state on the parent chain.

Each assertion contains:

*   the assertion number
*   the predecessor assertion number: assertion number of the last assertion before this one that is (claimed to be) correct
*   the number of child chain blocks that have been created in the chain's history
*   the number of inbox messages that have been consumed in the chain’s history
*   a hash of the outputs produced over the chain’s history.

Except for the assertion number, the contents of the assertion are all just claims by the assertion's proposer. Arbitrum doesn’t know at first whether any of these fields are correct. If all of these fields are correct, the protocol should eventually confirm the assertion. If one or more of these fields are incorrect, the protocol should eventually reject the assertion.

An assertion is implicitly claiming that its predecessor assertion is correct. This implies, transitively, that an assertion implicitly claims the correctness of a complete history of the chain: a sequence of ancestor assertions that reaches all the way back to the birth of the chain.

An assertion is also implicitly claiming that its older siblings (older assertions with the same predecessor), if there are any, are incorrect. If two assertions are siblings, and the older sibling is correct, then the younger sibling is considered incorrect, even if everything else in the younger sibling is true.

The assertion is assigned a deadline, which says how long other validators have to respond to it. For an assertion R with no older siblings, this will equal the time the assertion was posted, plus an interval of time known as the Challenge Period; subsequent younger siblings will have the same deadline as their oldest sibling (R). If you’re a validator, and you agree that an assertion is correct, you don’t need to do anything. If you disagree with an assertion, you can post another assertion with a different result, and you’ll probably end up in a challenge against the party who proposed the first assertion (or another party acting in support of that assertion). More on challenges below:

In the normal case, the rollup chain will look like this:

![Normal Rollup](/img/haw-normal-rollup.svg)

On the left, representing an earlier part of the chain’s history, we have confirmed assertions. These have been fully accepted and recorded by the parent chain contracts that manage the chain. The newest of the confirmed assertions, assertion 94, is called the “latest confirmed assertion.” On the right, we see a set of newer proposed assertions. The protocol can’t yet confirm or reject them, because their deadlines haven’t run out yet. The oldest assertion whose fate has yet to be determined, assertion 95, is called the “first unresolved assertion.”

Notice that a proposed assertion can build on an earlier proposed assertion. This allows validators to continue proposing assertions without needing to wait for the protocol to confirm the previous one. Normally, all of the proposed assertions will be valid, so they will all eventually be accepted.

Here’s another example of what the chain state might look like, if several validators are being malicious. It’s a contrived example, designed to illustrate a variety of cases that can come up in the protocol, all smashed into a single scenario.

![Rollup with malicious validator](/img/haw-rollup-malicious-validator.svg)

There’s a lot going on here, so let’s unpack it.

*   Assertion 100 has been confirmed.
*   Assertion 101 claimed to be a correct successor to assertion 100, but 101 was rejected (hence it is orange).
*   Assertion 102 was eventually confirmed as the correct successor to 100.
*   Assertion 103 was confirmed and is now the latest confirmed assertion.
*   Assertion 104 was proposed as a successor to assertion 103, and 105 was proposed as a successor to 104. 104 was rejected as incorrect, and as a consequence 105 was rejected because its predecessor was rejected.
*   Assertion 106 is unresolved. It claims to be a correct successor to assertion 103 but the protocol hasn’t yet decided whether to confirm or reject it. It is the first unresolved assertion.
*   Assertions 107 and 108 claim to chain from 106. They are also unresolved. If 106 is rejected, they will be automatically rejected too.
*   Assertion 109 disagrees with assertion 106, because they both claim the same predecessor. At least one of them will eventually be rejected, but the protocol hasn’t yet resolved them.
*   Assertion 110 claims to follow 109. It is unresolved. If 109 is rejected, 110 will be automatically rejected too.
*   Assertion 111 claims to follow 104. 111 will inevitably be rejected because its predecessor has already been rejected. But it hasn’t been rejected yet, because the protocol resolves assertions in assertion number order, so the protocol will have to resolve 106 through 110, in order, before it can resolve 111. After 110 has been resolved, 111 can be rejected immediately.

Again, this sort of thing is very unlikely in practice. In this diagram, at least four different bonds must have been placed on wrong assertions, and when the dust settles at least four bonds will be forfeited. The protocol handles these cases correctly, of course, but they’re rare corner cases. This diagram is designed to illustrate the variety of situations that are possible in principle, and how the protocol would deal with them.

### Staking[​](#staking "Direct link to Staking")

At any given time, some validators will be bonders, and some will not. Bonders deposit funds that are held by the Arbitrum parent chain contracts and will be confiscated if the bonder loses a challenge. Nitro chains accept bonds in ETH.

A single bond can cover a chain of assertions. Every bonder is bonded on the latest confirmed assertion; and if you’re bonded on an assertion, you can also bond on one successor of that assertion. So you might be bonded on a sequence of assertions that represent a single coherent claim about the correct history of the chain. A single bond suffices to commit you to that sequence of assertions.

In order to create a new assertion, you must be a bonder, and you must already be bonded on the predecessor of the new assertion you’re creating. The bond requirement for assertion creation ensures that anyone who creates a new assertion has something to lose if that assertion is eventually rejected.

The rules for staking are as follows:

*   If you’re not bonded, you can bond on the latest confirmed assertion. When doing this, you deposit the current minimum bond amount.
*   If you’re bonded on an assertion, you can also add your bond to any one successor of that assertion. (The protocol tracks the maximum assertion number you’re bonded on, and lets you add your bond to any successor of that assertion, updating your maximum to that successor.) This doesn’t require you to place a new bond.
    *   A special case of adding your bond to a successor assertion is when you create a new assertion as a successor to an assertion you’re already bonded on.
*   If you’re bonded only on the latest confirmed assertion (and possibly earlier assertions), you or anyone else can ask to have your bond refunded. Your bonded funds will be returned to you, and you will no longer be a bonder.
*   If you lose a challenge, your bond is removed from all assertions and you forfeit your bonded funds.

Notice that once you are bonded on an assertion, there is no way to unbond. You are committed to that assertion. Eventually one of two things will happen: that assertion will be confirmed, or you will lose your bond. The only way to get your bond back is to wait until all of the assertions you are bonded on are confirmed.

### Rules for confirming or rejecting assertions[​](#rules-for-confirming-or-rejecting-assertions "Direct link to Rules for confirming or rejecting assertions")

The rules for resolving assertions are fairly simple.

Any unresolved assertion can be confirmed if:

*   the assertion's predecessor is the latest confirmed assertion, and
*   the assertion's deadline has passed

Any unresolved assertion can be rejected if:

*   the assertion's predecessor has been rejected, or
*   the assertion has a sibling that has been confirmed

A consequence of these rules is that once the first unresolved assertion's deadline has passed (and assuming there is at least one bonder bonded on something other than the latest confirmed assertion), the only way the assertion can be unresolvable is if at least one bonder is bonded on it and at least one bonder is bonded on a different assertion with the same predecessor. If this happens, the two bonders are disagreeing about which assertion is correct. It’s time for a challenge, to resolve the disagreement.

Delays[​](#delays "Direct link to Delays")
------------------------------------------

Even if the  Tree has multiple conflicting assertions and, say, multiple disputes are in progress, validators can continue making assertions; honest validators will simply build on the one valid assertion (intuitively: an assertion is also an implicit claim of the validity of all of its parent-assertions.) Likewise, users can continue transacting on the child chain, since transactions continue to be posted in the chain's inbox.

The only delay that users experience during a dispute is of their [L2 to L1 messages](/how-arbitrum-works/l2-to-l1-messaging) (i.e., "withdrawals"). A key property of BoLD is that we can guarantee that in the common case, their withdrawals/messages will be delayed by only one challenge period; and in the case of an actual dispute, the withdrawals/messages will be delayed by no more than two challenge periods, regardless of the adversaries' behavior during the challenge.

Validators[​](#validators "Direct link to Validators")
------------------------------------------------------

Arbitrum full nodes normally "live at the child chain" which means that they don’t worry about the Rollup protocol but simply treat their Arbitrum chain as a mechanism that feeds inbox messages to the State Transition Function to evolve the child chain chain and produce outputs.

Some Arbitrum nodes will choose to act as _validators_. This means that they watch the progress of the Rollup protocol and participate in that protocol to advance the state of the chain securely.

Not all nodes will choose to do this. Because the Rollup protocol doesn’t decide what the chain will do but merely confirms the correct behavior that is fully determined by the inbox messages, a node can ignore the Rollup protocol and simply compute for itself the correct behavior.

 provides open source validator software, including a pre-built Docker image.

Every validator can choose their own approach, but we expect validators to follow three common strategies (For more details on these strategies see [Run a validator](/run-arbitrum-node/more-types/run-validator-node)):

*   The _active validator_ strategy tries to advance the state of the chain by proposing new assertions. An  is always bonded, because creating an assertion requires being bonded. A chain really only needs one honest active validator; any more is an inefficient use of resources. For the Arbitrum One chain, Offchain Labs runs an active validator.
*   The _defensive validator_ strategy watches the Rollup protocol operate. If only correct assertions are proposed, this strategy doesn't bond. But if an incorrect assertion is proposed, this strategy intervenes by posting a correct assertion or staking on a correct assertion that another party has posted. This strategy avoids staking when things are going well, but if someone is dishonest it bonds in order to defend the correct outcome.
*   The _watchtower validator_ strategy never bonds. It simply watches the Rollup protocol, and if an incorrect assertion is proposed, it raises the alarm (by whatever means it chooses) so that others can intervene. This strategy assumes that other parties who are willing to bond will be willing to intervene in order to take some of the dishonest proposer’s bond and that that can happen before the dishonest assertion's deadline expires. (In practice, this will allow several days for a response.)

Under normal conditions, validators using the defensive and watchtower strategies won’t do anything except observe. A malicious actor who is considering whether to try cheating won’t be able to tell how many defensive and watchtower validators are operating incognito. Perhaps some defensive validators will announce themselves, but others probably won’t, so a would-be attacker will always have to worry that defenders are waiting to emerge.

The underlying protocol supports permissionless validation, i.e., anyone can do it. Currently on Arbitrum One, validators that require bond (i.e., active and defensive validators) are whitelisted; see ["State of Progressive Decentralization"](https://docs.arbitrum.foundation/state-of-progressive-decentralization).

Who will be validators? Anyone will be able to do it, but most people will choose not to. In practice we expect people to validate a chain for several reasons.

*   Validators could be paid for their work, by the party that created the chain or someone else. A chain could be configured such that a portion of the funds from user transaction fees are paid directly to validators.
*   Parties who have significant assets at bond on a chain, such as  developers, exchanges, power-users, and liquidity providers, may choose to validate in order to protect their investment.
*   Anyone who chooses to validate can do so. Some users will probably choose to validate in order to protect their own interests or just to be good citizens. But ordinary users don’t need to validate, and we expect that the vast majority of users won’t.

---

# Separating Execution from Proving | Arbitrum Docs

## Separating Execution from Proving

One of the challenges in designing a practical rollup system is the tension between wanting the system to perform well in ordinary execution versus being able to reliably prove the results of execution. Nitro resolves this tension by using the same source code for both execution and proving, but compiling it to different targets for the two cases.

When compiling the Nitro node software for _execution_, the ordinary Go compiler is used, producing native code for the target architecture, which of course will be different for different node deployments. (The node software is distributed in source code form and as a Docker image containing a compiled binary.)

Separately, for _proving_, the portion of the code that is the  is compiled by the Go compiler to WebAssembly (), which is a typed, portable machine code format. The wasm code then goes through a simple transformation into a format we call WAVM, which is detailed below. If there is a dispute about the correct result of computing the STF, it is resolved with reference to the WAVM code.

WAVM[​](#wavm "Direct link to WAVM")
------------------------------------

The Wasm format has many features that make it a good vehicle for fraud proofs—it is portable, structured, well-specified, and has reasonably good tools and support. However, it needs a few modifications to do the job completely. Nitro uses a slightly modified version of Wasm, which we call WAVM. A simple transformation stage turns the Wasm code produced by the Go compiler into WAVM code suitable for proving.

WAVM differs from wasm in three main ways. First, WAVM removes some wasm features that the Go compiler does not generate; the transformation phase verifies that these features are not present.

Second, WAVM restricts a few features of wasm. For example, WAVM does not contain floating-point instructions, so the transformer replaces floating-point instructions with calls to the Berkeley SoftFloat library. (We use software floating-point to reduce the risk of floating-point incompatibilities between architectures. The core Nitro functions never use floating-point, but the Go runtime does use some floating-point operations.) WAVM does not contain nested control flow, so the transformer flattens control flow constructs, turning control flow instructions into jumps. Some wasm instructions take a variable amount of time to execute, which we avoid in WAVM by transforming them into constructs using fixed-cost instructions. These transformations simplify proving.

Third, WAVM adds a few opcodes to enable interaction with the  environment. For example, new instructions allow the WAVM code to read and write the chain's global state, to get the next message from the chain's inbox, or to signal a successful end to execute the State Transition Function.

ReadPreImage and the Hash Oracle Trick[​](#readpreimage-and-the-hash-oracle-trick "Direct link to ReadPreImage and the Hash Oracle Trick")
------------------------------------------------------------------------------------------------------------------------------------------

The most interesting new instruction is `ReadPreImage` which takes as input a hash `H` and an offset `I`, and returns the word of data at offset `I` in the preimage of `H` (and the number of bytes written, which is zero if `I` is at or after the end of the preimage). Of course, it is not feasible in general to produce a preimage from an arbitrary hash. For safety, the `ReadPreImage` instruction can only be used in a context where the preimage is publicly known, and where the size of the preimage is known to be less than a fixed upper bound of about 110 kbytes.

(In this context, "publicly known" information is information that can be derived or recovered efficiently by any honest party, assuming that the full history of the parent Ethereum chain is available. For convenience, a hash preimage can also be supplied by a third party such as a public server, and the correctness of the supplied value is easily verified.)

As an example, the state of a Nitro chain is maintained in Ethereum's state tree format, which is organized as a Merkle tree. Nodes of the tree are stored in a database, indexed by the Merkle hash of the node. In Nitro, the state tree is kept outside of the State Transition Function's storage, with the STF only knowing the root hash of the tree. Given the hash of a tree node, the STF can recover the tree node's contents by using `ReadPreImage`, relying on the fact that the full contents of the tree are publicly known and that nodes in the Ethereum state tree will always be smaller than the upper bound on preimage size. In this manner, the STF is able to arbitrarily read and write to the state tree, despite only storing its root hash.

The only other use of `ReadPreImage` is to fetch the contents of recent  headers, given the header hash. This is safe because the block headers are publicly known and have bounded size.

This "hash oracle trick" of storing the Merkle hash of a data structure, and relying on protocol participants to store the full structure and thereby support fetch-by-hash of the contents, goes back to the original  design.

---

# The Sequencer and Censorship Resistance | Arbitrum Docs

## The Sequencer and Censorship Resistance

The  is a pivotal component of the  network and is responsible for efficiently ordering and processing transactions. It plays a crucial role in providing users with fast  confirmations while maintaining the security and integrity of the . In Arbitrum, the Sequencer orders incoming transactions and manages the batching, compression, and posting of transaction data to , optimizing costs and performance.

![Sequencer operations](/img/haw-sequencer-operations.svg)

In this section, we will explore the operation of the Sequencer in detail. The topics covered include:

*   [Sequencing and Broadcasting (Sequencer Feed)](#sequencing-and-broadcasting): An overview of the real-time transaction feed provided by the Sequencer, which allows nodes to receive instant updates on the transaction sequence.
*   [Batch-Posting](#batch-posting): How the Sequencer groups transactions into batches, compresses them to reduce data size and sends them to the Sequencer Inbox Contract on the parent chain. This section also delves into the parent chain pricing model and how it affects transaction costs.
    *   [Batching](#batching-and-compression)
    *   [Compression](#compression)
    *   [Submitting to the Sequencer Inbox Contract](#submitting-to-the-sequencer-inbox-contract)
*   [Finality](#finality): Understanding how transaction finality is achieved in Arbitrum through both soft and hard finality mechanisms, ensuring that transactions are confirmed securely and reliably. (not as a sequencer task)
*   [Censorship Timeout](#censorship-timeout): A brief introduction to a special feature that aims to limit the negative effects of prolonged sequencer censorship and/or unexpected sequencer outages.

By examining these aspects, you will understand the Sequencer's role within the Arbitrum ecosystem, including how it enhances transaction throughput, reduces latency, and maintains a fair and decentralized network.

Sequencing and Broadcasting[​](#sequencing-and-broadcasting "Direct link to Sequencing and Broadcasting")
---------------------------------------------------------------------------------------------------------

The  is a critical component of the Arbitrum network's Nitro architecture. It enables real-time dissemination of transaction data as they are accepted and ordered by the Sequencer. It allows users and nodes to receive immediate updates on transaction sequencing, facilitating rapid transaction confirmations and enhancing the network's overall responsiveness.

### How the Sequencer Publishes the Sequence[​](#how-the-sequencer-publishes-the-sequence "Direct link to How the Sequencer Publishes the Sequence")

The Sequencer communicates the transaction sequence through two primary channels:

1.  **Real-Time Sequencer Feed**: A live broadcast that publishes transactions instantly as they are sequenced. Nodes and clients subscribed to this feed receive immediate notifications, allowing them to process transactions without delay.
2.  **Batches Posted on the Parent Chain**: At regular intervals, the Sequencer aggregates transactions and posts them to the parent chain for finality. (Refer to the \-Posting section for detailed information on this process.)

![Sequencer feed](/img/haw-sequencer-feed.svg)

### Real-Time Sequencer Feed[​](#real-time-sequencer-feed "Direct link to Real-Time Sequencer Feed")

The real-time feed represents the Sequencer's commitment to process transactions in a specific order. By subscribing to this feed, nodes and clients can:

*   **Receive Immediate Notifications**: Obtain instant information about newly sequenced transactions and their ordering.
*   **Process Transactions Promptly**: Utilize the sequenced transactions to update the state locally, enabling rapid application responses and user interactions.
*   **Benefit from Soft Finality**: Gain provisional assurance about transaction acceptance and ordering before the parent chain reaches finality.

This mechanism is particularly valuable for applications requiring low latency and high throughput, such as decentralized exchanges or real-time gaming platforms.

### Soft Finality and Trust Model[​](#soft-finality-and-trust-model "Direct link to Soft Finality and Trust Model")

"Soft finality" refers to the preliminary  of transactions based on the Sequencer's real-time feed. Key aspects include:

*   **Dependence on Sequencer Integrity**: The feed's accuracy and reliability depend on the Sequencer operating honestly and without significant downtime.
*   **Immediate User Feedback**: Users can act on transaction confirmations swiftly, improving the user experience.
*   **Eventual Consistency with the parent chain**: While the real-time feed provides quick updates, ultimate security, and finality are established once transactions are posted to and finalized on the parent chain. (See the **Finality** section for an in-depth discussion.)

Understanding this trust model is essential. While we expect the Sequencer to behave correctly, users and developers should know that soft finality depends on this assumption. In scenarios where absolute certainty is required, parties may wait for transactions to achieve finality on the parent chain.

### Role of the Sequencer Feed in the Network[​](#role-of-the-sequencer-feed-in-the-network "Direct link to Role of the Sequencer Feed in the Network")

The Sequencer Feed serves several vital functions within the Arbitrum ecosystem:

*   **State Synchronization**: Nodes use the feed to stay synchronized with the latest state of the network, ensuring consistency across the decentralized platform.
*   **Application Development**: Developers can build applications that respond instantly to network events, enabling features like live updates, instant notifications, and real-time analytics.
*   **Ecosystem Transparency**: The feed promotes transparency and trust within the community by providing visibility into transaction sequencing and network activity.

### Considerations and Limitations[​](#considerations-and-limitations "Direct link to Considerations and Limitations")

While the Sequencer Feed offers significant advantages, consider the following:

*   **Reliance on Sequencer Availability**: The effectiveness of the real-time feed depends on the Sequencer's uptime and responsiveness. Network issues or Sequencer downtime can delay transaction visibility.
*   **Provisional Nature of Soft Finality**: Until transactions reach finality on the parent chain, there is a small risk that the provisional ordering provided by the feed could change in exceptional circumstances.
*   **Security Implications**: For high-stakes transactions where security is paramount (e.g., centralized exchange deposits and withdrawals), users may prefer to wait for the parent chain confirmation despite the longer latency.

Developers and users should design their applications and interactions with these factors in mind, choosing the appropriate balance between speed and certainty based on their requirements.

### **Delayed messages on the Sequencer feed**[​](#delayed-messages-on-the-sequencer-feed "Direct link to delayed-messages-on-the-sequencer-feed")

As illustrated in the diagram, the Sequencer feed not only sends  transactions posted directly to the Sequencer but also incorporates parent chain (L1)-submitted child chain (L2) transactions. These include child chain messages submitted on the parent chain and retryable transactions. The Sequencer agent monitors the finalized messages submitted to the parent chain's  Contract. Once finalized, it processes them as incoming messages to the feed, ensuring they are added as ordered transactions.

It is important to note that the Nitro node can be configured to add delayed inbox transactions immediately after their submission to the parent chain, even before finalization. However, this approach introduces a risk of the child chain reorganization if the transaction fails to finalize on the parent chain. To mitigate this risk, on  and Nova, the Sequencer only includes these transactions in the feed once they are finalized on the Ethereum chain.

You can also explore how the feed sends incoming messages via WebSocket and learn how to extract message data from the feed on this page: [Read Sequencer Feed](https://docs.arbitrum.io/run-arbitrum-node/sequencer/read-sequencer-feed).

Batch-Posting[​](#batch-posting "Direct link to Batch-Posting")
---------------------------------------------------------------

Batch-Posting is a fundamental process in the operation of the Sequencer within the Arbitrum network. It involves collecting multiple child chain transactions, organizing them into batches, compressing the data to reduce size, and sending these batches to the Sequencer Inbox Contract on parent chain. This mechanism is crucial for ensuring that transactions are securely recorded on the parent chain blockchain while optimizing for cost and performance.

In this section, we will explore the Batch-Posting process in detail, covering the following topics:

*   **Batching**: How the Sequencer groups incoming transactions into batches for efficient processing and posting.
*   **Compression**: The methods used to compress transaction data, minimizing the amount of data that needs to be posted on parent chain and thereby reducing costs.
*   **Sending to Sequencer Inbox Contract**: The procedure for submitting compressed batches to the Sequencer Inbox Contract on parent chain, ensuring secure and reliable recording of transactions.

Understanding Batch-Posting is essential for grasping how Arbitrum achieves scalability and cost-efficiency without compromising security. By delving into these subtopics, you'll gain insight into the Sequencer's role in optimizing transaction throughput and minimizing fees, as well as the innovative solutions implemented to address the challenges of parent chain data pricing.

Batching and compression[​](#batching-and-compression "Direct link to Batching and compression")
------------------------------------------------------------------------------------------------

The Sequencer in Arbitrum is critical in collecting and organizing child chain transactions before posting them to the parent chain. The batching process is designed to optimize for both cost efficiency and timely transaction inclusion.

![Batching](/img/haw-batching.svg)

**Transaction Collection and Ordering:**

*   **Continuous Reception:** The Sequencer continuously receives transactions submitted by users.
*   **Ordering:** Transactions are ordered based on the sequence in which they are received, maintaining a deterministic transaction order.
*   **Buffering:** Received transactions are temporarily stored in a buffer awaiting batch formation.

**Batch Formation Criteria:**

*   **Size Thresholds:** Batch formation occurs when accumulated transactions reach a predefined size limit. This limit ensures that the fixed costs of posting data to the parent chain are amortized over more transaction, improving cost efficiency.
*   **Time Constraints:** The Sequencer also monitors the time elapsed since the last posted batch to prevent undue delays. Upon reaching the maximum time threshold, the Sequencer will create a batch with the transactions collected so far, even if the batch doesn't meet the size threshold.

**Batch Creation Process:**

*   **Aggregation:** Once the batch formation criteria (the size or time threshold) are satisfied, the Sequencer aggregates the buffered transactions into a single batch.
*   **Metadata Inclusion:** The batch includes the necessary metadata of all transactions.
*   **Preparation for Compression:** Batch preparation for the compression stage begins, where techniques will minimize the data size before posting to parent chain.

This batching mechanism allows the Sequencer to efficiently manage transactions by balancing the need for cost-effective parent chain posting with the requirement for prompt transaction processing. By strategically grouping transactions into batches based on size and time criteria, the Sequencer reduces per-transaction costs and enhances the overall scalability of the Arbitrum network.

### Compression[​](#compression "Direct link to Compression")

The Sequencer employs compression when forming transaction batches to optimize the data and cost of batches posted to the parent chain. Arbitrum uses the Brotli compression algorithm due to its high compression ratio and efficiency, crucial for reducing parent chain posting costs.

![Compression](/img/haw-compression.svg)

### Compression level in the Brotli algorithm[​](#compression-level-in-the-brotli-algorithm "Direct link to Compression level in the Brotli algorithm")

Brotli’s compression algorithm includes a parameter: **compression level**, which ranges from **0 to 11**. This parameter allows you to balance two key factors:

*   **Compression Efficiency**: Higher levels result in greater size reduction.
*   **Computational Cost**: Higher levels require more processing power and time.

As the compression level increases, you achieve better compression ratios at the expense of longer compression times.

### Dynamic compression level setting[​](#dynamic-compression-level-setting "Direct link to Dynamic compression level setting")

The compression level on Arbitrum is dynamically adjusted based on the current backlog of batches waiting to be posted to parent chain by Sequencer. In scenarios where multiple batches are queued in the buffer, the **compression level** can be dynamically adjusted to improve throughput. When the buffer becomes overloaded with overdue batches, the compression level decreases.

This tradeoff prioritizes speed over compression efficiency, enabling faster processing and transmitting pending batches. Doing so, clears the buffer more quickly, ensuring smoother overall system performance.

Now that transactions are batched and compressed, they can be passed to batch-poster to be sent to the parent chain.

Submitting to the Sequencer Inbox Contract[​](#submitting-to-the-sequencer-inbox-contract "Direct link to Submitting to the Sequencer Inbox Contract")
------------------------------------------------------------------------------------------------------------------------------------------------------

After batching and compressing transactions, the Sequencer posts these batches to the parent chain to ensure security and finality. This process involves the **Batch Poster**, an Externally Owned Account (EOA) controlled by the Sequencer. The Batch Poster is responsible for submitting the compressed transaction batches to the **Sequencer Inbox Contract** on parent chain.

There are two primary methods the Sequencer uses to send batches to the parent chain, depending on whether the chain supports EIP-4844 (Proto-Danksharding) and the current network conditions:

![Submit to Sequencer inbox](/img/haw-submit-to-sequencer-inbox.svg)

### 1\. Using Blobs with `addSequencerL2BatchFromBlobs`[​](#1-using-blobs-with-addsequencerl2batchfromblobs "Direct link to 1-using-blobs-with-addsequencerl2batchfromblobs")

*   **Default Approach**: When the parent chain supports EIP-4844, the Sequencer utilizes blob transactions to post batches efficiently.
*   **Method**: The Batch Poster calls the `addSequencerL2BatchFromBlobs` function of the Sequencer Inbox Contract.
*   **Process**:
    *   Batch data gets included as blobs—large binary data structures optimized for scalability.
    *   The transaction includes metadata about the batch but does not include the batch data itself in the calldata.
*   **Benefits**:
    *   **Cost Efficiency**: Blobs allow cheaper data inclusion than calldata, reducing gas costs.
    *   **Scalability**: Leveraging blobs enhances the network's ability to handle large volumes of transactions.

### 2\. Using Calldata with `addSequencerL2Batch`[​](#2-using-calldata-with-addsequencerl2batch "Direct link to 2-using-calldata-with-addsequencerl2batch")

*   **Alternative Approach**: If the **Blob Base Fee** is significantly high or the blob space is constrained during batch posting, the Sequencer may opt to use calldata.
*   **Method**: The Batch Poster calls the `addSequencerL2Batch` function of the Sequencer Inbox Contract.
*   **Process**:
    *   The compressed batch transactions are included directly in the transaction's calldata.
*   **Considerations**:
    *   **Cost Evaluation**: The Sequencer dynamically assesses whether using calldata is more cost-effective than blobs based on current gas prices and blob fees.
    *   **Compatibility**: If the parent chain does not support EIP-4844, this method is the default and only option for batch posting.

note

The Sequencer continuously monitors network conditions to choose the most economical method for batch posting, ensuring optimal operation under varying circumstances.

### Authority and Finality[​](#authority-and-finality "Direct link to Authority and Finality")

*   **Exclusive Access**: Only the Sequencer can call these methods on the Sequencer Inbox Contract. This exclusivity ensures that no other party can directly include messages.
*   **Soft-Confirmation Receipts**: The Sequencer's unique ability to immediately process and include transactions allows it to provide users with instant, "soft-confirmation" receipts,
*   **Parent chain Finality**: Once batches post, the transactions achieve parent-chain-level finality, secured by Parent chain’s consensus mechanism.

By efficiently sending compressed transaction batches to the Sequencer Inbox Contract using the most cost-effective method available, the Sequencer ensures transactions are securely recorded on parent chain. This process maintains the integrity and reliability of the network, providing users with fast and secure transaction processing.

Finality[​](#finality "Direct link to Finality")
------------------------------------------------

Finality in blockchain systems refers to the point at which a transaction becomes irreversible and permanently included in the blockchain's ledger. In the context of Arbitrum's Nitro architecture, understanding finality is crucial for developers and users to make informed decisions about transaction confirmations, security guarantees, and application design.

Arbitrum offers two levels of finality:

1.  **Soft Finality**: Provided by the Sequencer's real-time feed, offering immediate but provisional transaction confirmations.
2.  **Hard Finality**: Occurs when transactions are included in batches posted to and finalized on the parent chain, providing strong security assurances.

This section explores the concepts of soft and hard finality, their implications, trust considerations, and guidance for utilizing them effectively within the Arbitrum network.

### Soft Finality[​](#soft-finality "Direct link to Soft Finality")

Soft finality refers to the preliminary confirmation of transactions based on the Sequencer's real-time feed. Key characteristics include:

*   **Immediate Confirmation**: Transactions are confirmed almost instantly as they are accepted and ordered by the Sequencer.
*   **Provisional Assurance**: The confirmations are provisional and rely on the Sequencer's integrity and availability.
*   **High Performance**: Enables applications to offer rapid responses and real-time interactions, enhancing user experience.

**Advantages of Soft Finality**:

*   **Low Latency**: Users receive immediate feedback on transaction status.
*   **Optimized for Speed**: Ideal for applications where responsiveness is critical.
*   **Improved User Experience**: Reduces waiting times and uncertainty.

**Limitations of Soft Finality**:

*   **Trust Dependency**: Relies on the Sequencer's honesty and ability to maintain uptime..
*   **Potential for Reordering**: In rare cases, if the Sequencer acts maliciously or encounters issues, the provisional ordering could change.
*   **Not Suitable for High-Value Transactions**: For transactions requiring strong security guarantees, soft finality may not suffice.

### Hard Finality[​](#hard-finality "Direct link to Hard Finality")

Hard finality occurs when batched transactions get posted to the parent chain. Key characteristics include:

*   **Strong Security Guarantees**: When included in blocks on the parent chain, transactions inherit the parent chain's security assurances.
*   **Irreversibility**: Once finalized, transactions are immutable and cannot be altered or reversed.
*   **Data Availability**: All transaction data is recorded on-chain, ensuring transparency and verifiability.

**Advantages of Hard Finality**:

*   **Maximum Security**: Protected by the robustness of the parent chain's consensus mechanism.
*   **Trust Minimization**: This does not require trust in the Sequencer; security comes from the underlying blockchain.
*   **Suitable for High-Value Transactions**: Ideal for scenarios where security and immutability are paramount.

**Limitations of Hard Finality**:

*   **Higher Latency**: Achieving hard finality takes longer due to the time required for the parent chain to process and finalize batches.
*   **Cost Considerations**: Posting batches to the parent chain incurs fees, which may affect transaction costs.

### Trust Considerations[​](#trust-considerations "Direct link to Trust Considerations")

Understanding the trust assumptions associated with each level of finality is essential:

*   **Soft Finality Trust Model**:
    *   **Reliance on the Sequencer**: Users must trust that the Sequencer operates honestly, sequences transactions correctly, and remains available.
    *   **Risk of Misbehavior**: If the Sequencer acts maliciously, it could reorder or censor certain transactions before they achieve hard finality.
*   **Hard Finality Trust Model**:
    *   **Reliance on the Parent Chain**: Security is based on the consensus and integrity of the parent chain.
    *   **Reduced Trust in Sequencer**: Even if the Sequencer misbehaves, transactions included in posted batches are secured once finalized on the parent chain.

### Application Implications[​](#application-implications "Direct link to Application Implications")

Developers and users should consider the appropriate level of finality based on their specific use cases:

*   **When to Rely on Soft Finality**:
    *   **Low-Risk Transactions**: For transactions where the potential impact of reordering or delays is minimal.
    *   **User Experience Priority**: Applications where responsiveness and immediacy enhance user engagement, such as gaming or social platforms.
    *   **Frequent Transactions**: Scenarios involving a high volume of small transactions where waiting for hard finality is impractical.
*   **When to Require Hard Finality**:
    *   **High-Value Transactions**: Financial transfers, large trades, or any transaction where security is critical.
    *   **Regulatory Compliance**: Situations requiring strict adherence to security standards and auditable records.
    *   **Centralized Exchanges (CeXs)**: For deposit and withdrawal operations where certainty of transaction finality is mandatory.

Censorship Timeout[​](#censorship-timeout "Direct link to Censorship Timeout")
------------------------------------------------------------------------------

As mentioned in the original [Arbitrum BoLD Forum Post](https://forum.arbitrum.foundation/t/aip-bold-permissionless-validation-for-arbitrum/23232/70?), the initial release of [Arbitrum BoLD](/how-arbitrum-works/bold/gentle-introduction) will come with a feature called ”Censorship Timeout” (originally called “Delay Buffer”). For Arbitrum One and Arbitrum Nova, it is proposed that this feature be enabled by default alongside BoLD’s upgrade.

Censorship Timeout aims to limit the negative effects of:

*   Prolonged sequencer censorship, and/or,
*   Unexpected sequencer outages.

### How the Censorship Timeout feature works[​](#how-the-censorship-timeout-feature-works "Direct link to How the Censorship Timeout feature works")

To explain how this feature improves the security of chains settling to Arbitrum One and Arbitrum Nova, consider the scenario where an L3’s parent chain sequencer (the L2 sequencer) is censoring or offline. In such a case, every assertion and/or sub-challenge move would need to wait 24 hours before bypassing the L2 sequencer (using the SequencerInbox’s forceInclusion method described here). In this scenario, challenge resolution would be delayed by a time `t` where `t = (24 hours) * number of moves for a challenge`. To illustrate with sample numbers, if a challenge takes 50 sequential moves to resolve, then the delay would be 50 days.

The Censorship Timeout feature mitigates this by decreasing the force inclusion threshold when unexpected delays in delayed message inclusion occur due to one (or all) of the above mentioned cases of censorship or sequencer outage, enabling entities to make moves without the 24 hour delay-per-move.

The force inclusion window is actually the lesser of either the `delayBuffer` and `delayBlocks`, where delayBlocks is a constant, currently set to 24 hours, and `delayBuffer` grows and shrinks between 30 minutes and 48 hours.

The `delayBuffer` value "grows and shrinks" depending on how long the sequencer is offline or censoring transactions. As a way to measure this behavior, the `delayBuffer` is decremented by the difference between a delayed message's delay beyond the `threshold` and how long it has been delayed (i.e. when some delayed messages are delayed by more than the `threshold`, the difference between the messages' delay and the `threshold` is removed from the buffer). As an example, if the `threshold` is 30 minutes and a message was delayed by 32 minutes, then the `delayBuffer` is decremented by 2 minutes. The `threshold` is set to 30 minutes on Arbitrum One and 1 hour on Arbitrum Nova.

The `delayBuffer` replenishes at a linear rate when the sequencer is operating correctly at a nominal rate of 1 minute for every 20 minutes of time where no messages are delayed beyond the `threshold`.

Below are the initial, proposed parameter values for the Censorship Timeout feature for Arbitrum One and Arbitrum Nova:

*   `delay buffer` = 14400 L1 Ethereum blocks (2 days)
*   `threshold` = 150 L1 Ethereum blocks (30 minutes) for Arbitrum One and 300 L1 Ethereum blocks (1 hour) for Arbitrum Nova
*   `replenish rate` = 5% (meaning 1 day is replenished every 20 days or roughly a 95% uptime)

We believe that the Censorship Timeout feature provides stronger guarantees of censorship resistance for Arbitrum chains - especially those that settle to Arbitrum One or Arbitrum Nova. As always, chain owners can decide whether to utilize this feature for their chain and can also change the default parameters as they see fit for their use case.

### Decentralized Fair Sequencing[​](#decentralized-fair-sequencing "Direct link to Decentralized Fair Sequencing")

Arbitrum’s long-term vision includes transitioning from a centralized Sequencer to a decentralized, fair sequencing model. In this framework, a committee of servers (or validators) collectively determines transaction ordering, ensuring fairness, reducing the influence of any single party, and making it more resistant to manipulation. By requiring a supermajority consensus, this approach distributes sequencing power among multiple honest participants, mitigates the risks of front-running or censorship, and aligns with the broader blockchain principles of enhanced security, transparency, and decentralization.

---

# A gentle Introduction: Timeboost | Arbitrum Docs

## A gentle Introduction: Timeboost

This introduction will walk you through : a novel  for Arbitrum chains that allows chain owners to capture the Maximal Extractable Value (MEV) on their chain and reduce spam, all while preserving fast block times and protecting users from harmful types of MEV, such as sandwich attacks and front-running.

Timeboost is the culmination of over a year of research and development by the team at Offchain Labs and will soon be available for any Arbitrum chain, including Arbitrum One and Arbitrum Nova (should the Arbitrum DAO choose to adopt it). Like all features and upgrades to the Arbitrum technology stack, Timeboost will be rolled out on Arbitrum Sepolia first for testing, and chain owners will have the option of adopting Timeboost at any time or customizing Timeboost in any way they choose.

### In a nutshell[​](#in-a-nutshell "Direct link to In a nutshell")

*   The current  ordering policy has many benefits, including a great UX and protection from harmful types of MEV. However, nearly all MEV on the chain is extracted by searchers who invest wastefully in hardware and spamming to win latency races (which negatively strains the network and leads to congestion). Timeboost is a new transaction ordering policy that preserves many of the great benefits of FCFS while unlocking a path for chain owners to capture some of the available MEV on their network and introducing an auction to reduce latency, racing, and, ultimately, spam.
*   Timeboost introduces a few new components to an Arbitrum chain's infrastructure: a sealed-bid second-price auction and a new  at an Arbitrum chain's sequencer. Valid transactions submitted to the express lane will be sequenced immediately with no delay, while all other transactions submitted to the chain's sequencer will experience a nominal delay (default: 200ms). The auction winner is granted the sole right to control the express lane for pre-defined, temporary intervals. The default block time for Arbitrum chains will continue to be industry-leading at 250ms, even with Timeboost enabled. What will change with Timeboost is that some transactions not in the express lane will be delayed to the next block.
*   Timeboost is an optional feature for Arbitrum chains aimed at two types of groups of entities: (1) chain owners and their ecosystems and (2) sophisticated on-chain actors and searchers. Chain owners can use Timeboost to capture additional revenue from the MEV their chain generates already, and sophisticated on-chain actors and searchers will spend their resources on buying rights for the express lane (instead of spending those resources on winning latency races, which otherwise leads to spam and congestion on the network).
*   Timeboost will work with both centralized and [decentralized sequencer setups](https://medium.com/@espressosys/espresso-systems-and-offchain-labs-publish-decentralized-timeboost-specification-b29ff20c5db8). The specification for a centralized sequencer is public ([here](https://github.com/OffchainLabs/timeboost-design)) and the [proposal before the Arbitrum DAO](https://forum.arbitrum.foundation/t/constitutional-aip-proposal-to-adopt-timeboost-a-new-transaction-ordering-policy/25167/1) allows us to deliver Timeboost to market sooner, rather than waiting until the design with a decentralized sequencer set up and its implementation are complete.

Why do Arbitrum chains need Timeboost?[​](#why-do-arbitrum-chains-need-timeboost "Direct link to Why do Arbitrum chains need Timeboost?")
-----------------------------------------------------------------------------------------------------------------------------------------

Today, Arbitrum chains order incoming transactions on a  basis. This ordering policy was chosen as the default for Arbitrum chains because it is simple to understand and implement, enables fast block times (starting at 250ms and down to 100ms if desired), and protects users from harmful types of MEV like front-running & sandwich attacks.

However, there are a few downsides to an FCFS ordering policy. Under FCFS, searchers are incentivized to participate in and try to win latency races through investments in off-chain hardware. This means that for searchers on Arbitrum chains, generating a profit from arbitrage and liquidation opportunities involves a lot of spam, placing stress on chain infrastructure and contributing to congestion. Additionally, all of the captured MEV on an Arbitrum chain today under FCFS goes to searchers - returning none of the available MEV to the chain owner or the applications on the chain.

Timeboost retains most FCFS benefits while addressing FCFS limitations.

#### Timeboost preserves the great UX that Arbitrum chains are known for[​](#timeboost-preserves-the-great-ux-that-arbitrum-chains-are-known-for "Direct link to Timeboost preserves the great UX that Arbitrum chains are known for")

*   The default block time for Arbitrum chains will continue to be industry-leading at 250ms, even after Timeboost. What will change with Timeboost is that some transactions not in the express lane will be delayed to the next block.

#### With Timeboost, Arbitrum chains will continue to protect users from harmful types of MEV[​](#with-timeboost-arbitrum-chains-will-continue-to-protect-users-from-harmful-types-of-mev "Direct link to With Timeboost, Arbitrum chains will continue to protect users from harmful types of MEV")

*   Timeboost only grants the auction winner a _temporary time advantage_ - not the power to view or reorder incoming transactions or be the first in every block. Furthermore, the transactions mempool will continue to be private, which means users with Timeboost enabled will continue to be protected from harmful MEV-like front-running and sandwich attacks.

#### Timeboost unlocks a new value accrual path for chain owners[​](#timeboost-unlocks-a-new-value-accrual-path-for-chain-owners "Direct link to Timeboost unlocks a new value accrual path for chain owners")

*   Chain owners may use Timeboost to capture a portion of the available MEV on their chain that would have otherwise gone entirely to searchers. There are many flavors of this, too - including custom gas tokens and/or redistribution of these proceeds back to the applications and users on the chain.

#### Timeboost may help reduce spam and congestion on a network[​](#timeboost-may-help-reduce-spam-and-congestion-on-a-network "Direct link to Timeboost may help reduce spam and congestion on a network")

*   By introducing the ability to "purchase a time advantage" through the Timeboost auction, it is expected that rational, profit-seeking actors will spend on auctions _instead of_ investing in hardware or infrastructure to win latency races. This diversion of resources by these actors is expected to reduce FCFS MEV-driven spam on the network.

What is Timeboost, and how does it work?[​](#what-is-timeboost-and-how-does-it-work "Direct link to What is Timeboost, and how does it work?")
----------------------------------------------------------------------------------------------------------------------------------------------

Timeboost is a _transaction ordering policy_. It's a set of rules that the sequencer of an Arbitrum chain is trusted to follow when ordering transactions submitted by users. In the near future, multiple sequencers will be able to enforce those rules with decentralized Timeboost.

For Arbitrum chains, the sequencer's sole job is to take arriving, valid transactions from users, place them into an order dictated by the transaction ordering policy, and then publish the final sequence to a real-time feed and in compressed batches to the chain's data availability layer. The current transaction ordering policy is FCFS, and Timeboost is a modified FCFS ordering policy.

Timeboost is implemented using three separate components that work together:

*   **A special "express lane"** which allows valid transactions to be sequenced as soon as the sequencer receives them for a given round.
*   **An off-chain auction** to determine the controller of the express lane for a given round. This auction is managed by an .
*   **An ** deployed on the target chain to serve as the canonical source of truth for the auction results and handling of auction proceeds.

To start, the default duration of a round is 60 seconds. Transactions not in the express lane will be subject to a default 200-millisecond artificial delay to their arrival timestamp before their transaction is sequenced, which means that some non-express lane transactions may get delayed to the next block. It's important to note that the default Arbitrum block time will remain at 250 milliseconds (which can be adjusted to 100 milliseconds if desired). Let's dive into how each of these components works.

### The express lane[​](#the-express-lane "Direct link to The express lane")

![Using the express lane](/img/timeboost-centralized-timeboost-express-lane-workflow.jpg)

The express lane is implemented using a special endpoint on the sequencer, formally titled `timeboost_sendExpressLaneTransaction`. This endpoint is special because transactions submitted to it will be sequenced immediately by the sequencer, hence the name, express lane. The sequencer will only accept valid transaction payloads to this endpoint if they are correctly signed by the current round's . Other transactions can still be submitted to the sequencer as normal, but these will be considered non-express lane transactions and will, therefore, have their arrival timestamp delayed by 200 milliseconds. It is important to note that transactions from both the express and non-express lanes are eventually sequenced into a single, ordered stream of transactions for node operators to produce an assertion and later post the data to a data availability layer. The express lane controller does _not_:

*   Have the right to re-order transactions.
*   Have a guarantee that their transactions will always be first at the "top-of-the-block."
*   Guarantee a profit at all.

The value of the express lane will be the sum of how much MEV the express lane controller predicts they can extract during the upcoming round (i.e., MEV opportunity estimates made before the auction closes) _plus_ the amount of MEV extracted by the express lane controller while they are in control (that they otherwise did not predict). Understanding how the value of the express lane is determined can be useful for chain owners when adjusting to the artificial delay and the time before the auction closes.

### The Timeboost auction[​](#the-timeboost-auction "Direct link to The Timeboost auction")

![Timeboost auction workflow](/img/timeboost-centralized-timeboost-auction-workflow.jpg)

Control of the express lane in each round (default: 60 seconds) is determined by a per-round auction, which is a sealed-bid, second-price auction. This auction is held to determine the express lane controller for the next round. In other words, the express lane controller was determined at any point in time in the previous auction round. Bids for the auction can be made with any ERC20 token, in any amount, and be collected by any address - at the full discretion of the chain owner.

The auction for a round has a closing time that is `auctionClosingSeconds` (default: 15) seconds before the beginning of the round. This means that, in the default parameters, parties have 45 seconds to submit bids before the auction will no longer accept bids. In the 15 seconds between when bids are no longer accepted and when the new round begins, the autonomous auctioneer will verify all bids, determine the winner, and make a call to the on-chain auction contract to formally resolve the auction.

### Auction contract[​](#auction-contract "Direct link to Auction contract")

Before placing a bid in the auction, a party must deposit funds into the Auction Contract. Deposits can be made, or funds can be added to an existing deposit at any time. These deposits are fully withdrawable, with some nominal delay (2 rounds or 2 minutes by default), so as not to impact the outcome of an existing round. There is no minimum deposit amount, but there is a starting minimum bid of 0.001 ETH (default amount and token) called the "minimum reserve price". The chain owner sets the minimum reserve price, which can be updated at any time up to 30 seconds (default) before the start of the next round to ensure the auction participants will always know the reserve price at least 30 seconds before they must submit their bids. A reserve price can also be set by the chain owner (or by an address designated by the chain owner) as a way to raise the minimum bid, as the Auction Contract enforces that the reserve price is never less than the minimum reserve price.

Once the autonomous auctioneer determines an auction winner, the auction contract will deduct the second-highest bid amount from the account of the highest bidder and transfer those funds to a `beneficiary` account designated by the chain owner by default. The `expressLaneControllerAddress` specified in the highest bid will become the express lane controller for the round.

### Default parameters[​](#default-parameters "Direct link to Default parameters")

Below are a few of the default Timeboost parameters mentioned earlier. All these parameters and more are configurable by the chain owner.

Parameter name

Description

Recommended default value

`roundDurationSeconds`

Duration of time that the sequencer will honor the express lane privileges for transactions signed by the current round's express lane controller.

60 seconds

`auctionClosingSeconds`

Time before the start of the next round. The autonomous auctioneer will not accept bids during this time interval.

15 seconds

`beneficiary`

Address where proceeds from the Timeboost auction are sent to when `flushBeneficiaryBalance()` gets called on the auction contract.

An address controlled by the chain's owner

`_biddingToken`

Address of the token used to make bids in the Timeboost auction. It can be any ERC20 token (assuming the token address chosen does not have fee-on-transfer, rebasing, transfer hooks, or otherwise non-standard ERC20 logic).

WETH

`nonExpressDelayMsec`

The artificial delay applied to the arrival timestamp of non-express lane transactions _before_ the non-express lane transactions are sequenced.

0.2 seconds, or 200 milliseconds

`reservePrice`

The minimum bid amount accepted by the auction contract for Timeboost auctions, denominated in `_biddingToken`.

None

`_minReservePrice`

A value that must be equal to or below the `reservePrice` to act as a "floor minimum" for Timeboost bids. Enforced by the auction contract.

0.001 `WETH`

Who is Timeboost for, and how do I use it?[​](#who-is-timeboost-for-and-how-do-i-use-it "Direct link to Who is Timeboost for, and how do I use it?")
----------------------------------------------------------------------------------------------------------------------------------------------------

Timeboost is an optional addition to an Arbitrum chain's infrastructure, meaning that enabling Timeboost is at the discretion of the chain owner and that an Arbitrum chain can fully function normally without Timeboost.

When enabled, Timeboost is meant to serve different groups of parties with varying degrees of impact and benefits. Let's go through them below:

#### For regular users:[​](#for-regular-users "Direct link to For regular users:")

Timeboost will have a minimal impact. Non-express lane transactions will be delayed by a nominal 200ms, which means to the average user, their transactions will take approximately 450ms to be sequenced and included into a block (up from approximately 200ms). All users will remain protected from harmful MEV activity, such as sandwich attacks and front-running, through the continued use of a private mempool.

#### For chain owners:[​](#for-chain-owners "Direct link to For chain owners:")

Timeboost represents a unique way to accrue value to their token and generate revenue for the chain. Explicitly, chain owners can set up their Timeboost auction to collect bid proceeds in the same token used for gas on their network and then choose what to do with these proceeds afterward.

#### For searchers/arbitrageurs:[​](#for-searchersarbitrageurs "Direct link to For searchers/arbitrageurs:")

Timeboost adds a unique twist to your existing or prospective MEV strategies that may become more profitable than before. For instance, purchasing the time advantage offered by Timeboost's auction may end up costing _less_ than the costs to invest in hardware and win latency races. Another example is the potential new business model of reselling express lane rights to other parties in time slots or on a granular, per-transaction basis.

### Special note on Timeboost for chain owners[​](#special-note-on-timeboost-for-chain-owners "Direct link to Special note on Timeboost for chain owners")

As with many new features and upgrades to Arbitrum Nitro, Timeboost is an optional feature that chain owners may choose to deploy and customize however they see fit. Deploying and enabling/disabling Timeboost on a live Arbitrum chain will not halt or impact the chain but will instead influence the chain's transaction ordering policy. An Arbitrum chain will, by default, fall back to FCFS if Timeboost is deployed but disabled or if there is no express lane controller for a given round.

It is recommended that Arbitrum teams holistically assess the applicability and use cases of Timeboost for their chain before deploying and enabling Timeboost. This is because some Arbitrum chains may not have that much MEV (e.g., arbitrage) to begin with. Furthermore, we recommend that Arbitrum chains start with the default parameters recommended by Offchain Labs and closely monitor the results and impacts on your chain's ecosystem over time before considering adjusting any of the parameters.

### Wen mainnet?[​](#wen-mainnet "Direct link to Wen mainnet?")

Timeboost's auction contract has completed a third-party audit and is rapidly approaching production readiness. Specifically for Arbitrum One and Arbitrum Nova, a [temperature check vote on Snapshot](https://snapshot.box/#/s:arbitrumfoundation.eth/proposal/0xffe9bb38228fdaf3d121140856fd2d51c2ca7f8e0d1021c07e791cebb541129a) has already passed and the AIP will move towards an on-chain Tally vote next hopefully before the end of Q1 2025.

In the meantime, please read the following resources to learn more about Timeboost:

*   [Arbitrum DAO Forum Post on Timeboost](https://forum.arbitrum.foundation/t/constitutional-aip-proposal-to-adopt-timeboost-a-new-transaction-ordering-policy/25167/86)
*   [Timeboost FAQ](https://www.notion.so/bba234acf92e476b8ca5db6855d7da45?pvs=21)
*   [Debunking common misconceptions about Timeboost](https://medium.com/offchainlabs/debunking-common-misconceptions-about-timeboost-92d937568494)
*   [Technical specification for Timeboost with a centralized sequencer](https://github.com/OffchainLabs/timeboost-design/blob/main/research_spec.md)
*   [Engineering design of Timeboost with a centralized sequencer](https://github.com/OffchainLabs/timeboost-design/blob/main/implementation_design.md)
*   [Implementation of Timeboost with a centralized sequencer](https://github.com/OffchainLabs/nitro/pull/2561)
*   [Technical specification for Timeboost with a decentralized sequencer](https://github.com/OffchainLabs/decentralized-timeboost-spec)
*   [Audit report for Timeboost auction contracts](https://github.com/trailofbits/publications/blob/master/reviews/2024-08-offchainlabs-timeboost-auction-contracts-securityreview.pdf)

---

# Sequencing, Followed by Deterministic Execution | Arbitrum Docs

## Sequencing, Followed by Deterministic Execution

This section explores the various methods users can employ to submit transactions for inclusion on the  chain. We discuss the different pathways available—sending transactions to the  or bypassing it by submitting transactions through the  contract on the . By outlining these options, we aim to clarify how users can interact with the network, detail the processes involved in each method, and identify the modules responsible for handling these transactions. This overview will enhance your understanding of the initial steps in Arbitrum ecosystem's  lifecycle and prepare you for a detailed exploration of transaction inclusion mechanisms in the subsequent sections.

The first subsection, [Submitting Transactions to the Sequencer](#submitting-transactions-to-the-sequencer), presents four different methods users can utilize to send their transactions to the sequencer: via Public RPC, Third-Party RPC, Arbitrum Nodes, and the Sequencer Endpoint. Transactions sent through the first three pathways will route through our Load Balancer before reaching the sequencer. In contrast, the Sequencer Endpoint allows transactions to bypass the Load Balancer and be sent directly to the sequencer.

The second subsection, [Bypassing the Sequencer](#bypassing-the-sequencer), describes an alternative method where users can include their transactions on the  without relying on the sequencer. By sending transactions directly to the delayed inbox contract on the parent chain (L1), users gain additional flexibility, ensuring that their transactions can be processed even if the sequencer is unavailable or if they prefer not to use it.

This diagram illustrates the various pathways for submitting transactions to the Arbitrum chain. It highlights the options for sending transactions through the sequencer or bypassing it and using the delayed inbox contract on the parent chain.

![Transaction lifecycle diagram showing various pathways for submitting transactions](/img/haw-transaction-lifecycle.svg)

Submitting transactions to the Sequencer[​](#submitting-transactions-to-the-sequencer "Direct link to Submitting transactions to the Sequencer")
------------------------------------------------------------------------------------------------------------------------------------------------

This section outlines the different methods for users to submit transactions to the sequencer on the Arbitrum chain. There are four primary ways to do this: Public RPC, Third-Party RPCs, Arbitrum Nodes, and the Sequencer Endpoint. We will explore these methods in detail, explaining when to choose one over the other and how to use each to effectively submit transactions to the Arbitrum sequencer.

### 1\. Public RPC[​](#1-public-rpc "Direct link to 1. Public RPC")

Arbitrum provides public RPCs for its main chains: , , and Arbitrum Sepolia. Due to their rate-limited nature, these RPC endpoints are suitable for less resource-intensive operations. Public RPCs can be an accessible option for general use cases and light interactions with the network.

For more details on the specific RPC endpoints for each chain, please see [this section](https://docs.arbitrum.io/build-decentralized-apps/reference/node-providers#arbitrum-public-rpc-endpoints) of the documentation.

### 2\. Third-Party RPC[​](#2-third-party-rpc "Direct link to 2. Third-Party RPC")

Users also have the option to interact with Arbitrum's public chains using third-party node providers. These providers are often the same popular ones used for Ethereum, making them reliable choices for resource-intensive operations. We recommend using these third-party providers when performance and scalability are critical.

You can find a list of supported third-party providers [here](https://docs.arbitrum.io/build-decentralized-apps/reference/node-providers#third-party-rpc-providers).

### 3\. Arbitrum Nodes[​](#3-arbitrum-nodes "Direct link to 3. Arbitrum Nodes")

Another approach for sending transactions to the sequencer is through self-hosted Arbitrum nodes. Running a node gives you direct control over your transactions, which go to the sequencer via the .

Please see the [Arbitrum Node](https://docs.arbitrum.io/run-arbitrum-node/overview) documentation to learn more about setting up and running a node.

### 4\. Sequencer Endpoint[​](#4-sequencer-endpoint "Direct link to 4. Sequencer Endpoint")

The Sequencer Endpoint is the most direct method for users looking to minimize delays in their transactions reaching the sequencer. Unlike standard RPC URLs, the Sequencer Endpoint supports only `eth_sendRawTransaction` and `eth_sendRawTransactionConditional` calls, bypassing the load balancer entirely. This endpoint makes it an optimal choice for users who require the quickest transaction processing time.

The diagram below shows different ways to submit transactions to the sequencer:

![Submit transaction to the Sequencer](/img/haw-submit-tx-to-sequencer.svg)

Bypassing the Sequencer[​](#bypassing-the-sequencer "Direct link to Bypassing the Sequencer")
---------------------------------------------------------------------------------------------

This section delves into an alternative method for submitting transactions to the Arbitrum chain, bypassing the sequencer. This page focuses on how users can send their transactions directly to the delayed inbox contract on the parent chain rather than through the sequencer. This method offers two distinct paths a transaction can take, with each route interacting with the network differently to achieve transaction inclusion. This approach provides users with greater flexibility and ensures that transactions can still be processed if the sequencer is unavailable or if users choose not to depend on it. This section highlights these alternative submission mechanisms and underscores the robustness and decentralization features inherent in the Arbitrum network.

In **Diagram 3**, we demonstrate how users can submit their transactions using the delayed inbox contract to bypass the sequencer. As illustrated in the diagram, there are two possible paths for transaction handling. When a transaction is submitted to the delayed inbox, the sequencer may automatically pick it up, include it as an ordered transaction, and send it to the sequencer feed. However, if the sequencer does not process the transaction within 24 hours, users have the reliable option to call the `forceInclude` function on the sequencer inbox contract. This action ensures that the sequencer to picks up the transaction and includes it in the ordered transaction list, providing users with a sense of security about their transactions.

![Bypassing the Sequencer](/img/haw-bypassing-the-sequencer.svg)

To send a transaction to the delayed inbox instead of submitting it to the sequencer, users can construct their transaction and then call the [`sendL2Message`](https://github.com/OffchainLabs/nitro-contracts/blob/fbbcef09c95f69decabaced3da683f987902f3e2/src/bridge/AbsInbox.sol#L150) function, passing the data of the serialized signed transaction as an argument. This function allows users to send a generic child chain messages to the chain, suitable for any message that does not require parent chain validation.

If the sequencer is not back online within 24 hours or decides to censor the transaction, users can invoke the [`forceInclusion`](https://github.com/OffchainLabs/nitro-contracts/blob/fbbcef09c95f69decabaced3da683f987902f3e2/src/bridge/SequencerInbox.sol#L284) function on the SequencerInbox contract. This action ensures their transaction is included on the chain, bypassing the sequencer's role.

Additionally, the Arbitrum SDK provides the [`InboxTools`](https://github.com/OffchainLabs/arbitrum-sdk/blob/792a7ee3ccf09842653bc49b771671706894cbb4/src/lib/inbox/inbox.ts#L64C14-L64C24) class, which simplifies the process of submitting transactions to the delayed inbox. Users can utilize the [`sendChildSignedTx`](https://github.com/OffchainLabs/arbitrum-sdk/blob/792a7ee3ccf09842653bc49b771671706894cbb4/src/lib/inbox/inbox.ts#L401C16-L401C33) method to send the transaction and the [`forceInclude`](https://github.com/OffchainLabs/arbitrum-sdk/blob/792a7ee3ccf09842653bc49b771671706894cbb4/src/lib/inbox/inbox.ts#L367) method to ensure its inclusion. The SDK also offers helper methods like [`signChildTx`](https://github.com/OffchainLabs/arbitrum-sdk/blob/792a7ee3ccf09842653bc49b771671706894cbb4/src/lib/inbox/inbox.ts#L429) to assist with signing the transaction during the creation of the serialized signed transaction hex string, streamlining the entire process.

---

# A gentle introduction to Arbitrum | Arbitrum Docs

## A gentle introduction to Arbitrum

#### Q: Hello! What’s Arbitrum?[​](#q-hello-whats-arbitrum "Direct link to Q: Hello! What’s Arbitrum?")

Hi!  is a technology suite designed to scale Ethereum. You can use Arbitrum chains to do all things you do on Ethereum — use Web3 apps, deploy smart contracts, etc., but your transactions will be cheaper and faster. Our flagship product — Arbitrum Rollup — is an Optimistic rollup protocol that inherits Ethereum-level security.

#### Q: What, what’s “Ethereum”? What's a “smart contract”? Where am I?[​](#q-what-whats-ethereum-whats-a-smart-contract-where-am-i "Direct link to Q: What, what’s “Ethereum”? What's a “smart contract”? Where am I?")

If you aren’t yet familiar with the Ethereum ecosystem, you can check out [ethereum.org](https://ethereum.org/en/learn/) for an intro. Come back whenever you're ready, no rush.

#### Q: You said Arbitrum exists to “scale” Ethereum; why does Ethereum need this help? Is there something wrong with Ethereum?[​](#q-you-said-arbitrum-exists-to-scale-ethereum-why-does-ethereum-need-this-help-is-there-something-wrong-with-ethereum "Direct link to Q: You said Arbitrum exists to “scale” Ethereum; why does Ethereum need this help? Is there something wrong with Ethereum?")

Ethereum is awesome; on its own, however, it’s also very limited. The Ethereum  only allows about 20-40 transactions per second (TPS) (that’s in total, for all Ethereum users); when the limit is reached, users are forced to compete against each other for their transactions to be included, which causes fees to go up.

#### Q: Why does Ethereum have such low TPS?[​](#q-why-does-ethereum-have-such-low-tps "Direct link to Q: Why does Ethereum have such low TPS?")

This was a deliberate decision in Ethereum’s design. Ethereum requires that its nodes (computers running the Ethereum software) have a way of coming to consensus on the current state of things; the way they do this is by processing every  in Ethereum’s history; i.e., if you’ve ever used Ethereum, every Ethereum full node has a copy of your transactions in its blockchain ledger.

One of the Ethereum community’s precepts, being an open, decentralized, peer to peer system, is that it should be reasonably accessible for anyone to run an Ethereum node and validate the chain for themselves; i.e., if it gets too expensive (in terms of hardware requirements / computational resources), this undercuts the fundamental goal of decentralization. The combination of these two factors — every node has to process every transaction, and we want it to be relatively feasible to run a node — means Ethereum transaction throughput has to be capped fairly low.

#### Q: And Arbitrum Rollup fixes this?[​](#q-and-arbitrum-rollup-fixes-this "Direct link to Q: And Arbitrum Rollup fixes this?")

Arbitrum rollup fixes this! The basic idea is this: an  runs as a sort of sub-module within Ethereum. Unlike regular, layer 1 ( “L1”) Ethereum transactions, we don’t require Ethereum nodes to process every Arbitrum transaction; rather, Ethereum adopts an [“innocent until proven guilty"](https://insights.deribit.com/market-research/making-sense-of-rollups-part-2-dispute-resolution-on-arbitrum-and-optimism/) attitude to Arbitrum. Layer 1 initially “optimistically assumes” activity on Arbitrum is following the proper rules. If a violation occurs (i.e., somebody claims “now I have all of your money”), this claim can be disputed back on L1; fraud will be proven, the invalid claim disregarded, and the malicious party will be financially penalized.

This ability to adjudicate and prove fraud on L1 is Arbitrum’s key, fundamental feature, and is how and why the system inherits Ethereum’s security.

#### Q: So we can use Ethereum to prove fraud on Arbitrum; cool! But if fraud is committed, can we be absolutely sure that we'll be able to prove it?[​](#q-so-we-can-use-ethereum-to-prove-fraud-on-arbitrum-cool-but-if-fraud-is-committed-can-we-be-absolutely-sure-that-well-be-able-to-prove-it "Direct link to Q: So we can use Ethereum to prove fraud on Arbitrum; cool! But if fraud is committed, can we be absolutely sure that we'll be able to prove it?")

Yes, indeed we can be. This is where the “rollup” part comes in. The data that gets fed into an Arbitrum Rollup chain (i.e., user’s transaction data) is posted directly on Ethereum. Thus, as long as Ethereum itself is running securely, anybody who’s interested has visibility into what’s going on in Arbitrum, and has the ability to detect and prove fraud.

#### Q: Who actually does this work (of checking for fraud, proving it, etc?)[​](#q-who-actually-does-this-work-of-checking-for-fraud-proving-it-etc "Direct link to Q: Who actually does this work (of checking for fraud, proving it, etc?)")

The parties who move the Arbitrum chain state forward on L1 — i.e., making claims about the chain’s state, disputing other’s claims, etc. — are called validators. In practice, we don’t expect the average Arbitrum user to be interested in running a validator, just like the average Ethereum user typically doesn’t run their own layer 1 staking node. The crucial property, however, is that anybody can; becoming an Arbitrum validator requires no special permission ([once the allowlist is lifted](https://docs.arbitrum.foundation/state-of-progressive-decentralization)), only that a user runs the [open source validator software](https://github.com/OffchainLabs/nitro) (and stakes Ether when/if they need to take action).

Additionally, as long as there’s even just one honest validator, the chain will remain secure; i.e., it only takes one non-malicious fraud-prover to catch any number of malicious trouble-makers. These properties together make the system “trustless”; users are not relying on any special designated party for their funds to be secure.

#### Q: And how exactly is “fraud” “proven”? Sounds complicated.[​](#q-and-how-exactly-is-fraud-proven-sounds-complicated "Direct link to Q: And how exactly is “fraud” “proven”? Sounds complicated.")

Oh, it’s not so bad. In essence, if two validators disagree, only one of them (at most) can be telling the truth. In a dispute, the two validators play an interactive, call-and-response game in which they narrow down their dispute to a single computational step (think of something small and simple, like multiplying two numbers). This one step gets executed on L1 and will necessarily prove that the honest party was telling the truth. For a more detailed rundown, see [here](/how-arbitrum-works/interactive-fraud-proofs).

#### Q: This dispute game obviously takes some time; does this impose any sort of delay on Arbitrum users' transactions?[​](#q-this-dispute-game-obviously-takes-some-time-does-this-impose-any-sort-of-delay-on-arbitrum-users-transactions "Direct link to Q: This dispute game obviously takes some time; does this impose any sort of delay on Arbitrum users' transactions?")

The only delay that's felt by a user is in "withdrawing" — moving their funds from Arbitrum back to Ethereum; if users are withdrawing directly from Arbitrum to Ethereum, they must typically wait 1 week before receiving their funds on L1. If users use a fast- application, however, they can bypass this delay period entirely (likely for a small fee). Anything else a user does — i.e., depositing funds from Ethereum onto Arbitrum, or using a  deployed on an Arbitrum chain — doesn't incur this delay period.

#### Q: Okay, so backing up: the “optimistic execution” part is how and why Arbitrum is able to offer low fees, yes?[​](#q-okay-so-backing-up-the-optimistic-execution-part-is-how-and-why-arbitrum-is-able-to-offer-low-fees-yes "Direct link to Q: Okay, so backing up: the “optimistic execution” part is how and why Arbitrum is able to offer low fees, yes?")

Primarily, yes, this is the heart of where the savings come from. However, there are a number of other means by which Arbitrum alleviates the burden on L1, all of which translate to lower transaction costs for end users. For one, Arbitrum transactions are submitted on the L1 in batches; typically, a single  (submitted in a single L1 transaction) will contain several hundred L2 transactions. Batching amortizes the overhead cost of interacting with the L1, and thus offers significant savings over posting individual transactions at a time. Furthermore, the transaction data is posted on L1 in compressed form (and only decompressed within the L2 environment), further minimizing the transaction’s L1 footprint.

#### Q: As far as the experience of using Arbitrum: when you said that it’s very similar to using Ethereum…[​](#q-as-far-as-the-experience-of-using-arbitrum-when-you-said-that-its-very-similar-to-using-ethereum "Direct link to Q: As far as the experience of using Arbitrum: when you said that it’s very similar to using Ethereum…")

We really meant it, yes. Different layer 2 protocols emphasize and optimize for different things; Arbitrum was created with Ethereum compatibility as a top priority. This means users can use Arbitrum with all their favorite Ethereum wallets; developers can build and deploy contracts with all their favorite Ethereum libraries and tooling; in fact, most of the time, the experience of using Arbitrum will feel identical to that of using Ethereum (with the important exception of it being much cheaper and faster).

Much development went into achieving this level of Ethereum compatibility. But at its core: the Arbitrum itself uses a fork of [Geth](/how-arbitrum-works/geth-at-the-core) — the most widely used Ethereum implementation — with modifications to transform it into a trustless layer 2. This means most of the code running in Arbitrum is identical to the code running in Ethereum. We call this cutting-edge approach Nitro (developers can see the codebase [here](https://github.com/OffchainLabs/nitro)).

#### Q: So builders can do all the stuff they do on Ethereum on Arbitrum, nice! But can they do _more_?[​](#q-so-builders-can-do-all-the-stuff-they-do-on-ethereum-on-arbitrum-nice-but-can-they-do-more "Direct link to q-so-builders-can-do-all-the-stuff-they-do-on-ethereum-on-arbitrum-nice-but-can-they-do-more")

They can; the latest version of the Arbitrum tech stack, called , keeps Nitro's Ethereum compatibility, while adding on powerful new features, namely the ability to write highly performant smart contracts in programming languages like Rust, C++, and more.  is currently on public testnet; you can read more about it [here](/stylus/gentle-introduction).

#### Q: So it sounds like Arbitrum Rollup is an ideal solution that solves any and all scaling problems…?[​](#q-so-it-sounds-like-arbitrum-rollup-is-an-ideal-solution-that-solves-any-and-all-scaling-problems "Direct link to Q: So it sounds like Arbitrum Rollup is an ideal solution that solves any and all scaling problems…?")

Arbitrum Rollup is very awesome and cool; its design is geared heavily toward avoidance of introducing any centralization or trust assumptions, and it is thus a clear, strict net-win for the Ethereum ecosystem. Decentralization, however, comes at a (literal) price, and not all applications and users necessarily want or need to pay that price. For dapp use-cases with different security considerations, different tools in the Arbitrum suite are appropriate; i.e., Arbitrum AnyTrust chains!

#### Q: What’s an AnyTrust chain?[​](#q-whats-an-anytrust-chain "Direct link to Q: What’s an AnyTrust chain?")

An  doesn’t have the same decentralization / trustlessness / permissionless security guarantees of a Rollup chain, and thus can offer lower fees. Rollup and AnyTrust are similar in many ways, though have one key difference: whereas in Rollup, all data is posted on L1 (which allows anyone to permissionless join as a validator), in AnyTrust, data is managed off-chain. In the case of a , an AnyTrust chain reverts back to “rollup mode”; the security assumption here is that at least 2 of the committee members are honest (i.e., they will provide the data when it’s necessary). Keeping the data off-chain in the happy/common case means the system can charge the user significantly lower fees. For applications that require high transaction throughput and don’t require the full decentralization that rollups provide, AnyTrust could be a sensible tradeoff.

#### Q: So there's more than one Arbitrum chain out there?[​](#q-so-theres-more-than-one-arbitrum-chain-out-there "Direct link to Q: So there's more than one Arbitrum chain out there?")

Yep! The fact that multiple chains can run in parallel is a crucial perk to off-chain scaling technology.

Here’s a snapshot of the chains running on Arbitrum:

*   On Ethereum mainnet:
    
    *   ["Arbitrum One"](https://portal.arbitrum.one/): an  operated by the [Arbitrum Foundation](https://arbitrum.foundation)
    *   ["Nova"](https://nova.arbitrum.io/): an  operated by the [Arbitrum Foundation](https://arbitrum.foundation)
*   On Arbitrum One and Nova:
    
    *   Various L3 (Orbit) chain
*   On other L2s:
    
    *   Various L2 (Orbit) chain

![700px-img](/assets/images/arbitrum-chains-diagram-b72489f575d8d56d39425a73c645072b.jpeg)

Developers can launch their own Arbitrum chains that run as an L2 chain on top of Ethereum. They can also run Arbitrum chains that run on top of an EVM L2 chain.

Checkout the [Arbitrum Portal](https://portal.arbitrum.io/orbit/ecosystem) for an extensive overview of the Orbit chains running on Arbitrum.

Users and developers can pick whatever suits their security / transaction cost needs.

#### Q: Who makes decisions about the future of Arbitrum One and Arbitrum Nova?[​](#q-who-makes-decisions-about-the-future-of-arbitrum-one-and-arbitrum-nova "Direct link to Q: Who makes decisions about the future of Arbitrum One and Arbitrum Nova?")

The  and Nova chains are owned by the Governance system; to learn more, see the [Arbitrum Governance docs](https://docs.arbitrum.foundation/).

---

# Arbitrum glossary | Arbitrum Docs

## Arbitrum glossary

### Active Validator[​](#active-validator "Direct link to Active Validator")

A staked [Validator](/intro/glossary#validator) that makes disputable assertions to advance the state of an Arbitrum chain or to challenge the validity of others' assertions. (Not to be confused with the [Sequencer](/intro/glossary#sequencer) ).

### Address Alias[​](#address-alias "Direct link to Address Alias")

An address deterministically generated from an L1 contract address used on L2 to safely identify the source of an L1 to L2 message.

### Arb Token Bridge[​](#arb-token-bridge "Direct link to Arb Token Bridge")

A series of contracts on an Arbitrum chain and its underlying chain that facilitate trustless movement of ERC-20 tokens between the two layers.

### Arbified Token List[​](#arbified-token-list "Direct link to Arbified Token List")

A token list that conforms to [Uniswap's token list specification](https://github.com/Uniswap/token-lists); Arbified lists are generated by inputting externally maintained list ([i.e., coinmarketcap's list](https://api.coinmarketcap.com/data-api/v3/uniswap/all.json)) and outputting a list that includes all of the instances of token contracts on the Arbitrum chain bridged via the canonical [Arb Token Bridge](/intro/glossary#arb-token-bridge) from tokens on the inputted list. (See code [here](https://github.com/OffchainLabs/arbitrum-token-lists).)

### Arbitrum[​](#arbitrum "Direct link to Arbitrum")

A suite of Ethereum layer-2 scaling technologies built with the [Arbitrum Nitro](/intro/glossary#arbitrum-nitro) tech stack that includes [Arbitrum One](/intro/glossary#arbitrum-one) (a live implementation of the [Arbitrum Rollup Protocol](/intro/glossary#arbitrum-rollup-protocol)) and [Arbitrum Nova](/intro/glossary#arbitrum-nova) (a live implementation of the [Arbitrum AnyTrust Protocol](/intro/glossary#arbitrum-anytrust-protocol)).

### Arbitrum AnyTrust Chain[​](#arbitrum-anytrust-chain "Direct link to Arbitrum AnyTrust Chain")

An [Arbitrum chain](/intro/glossary#arbitrum-chain) that implements the [Arbitrum AnyTrust Protocol](/intro/glossary#arbitrum-anytrust-protocol).

### Arbitrum AnyTrust Protocol[​](#arbitrum-anytrust-protocol "Direct link to Arbitrum AnyTrust Protocol")

An Arbitrum protocol that manages data availability with a permissioned set of parties known as the [Data Availability Committee (DAC)](/intro/glossary#data-availability-committee-dac). This protocol reduces transaction fees by introducing an additional trust assumption for data availability in lieu of Ethereum's [Trustless](/intro/glossary#trustless) data availability mechanism. [Arbitrum Nova](/intro/glossary#arbitrum-nova) is an example of an AnyTrust chain; [Arbitrum One](/intro/glossary#arbitrum-one) is an alternative chain that implements the purely trustless (and more L1-gas intensive) [Arbitrum Rollup Protocol](/intro/glossary#arbitrum-rollup-protocol).

### Arbitrum Bridge UI[​](#arbitrum-bridge-ui "Direct link to Arbitrum Bridge UI")

Web application built and maintained by [Offchain Labs](/intro/glossary#offchain-labs) for user-interactions with the [Arb Token Bridge](/intro/glossary#arb-token-bridge); visit it [here](https://bridge.arbitrum.io/).

### Arbitrum chain[​](#arbitrum-chain "Direct link to Arbitrum chain")

A blockchain that runs on the Arbitrum protocol. Arbitrum chains are EVM compatible, and use an underlying EVM chain (e.g., Ethereum) for settlement and for succinct fraud-proofs (as needed). Arbitrum chains come in two forms: [Arbitrum Rollup Chain](/intro/glossary#arbitrum-rollup-chain)s and [Arbitrum AnyTrust Chain](/intro/glossary#arbitrum-anytrust-chain)s.

### Arbitrum Classic[​](#arbitrum-classic "Direct link to Arbitrum Classic")

[Old Arbitrum stack](https://github.com/OffchainLabs/arbitrum) that used custom virtual machine ("AVM"); no public Arbitrum chain uses the classic stack as of 8/31/2022 (they instead use [Arbitrum Nitro](/intro/glossary#arbitrum-nitro) ).

### Arbitrum Full Node[​](#arbitrum-full-node "Direct link to Arbitrum Full Node")

A party who keeps track of the state of an Arbitrum chain and receives remote procedure calls (RPCs) from clients. Analogous to a non-staking L1 Ethereum node.

### Arbitrum Nitro[​](#arbitrum-nitro "Direct link to Arbitrum Nitro")

Current Arbitrum tech stack; runs a fork of [Geth](/intro/glossary#geth) and uses WebAssembly as its underlying VM for fraud proofs.

### Arbitrum Nova[​](#arbitrum-nova "Direct link to Arbitrum Nova")

The first [Arbitrum AnyTrust Chain](/intro/glossary#arbitrum-anytrust-chain) running on Ethereum mainnet. Introduces cheaper transactions; great for gaming and social use-cases. Implements the [Arbitrum AnyTrust Protocol](/intro/glossary#arbitrum-anytrust-protocol), not the [Arbitrum Rollup Protocol](/intro/glossary#arbitrum-rollup-protocol) protocol. Governed by the [Arbitrum DAO](https://docs.arbitrum.foundation/gentle-intro-dao-governance).

### Arbitrum One[​](#arbitrum-one "Direct link to Arbitrum One")

The first [Arbitrum Rollup Chain](/intro/glossary#arbitrum-rollup-chain) running on Ethereum mainnet. Great for decentralized finance and other use-cases that demand strong security guarantees. Governed by the [Arbitrum DAO](https://docs.arbitrum.foundation/gentle-intro-dao-governance).

### Arbitrum Orbit[​](#arbitrum-orbit "Direct link to Arbitrum Orbit")

Arbitrum Orbit refers to the ability for anyone to permissionlessly deploy [Layer 3 (L3)](/intro/glossary#layer-3-l3) chains on top of Arbitrum [Layer 2 (L2)](/intro/glossary#layer-2-l2) chains.

### Arbitrum Rollup Chain[​](#arbitrum-rollup-chain "Direct link to Arbitrum Rollup Chain")

An [Arbitrum chain](/intro/glossary#arbitrum-chain) that implements the [Arbitrum Rollup Protocol](/intro/glossary#arbitrum-rollup-protocol).

### Arbitrum Rollup Protocol[​](#arbitrum-rollup-protocol "Direct link to Arbitrum Rollup Protocol")

A trustless, permissionless Arbitrum protocol that uses its underlying base layer for data availability and inherits its security. This protocol is implemented by our [Arbitrum One](/intro/glossary#arbitrum-one) chain.

### ArbOS[​](#arbos "Direct link to ArbOS")

Arbitrum's "operating system" that trustlessly handles system-level operations; includes the ability to emulate the EVM.

### Assertion[​](#assertion "Direct link to Assertion")

A staked claim by an Arbitrum [Validator](/intro/glossary#validator). An assertion may, e.g., propose a new [RBlock](/intro/glossary#rblock), or may be a step in a [Challenge](/intro/glossary#challenge).

### Auction Contract[​](#auction-contract "Direct link to Auction Contract")

A smart contract that handles the state, accounting of funds for bids, and various operations of the [Timeboost](/intro/glossary#timeboost) auction. The contract is deployed on the target chain for which Timeboost is enabled.

### Autonomous Auctioneer[​](#autonomous-auctioneer "Direct link to Autonomous Auctioneer")

Off chain software that receives bids from [Timeboost](/intro/glossary#timeboost) participants, processes and validates bids, and then posts the top valid bid (or top two valid bids in the case of a tie) to the [Auction Contract](/intro/glossary#auction-contract) to resolve the on-going Timeboost auction. The autonomous auctioneer, for a given chain, is provisioned & deployed by an entity designated by the chain's owner.

### Batch[​](#batch "Direct link to Batch")

A group of Arbitrum transactions posted in a single transaction on the [Underlying Chain](/intro/glossary#underlying-chain) into the [Fast Inbox](/intro/glossary#fast-inbox) by the [Sequencer](/intro/glossary#sequencer).

### Blockchain[​](#blockchain "Direct link to Blockchain")

A distributed digital ledger that is used to record transactions and store data in a secure, transparent, and tamper-resistant way, notably in cryptocurrency protocols.

### BLS Signature[​](#bls-signature "Direct link to BLS Signature")

A cryptographic scheme that allows multiple signatures to be aggregated and compacted into one efficiently verifiable, constant-sized signature. Used in the [Arbitrum AnyTrust Protocol](/intro/glossary#arbitrum-anytrust-protocol) for the [Data Availability Committee (DAC)](/intro/glossary#data-availability-committee-dac)'s signatures.

### BoLD[​](#bold "Direct link to BoLD")

Short for "Bounded Liquidity Delay"; latest version of the Arbitrum [Challenge protocol](/intro/glossary#challenge-protocol) designed to eliminate [delay attack vectors](https://medium.com/offchainlabs/solutions-to-delay-attacks-on-rollups-434f9d05a07a) (see [here](https://medium.com/offchainlabs/bold-permissionless-validation-for-arbitrum-chains-9934eb5328cc) for more). Not currently on mainnet.

### Bridge[​](#bridge "Direct link to Bridge")

A set of smart contracts for sending [Cross-chain message](/intro/glossary#crosschain-message)s between blockchains. Every [Arbitrum chain](/intro/glossary#arbitrum-chain) includes a bridge to/from its [Parent chain](/intro/glossary#parent-chain).

### Chain Owner[​](#chain-owner "Direct link to Chain Owner")

An entity (i.e., a smart contract) with affordance to carry out critical upgrades to an Arbitrum chain's core protocol; this includes upgrading protocol contracts, setting core system parameters, and adding and removing other chain owners.

### Chain state[​](#chain-state "Direct link to Chain state")

A particular point in the history of an [Arbitrum chain](/intro/glossary#arbitrum-chain). A chain's state is determined by applying Arbitrum state-transition function to sequence of transactions (i.e., the chain's history).

### Challenge[​](#challenge "Direct link to Challenge")

When two [Staker](/intro/glossary#staker)s disagree about the correct verdict on an [Assertion](/intro/glossary#assertion), those stakers can be put in a challenge. The challenge is refereed by the contracts on the underlying chain. Eventually one staker wins the challenge. The protocol guarantees that an honest party will always win a challenge; the loser forfeits their stake.

### Challenge Period[​](#challenge-period "Direct link to Challenge Period")

Window of time (1 week on Arbitrum One) over which an asserted [RBlock](/intro/glossary#rblock) can be challenged, and after which the RBlock can be confirmed.

### Challenge protocol[​](#challenge-protocol "Direct link to Challenge protocol")

The protocol by which [RBlock](/intro/glossary#rblock)s are submitted, disputed, and ultimately confirmed. The Challenge Protocol guarantees that only valid RBlocks will be confirmed provided that there is at least one honest [Active Validator](/intro/glossary#active-validator).

### Child chain[​](#child-chain "Direct link to Child chain")

An Arbitrum Chain that settles to an underlying [Parent chain](/intro/glossary#parent-chain) . For example, Arbitrum One and Arbitrum Nova are child chains of Ethereum.

### Client[​](#client "Direct link to Client")

A program running on a user's machine, often in the user's browser, that interacts with contracts on an [Arbitrum chain](/intro/glossary#arbitrum-chain) and provides a user interface.

### Confirmation[​](#confirmation "Direct link to Confirmation")

The decision by an [Arbitrum chain](/intro/glossary#arbitrum-chain) to finalize an [RBlock](/intro/glossary#rblock) as part of the chain's history. Once an RBlock is confirmed its [L2 to L1 Message](/intro/glossary#l2-to-l1-message)s (e.g., withdrawals) can be executed.

### Cross-chain message[​](#crosschain-message "Direct link to Cross-chain message")

An action taken on some chain A which asynchronously initiates an additional action on chain B.

### Custom Arb-Token[​](#custom-arbtoken "Direct link to Custom Arb-Token")

Any L2 token contract registered to the [Arb Token Bridge](/intro/glossary#arb-token-bridge) that isn't a standard arb-token (i.e., a token that uses any gateway other than the [StandardERC20 gateway](/intro/glossary#standarderc20-gateway) ).

### Custom gateway[​](#custom-gateway "Direct link to Custom gateway")

Any [Token Gateway](/intro/glossary#token-gateway) that isn't the [StandardERC20 gateway](/intro/glossary#standarderc20-gateway).

### dApp[​](#dapp "Direct link to dApp")

Short for "decentralized application." A dApp typically consists of smart contracts as well as a user-interface for interacting with them.

### Data Availability Certificate[​](#data-availability-certificate "Direct link to Data Availability Certificate")

Signed promise from a [Data Availability Committee (DAC)](/intro/glossary#data-availability-committee-dac) attesting to the availability of a batch of data for an [Arbitrum AnyTrust Chain](/intro/glossary#arbitrum-anytrust-chain).

### Data Availability Committee (DAC)[​](#data-availability-committee-dac "Direct link to Data Availability Committee (DAC)")

A permissioned set of parties responsible for enforcing data availability in an [Arbitrum AnyTrust Protocol](/intro/glossary#arbitrum-anytrust-protocol) chain. See _[Introducing AnyTrust Chains: Cheaper, Faster L2 Chains with Minimal Trust Assumptions](https://medium.com/offchainlabs/introducing-anytrust-chains-cheaper-faster-l2-chains-with-minimal-trust-assumptions-31def59eb8d7)_ to learn more.

### Defensive Validator[​](#defensive-validator "Direct link to Defensive Validator")

A [Validator](/intro/glossary#validator) that watches an Arbitrum chain and takes action (i.e., stakes and challenges) only when and if an invalid [Assertion](/intro/glossary#assertion) occurs.

### Delayed Inbox[​](#delayed-inbox "Direct link to Delayed Inbox")

A contract that holds [Parent chain](/intro/glossary#parent-chain) initiated messages to be eventually included in the [Fast Inbox](/intro/glossary#fast-inbox). Inclusion of messages doesn't depend on the [Sequencer](/intro/glossary#sequencer).

### Dev-Tools Dashboard[​](#devtools-dashboard "Direct link to Dev-Tools Dashboard")

Web application built and maintained by [Offchain Labs](/intro/glossary#offchain-labs) for developers and users to debug Arbitrum transactions; i.e., executing or checking the status of [Cross-chain message](/intro/glossary#crosschain-message)s; visit it [here](https://retryable-dashboard.arbitrum.io/).

### Dissection[​](#dissection "Direct link to Dissection")

A step in the [Challenge protocol](/intro/glossary#challenge-protocol) in which two challenging parties interactively narrow down their disagreement until they reach a [One Step Proof](/intro/glossary#one-step-proof).

### Ethereum Wallet[​](#ethereum-wallet "Direct link to Ethereum Wallet")

A software application used for transacting with the Ethereum [Blockchain](/intro/glossary#blockchain).

### EVM+[​](#evm "Direct link to EVM+")

The paradigm introduced by [Stylus](/intro/glossary#stylus) in which Arbitrum's EVM compatibility is preserved while new features and improvements are introduced.

### Express Lane[​](#express-lane "Direct link to Express Lane")

A component of [Timeboost](/intro/glossary#timeboost), the express lane is a special endpoint on the [Sequencer](/intro/glossary#sequencer) that immediately sequences incoming, valid transactions signed by the current express lane controller.

### Express Lane Controller[​](#express-lane-controller "Direct link to Express Lane Controller")

An address, defined in the [Auction Contract](/intro/glossary#auction-contract), that is granted the privilege to use the [Express Lane](/intro/glossary#express-lane). These privileges are granted after verifying that the incoming transactions were properly signed by the express lane controller, among other checks.

### Fair Ordering Algorithm[​](#fair-ordering-algorithm "Direct link to Fair Ordering Algorithm")

BFT algorithm in which a committee comes to consensus on transaction ordering; current single-party [Sequencer](/intro/glossary#sequencer) on Arbitrum may eventually be replaced by a fair-ordering committee.

### Fast Exit / Liquidity Exit[​](#fast-exit--liquidity-exit "Direct link to Fast Exit / Liquidity Exit")

A means by which a user can bypass an Arbitrum chain's [Challenge Period](/intro/glossary#challenge-period) when withdrawing fungible assets (or more generally, executing some "fungible" L2 to L1 operation); for trustless fast exits, a liquidity provider facilitates an atomic swap of the asset on L2 directly to L1.

### Fast Inbox[​](#fast-inbox "Direct link to Fast Inbox")

Contract that holds a sequence of messages sent by clients to an Arbitrum Chain; a message can be put into the fast Inbox directly by the [Sequencer](/intro/glossary#sequencer) or indirectly through the [Delayed Inbox](/intro/glossary#delayed-inbox).

### First Come First Serve (FCFS)[​](#first-come-first-serve-fcfs "Direct link to First Come First Serve (FCFS)")

A type of [Transaction Ordering Policy](/intro/glossary#transaction-ordering-policy) used by the sequencer in Arbitrum chains whereby incoming transactions are sequenced into a block in the order that the transactions arrived.

### Force-Inclusion[​](#forceinclusion "Direct link to Force-Inclusion")

Censorship resistant path for including a message into an Arbitrum chain via the [Delayed Inbox](/intro/glossary#delayed-inbox) on its [Parent chain](/intro/glossary#parent-chain); bypasses any Sequencer involvement.

### Fraud proof[​](#fraud-proof "Direct link to Fraud proof")

The means by which an [Active Validator](/intro/glossary#active-validator) proves to its underlying chain that an invalid state transition has taken place.

### Gas Price Floor[​](#gas-price-floor "Direct link to Gas Price Floor")

Protocol-enforced minimum gas price on an Arbitrum chain; currently 0.1 gwei on [Arbitrum One](/intro/glossary#arbitrum-one) and 0.01 gwei on [Arbitrum Nova](/intro/glossary#arbitrum-nova).

### Gateway Router[​](#gateway-router "Direct link to Gateway Router")

Contracts in the [Arb Token Bridge](/intro/glossary#arb-token-bridge) responsible for mapping tokens to their appropriate [Token Gateway](/intro/glossary#token-gateway).

### Generic-Custom Gateway[​](#genericcustom-gateway "Direct link to Generic-Custom Gateway")

A particular [Custom gateway](/intro/glossary#custom-gateway) via which an L1 token contract can be registered to a token contract deployed to L2. A useful alternative to the [StandardERC20 gateway](/intro/glossary#standarderc20-gateway) for projects that wish to control the address of their L2 token contract, maintain L2 token contract upgradability, and for various other use-cases.

### Geth[​](#geth "Direct link to Geth")

An execution-layer client that defines the Ethereum state transition function and handles network-layer logic like transaction memory pooling. [Arbitrum Nitro](/intro/glossary#arbitrum-nitro) utilizes a fork of Geth to implement Arbitrum's state transition function.

### Ink[​](#ink "Direct link to Ink")

The equivalent of gas in the [Stylus](/intro/glossary#stylus) vm. Ink is introduced for finer granularity than gas offers since Stylus's operations are considerably cheaper than their EVM analogs.

### L2 Block[​](#l2-block "Direct link to L2 Block")

Data structure that represents a group of L2 transactions (analogous to L1 blocks).

### L2 to L1 Message[​](#l2-to-l1-message "Direct link to L2 to L1 Message")

A message initiated from within an Arbitrum chain to be eventually executed on [Layer 1 (L1)](/intro/glossary#layer-1-l1) (e.g., token or Ether withdrawals). On Rollup chains like [Arbitrum One](/intro/glossary#arbitrum-one), the [Challenge Period](/intro/glossary#challenge-period) must pass before an L2 to L1 message is executed.

### Layer 1 (L1)[​](#layer-1-l1 "Direct link to Layer 1 (L1)")

The base protocol and underlying blockchain of the Ethereum network. Responsible for maintaining the integrity of the distributed ledger and executing smart contracts. Contains both Ethereum's execution layer and consensus layer.

### Layer 2 (L2)[​](#layer-2-l2 "Direct link to Layer 2 (L2)")

Trustless scaling solutions built on top of Ethereum's [Layer 1 (L1)](/intro/glossary#layer-1-l1) base protocol, such as state channels, plasma chains, optimistic rollups, and ZK-rollups. Layer 2 solutions aim to increase scalability and reduce the cost of transactions on Ethereum's Layer 1 without introducing additional trust assumptions.

### Layer 3 (L3)[​](#layer-3-l3 "Direct link to Layer 3 (L3)")

An Arbitrum chain whose core contract reside on an Arbitrum [Layer 2 (L2)](/intro/glossary#layer-2-l2) chain.

### Native Fee Token[​](#native-fee-token "Direct link to Native Fee Token")

An ERC-20 token used as the native currency for gas fees on an [Arbitrum chain](/intro/glossary#arbitrum-chain) (i.e., as opposed to using Ether). [Arbitrum Orbit](/intro/glossary#arbitrum-orbit) introduced the option for chains to use native fee tokens.

### Offchain Labs[​](#offchain-labs "Direct link to Offchain Labs")

The initial builders Arbitrum; current contributors to the Arbitrum ecosystem and service providers to the [Arbitrum DAO](https://docs.arbitrum.foundation/gentle-intro-dao-governance). Offchain also runs and maintains the [Sequencer](/intro/glossary#sequencer)s for [Arbitrum One](/intro/glossary#arbitrum-one) and [Arbitrum Nova](/intro/glossary#arbitrum-nova).

### One Step Proof[​](#one-step-proof "Direct link to One Step Proof")

Final step in a challenge; a single operation of the Arbitrum VM ([WASM](/intro/glossary#wasm) ) is executed on the underlying chain, and the validity of its state transition is verified.

### Outbox[​](#outbox "Direct link to Outbox")

An L1 contract responsible for tracking [L2 to L1 Message](/intro/glossary#l2-to-l1-message)s, including withdrawals, which can be executed once they are confirmed. The outbox stores a Merkle Root of all outgoing messages.

### Parent chain[​](#parent-chain "Direct link to Parent chain")

EVM compatible chain that acts as the settlement layer for one or more Arbitrum Chains (aka [Child chain](/intro/glossary#child-chain) ). E.g., Ethereum is the parent chain of both Arbitrum One and Arbitrum Nova. Parent chain is synonymous with "underlying chain."

### Portal[​](#portal "Direct link to Portal")

A web application maintained by [Offchain Labs](/intro/glossary#offchain-labs) showcasing the Arbitrum ecosystem; visit it [here](https://portal.arbitrum.io/).

### RBlock[​](#rblock "Direct link to RBlock")

An assertion by an Arbitrum [Validator](/intro/glossary#validator) that represents a claim about an Arbitrum chain's state.

### Reorg[​](#reorg "Direct link to Reorg")

A situation in which transactions on a chain that were at some point considered accepted then get rejected. In the context of an Arbitrum chain, once transactions are posted in the chain's [Fast Inbox](/intro/glossary#fast-inbox), the only way the chain can experience a reorg is if its [Underlying Chain](/intro/glossary#underlying-chain) itself reorgs. Of note, [Fraud proof](/intro/glossary#fraud-proof)s do not cause reorgs.

### Retryable Autoredeem[​](#retryable-autoredeem "Direct link to Retryable Autoredeem")

The "automatic" (i.e., requiring no additional user action) execution of a [Retryable Ticket](/intro/glossary#retryable-ticket) on an Arbitrum chain.

### Retryable Redeem[​](#retryable-redeem "Direct link to Retryable Redeem")

The execution of a [Retryable Ticket](/intro/glossary#retryable-ticket) on L2; can be automatic (see [Retryable Autoredeem](/intro/glossary#retryable-autoredeem)) or manual via a user-initiated L2 transaction.

### Retryable Ticket[​](#retryable-ticket "Direct link to Retryable Ticket")

An L1 to L2 cross chain message initiated by an L1 transaction sent to an Arbitrum chain for execution (e.g., a token deposit).

### Reverse Token Gateway[​](#reverse-token-gateway "Direct link to Reverse Token Gateway")

A [Token Gateway](/intro/glossary#token-gateway) in which the [Child chain](/intro/glossary#child-chain) gateway contract escrows and releases tokens, which the [Parent chain](/intro/glossary#parent-chain) Gateway contract mints and burns tokens. This in the inverse to how "typical" gateways work.

### Sequencer[​](#sequencer "Direct link to Sequencer")

An entity (currently a single-party on Arbitrum One) given rights to reorder transactions in the [Fast Inbox](/intro/glossary#fast-inbox) over a fixed window of time, who can thus give clients sub-blocktime [Soft Confirmation](/intro/glossary#soft-confirmation)s. (Not to be confused with a [Validator](/intro/glossary#validator)).

### Sequencer Feed[​](#sequencer-feed "Direct link to Sequencer Feed")

Off chain data feed published by the [Sequencer](/intro/glossary#sequencer) which clients can subscribe to for [Soft Confirmation](/intro/glossary#soft-confirmation)s of transactions before they are posted in [Batch](/intro/glossary#batch)es.

### Shared Sequencing[​](#shared-sequencing "Direct link to Shared Sequencing")

A protocol design space in which multiple rollups use the same entity as their [Sequencer](/intro/glossary#sequencer); potential benefits include enhanced interoperability and credible neutrality.

### Smart Contract[​](#smart-contract "Direct link to Smart Contract")

A computer program whose operations are defined and executed within a blockchain consensus protocol.

### Soft Confirmation[​](#soft-confirmation "Direct link to Soft Confirmation")

A semi-trusted promise from the [Sequencer](/intro/glossary#sequencer) to post a user's transaction in the near future; soft-confirmations happen prior to posting on the [Parent chain](/intro/glossary#parent-chain), and thus can be given near-instantaneously (i.e., faster than the parent chain's block times)

### Speed Limit[​](#speed-limit "Direct link to Speed Limit")

Target computation limit for an Arbitrum chain. [Arbitrum One](/intro/glossary#arbitrum-one) and [Arbitrum Nova](/intro/glossary#arbitrum-nova) currently target 7,000,000 gas / second. When computation exceeds this limit, fees rise, ala [EIP-1559](https://notes.ethereum.org/@vbuterin/eip-1559-faq).

### Staker[​](#staker "Direct link to Staker")

A [Validator](/intro/glossary#validator) who deposits a stake (in Ether on [Arbitrum One](/intro/glossary#arbitrum-one) and [Arbitrum Nova](/intro/glossary#arbitrum-nova) ) to vouch for a particular [RBlock](/intro/glossary#rblock) in an Arbitrum Chain. A validator who stakes on a false RBlock can expect to lose their stake. An honest staker can recover their stake once the RBlock they are staked on has been confirmed.

### Standard Arb-Token[​](#standard-arbtoken "Direct link to Standard Arb-Token")

An token contract on an Arbitrum chain deployed via the [StandardERC20 gateway](/intro/glossary#standarderc20-gateway); offers basic ERC20 functionality in addition to deposit / withdrawal affordances.

### StandardERC20 gateway[​](#standarderc20-gateway "Direct link to StandardERC20 gateway")

[Token Gateway](/intro/glossary#token-gateway) via which any underlying chain's ERC20 token can permissionlessly bridge; the StandardERC20 gateway contracts deploy a [Standard Arb-Token](/intro/glossary#standard-arbtoken) on the [Child chain](/intro/glossary#child-chain) for each bridged token.

### State Transition Function[​](#state-transition-function "Direct link to State Transition Function")

The STF (State Transition Function) defines how new blocks are produced from input messages (i.e. transactions) in an Arbitrum chain.

### Stylus[​](#stylus "Direct link to Stylus")

Upgrade to the [Arbitrum Nitro](/intro/glossary#arbitrum-nitro) virtual machine that allows smart contract support for languages like Rust and C++ by taking advantage of Nitro's use of WASM. Currently on testnet ([read more](https://docs.arbitrum.io/stylus/stylus-gentle-introduction)).

### Timeboost[​](#timeboost "Direct link to Timeboost")

A transaction ordering policy in which entities can bid for the right to access an express lane on the [Sequencer](/intro/glossary#sequencer) for faster transaction inclusion. See the [research specification](https://github.com/OffchainLabs/timeboost-design/tree/main) to learn more.

### Token Gateway[​](#token-gateway "Direct link to Token Gateway")

A pair of contracts in the token bridge — one on the [Parent chain](/intro/glossary#parent-chain) , one on the [Child chain](/intro/glossary#child-chain) — that provide a particular mechanism for handling the transfer of tokens between layers. Token gateways currently active in the bridge include the [StandardERC20 gateway](/intro/glossary#standarderc20-gateway) , the [Generic-Custom Gateway](/intro/glossary#genericcustom-gateway) , and the [WETH Gateway](/intro/glossary#weth-gateway).

### Transaction[​](#transaction "Direct link to Transaction")

A user-initiated interaction with a Blockchain. Transactions are typically signed by users via wallets and are paid for via transaction fees.

### Transaction Ordering Policy[​](#transaction-ordering-policy "Direct link to Transaction Ordering Policy")

The rules and logic employed by a chain to order incoming transactions into a block.

### Trustless[​](#trustless "Direct link to Trustless")

In the context of Ethereum, trustless refers to the ability of a system to operate without reliance on a central authority or intermediary. Instead, users place their trust in math and protocols.

  
  

This is achieved through the use of cryptographic techniques and decentralized consensus mechanisms that let users verify the integrity of network transactions using open-source software. Trustless systems are considered to be more secure and resistant to fraud or tampering because they don't rely on a single point of failure that can be exploited by attackers.

### Underlying Chain[​](#underlying-chain "Direct link to Underlying Chain")

Synonymous with [Parent chain](/intro/glossary#parent-chain).

### Validator[​](#validator "Direct link to Validator")

An [Arbitrum Full Node](/intro/glossary#arbitrum-full-node) that tracks the status of the chains' [Assertion](/intro/glossary#assertion)s. A validator may be a [Watchtower Validator](/intro/glossary#watchtower-validator), a [Defensive Validator](/intro/glossary#defensive-validator), or an [Active Validator](/intro/glossary#active-validator).

### WASM[​](#wasm "Direct link to WASM")

Widely supported binary code format for executable programs. Used by [Arbitrum Nitro](/intro/glossary#arbitrum-nitro) for [Fraud proof](/intro/glossary#fraud-proof)s , and more broadly used by [Stylus](/intro/glossary#stylus) to support performant smart contracts in a wide variety of languages.

### WASMer[​](#wasmer "Direct link to WASMer")

A popular WebAssembly runtime for executing [WASM](/intro/glossary#wasm) binaries. [A fork of WASMer](https://github.com/OffchainLabs/wasmer) is used for executing [Stylus](/intro/glossary#stylus) programs. WASMer executes considerably faster than Geth executes EVM code, contributing to Stylus's lower fees.

### Watchtower Validator[​](#watchtower-validator "Direct link to Watchtower Validator")

A [Validator](/intro/glossary#validator) that never stakes / never takes on chain action, who raises the alarm (by whatever off-chain means it chooses) if it witnesses an invalid assertion.

### WETH Gateway[​](#weth-gateway "Direct link to WETH Gateway")

[Token Gateway](/intro/glossary#token-gateway) for handing the bridging of wrapped Ether (WETH). WETH is unwrapped on L1 and rewrapped on L1 upon depositing (and vice-versa upon withdrawing), ensuring WETH on L2 always remains collateralized.

---

# A gentle introduction: Orbit chains | Arbitrum Docs

## A gentle introduction: Orbit chains

This document is for developers and decision-makers who want to learn more about **Arbitrum Orbit**, a new product offering that lets you create your own Arbitrum  and  chains.

If you'd prefer to learn by doing, see the [Orbit quickstart](/launch-orbit-chain/orbit-quickstart) for step-by-step instructions that walk you through the process of configuring and launching your own Orbit chain.

### In a nutshell:[​](#in-a-nutshell "Direct link to In a nutshell:")

*   Arbitrum Orbit is the **permissionless path** for launching customizable dedicated chains using Arbitrum technology.
*   Orbit Chains can be a  chain which settles directly to Ethereum, or a Layer 3 (L3) chain which can settle to any Ethereum L2, such as .
*   Configure numerous components of the chain such as throughput, privacy, gas token, governance, precompiles, data availability layers and more, **the possibilities are endless**.
*   **You own your Orbit chain** and can decentralize its ownership, validation, and other dependencies.
*   Leverage , the tech stack powering interactive fraud proofs, advanced compression, [EVM+ compatibility via Stylus](https://docs.arbitrum.io/stylus/gentle-introduction), and continuous improvements.

### What's Orbit?[​](#whats-orbit "Direct link to What's Orbit?")

graph TB 1("Orbit L2") -.-> 5("Ethereum (L1)") 2("Orbit L3") -.-> 3("Arbitrum One (L2)") 3 -.-> 5 4("Orbit L2") -.-> 5

**Arbitrum Orbit** is a new product offering that lets you create your own customizable L2 or L3 chain.

L3 Orbit chains can settle to other L2 chains, such as **Arbitrum One**, which settles to Ethereum.

**Ethereum** is a public Layer 1 (L1) chain.

*   You can think of Orbit chains as **deployable, configurable instances of the Arbitrum Nitro tech stack**.
*   You can also think of them as **tailored chains** - chains tailored precisely to **your exact use-case and business needs**.
*   This gives you another way to **progressively decentralize** your applications and **incrementally adopt** the properties and security assumptions of Ethereum's base layer.
*   Every Orbit chain can be configured to be either a  or  Chain.
    *   Note that  is an example of a rollup, and  is an example of an AnyTrust chain.
*   Arbitrum One and Arbitrum Nova are owned and governed by the [Arbitrum DAO](https://docs.arbitrum.foundation/concepts/arbitrum-dao). With Orbit chains, _you_ determine the way that your chain is governed.

### What problem does Orbit solve?[​](#what-problem-does-orbit-solve "Direct link to What problem does Orbit solve?")

The Ethereum ecosystem is supported by a **decentralized network of nodes** that each run Ethereum's Layer 1 (L1) client software. Ethereum's block space is in high demand, so users are often stuck waiting for the network to become less congested (and thus, less expensive).

Arbitrum's  and  protocols address this challenge by offloading some of the Ethereum network's heavy lifting to **another decentralized network of nodes** that support the  and  L2 chains, respectively.

There are important differences between these chains. The choice between Rollup and AnyTrust represents a **tradeoff** between decentralization and performance:

*   **Arbitrum One** implements the Rollup protocol, which stores raw transaction data on Ethereum L1, while
*   **Arbitrum Nova** implements the AnyTrust protocol, which uses a  to store raw transaction data, expediting settlement and reducing costs by introducing a security assumption.

**These two public chains will meet most projects' needs** - they already support thousands of apps and millions of users! But shared public chains aren't for everyone. Some projects can benefit from their own AnyTrust or Rollup chains that afford the same security, but with a higher degree of control over the chain's features and governance (remember, these public L2 chains and their protocols are governed by the [Arbitrum DAO](https://docs.arbitrum.foundation/gentle-intro-dao-governance)).

Orbit chains give you the ability to create your own AnyTrust and Rollup chains using your own infrastructure. You can think of your Orbit chain as a **self-managed priority lane on Ethereum**. Each Orbit chain is capable of supporting many times the capacity of Ethereum, all while benefitting directly from Ethereum's security.

Said simply:

*   **Arbitrum One** and **Arbitrum Nova** chains unlocked two options that scale Ethereum and meet most projects' needs.
*   **Arbitrum Orbit** chains unlock an **[infinite garden](https://ethereum.foundation/infinitegarden)** that scale Ethereum even further, with each individual Orbit chain being tailored precisely to its owner's needs.

### How does Orbit help me build decentralized apps?[​](#how-does-orbit-help-me-build-decentralized-apps "Direct link to How does Orbit help me build decentralized apps?")

Benefit

Description

**Dedicated throughput**

You may need dedicated throughput if your dApp demands high-performance or consistent resource availability. Running your dApp on its own Orbit chain significantly increases resource availability, so you don’t need to compete for computation and storage resources.

**EVM+ compatibility**

Orbit chains will benefit the same EVM+ compatibility that [Stylus](https://offchain.medium.com/hello-stylus-6b18fecc3a22) introduces. This means that you'll be able to deploy EVM-compatible smart contracts using Solidity, C, C++, and Rust - no need to migrate away from the language and toolchain that you're already using!

**Independent product roadmap**

If you want to decouple your app chain's roadmap from that of Ethereum and/or Arbitrum, Orbit makes this possible. This lets you implement cutting-edge features like account abstraction ahead of projects following Ethereum's public roadmap.

**Increased gas price reliability**

Many types of dApps rely on predictable transaction costs. Because Orbit chains are isolated from Arbitrum L2 and Ethereum L1 traffic, using Orbit chains means that you won't be significantly affected by other apps' on-chain activity, allowing your dApp's users to enjoy more reliable gas prices.

**Account abstraction**

Predictable gas prices make it easy to model and predict business costs, which makes it easier to experiment with traditionally cost-prohibitive mechanisms like **transaction fee subsidization**. This makes it easier to further abstract the technical complexity of decentralized apps away from end-user experiences, allowing you to deliver decentralized experiences that feel familiar to nontechnical audiences (who may not understand or care about implementation details).

**Custom gas token**

Orbit chains can use alternative ERC-20 tokens as the native gas token on the network for gas fees, facilitating seamless integration with your app's ecosystem. This is currently supported for AnyTrust chains.

**Customizable protocol logic**

You may need to modify the logic of your chain's settlement, execution, or governance protocols in order to meet specific requirements. Orbit's chains let you do this, while benefiting from the security of Ethereum, through Arbitrum's DAO-governed L2 chains.

**Nitro extensibility**

Orbit chains will have access to all Nitro code upgrades, feature additions, and improvements, giving your Orbit chain the option to stay up-to-date and incorporate the latest and greatest in Ethereum scaling technology.

**Decentralization options**

You can build an  chain that uses Ethereum for data availability, or you can build an  chain that uses a  to expedite the settlement of transactions to your Orbit chain's base chain, making things even cheaper for you and your end-users. Orbit chains can use either of these technologies.

**Low prototyping costs**

Orbit chains can be easily created. See the [Orbit Quickstart](/launch-orbit-chain/orbit-quickstart) for step-by-step instructions.

**Security**

Arbitrum technology powers the most secure L2s, and you can use this same mature technology stack for your Orbit chain.

**Flexible technology options**

Orbit lets you choose between Rollup, AnyTrust, or custom technology stacks. This makes Ethereum and Arbitrum technologies more adaptable by allowing you to incorporate only the elements of the technologies that you need.

**Permissioned access**

Orbit gives you the freedom to choose which contracts are deployed on your chain. You can keep it as open and permissionless as Ethereum, restrict contract deployment so that only your app can be deployed on this chain, or anything in between!

### How does Orbit help the Ethereum ecosystem?[​](#how-does-orbit-help-the-ethereum-ecosystem "Direct link to How does Orbit help the Ethereum ecosystem?")

Orbit helps Ethereum move towards a **multi-chain future**. This is valuable for the following reasons:

Value add

Description

**Scalability**

Multiple chains help overcome scaling bottlenecks by dividing activity into opt-in environments with separate resource management.

**Flexible security models**

Different chains can experiment with different security models, allowing for tradeoffs. For example: Arbitrum One and Arbitrum Nova are both L2 chains, with Arbitrum Nova giving developers the ability to optimize for lower fees. With Arbitrum Orbit, extending the technology and experimenting is easier than ever.

**Flexible execution environments**

Different chains can experiment with more-or-less restrictive execution environments. For example, although Arbitrum chains are fully EVM compatible, Orbit chains can restrict smart contract functionality to optimize for your project's needs.

**Flexible governance**

Orbit chains let you define your own governance protocols.

### Are Orbit chains the same thing as "app chains"?[​](#are-orbit-chains-the-same-thing-as-app-chains "Direct link to Are Orbit chains the same thing as \"app chains\"?")

It depends on your definition of "app chain". Orbit chains can be used as application-specific chains (often referred to as "app chains" or "appchains"). But **they aren't just for apps**. They're for **hosting EVM-compatible smart contracts using self-managed infrastructure that isolates compute resources away from Arbitrum's public L2 chains** based on your unique needs.

*   You can use your Orbit chain to host the smart contracts that support one app, two apps, an ecosystem of apps, or no apps at all.
*   You can use your Orbit chain to host a private, centralized service.
*   Your Orbit chain can be special-purpose, general-purpose, and everything in-between.
*   You could even build an app that uses multiple Orbit chains to support strange new forms of redundancy, high availability, and trustlessness.

### What's the best model: AnyTrust or Rollup?[​](#whats-the-best-model-anytrust-or-rollup "Direct link to What's the best model: AnyTrust or Rollup?")

The AnyTrust and Rollup data availability models reflect prioritization choices within the blockchain trilemma (scalability vs. security vs. decentralization), so the best option depends on what features matter most for your use case.

Here's a short list to help you pick the model that meets your chain's requirements:

#### I need my chain to be cost-efficient[​](#i-need-my-chain-to-be-cost-efficient "Direct link to I need my chain to be cost-efficient")

*   **AnyTrust:** By leveraging a Data Availability Committee (DAC), AnyTrust significantly reduces data availability costs compared to storing all data on Ethereum L1.

#### I need the most robust security model[​](#i-need-the-most-robust-security-model "Direct link to I need the most robust security model")

*   **Rollup:** By storing raw transaction data on Arbitrum One or Ethereum L1, Rollup chains inherit Ethereum's robust security model, offering high resilience against attacks.

#### I need my chain to use a custom gas token[​](#i-need-my-chain-to-use-a-custom-gas-token "Direct link to I need my chain to use a custom gas token")

*   **AnyTrust:** The AnyTrust model allows you to use any `ERC-20` token for gas fees.

#### I want my chain to be trust-minimized and decentralized[​](#i-want-my-chain-to-be-trust-minimized-and-decentralized "Direct link to I want my chain to be trust-minimized and decentralized")

*   **Rollup:** If your Rollup Orbit chain settles to Arbitrum One or Ethereum, it inherits the highest levels of trustlessness and decentralization of the Ethereum environment.

### Can my Orbit chain talk to other Orbit chains?[​](#can-my-orbit-chain-talk-to-other-orbit-chains "Direct link to Can my Orbit chain talk to other Orbit chains?")

Yes! All Orbit chains are powered by self-managed nodes running their own instance of 's node software. This software implements both **AnyTrust** and **Rollup** protocols; your Orbit chain can be configured to use either.

This means that your Orbit chain **isn't a completely isolated blockchain network**. When you launch an Orbit chain, you’re joining an ecosystem of connected chains that can exchange information.

Our small-but-mighty team is hard at work developing tools and patterns that make it easy to launch natively interoperable Orbit chains. Interop features haven't been released just yet, but let us know if you need them - we'd like to learn from you as this capability matures.

Orbit's product roadmap is firmly aligned with Ethereum's vision of a decentralized web - one that makes it easy for users to carry their digital swords, spells, skins, art, tokens, and other assets across digital boundaries of all kinds, without having to worry about security, censorship, or UX friction.

### What should I know about Orbit's licensing?[​](#what-should-i-know-about-orbits-licensing "Direct link to What should I know about Orbit's licensing?")

You can launch any Orbit chain permissionlessly. Nitro is licensed under a Business Source license, similar to DeFi protocols like Uniswap and Aave, among others. This license contains an Additional Use Grant that permits the permissionless deployment of Nitro software on blockchains that settle to Arbitrum One or Nova. However, Orbit chains that settle to a parent chain other than Arbitrum One or Nova are subject to additional licensing guidelines under the [AEP](https://docs.arbitrum.foundation/aep/ArbitrumExpansionProgramTerms.pdf).

### I'd love to tinker with Orbit! What should I do next?[​](#id-love-to-tinker-with-orbit-what-should-i-do-next "Direct link to I'd love to tinker with Orbit! What should I do next?")

Visit the [Orbit Quickstart](/launch-orbit-chain/orbit-quickstart), start tinkering, and let us know how it goes - we're excited to learn and grow with you! 🚀

### How can I launch an Orbit chain on mainnet?[​](#how-can-i-launch-an-orbit-chain-on-mainnet "Direct link to How can I launch an Orbit chain on mainnet?")

While launching a chain on your own is possible, there are multiple infrastructure providers such as [Caldera](https://caldera.xyz/), [Conduit](https://conduit.xyz/), [AltLayer](https://altlayer.io/), [Zeeve](https://www.zeeve.io/), and [Gelato](https://www.gelato.network/raas) that are enabling developers to quickly launch their own rollups.

---

# Orbit licensing | Arbitrum Docs

## Orbit licensing

What do I need to know about the Orbit license?[​](#what-do-i-need-to-know-about-the-orbit-license "Direct link to What do I need to know about the Orbit license?")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Nitro is currently licensed under a [Business Source License](https://github.com/OffchainLabs/nitro/blob/master/LICENSE.md), similar to DeFi protocols like Uniswap and Aave, among others, with an “Additional Use Grant” to ensure that everyone can have full comfort using and running nodes on all public Arbitrum chains.

The Additional Use Grant also permits deployment of the Nitro software in a permissionless, zero-cost fashion, as a new blockchain provided that the chain settles to either Arbitrum One or Arbitrum Nova. L3s that settle to Arbitrum One or Nova have no obligation to share revenue with the Arbitrum DAO and remain first class members of the Arbitrum ecosystem. As an expansion of this license, the [Arbitrum Expansion Program](https://docs.arbitrum.foundation/aep/ArbitrumExpansionProgramTerms.pdf) (AEP) is a self-service licensing model that makes it easy for developers to build and customize L2s/L3s using Arbitrum’s technology alongside different parent chains.

Benefits:

*   Leverage battle-tested technology to permissionlessly deploy L2s/L3s that settle to any supported parent chain.
*   Governance freedom - Orbit chains are not required to be governed by the Arbitrum DAO.
*   Flexible licensing allows developers to modify chain configurations. Orbit chains are free to modify any part of the stack, including implementation of custom gas tokens, alternative DA integrations, novel sequencing mechanisms, account abstraction, altVMs, etc.
*   L3s that settle to parent chains other than Arb1 and Nova must contribute [net chain revenue](https://docs.arbitrum.io/launch-orbit-chain/how-tos/calculate-aep-fees#calculating-aep-fees), where 8% flows to the DAO and 2% to the developer guild.

---

# BoLD for Orbit chains | Arbitrum Docs

## BoLD for Orbit chains

PUBLIC PREVIEW DOCUMENT

This document is currently in **public preview** and may change significantly as feedback is captured from readers like you. Click the _Request an update_ button at the top of this document or [join the Arbitrum Discord](https://discord.gg/arbitrum) to share your feedback.

Launch details and key dates[​](#launch-details-and-key-dates "Direct link to Launch details and key dates")
------------------------------------------------------------------------------------------------------------

*   **Status:** Alpha - continued testing and evaluation of performance of BoLD with Stylus
*   **Arbitrum Sepolia** Dec 11, 2024
*    09:00 ET (GMT-5) on Feb 12, 2025
*    09:00 ET (GMT-5) on Feb 12, 2025

### tldr;[​](#tldr "Direct link to tldr;")

 is an upgrade to the dispute protocol on Arbitrum chains that delivers both permissionless validation and core security benefits. As with all features on the Arbitrum stack, Orbit chains can adopt BoLD at their own discretion and on their own timeline. To upgrade to BoLD, it is required to upgrade both the Nitro node software and the rollup's smart contracts on its parent chain.

### Recommended Adoption Path[​](#recommended-adoption-path "Direct link to Recommended Adoption Path")

BoLD brings new security benefits to Orbit chains, regardless of whether their validators are permissioned or permissionless. These new security benefits include improved resistance to delay attacks and increased censorship resistance for `L3s`. We strongly recommend Orbit chains adopt Arbitrum BoLD to register these security benefits while **keeping validation permissioned**. We currently recommend Orbit chain owners to adopt Arbitrum BoLD ~30 days after BoLD has been activated on Arbitrum One and Arbitrum Nova (timestamps [here](https://docs.arbitrum.foundation/network-upgrades#network-activation-statuses)) to minimize any stability risks/bugs.

warning

It is strongly recommended that existing and prospective Orbit chains upgrade to use Arbitrum BoLD but **keep validation permissioned** because of the increased risks associated with allowing any entity to advance and challenge the state of your chain. The risks are summarized below. Rigorous testing and research has been poured into the parameters chosen for Arbitrum One and so we cannot formally support or endorse use of permissionless Arbitrum BoLD in other configurations. Please note that when a chain upgrades to use Arbitrum BoLD, any withdrawals (to the parent chain) will be delayed by an additional challenge period. The default challenge period is 6.4 days. We recommend informing the Offchain Labs teams of your timelines and intent to upgrade so adequate warning can be provided to your chain's users on the [Arbitrum Bridge](https://bridge.arbitrum.io/).

Below is a quick breakdown of the benefits of permissioned BoLD vs. permissionless BoLD for your Orbit chain:

![AEP scenario 1](/img/orbit-bold-orbit-permissionless-vs-permissioned.png)

### Benefits of adopting Arbitrum BoLD[​](#benefits-of-adopting-arbitrum-bold "Direct link to Benefits of adopting Arbitrum BoLD")

Arbitrum BoLD enables an  to be permissionlessly validated thanks to several key improvements to the existing dispute protocol. These key improvements benefit an  chain even if validation is kept permissioned on a BoLD-enabled Orbit chain.

Below are some benefits for an Orbit chain that come with adopting Arbitrum BoLD - **regardless of whether validation is kept permissioned or not**:

#### Improved resistance to delay attacks[​](#improved-resistance-to-delay-attacks "Direct link to Improved resistance to delay attacks")

Disputes on a BoLD-enabled chain are resolved in a round-robin style format where disputes can be concurrently resolved. This is an evolution from the current dispute protocol, where challenges are resolved one-by-one. This evolution means that an upper time bound can be placed on all disputes such that a malicious actor cannot delay the chain indefinitely like they can today. Even when validation is kept permissioned, this upper time bound is critical to mitigating the risk of [delay attacks](https://medium.com/offchainlabs/solutions-to-delay-attacks-on-rollups-434f9d05a07a) by parties on the validator allowlist for an Orbit chain.

#### Being on the latest version of Arbitrum technology[​](#being-on-the-latest-version-of-arbitrum-technology "Direct link to Being on the latest version of Arbitrum technology")

Adopting Arbitrum BoLD for your Orbit chain will require upgrading the Nitro node software and deploying a new set of contracts on your parent chain. While not specifically related to Arbitrum BoLD, it is always strongly recommended that Orbit chain owners upgrade and keep their chain on the latest stable releases of both Nitro node software and the relevant on-chain contracts. This is critical to ensure your Orbit chain benefits from the latest security improvements and features that the Offchain Labs team is constantly churning out.

#### Secured by interactive fraud-proofs[​](#secured-by-interactive-fraud-proofs "Direct link to Secured by interactive fraud-proofs")

Arbitrum BoLD is not an upgrade to a different type of proving architecture and will continue to be secured with an interactive proving game between validators using fraud proofs. The same single-honest party assumption applies but now with strict improvements to security to the point where chains, like Arbitrum One, can be permissionlessly validated and have their state assertions be permissionlesly challenged.

#### Use of your project's native token as the bonding asset to secure the chain[​](#use-of-your-projects-native-token-as-the-bonding-asset-to-secure-the-chain "Direct link to Use of your project's native token as the bonding asset to secure the chain")

Arbitrum BoLD enables the chain owner to use any `ERC-20` token on the parent chain as the bond for validators to participate in securing the network. By default, this token will be `WETH` for  and we do not recommend teams to use alternative tokens as the bonding asset. For more information on the rationale, we recommend teams consult our documentation to understand [why `WETH` was selected for Arbitrum One](https://docs.arbitrum.io/how-arbitrum-works/bold/gentle-introduction#q-why-is-arb-not-the-bonding-token-used-in-bold-on-arbitrum-one) (and not `ARB`).

#### Increased censorship resistance for `L3` Orbit chains[​](#increased-censorship-resistance-for-l3-orbit-chains "Direct link to increased-censorship-resistance-for-l3-orbit-chains")

Today, the force inclusion window is a fixed 24 hours. This force inclusion window exists to enable both users and validators to force-include their transactions and assertions on the parent chain, with a 24-hour delay, if the sequencer is offline or censoring transactions. Arbitrum BoLD's release will come with the _Censorship Timeout_ feature that will automatically reduce the force inclusion time window if the parent chain or sequencer is maliciously censoring user transactions/assertions or the sequencer goes offline. This massively benefits Orbit `L3` chains (that settle to a BoLD-enabled parent chain) as it ensures the chain can advance with minimal UX degradation during periods of censorship. You can read more about how this feature works in the [gentle introduction to BoLD](https://docs.arbitrum.io/how-arbitrum-works/bold/gentle-introduction#q-how-do-bold-based-l3s-challenge-periods-operate-considering-the-worst-case-scenario).

### Caveats that come with adopting Arbitrum BoLD for permissionless validation[​](#caveats-that-come-with-adopting-arbitrum-bold-for-permissionless-validation "Direct link to Caveats that come with adopting Arbitrum BoLD for permissionless validation")

Arbitrum BoLD's implementation and specification have been thoroughly tested and audited. The upgrade to Arbitrum BoLD is not the subject of this section, but rather the caveats and nuances that come with whether to enable permissionless validation.

warning

It is strongly recommended that existing and prospective Orbit chains upgrade to use Arbitrum BoLD but **keep validation permissioned** because of the increased risks associated with allowing any entity to advance and challenge the state of your chain. The risks are summarized below. Rigorous testing and research has been poured into the parameters chosen for Arbitrum One and so we cannot formally support or endorse use of permissionless Arbitrum BoLD in other configurations.

Enabling permissionless validation means that any entity can spin up a validator and open challenges to dispute invalid claims made by other validators on the network. This opens up an Orbit chain to the risk of spam and attacks by unknown and malicious entities. To mitigate this risk for Arbitrum One, a considerable amount of research and testing has been done to optimize the trade-offs between deterring attacks and managing the costs of defending Arbitrum for honest parties. This research includes carefully calculating all relevant bond sizes, challenge period durations, and relevant plans for operating the infrastructure. More information on this research can be found in the [BoLD whitepaper](https://arxiv.org/abs/2404.10491). Below are a few examples of various risks that an Orbit chain will hold should they pursue permissionless BoLD:

#### Risk of resource exhaustion attacks[​](#risk-of-resource-exhaustion-attacks "Direct link to Risk of resource exhaustion attacks")

Where malicious entities can acquire and utilize more resources than honest parties can put together during a challenge. Such an attack can take many forms and includes both on-chain and off-chain computational/infra costs. For example, a well-coordinated attack on an Orbit chain could overwhelm honest parties if the malicious actors can spend more gas and computational power and acquire more of the bonding asset than the defenders can. This risk can be mitigated by a combination of high bond sizes, use of a price-independent bonding asset, use of a bonding asset with high liquidity, strong economic guarantees that attackers will lose most of their resources, sufficiently long challenge periods, and robust infrastructure operations and resources that can respond and scale up when necessary. More information on resource exhaustion attacks and how Arbitrum BoLD's design accounts for this risk can be found in [Section 6.1.4 of the BoLD whitepaper](https://arxiv.org/abs/2404.10491). We recommend teams consider a resource exhaustion ratio greater than 5 assuming very high L1 gas costs (like 100gwei/gas).

#### Increased infrastructure costs and overhead[​](#increased-infrastructure-costs-and-overhead "Direct link to Increased infrastructure costs and overhead")

Related to, and expanding on, the above point about resource exhaustion attacks, the honest parties operating active validators and proposers for a BoLD-enabled chain will need to be ready to vertically scale their infrastructure, and cover the off-chain costs of doing so, in the event of an attack. This is because a malicious actor may choose to spam and overwhelm the honest defenders with multiple challenges. Making moves, honest or malicious, costs resources to perform bisections on history committments down to a single step of execution. If this happens, each malicious challenge must be met with an honest counter-challenge during the interactive fraud proof game. Orbit chains who decide to adopt Arbitrum BoLD in permissionless mode are strongly encouraged to work with their Rollup-as-a-Service (RaaS) team to: deploy robust monitoring for challenges, set aside a budget to vertically scale up infrastructure and fund counter-challenges, and have an incident response plan drafted and rehearsed to ensure prompt and decisive reactionary steps in the event of an attack.

#### Risks to liveness or delays of the chain[​](#risks-to-liveness-or-delays-of-the-chain "Direct link to Risks to liveness or delays of the chain")

If the bond sizes are set too low, an adversary can cheaply create a challenge and delay confirmation of an assertion for up to an entire extra challenge period if they can censor honest BoLD moves. Remember that challenges, while time-bound, still take time to complete. Delaying the confirmation of assertions for a chain could negatively impact the chain in many ways that an attacker could benefit from (e.g., profiting from price volatility and price impacts on the Orbit chain's token may make delaying the chain worthwhile for an attacker). We recommend teams set bond sizes to be much greater than the opportunity cost of a week of delay, based on your chain's TVL (e.g. if your chain's TVL is $1B, then the opportunity cost of $1B should be used as a _floor_ for the block level bond amount size). We further recommend that the bonding token used is highly liquid on the parent chain and relatively non-volatile.

### Conclusion for Orbit chains considering BoLD Permissionless Validation[​](#conclusion-for-orbit-chains-considering-bold-permissionless-validation "Direct link to Conclusion for Orbit chains considering BoLD Permissionless Validation")

Due to the uniquely different tokenomics, sizes, and varying types of  chains deployed (or in active development) today,  does not provide a "one-size-fits-all" recommendation for how best to safely set up and enable permissionless validation for Orbit chains. Instead, we recommend teams adopt Arbitrum BoLD but keep validation permissioned.

Should Orbit teams strongly desire to adopt Arbitrum BoLD in permissionless mode, we do not endorse using configurations that differ from those on [Arbitrum One](https://github.com/OffchainLabs/nitro-contracts/blob/bold-merge/scripts/files/configs/arb1.ts). We especially do not recommend teams use custom ERC20 tokens as the bonding asset and/or with low bond minimums. If your team would like to have permissionless validation for your Orbit chain, please reach out to us [via this form](https://docs.google.com/forms/d/e/1FAIpQLSe5YWxFbJ8DgWcDNbIW2YYuTRmegtx2FHObym00_sOt0kq4wA/viewform) so that we can schedule some time to understand your needs better.

### How to adopt Arbitrum BoLD[​](#how-to-adopt-arbitrum-bold "Direct link to How to adopt Arbitrum BoLD")

As mentioned earlier, the upgrade to the dispute protocol involves both a Nitro node software upgrade and the deployment/upgrade of new smart contracts on your Orbit's parent chain.

More details on deploying Arbitrum BoLD for your Orbit chain will be added here when they are available.

---

# Orbit chain ownership | Arbitrum Docs

## Orbit chain ownership

A **chain owner** of an  chain is an entity that can carry out critical upgrades to the chain's core protocol; this includes upgrading protocol contracts, setting core system parameters, and adding & removing other chain owners.

An Orbit chain's initial chain owner is set by the chain's creator when the chain is deployed.

The chain-ownership architecture is designed to give Orbit chain creators flexibility in deciding how upgrades to their chain occur.

### Architecture[​](#architecture "Direct link to Architecture")

Chain ownership affordance is handled via [**Upgrade Executor**](https://github.com/OffchainLabs/upgrade-executor) contracts.

Each Orbit chain is deployed with two Upgrade Executors — one on the Orbit chain itself, and one on its  At deployment, the chain's critical affordances are given to the Upgrade Executor contracts.

Some examples:

*   The parent chain's core protocol contracts are upgradeable proxies that are controlled by a proxy admin; the proxy admin is owned by the Upgrade Executor on the parent chain.
*   The core Rollup contract's admin role is given to the Upgrade Executor on the parent chain.
*   The affordance to call setters on the ArbOwner procompile — which allows for setting system gas parameters and scheduling ArbOS upgrades (among other things) — is given to the Upgrade Executor on the Orbit chain.

Calls to an Upgrade Executor can only be made by chain owners; e.g., entities granted the `EXECUTOR_ROLE` affordance on the Upgrade Executor. Upgrade executors also have the `ADMIN_ROLE` affordance granted to themselves, which lets chain owners add or remove chain owners.

With this architecture, the Upgrade Executor represents a single source of truth for affordances over critical upgradability of the chain.

### Upgrades[​](#upgrades "Direct link to Upgrades")

Upgrades occur via a chain owner initiating a call to an Upgrade Executor, which in turns calls some chain-owned contract.

Chain owners can either call [UpgradeExecutor.executeCall](https://github.com/OffchainLabs/upgrade-executor/blob/a8d3020c2771d164ebd323b1d99249049fe749f9/src/UpgradeExecutor.sol#L73), which will in turn call the target contract directly, or [UpgradeExecutor.execute](https://github.com/OffchainLabs/upgrade-executor/blob/a8d3020c2771d164ebd323b1d99249049fe749f9/src/UpgradeExecutor.sol#L57), which will delegate-call to an "action contract" and use its code to call the target contract.

### Ownership flexibility[​](#ownership-flexibility "Direct link to Ownership flexibility")

A chain owner is simply an address; it is set by the Orbit chain's deployer and can represent any sort of governance scheme. I.e., it could be an EOA (as is set via the [Orbit Quickstart](/launch-orbit-chain/orbit-quickstart)), a Multisig, a governance token system, etc.

The Arbitrum DAO governed chains, while not Orbit chains themselves, use a similar architecture and upgrade pattern as Orbit chains, with both a governance token and a Multisig (aka, the "Security Council") as chain owners. For more info and best practices on action contracts, see ["DAO Governance Action Contracts"](https://github.com/ArbitrumFoundation/governance/blob/main/src/gov-action-contracts/README.md).

(_NOTE: The DAO Governed chains' Upgrade Executor contracts don't have the `.executeCall` method; only the `.execute` method_)

---

# SDK support for custom gas token Orbit chains | Arbitrum Docs

## SDK support for custom gas token Orbit chains

Arbitrum SDK is a TypeScript library for client-side interactions with Arbitrum. It provides common helper functionality as well as access to the underlying smart contract interfaces.

### Custom gas token APIs[​](#custom-gas-token-apis "Direct link to Custom gas token APIs")

Custom gas token support in the Arbitrum SDK introduces a suite of APIs designed for the specific purpose of facilitating **bridging** operations. These APIs are tailored for use cases where there is a need to transfer a native token or an ERC-20 token from the parent chain to an orbit chain utilizing a `custom gas token`. The process involves an initial step of authorizing the native token on the parent chain. To streamline this, our APIs provide functionalities for token approval and offer a mechanism to verify the current status of this approval. Detailed below is a guide to how each of these APIs can be effectively utilized for distinct purposes:

1.  **EthBridger Context:**
    
    *   **APIs:** `getApproveGasTokenRequest` and `approveGasToken`.
    *   **Purpose:** These APIs are essential for the bridging of native tokens to the Orbit chain. They facilitate the necessary approval for native tokens, allowing contracts to manage fund movements. This process includes escrowing a specified amount of the native token on the parent chain and subsequently bridging it to the Orbit chain.
    *   **Note** that you should use `EthBridger` when bridging the native token between the parent chain and the orbit chain.
2.  **Erc20Bridger Context:**
    
    *   **APIs:** `getApproveGasTokenRequest` and `approveGasToken`.
    *   **Purpose:** In the scenario of bridging ERC20 assets to an Orbit chain, these APIs play a crucial role. Token Bridging on Arbitrum Nitro stack uses retryable tickets and needs a specific fee to be paid for the creation and redemption of the ticket. For more information about retryable tickets, please take a look at [our chapter about retryable tickets](/how-arbitrum-works/l1-to-l2-messaging#retryable-tickets) part of our docs. The Orbit chain operates as a custom gas token network, necessitating the payment of fees in native tokens for the creation of retryable tickets and their redemption on the Orbit chain. To cover the submission and execution fees associated with retryable tickets on the Orbit chain, an adequate number of native tokens must be approved and allocated to the parent chain to cover the fees.
    *   **Note** that you should use `Erc20Bridger` when bridging an ERC-20 token between the parent chain and the orbit chain.

**Note** that these APIs are just needed for `custom gas token` orbit chains and for ETH-powered rollup and anytrust orbit chains, you don't need to use them.

**Note** that when native tokens are transferred to the custom gas token orbit chain, they function equivalently to ETH on EVM chains. This means these tokens will exhibit behavior identical to that of ETH, the native currency on EVM chains. This similarity in functionality is a key feature to consider in transactions and operations within the orbit chain.

**Note** that everything else is under the hood, and the custom gas token code paths will be executed just if the `L2Network` object config has a `nativeToken` field.

### Registering a custom token in the Token Bridge[​](#registering-a-custom-token-in-the-token-bridge "Direct link to Registering a custom token in the Token Bridge")

When [registering a custom token in the Token Bridge](/build-decentralized-apps/token-bridging/token-bridge-erc20#setting-up-your-token-with-the-generic-custom-gateway) of a custom-gas-token Orbit chain, there's an additional step to perform before calling `registerTokenToL2`.

Since the Token Bridge [router](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1OrbitGatewayRouter.sol#L142-L144) and the [generic-custom gateway](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1OrbitCustomGateway.sol#L203-L210) expect to have allowance to transfer the native token from the `msg.sender()` to the inbox contract, it's usually the token in the parent chain who handles those approvals. In the [TestCustomTokenL1](https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/test/TestCustomTokenL1.sol#L158-L168), we offer as an example of implementation. We see that the contract transfers the native tokens to itself and then approves the router and gateway contracts. If we follow that implementation, we only need to send an approval transaction to the native token to allow the TestCustomTokenL1 to transfer the native token from the caller of the `registerTokenToL2` function to itself.

You can find a [tutorial that deploys two tokens and registers them in the Token Bridge of a custom-gas-token-based chain](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/custom-token-bridging).

---

# Public preview: What to expect | Arbitrum Docs

## Public preview: What to expect

Orbit chains are currently a **public preview** offering. This concept document explains what "public preview" means, what to expect from Orbit's public preview capabilities, and how to engage with our team as you tinker.

### Arbitrum Orbit is Mainnet ready, but deploy to Testnet first[​](#arbitrum-orbit-is-mainnet-ready-but-deploy-to-testnet-first "Direct link to Arbitrum Orbit is Mainnet ready, but deploy to Testnet first")

Arbitrum Orbit's core technology has undergone a comprehensive audit and is now able to support deployments to Mainnet.

It's important to note that Orbit is a new technology and as such, **there are risks involved**.

To mitigate these risks, you're strongly encouraged to **deploy your Orbit chain on Testnet first**. If you don't launch on Testnet first, you significantly increase risk.

Refer to the [Orbit quickstart](/launch-orbit-chain/orbit-quickstart) for instructions that walk you through the process of deploying your Orbit chain to Testnet.

### How products like Orbit are developed at Offchain Labs[​](#how-products-like-orbit-are-developed-at-offchain-labs "Direct link to How products like Orbit are developed at Offchain Labs")

Offchain Labs builds products in a way that aligns loosely with the spirit of "building in public". We like to release things **early and often** so that we can capture feedback and iterate in service of your needs, as empirically as possible.

To do this, some of our product offerings are documented with **public preview** disclaimers that look like this:

This banner's purpose is to set expectations while inviting readers like you to express your needs so that we can incorporate them into the way that we iterate on product.

### What to expect when using public preview offerings[​](#what-to-expect-when-using-public-preview-offerings "Direct link to What to expect when using public preview offerings")

As you tinker and provide feedback, we'll be listening. Sometimes, we'll learn something non-obvious that will result in a significant change. More commonly, you'll experience incremental improvements to the developer experience as the offering grows out of its **public preview** status, towards **stable** status.

Public preview offerings are evolving rapidly, so don't expect the degree of release notes discipline that you'd expect from a stable offering. Keep your eyes open for notifications regarding patch, minor, and major changes, along with corresponding relnotes that highlight breaking changes and new capabilities.

### How to provide feedback[​](#how-to-provide-feedback "Direct link to How to provide feedback")

Our product team primarily uses three feedback channels while iterating on public preview capabilities:

1.  **Docs**: Click on the `Request an update` button located in the top-right corner of any document to provide feedback on the docs and/or developer experience. This will lead you to a prefilled Github issue that members of our product team periodically review.
2.  **Discord**: [Join the Arbitrum Discord](https://discord.gg/arbitrum) to engage with members of the Arbitrum community and product team.
3.  **Google form**: Complete [this form](http://bit.ly/3yy6EUK) to ask for support.

### What to expect when providing feedback[​](#what-to-expect-when-providing-feedback "Direct link to What to expect when providing feedback")

Our ability to respond to feedback is determined by our ever-evolving capacity and priorities. We can't guarantee responses to all feedback submissions, but our small-but-mighty team is listening, and we'll try our best to acknowledge and respond to your feedback. No guarantees though!

_PS, [our small-but-mighty team is hiring](https://jobs.lever.co/offchainlabs)._

### Thank you![​](#thank-you "Direct link to Thank you!")

Thanks for helping us build things that meet your needs! We're excited to engage with OGs and newcomers alike; please don't hesitate to reach out.

---

# AEP fee router | Arbitrum Docs

## AEP fee router

---

# Enable fast withdrawals on your Orbit chain | Arbitrum Docs

## Enable fast withdrawals on your Orbit chain

Optimistic Rollups must sustain a multi-day challenge period to allow time for fraud proofs. This delays finality for users and dApps, resulting in multi-day withdrawal times and cross-chain communication delays.

Fast withdrawals is a new configuration allowing Orbit chains to achieve fast finality. When an Orbit chain operates on Fast Withdrawals, its transactions will be processed by a committee of validators. Transactions reaching a unanimous vote across the committee will be immediately confirmed.

This will allow:

*   Setting up a withdrawal frequency of any time period (up to 15 minutes)
*   Users' withdrawals confirmation on the parent chain at frequencies up to ~15 minutes
*   Cross-chain dApps to read the finalized state at the same rate as the fast withdrawal frequency

Recommended configuration[​](#recommended-configuration "Direct link to Recommended configuration")
---------------------------------------------------------------------------------------------------

While any Orbit chain can adopt Fast Withdrawals, we only _recommend_ that fast withdrawals be adopted by AnyTrust chains with a minimum validator and DAC member requirement. We explain both these recommendations below:

### Fast withdrawals for AnyTrust chains[​](#fast-withdrawals-for-anytrust-chains "Direct link to Fast withdrawals for AnyTrust chains")

As AnyTrust chains are an optimum (an optimistic rollup using a separate data availability layer), AnyTrust chains are already placing a trust assumption on their Data Availability Committee (DAC) to provide the data needed for fraud proofs and recreating the chain.

The optimal setup for an AnyTrust chain is to have all DAC members _also_ run validators as part of the fast withdrawals committee. This will leverage the existing trust assumption placed on the DAC operators such that **enabling fast withdrawals does not add any new trusted parties.**

It is possible for an Orbit Rollup to adopt fast withdrawals. However, it would technically no longer be a Rollup as the minimum trust assumption will shift to the trust placed in the Fast Confirmations committee.

### Minimum validator and DAC nodes[​](#minimum-validator-and-dac-nodes "Direct link to Minimum validator and DAC nodes")

We recommend that any Fast Withdrawals-enabled chain have at least three DAC members and three validators acting in the fast withdrawals committee. Given that fast withdrawals will enable confirmation of new Rollup state much faster than the usual 6.4-day challenge period (15 minutes for L2s and 15 seconds for L3s), it becomes even more important to have additional parties involved in validation to further reduce trust assumptions. This requirement can be be met with three total operators, who each run a single DAS node and a single validator.

Technical lower bound for fast withdrawals[​](#technical-lower-bound-for-fast-withdrawals "Direct link to Technical lower bound for fast withdrawals")
------------------------------------------------------------------------------------------------------------------------------------------------------

Once fast withdrawals is enabled, the committee will confirm transactions at the configured frequency. However, a higher network load can cause the fast withdrawals committee to experience slight delays from the configured rate.

*   For low-to-medium activity chains (< 1 Mgas/s), 15 seconds is considered to be the sustained lower bound for Fast Withdrawals.
*   For chains with higher throughput (>1 Mgas/s), the practical lower bound for fast withdrawals is between 1-2 minutes.

Chain owners and operators should be aware that the fast withdrawals committee may take longer to confirm new assertions under conditions with greater network load. This behavior is to be expected and does not interfere with the security or trust model of the fast withdrawals committee.

Practical lower bounds concerning parent chain finality[​](#practical-lower-bounds-concerning-parent-chain-finality "Direct link to Practical lower bounds concerning parent chain finality")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

While a fast withdrawals-enabled chain can be configured to finality in as little as 15 seconds, there are externalities on the parent chain and from cross-chain messaging layers that must be considered.

For an Ethereum-based Layer-2, we recommend that the fast withdrawal frequency remain above 12.8 minutes, which is the time for Ethereum to achieve finality. For non-Ethereum L1s, we similarly recommend staying above the accepted finality threshold specific to that L1.

For an Arbitrum One-based Layer-3, there are three tiers of finality to consider:

1.  Soft finality from the sequencer's confirmation of transaction inclusion (~250ms)
2.  Safe finality from batch inclusion after Arbitrum One's assertion is included in an Ethereum block.
3.  Hard finality after the Ethereum block containing Arbitrum One's batch is finalized on Ethereum (~15 minutes)

Layer-3 Orbit chains can make their own determination about what level of finality to accept. We consider it safe to rely on soft finality, which would practically enable an Orbit chain to configure fast withdrawals down to 15 seconds.

Adoption instructions (example script)[​](#adoption-instructions-example-script "Direct link to Adoption instructions (example script)")
----------------------------------------------------------------------------------------------------------------------------------------

To enable the fast withdrawals feature, there are three actions to take:

1.  Make sure the chain is using nitro-contracts v2.1.0 or above
2.  Activate the fast withdrawals feature
3.  Upgrade the node software to nitro v3.1.2 or above

### Upgrading to nitro-contracts v2.1.0[​](#upgrading-to-nitro-contracts-v210 "Direct link to Upgrading to nitro-contracts v2.1.0")

As mentioned above, the fast withdrawals feature is available for chains that are using nitro-contracts v2.1.0 or above, especially the `RollupAdminLogic` and the `RollupUserLogic` contracts. You can check what nitro-contracts version your chain is using by running the [orbit versioner script](https://github.com/OffchainLabs/orbit-actions/blob/main/README.md#check-version-and-upgrade-path).

If your chain is not running with nitro-contracts v2.1.0 or above, you’ll need to perform an upgrade to enable this version. The [orbit versioner script](https://github.com/OffchainLabs/orbit-actions/blob/main/README.md#check-version-and-upgrade-path) will provide the upgrade paths needed to reach v2.1.0, but basically:

*   If the chain is running nitro-contracts v1.1.x, you need to [upgrade first to v1.2.1](https://github.com/OffchainLabs/orbit-actions/blob/main/scripts/foundry/contract-upgrades/1.2.1/README.md).
*   If the chain is running nitro-contracts v1.2.1, you need to [upgrade to v2.1.0](https://github.com/OffchainLabs/orbit-actions/blob/main/scripts/foundry/contract-upgrades/2.1.0/README.md).

Upgrading to the new nitro-contracts version also requires updating the node software. For v2.1.0, validator nodes and the batch poster node should run [nitro v3.1.2](https://github.com/OffchainLabs/nitro/releases/tag/v3.1.2) or above.

Suppose you’re upgrading your nitro-contracts from v1.2.1 to v2.1.0 and using the standard WASM module root (without customizations). In that case, there are [action contracts available in the supported chains](https://github.com/OffchainLabs/orbit-actions/blob/main/scripts/foundry/contract-upgrades/2.1.0/README.md#deployed-instances). If you’re using a customized nitro software, with a different WASM module root, you can still deploy the action contract referencing your modified WASM module root (pre and post upgrade).

### Activating fast withdrawals[​](#activating-fast-withdrawals "Direct link to Activating fast withdrawals")

Once the chain runs nitro-contracts v2.1.0 or above, the new fast withdrawal parameters will be available in the `RollupAdminLogic` and the `RollupUserLogic` contracts.

Both the Orbit SDK and the Orbit actions repository provide configurable scripts to activate and configure fast withdrawals on an AnyTrust chain. You can use either of those to activate the feature. Both scripts perform the same actions.

ℹ️ Even though two scripts are available to activate Fast Withdrawals, you only need to execute one of them. Both scripts perform the same actions.

**Orbit SDK script**

The Orbit SDK provides an [example script](https://github.com/OffchainLabs/arbitrum-orbit-sdk/tree/main/examples/setup-fast-withdrawal) to set up a fast withdrawal committee by performing the following operations:

1.  Create a new n/n Safe wallet with the specified validators as signers
2.  Add the specified validators to the Rollup validators allowlist
3.  Set the new Safe wallet as the `anytrustFastConfirmer` in the Rollup contract
4.  Set the new `minimumAssertionPeriod` if needed
5.  Show how to configure the batch poster and validator nodes

To configure the script, you need to specify the following environment variables:

Variable Name

Description

`CHAIN_OWNER_PRIVATE_KEY`

Private key of the account with executor privileges in the UpgradeExecutor admin contract for the chain. It will be the deployer of the multi-sig Safe wallet.

`PARENT_CHAIN_ID`

ChainId of the parent chain.

`ROLLUP_ADDRESS`

Address of the Rollup contract.

`FC_VALIDATORS`

Array of fast-withdrawal validators. They will be added as signers to the multisig Safe wallet and to the Rollup's validator allowlist. It is recommended that these are DAC members of the AnyTrust chain.

`MINIMUM_ASSERTION_PERIOD`

Optional parameter that defaults to 75 blocks (~15 minutes). Minimum number of blocks that have to pass in between assertions (measured in L1 blocks).

Finally, follow these steps to execute the script (from the `examples/setup-fast-withdrawal` folder):

1.  Install dependencies

```rust
yarn install
```

2.  Create a .env file and add the env vars

```rust
cp .env.example .env
```

3.  Run the script

```rust
yarn run dev
```

**Orbit actions script**

The Orbit actions repository also provides an [action script](https://github.com/OffchainLabs/orbit-actions/blob/main/scripts/foundry/fast-confirm/README.md) to activate fast withdrawals by performing the following operations:

1.  Make sure the "Validate fast confirmation" has not been enabled yet
2.  Create a Safe contract for the fast confirmation committee
3.  Set the Safe contract as the fast confirmer on the Rollup
4.  Set the Safe contract as a validator on the Rollup
5.  Set `setMinimumAssertionPeriod` to 1 block to allow more frequent assertion

To configure the action script, you need to specify the following environment variables:

Variable Name

Description

`UPGRADE_ACTION_ADDRESS`

Address of the upgrade action to execute. A standard version is deployed in all [supported chains](https://github.com/OffchainLabs/orbit-actions/blob/main/scripts/foundry/fast-confirm/README.md#deployed-instances). If you need to deploy your own action, execute the first step of [this process](https://github.com/OffchainLabs/orbit-actions/blob/main/scripts/foundry/fast-confirm/README.md#how-to-use-it).

`PARENT_UPGRADE_EXECUTOR_ADDRESS`

Private key of the account with executor privileges in the UpgradeExecutor admin contract on the parent chain. It will be the deployer of the multi-sig Safe wallet.

`PARENT_CHAIN_RPC`

RPC endpoint of the parent chain.

`ROLLUP`

Address of the Rollup contract.

`FAST_CONFIRM_COMMITTEE`

Comma-separated list of fast-withdrawal validators. They must be allowlisted validators in the Rollup contract. They will be added as signers to the multisig Safe wallet. It is recommended that these are DAC members of the AnyTrust chain.

Finally, follow these steps to execute the script (from the `scripts/foundry/fast-confirm` folder):

1.  Install dependencies

```rust
yarn install
```

2.  Create a .env file and add the env vars

```rust
cp .env.example .env
```

3.  Execute the action. The upgrade can be executed using  `cast`  CLI command ([cast is a part of the Foundry tools](https://book.getfoundry.sh/cast/)), using the owner account (the one with executor rights on parent chain `UpgradeExecutor`) to send the transaction:

```rust
(export $(cat .env | xargs) && cast send $PARENT_UPGRADE_EXECUTOR_ADDRESS "execute(address, bytes)" $UPGRADE_ACTION_ADDRESS $(cast calldata "perform(address, address[])" $ROLLUP \[$FAST_CONFIRM_COMMITTEE\]) --rpc-url $PARENT_CHAIN_RPC --account EXECUTOR)
# use --account XXX / --private-key XXX / --interactive / --ledger to set the account to send the transaction from
```

**NOTE:** If you have a multisig as executor, you can use the following command to create the payload for calling into the `PARENT_UPGRADE_EXECUTOR`:

```rust
(export $(cat .env | xargs) && cast calldata "execute(address, bytes)" $UPGRADE_ACTION_ADDRESS $(cast calldata "perform(address, address[])" $ROLLUP \[$FAST_CONFIRM_COMMITTEE\]))
```

### Configure fast withdrawal on nitro v3.1.2 or above[​](#configure-fast-withdrawal-on-nitro-v312-or-above "Direct link to Configure fast withdrawal on nitro v3.1.2 or above")

To be able to use Fast Withdrawal on your chain, the batch poster and the validators of the chain need to be running [nitro v3.1.2](https://github.com/OffchainLabs/nitro/releases/tag/v3.1.2) or above.

The following parameters need to be configured in those nodes.

**Batch poster**

Option

Description

`--node.batch-poster.max-delay=0h15m0s`

Since batches need to be posted so validators can create and confirm assertions, the maximum delay should be set to an amount close to the `minimumAssertionPeriod` defined in the Rollup contract. Modify `0h15m0s` to the configured value.

**Validators**

Option

Description

`--node.staker.enable-fast-confirmation=true`

Enables fast withdrawals in the validator node

`--node.staker.make-assertion-interval=0h15m0s`

Since assertions need to be created for them to be confirmed, the minimum interval to create these assertions should be set to an amount close to the `minimumAssertionPeriod` defined in the Rollup contract. Modify `0h15m0s` to the configured value.

note

Immediately after configuring fast withdrawals - your chain may not be operating fully at speed yet. This is because the validators have to work through the backlog of assertions which were not yet confirmed. You will see a series of NodeCreated and NodeConfirmed events. Once the backlog has been processed, your chain should operate fully at speed.

---

# Layer leap | Arbitrum Docs

## Layer leap

---

# The AEP fee router: introduction | Arbitrum Docs

## The AEP fee router: introduction

What is the Arbitrum expansion program?[​](#what-is-the-arbitrum-expansion-program "Direct link to What is the Arbitrum expansion program?")
--------------------------------------------------------------------------------------------------------------------------------------------

The [Arbitrum Expansion Program](https://forum.arbitrum.foundation/t/the-arbitrum-expansion-program-and-developer-guild/20722) (AEP) allows Orbit chains to deploy on _any chain_ permissionlessly. As part of the [AEP license](https://docs.arbitrum.foundation/aep/ArbitrumExpansionProgramTerms.pdf), Orbit chains deployed outside of Arbitrum One and Arbitrum Nova must pay 10% of their **Net Protocol Revenue** to the Arbitrum DAO.

The Arbitrum Expansion Program and Developer Guild are initiatives launched in collaboration with Offchain Labs to promote the development of customized Arbitrum chains using the Orbit framework. The Expansion Program simplifies the process for teams to create Layer 2 (L2) and Layer 3 (L3) chains, offering self-service tools and customization options. Projects benefit from features like:

*   Dedicated block space
*   Custom gas tokens
*   Flexible governance.

These chains can settle to any chain relying on the Ethereum security model.

The Developer Guild incentivizes developers contributing to the Arbitrum codebase, with 2% of revenue from new chains going to a fund dedicated to this purpose. The Expansion Program is designed to align with Ethereum, encourage innovation, and enable projects to tailor the Arbitrum stack to their specific needs. The program also aims to streamline chain deployment, making it easier for developers to adopt Arbitrum's technology while contributing back to the community.

As an Orbit chain owner, you may have the following questions:

How do I send my AEP fees from my Orbit chain to the Arbitrum DAO?[​](#how-do-i-send-my-aep-fees-from-my-orbit-chain-to-the-arbitrum-dao "Direct link to How do I send my AEP fees from my Orbit chain to the Arbitrum DAO?")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Arbitrum provides Orbit chains with easily deployable smart contracts that can streamline the transfer of AEP Fees into the Arbitrum DAO treasury. These contracts are known as **AEP Fee Routers**.

What is net protocol revenue?[​](#what-is-net-protocol-revenue "Direct link to What is net protocol revenue?")
--------------------------------------------------------------------------------------------------------------

Net Protocol Revenue is equivalent to an Orbit chain's profit (revenue minus costs).

How can I ensure I'm complying with the AEP license?[​](#how-can-i-ensure-im-complying-with-the-aep-license "Direct link to How can I ensure I'm complying with the AEP license?")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The Arbitrum Foundation will track compliance based on fees received through the **AEP Fee Router**.

How can I set up an AEP fee router on my Orbit chain?[​](#how-can-i-set-up-an-aep-fee-router-on-my-orbit-chain "Direct link to How can I set up an AEP fee router on my Orbit chain?")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

You can learn how to set up your AEP fee router in [implementation guide](/launch-orbit-chain/configure-your-chain/common-configurations/set-up-aep-fee-router).

![AEP scenario 1](/img/orbit-aep-scenario-1.svg)

![AEP scenario 2](/img/orbit-aep-scenario-2.svg)

![AEP scenario 3](/img/orbit-aep-scenario-3.svg)

![AEP scenario 4](/img/orbit-aep-scenario-4.svg)

![AEP scenario 5](/img/orbit-aep-scenario-5.svg)

---

# ArbOS configuration | Arbitrum Docs

## ArbOS configuration

---

# How to upgrade ArbOS on your Orbit chain | Arbitrum Docs

## How to upgrade ArbOS on your Orbit chain

This how-to provides step-by-step instructions for Orbit chain operators who want to upgrade ArbOS on their Orbit chain(s). Familiarity with ArbOS, Orbit, and [chain ownership](/launch-orbit-chain/concepts/chain-ownership) is expected. Note that Orbit chain owners have full discretion over when and whether to upgrade their ArbOS version.

The specific upgrade requirements for each ArbOS release are located under each reference page for that specific [ArbOS release](/run-arbitrum-node/arbos-releases/overview#list-of-available-arbos-releases).

#### Step 1: Update Nitro on nodes and validators[​](#step-1-update-nitro-on-nodes-and-validators "Direct link to Step 1: Update Nitro on nodes and validators")

Refer to the [requirements for the targeted ArbOS release](/run-arbitrum-node/arbos-releases/overview) to identify the specific [Nitro release](https://github.com/OffchainLabs/nitro/releases/) that supports the ArbOS version that you're upgrading to. For example, if your upgrade targets ArbOS 20, you'd use Nitro `v2.3.1` (Docker image: `offchainlabs/nitro-node:v2.3.1-26fad6f`) or higher. This is the version of the Nitro stack that needs to be running on each of your Orbit chain's nodes. A list of [all Nitro releases can be found on Github](https://github.com/OffchainLabs/nitro/releases).

Begin by upgrading your validator node(s) to the specified Nitro version, then update each remaining Orbit node to match this version.

Note that upgrading your node version _must occur_ before the deadline established for the target ArbOS upgrade. Refer to the timestamp in the ArbOS upgrade schedule for a precise deadline.

#### Step 2: Upgrade the Wasm module root & your chain's Nitro contracts[​](#step-2-upgrade-the-wasm-module-root--your-chains-nitro-contracts "Direct link to Step 2: Upgrade the Wasm module root & your chain's Nitro contracts")

While every ArbOS upgrade will require an update to the Wasm module root, not every ArbOS upgrade will require an upgrade to the chain's `nitro-contracts` version.

If necessary, as defined in the release notes for each ArbOS release ([example of ArbOS 20](/run-arbitrum-node/arbos-releases/arbos20)), you may need to deploy new versions of some (or all) of the Nitro contracts to the parent chain of your Orbit chain. These contracts include the rollup logic, bridging logic, fraud-proof contracts, and interfaces for interacting with Nitro precompiles. To verify the current version of your Nitro contracts, follow [these instructions](https://github.com/OffchainLabs/orbit-actions/blob/main/README.md#check-version-and-upgrade-path) while replacing the inbox contract address and network name with that of your Orbit chain. This information will allow you to find the correct upgrade path for your Nitro contracts.

To update the Wasm module root and deploy your chain's Nitro contracts to the parent chain for the most recent ArbOS release, you will need the following inputs (obtained from the [requirements for the targeted ArbOS release](/run-arbitrum-node/arbos-releases/overview)):

*   The WASM module root, and if necessary,
*   The required `nitro-contracts` version

Once you have the WASM module root and have identified the required `nitro-contracts` version for the target ArbOS release, if any, [please follow the instructions in this guide](https://github.com/OffchainLabs/orbit-actions?tab=readme-ov-file#nitro-contracts-upgrades) for specific actions based on the `nitro-contracts` version you are deploying. Note that each ArbOS release will require performing this step with a different Wasm module root and may require a different version of `nitro-contracts`. The guide linked above will be kept updated with the instructions for each specific ArbOS release.

The `WASM module root` is a 32-byte hash created from the Merkelized Go replay binary and its dependencies. When ArbOS is upgraded, a new Wasm module root is generated due to modifications in the State Transition Function. This new Wasm module root must be set in the rollup contract on the parent chain. You can get the For example, the Wasm module root for ArbOS 20 Atlas is `0x8b104a2e80ac6165dc58b9048de12f301d70b02a0ab51396c22b4b4b802a16a4`.

To set the Wasm module root manually (i.e. not using the above guide), use the `Rollup proxy` contract's [setWasmModuleRoot](https://github.com/OffchainLabs/nitro-contracts/blob/38a70a5e14f8b52478eb5db08e7551a82ced14fe/src/rollup/RollupAdminLogic.sol#L321) method. Note that the `upgrade executor` contract on the parent chain is the designated owner of the rollup contract, so the **chain owner account** needs to initiate a call to the `upgrade executor` contract in order to perform the upgrade. This call should include the correct calldata for setting the new Wasm module root.

Backward compatibility

Wasm module roots are backward compatible, so upgrading them before an ArbOS version upgrade will not disrupt your chain's functionality.

#### Step 3: Schedule the ArbOS version upgrade[​](#step-3-schedule-the-arbos-version-upgrade "Direct link to Step 3: Schedule the ArbOS version upgrade")

To schedule an ArbOS version upgrade for your Orbit chain, [follow this guide](https://github.com/OffchainLabs/orbit-actions/tree/main/scripts/foundry/arbos-upgrades/at-timestamp). In addition to the upgrade action contract address and the account address for the chain owner account, you will need the following inputs:

1.  **`newVersion`**: Specify the ArbOS version you wish to upgrade to (e.g. `20`).
2.  **`timestamp`**: Set the exact Unix timestamp at which you want your Orbit chain to transition to the new ArbOS version.

If you would prefer to do this manually, simply call the [`scheduleArbOSUpgrade`](https://github.com/OffchainLabs/nitro-contracts/blob/acb0ef919cce9f41da531f8dab1b0b31d9860dcb/src/precompiles/ArbOwner.sol#L61) function on the `ArbOwner` precompile of the Orbit chain(s) you're upgrading. Because this is an administrative action (similar to upgrading your Wasm module root), the **chain owner account** must call the target chain's `upgrade executor` contract with the appropriate calldata in order to invoke the `scheduleArbOSUpgrade` function of the ArbOwner precompile. This will schedule the ArbOS upgrade using the specified version and timestamp.

Immediate upgrades

To upgrade immediately (without scheduling), set the timestamp to `0`.

Obtaining the current ArbOS version

You can obtain the current ArbOS version of your chain by calling `ArbSys.ArbOSVersion()`. Keep in mind that this function adds `55` to the current ArbOS version. For example, if your chain is running on ArbOS 10, calling this function will return `65`.

When scheduling the ArbOS upgrade through `ArbOwner.scheduleArbOSUpgrade` you must use the actual ArbOS version you're upgrading to. For example, if you're upgrading to ArbOS 11, you will pass `11` when calling this function.

#### Step 4: Enable ArbOS specific configurations or feature flags (not always required)[​](#step-4-enable-arbos-specific-configurations-or-feature-flags-not-always-required "Direct link to Step 4: Enable ArbOS specific configurations or feature flags (not always required)")

For some ArbOS upgrades, such as [ArbOS 20 Atlas](/run-arbitrum-node/arbos-releases/arbos20), there may be additional requirements or steps that need to be satisfied to ensure your Orbit chain can use all of the new features and improvements made available in that particular ArbOS release.

If there are additional requirements for the targeted ArbOS release you're attempting to upgrade to; the additional requirements will be listed on the reference pages for [the targeted ArbOS release](/run-arbitrum-node/arbos-releases/overview#list-of-available-arbos-releases). For example, the additional requirements for Orbit chains upgrading to ArbOS 20 can be found [here on the ArbOS 20 docs](/run-arbitrum-node/arbos-releases/arbos20).

Congratulations! You've upgraded your Orbit chain(s) to the specified ArbOS version.

---

# Batch Posting and Assertion Control | Arbitrum Docs

## Batch Posting and Assertion Control

---

# Calculating AEP license fees | Arbitrum Docs

## Calculating AEP license fees

This document will help you calculate your Orbit chain’s _Protocol Net Revenue_ and AEP license fees.

Before we define “Protocol Net Revenue”, let's explain how fees work in a standard Orbit chain. From there, we can connect how each fee equates to a revenue or a cost.

### Sequencing revenue[​](#sequencing-revenue "Direct link to Sequencing revenue")

In a vanilla Orbit chain (a chain without customizations, transaction ordering policies, or other add-ons), users and dApps will pay a single gas fee to submit their transactions. Under the hood, however, a user’s fee is allocated across four components used by the network in different ways. These four fee components are split as follows:

*   `l2BaseFee`: fees paid to execute a transaction on the Orbit chain.
*   `l2SurplusFee`: surplus fees are charged in addition to the base fee when an Orbit chain is congested.
*   `l1BaseFee`: fees paid to cover the cost of an Orbit chain posting its settlement transaction to the parent chain.
*   `l1SurplusFee`: an additional surplus fee that can be configured to award extra fees to the batch poster.

Based on the above, we interpret that an Orbit chain’s revenue sources include all fee components: `l2BaseFee`, `l2SurplusFee`, `l1BaseFee`, and `l1SurplusFee`. However, one of these fee components is also a cost, `l1BaseFee`, as it is used to pay for parent chain settlement.

### Assertion costs[​](#assertion-costs "Direct link to Assertion costs")

The above fee system applies to an Orbit chain’s Sequencer and Batch Poster, but there is another important actor that is considered essential to the chain. These are the [validators](/how-arbitrum-works/optimistic-rollup#validators).

Validators are responsible for posting assertions on the parent chain, which are disputable claims about the new state of the Rollup. Posting an assertion is what progressed chain state on the parent chain. Validators are also responsible for securing the chain by creating disputes on false assertions.

As validators are necessary for chain security and chain progression, the gas costs paid by validators are a cost under the AEP license.

The AEP license permits an Orbit chain to deduct the gas costs of assertion posting and confirming **only for validators operated by the chain owner**. The AEP Fee Router does not deduct assertion costs from its fees. In a later section, we will explain how chain owners can optionally deduct assertion costs.

### Additional revenue sources[​](#additional-revenue-sources "Direct link to Additional revenue sources")

As the Orbit license allows chain owners to customize their Rollup, the AEP license accounts for revenue sources that could arise out of innovations. As such, it’s worth noting that the total calculation of revenue will also include:

*   Revenue from transaction ordering policies.
*   Revenue earned through fees on top of the bridge.
*   Broadly, any revenue earned in connection with your use of Arbitrum Nitro.

You can read the relevant legal terminology in Section 2 of the [AEP Terms](https://docs.arbitrum.foundation/aep/ArbitrumExpansionProgramTerms.pdf).

Calculating AEP fees[​](#calculating-aep-fees "Direct link to Calculating AEP fees")
------------------------------------------------------------------------------------

We are now in a place where we can precisely define AEP fees. An Orbit chain’s obligation for AEP license is 10% of a chain’s **Net Protocol Revenue**. Net Protocol Revenue is broadly the difference between (i) gross revenue and (ii) settlement costs.

Based on our understanding above, we can calculate AEP fees as follows.

```rust
AEP_FEES = [(gross revenue) - (settlement costs)]*0.1
AEP_FEES = [(sequencing revenue + additional revenue) - (settlement costs + assertion costs)]*0.1
AEP_FEES = [(l2BaseFee + l2SurplusFee + l1BaseFee + l1SurplusFee) - (l1BaseFee + assertion costs)]*0.1
```

Opting in for assertion cost deduction[​](#opting-in-for-assertion-cost-deduction "Direct link to Opting in for assertion cost deduction")
------------------------------------------------------------------------------------------------------------------------------------------

The AEP Fee Router **does not deduct** **assertion costs** from the fees it routes. This is because the contract system cannot track the amount of gas validators spend, and it cannot determine the eligibility of a validator.

As such, Orbit chains can choose to deduct these costs from their fee stream, but this will require Orbit chains to self-report assertion costs and implement an intermediary multisig that sits before the AEP Fee Router system.

Instructions for doing so can be found below.

### Eligible validators[​](#eligible-validators "Direct link to Eligible validators")

Only validators directly associated with the Orbit chain owner are eligible for assertion cost deductions. By directly associated, we mean a validator operated by the team directly or contracted by an external provider (e.g., a Rollup-as-a-Service team) to act as a validator on behalf of the team. In the event of a contracted validator, only one validator can be eligible.

### Eligible costs[​](#eligible-costs "Direct link to Eligible costs")

The following costs can be deducted for an eligible validator:

1.  The cost of posting assertions
2.  The cost of confirming assertions
3.  The cost of participating in fraud proofs

### Deducting assertion costs[​](#deducting-assertion-costs "Direct link to Deducting assertion costs")

If a team elects to deduct their assertion posting costs from eligible validators, they must establish and obey the following process:

*   Communicate to the Arbitrum Foundation that they intend to deduct on-chain assertion costs
    *   Align on a cadence of disbursal and accounting these costs with the Arbitrum Foundation (e.g., quarterly, annually)
    *   At this cadence, provide on-chain accounting to the Arbitrum Foundation to substantiate deducted costs from the AEP Fee Router stream.

To implement the deduction, the team should do the following:

*   [Configure all Orbit chain fee components](https://docs.arbitrum.io/launch-orbit-chain/how-tos/manage-fee-collectors#how-to-configure-the-fee-collector-addresses) to send all fees to a secure multisig address.
    *   For ease of accounting, it’s strongly recommended that this multisig handle no funds other than the rewards earned from the protocol.
*   On the established regular cadence (e.g., quarterly) deduct _all eligible assertion gas costs_ from the multisig’s balance by transferring it to your preferred fee-collecting address. The remainder of the amount must be forwarded to the `RewardDistributor` contract (configured as directed previously)
*   Following this, the `RewardDistributor` will split the post-deduction funds between the **AEP Fee Router** contracts and the configured chain-owner controlled addresses.

Special cases and exceptions[​](#special-cases-and-exceptions "Direct link to Special cases and exceptions")
------------------------------------------------------------------------------------------------------------

Certain Orbit configurations and customizations require special handling of AEP fees. The following is a non-exhaustive list of applicable scenarios and how to ensure AEP compliance. If any of the following cases apply, the recommended approach for fee handling will require manual handling of a portion of or all AEP Fees.

### L2-based custom gas tokens[​](#l2-based-custom-gas-tokens "Direct link to L2-based custom gas tokens")

If you are an L3 or higher chain with a custom gas token, your custom gas token contract might be deployed on L2. If this L2 is not an Arbitrum chain, then the L2 token can't be transferred via the AEP Fee Router, as this would first require bridging down to Ethereum (impossible for L2-based tokens). In this instance, we recommend your chain pay fees in ETH by manually sending fees to an ETH-configured routing system.

### Non-Ethereum L1[​](#non-ethereum-l1 "Direct link to Non-Ethereum L1")

If your Orbit chain is deployed on a non-Ethereum L1 (e.g., Solana, BNB Chain), your fees must be manually transferred to a Foundation-controlled address.

### Novel fee-earning customizations[​](#novel-fee-earning-customizations "Direct link to Novel fee-earning customizations")

As discussed above in Additional revenue sources, if you have customized your Orbit chain to earn revenue through any enshrined component, this revenue must be calculated as part of the AEP fees. In such cases, we recommend engaging with the AF to agree on a revenue model and reporting cadence and then manually send additional fees into the routing system as required.

### Other cases[​](#other-cases "Direct link to Other cases")

If you are still determining if your Orbit configuration applies to the listed or unlisted special cases, we recommend engaging with the Arbitrum Foundation.

---

# Customizable challenge period | Arbitrum Docs

## Customizable challenge period

The challenge period defines the time frame during which state updates (assertions) submitted to the parent chain remain open for scrutiny and potential challenges before they are finalized. This mechanism ensures that participants in the system have the opportunity to verify the validity of state updates and raise challenges if necessary.

The length of the challenge period is measured based on the parent chain's notion of time, typically reflected in `block.number`. For L3s settling to Arbitrum chains, this period is determined by L1 block progression rather than Arbitrum's (L2) blocks.

In addition to the main challenge period, **an extra challenge period** provides a buffer to resolve any pending challenges after the main period ends. Together, these parameters help balance security and confirm the chain's state.

Default challenge period and extra challenge period[​](#default-challenge-period-and-extra-challenge-period "Direct link to Default challenge period and extra challenge period")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

How time is measured in challenges

Chains settling to Ethereum or Arbitrum chains use `block.number` for all block calculations, which corespond to the chain's view of Ethereum's block number. For example, an L3 Arbitrum chain settling to Arbitrum One, will calculate block progression based on Ethereum's (L1) block number.

By default, the challenge period lasts approximately one week, which equates to roughly 45,818 L1 blocks for chains that settle to Ethereum or an Arbitrum chain. The default duration design is to provide sufficient time for validators to detect and challenge fraudulent assertions.

On the other hand, the extra challenge period adds a buffer of 40 minutes by default, 200 L1 blocks for chains settling to Ethereum or an Arbitrum chain. This time ensures that any last-minute challenges or ongoing dispute resolution processes can be completed before the rollup finalizes its state.

These default values are selected to carefully balance security and performance for most rollup use cases. However, developers and Orbit chain owners may wish to customize these parameters to suit their specific requirements.

Customizing the challenge period[​](#customizing-the-challenge-period "Direct link to Customizing the challenge period")
------------------------------------------------------------------------------------------------------------------------

### Challenge period blocks[​](#challenge-period-blocks "Direct link to Challenge period blocks")

The main challenge period configuration uses the `confirmPeriodBlocks` parameter, which specifies the duration of the challenge window based on the parent chain’s notion of `block.number`. This parameter can is customizable in two ways:

1.  **During deployment**: Developers can specify the desired value in the `confirmPeriodBlocks` field of the RollupCreator configuration when deploying the rollup.
2.  **Post-deployment**: The chain owner can update this value dynamically by calling the `Rollup.setConfirmPeriodBlocks(newValue)` function.

For example, setting `confirmPeriodBlocks` to 30,000 blocks reduces the challenge period to approximately 4.5 days. This configuration might be suitable for applications prioritizing faster state confirmation, while increasing the value would extend the challenge period, improving security.

### Extra challenge period blocks[​](#extra-challenge-period-blocks "Direct link to Extra challenge period blocks")

The extra challenge period is governable using the `extraChallengeTimeBlocks` parameter, which defines the additional buffer duration after the main challenge period. This period ensures that pending challenges are processed before the rollup state gets finalized.

By default, the extra challenge period is set to **200 blocks**, providing a short but sufficient buffer for most networks. However, developers can increase this value for applications requiring additional dispute resolution time or operate in environments with higher latency between the parent and child chain.

Like the main challenge period, this parameter is customizable in two ways:

1.  **During deployment**: The value can be set in the `extraChallengeTimeBlocks` field of the RollupCreator configuration.
2.  **Post-deployment**: The chain owner can dynamically adjust the parameter using the `Rollup.setExtraChallengeTimeBlocks(newExtraTimeBlocks)` function.

For example, the following command can update the extra challenge period to 300 blocks based on the parent chain’s notion of `block.number`:

```rust
cast send <ROLLUP_ADMIN_ADDRESS> "setExtraChallengeTimeBlocks(uint256)" 300 \
  --rpc-url <RPC_URL> \
  --private-key <PRIVATE_KEY>
```

Replace:

`<ROLLUP_ADMIN_ADDRESS>` with the contract address of the rollup admin. `<RPC_URL>` with the appropriate RPC endpoint. `<PRIVATE_KEY>` with the private key of the authorized admin account (e.g., chain owner).

Recommended values and best practices[​](#recommended-values-and-best-practices "Direct link to Recommended values and best practices")
---------------------------------------------------------------------------------------------------------------------------------------

For Orbit chains aligned with Arbitrum One's configuration, the recommended settings are:

*   **Challenge period blocks**: 45,818 Ethereum blocks (approximately one week).
*   **Extra challenge period blocks**: 200 Ethereum blocks (approximately 40 minutes).

These values offer a robust and balanced setup for most rollup use cases. Developers should consider their application’s requirements when adjusting these parameters:

*   **Shorter periods**: Suitable for applications that benefit from faster state confirmation, such as rollups prioritizing quicker exits or user withdrawals. For chains settling to Ethereum or an Arbitrum chain, this reduces challenge duration based on L1 block times.
*   **Longer periods**: Recommended for applications requiring higher security, such as cross-chain asset transfers or large-value transactions. The actual duration depends on the parent chain’s block intervals (e.g., Ethereum vs. other chains).

---

# Customizing AnyTrust | Arbitrum Docs

## Customizing AnyTrust

---

# Fee Management | Arbitrum Docs

## Fee Management

---

# Gas Optimization Tools | Arbitrum Docs

## Gas Optimization Tools

---

# Per batch gas cost | Arbitrum Docs

## Per batch gas cost

---

# Sequencer Timing Adjustments | Arbitrum Docs

## Sequencer Timing Adjustments

---

# How to set up an AEP fee router | Arbitrum Docs

## How to set up an AEP fee router

Quick start[​](#quick-start "Direct link to Quick start")
---------------------------------------------------------

You can adopt the AEP Fee Router by using the [AEP Router deployment scripts](https://github.com/OffchainLabs/arbitrum-orbit-sdk/tree/main/examples/setup-aep-fee-router) provided in the [Orbit SDK](https://github.com/OffchainLabs/arbitrum-orbit-sdk/tree/main)

### Canonical contracts[​](#canonical-contracts "Direct link to Canonical contracts")

Network

Contract

Address

Configured for

Ethereum

`Arbitrum Foundation's multisig wallet`

[0x1Afa41C006dA1605846271E7bdae942F2787f941](https://etherscan.io/address/0x1Afa41C006dA1605846271E7bdae942F2787f941)

`ETH`, `ERC-20`

Arbitrum Nova

`Child2ParentRouter`

[0xd27cb0fe2a696ebaa80d606ce0edf55aabaeab84](https://nova.arbiscan.io/address/0xd27cb0fe2a696ebaa80d606ce0edf55aabaeab84)

`ETH`

Base

`Child2ParentRouter`

[0xd9a2e0e5d7509f0bf1b2d33884f8c1b4d4490879](https://basescan.org/address/0xd9a2e0e5d7509f0bf1b2d33884f8c1b4d4490879)

`ETH`

The AEP fee router contract system[​](#the-aep-fee-router-contract-system "Direct link to The AEP fee router contract system")
------------------------------------------------------------------------------------------------------------------------------

This section describes the different fee distribution and router contracts that are available. You can find their source code [here](https://github.com/OffchainLabs/fund-distribution-contracts/tree/main/src/FeeRouter).

### RewardDistributor[​](#rewarddistributor "Direct link to RewardDistributor")

The **AEP fee router** system relies on configuring an escrow contract as the intended reward address for protocol fee components. This intermediary contract is known as the `RewardDistributor.`

The `RewardDistributor` is configured to separate the AEP portion of the fees from fees intended for the chain owner. The `RewardDistributor` can be permissionlessly called to perform a withdrawal which simultaneously transfers 90% of accrued fees to the chain’s fee collector and 10% of accrued fees to a target address on the parent chain. From here, the chain owner has complete control over their earned fees, and the routing contracts can direct AEP fees to a collecting address for the Arbitrum DAO.

### ChildToParentRouter[​](#childtoparentrouter "Direct link to ChildToParentRouter")

AEP fees from the `RewardDistributor` must first be sent to Ethereum before they can be deposited to the DAO-controlled address on Arbitrum One. To facilitate this transfer to Ethereum, AEP fees are sent through a series of contracts known as `ChildToParentRouters.`

The `ChildToParentRouter` is configured to withdraw a single token (immutable and specified at deployment) from the child chain to a specific target address on the parent chain: either another `ChildToParentRouter` or an address controlled by the Arbitrum Foundation on Ethereum.

Deploying your AEP fee router contracts[​](#deploying-your-aep-fee-router-contracts "Direct link to Deploying your AEP fee router contracts")
---------------------------------------------------------------------------------------------------------------------------------------------

An Orbit chain is responsible for deploying all `ChildToParentRouters` necessary for their AEP funds to arrive at the address controlled by the Arbitrum Foundation on Ethereum.

This includes:

*   Deploying a `ChildToParentRouter` on their Orbit chain configured for their gas token and configured to send funds to either:
    *   An address controlled by the Arbitrum Foundation on Ethereum (assuming the network is a Layer-2)
    *   Another `ChildToParentRouter` configured to the same gas token and configured to send funds to a successive parent chain (this is the case for a Layer-3 network or higher)
*   Deploying a `RewardDistributor` contract configured to forward 10% of fees to the `ChildToParentRouter` and 90% to the chain owner’s preferred reward-receiving address.

In the event that a `ChildToParentRouter` does not connect to the address controlled by the Arbitrum Foundation on Ethereum, an Orbit chain must deploy successive `ChildToParentRouter` contracts until a connection to such address is established. Additional `ChildToParentRouter` contracts configured to route ETH have been deployed in certain networks and can be leveraged by chains created on top of these networks. You can see which networks have a router deployed [here](#canonical-contracts).

Optionally, an Orbit chain can decide to deduct assertion costs by following the instructions in the [Deducting Assertion Costs](/launch-orbit-chain/configure-your-chain/common-configurations/calculate-aep-fees#assertion-costs) section:

🚨 Layer-3 chains with custom gas tokens with L2-based token contracts cannot send their custom gas tokens to Ethereum. A future version of the AEP Fee Router may allow Orbit chains with L2-based tokens to distribute fees using the routing system.

In the absence of these, please send `ETH` through the AEP Fee Router to fulfill your AEP license obligations.

Here are a few flows to help visualize the deployment:

2.  Scenario 1: You are an L2 Orbit Chain that settles on Ethereum.
    
3.  Scenario 2: You are an L3 Orbit Chain that settles to another L2. The custom gas token you are using exists on L1.
    
4.  Scenario 3: You are an L3 Orbit Chain that settles to another L2. The custom gas token doesn't exist on L1.
    

Deployment scripts[​](#deployment-scripts "Direct link to Deployment scripts")
------------------------------------------------------------------------------

The Orbit SDK provides a [configurable script](https://github.com/OffchainLabs/arbitrum-orbit-sdk/tree/main/examples/setup-aep-fee-router) that allows a chain operator to deploy quickly and set up the AEP fee router contracts.

Note for L3 chains with custom gas tokens

The standard script deploys and sets up the AEP fee router contracts to route funds to the parent chain. L2 chains are expected to route funds to the [multisig wallet owned by the Arbitrum Foundation](#canonical-contracts) living on Ethereum. L3 chains (or further layers) might need to specify a different target address on the parent chain depending on the gas token of the chain. If the chain uses ETH as the gas token, and a [ChildToParentRouter](#canonical-contracts) contract is deployed in the parent chain, they can route their funds to that contract. If the chain uses a different gas token, please contact the Arbitrum Foundation to confirm the target address to withdraw the AEP fees to.

The script performs the following operations:

1.  Obtain the rollup and inbox contract of the chain. These are needed to execute the next steps.
2.  Obtain the current fee collectors of the chain: Orbit base fee collector, Orbit surplus fee collector, and Parent chain surplus fee collector.
3.  Deploy the `ChildToParentRouter` contract, configured to send the amounts received to the appropriate target address on the parent chain.
4.  Deploy a `RewardDistributor` contract for each different fee collector account, configured to distribute 90% of the amounts received to the current fee collector, and 10% to the ChildToParentRouter contract deployed in the previous step.
5.  Set each of the fee collectors to the `RewardDistributor` contracts

info

Note that if the same address collects all three fee types, only one `RewardDistributor` contract will be deployed, which will collect all those fees.

To configure the script, you need to specify the following [environment variables](https://github.com/OffchainLabs/arbitrum-orbit-sdk/blob/main/examples/setup-aep-fee-router/.env.example):

*   `ROLLUP_ADDRESS`: address of the rollup contract
*   `CHAIN_OWNER_PRIVATE_KEY`: private key of the account with executor privileges in the `UpgradeExecutor` admin contract for the chain
*   `ORBIT_CHAIN_ID`: chain id of the Orbit chain
*   `ORBIT_CHAIN_RPC`: RPC of the Orbit chain
*   `PARENT_CHAIN_ID`: chain id of the parent chain, which shouldn't be an Arbitrum chain
*   `PARENT_CHAIN_TARGET_ADDRESS`: address on the parent chain where 10% of the revenue will be sent to. You can find the potential target addresses in this document's [canonical contracts](#canonical-contracts) section. If the parent chain is not on that list, or if your chain uses a gas token different than the one the router is configured for, contact the Arbitrum Foundation to obtain a specific target address for your chain.

Finally, follow these steps to execute the script (from the `examples/setup-aep-fee-router` folder):

1.  Install dependencies

```rust
yarn install
```

2.  Create .env file and add the env vars

```rust
cp .env.example .env
```

3.  Run the script

```rust
yarn dev
```

Triggering movement of funds[​](#triggering-movement-of-funds "Direct link to Triggering movement of funds")
------------------------------------------------------------------------------------------------------------

Any `ChildToParentRouter` contract deployed by an Orbit chain must be periodically called to move funds. The following commands should be set up to execute at the same interval as the router's minimum distribution interval (`minDistributionIntervalSeconds`).

The [router contracts repository](https://github.com/OffchainLabs/fund-distribution-contracts) contains scripts for calling the routers.

1.  Periodically trigger withdrawals to the parent chain

info

If the `ChildToParentRouter` is routing its chain's native token, this step should be skipped.

```rust
cast send <router_on_child_address> "routeToken()" --rpc-url <child_rpc_url> --private_key <private_key>
```

2.  Periodically redeem withdrawals on the parent chain

```rust
git clone https://github.com/OffchainLabs/fund-distribution-contracts
cd fund-distribution-contracts && yarn

# set PARENT_CHAIN_PK in .env
cp .env.sample .env

# add --opStack if the router is on an OP stack chain
yarn redeem-child-to-parent \
  --parentRPCUrl <parent_rpc_url> \
  --childRPCUrl <child_rpc_url> \
  --childToParentRewardRouterAddr <router_on_child_address> \
  --oneOff
```

---

# Smart contract size limit | Arbitrum Docs

## Smart contract size limit

---

# Stake and validator configurations | Arbitrum Docs

## Stake and validator configurations

*   **Base Stake**: Minimum stake required for validators.
*   **Stake Token**: Token used for staking.
*   **Loser Stake Escrow**: Address for escrowed funds from losing validators.

---

# How to use a custom gas token on your Orbit chain | Arbitrum Docs

## How to use a custom gas token on your Orbit chain

When deploying your AnyTrust Orbit chain you have the option of using a custom gas token, different than ETH, that is natively used for gas payments on the network. When choosing this option, there are certain requirements that the token needs to comply with, as well as certain chain configuration that needs to be adjusted. This guide covers this information.

Requirements of the custom gas token[​](#requirements-of-the-custom-gas-token "Direct link to Requirements of the custom gas token")
------------------------------------------------------------------------------------------------------------------------------------

The main requirements for a custom gas token is that it must be an ERC-20 token, and it must be natively deployed on the parent chain. During chain deployment, the gas token is "natively bridged" and then properly configured as the native gas token on the Orbit chain.

There are other important considerations to keep in mind when deciding to use a custom gas token. Restrictions on the ERC-20 token include:

*   The token can't be rebasing or have a transfer fee.
*   The token must not revert on transfers of 0 value (as per standard implementations).
*   The token must only be transferrable via a call to the token address itself.
*   The token must only be able to set allowance via a call to the token address itself.
*   The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert.

info

While certain restrictions are in place today (see above), some of them may be removed in upcoming releases of the custom gas token feature. Please reach out to the Offchain Labs team with any questions or requests for additions to the custom gas token feature.

Configuration of the Orbit chain when using a custom gas token[​](#configuration-of-the-orbit-chain-when-using-a-custom-gas-token "Direct link to Configuration of the Orbit chain when using a custom gas token")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

There are several parameter changes required to ensure proper functioning of an Orbit chain configured to use a custom gas token.

After deploying the chain, you must reset the base fees of the parent chain by calling the following functions in the [ArbOwner](/build-decentralized-apps/precompiles/reference#arbowner) precompile:

*   `SetL1PricePerUnit`, setting `pricePerUnit` to `0`
*   `SetL1PricingRewardRate`, setting `perUnitReward` to `0`

_Note: these methods use L1 to refer to the parent chain of the Orbit chain._

These parameter changes are strongly recommended to avoid charging users for a non-existent parent chain's base fee. The impact of not doing this is that Nitro will apply a parent chain's fee to all transactions. As Nitro assumes the native asset is ETH, all fees are expected to be denominated in ETH. This has the consequence of overcharging users for parent chain fees in native tokens that are more expensive than ETH (for example, if you use wrapped BTC as the custom gas token). In the case for tokens with prices much lower than ETH, the impact is far less pronounced.

In either case we strongly recommend taking these steps to avoid any issues with chain economics. You can read more about how Nitro manages fees in [Gas and fees](/how-arbitrum-works/gas-fees).

---

# How to customize ArbOS on your Orbit chain | Arbitrum Docs

## How to customize ArbOS on your Orbit chain

caution

### Customizations require expertise[​](#customizations-require-expertise "Direct link to Customizations require expertise")

Customizing your chain is a core benefit of building with Arbitrum Orbit. We strongly recommend that teams interested in customizations work alongside a partner with ArbOS and Nitro software expertise, such as a Rollup-as-a-Service team.

Working alongside an experienced Orbit operator can help your team navigate the complex tradeoff space of rollup customizations, which can include performance, security, and cost considerations. Offchain Labs is positioned to train and enable Rollup-as-a-Service in their work with clients to scale support to the Orbit ecosystem as a whole. As such, Offchain Labs does not necessarily have the capacity to review code changes made by individual Orbit chains.

We encourage you to leverage your in-house expertise, collaborate with expert partners, and allocate appropriate resources for both an initial implementation (including an audit) and ongoing maintenance and security management of your customization.

Cases where you may want to consider customizing your own ArbOS upgrade[​](#cases-where-you-may-want-to-consider-customizing-your-own-arbos-upgrade "Direct link to Cases where you may want to consider customizing your own ArbOS upgrade")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  When you want to make changes to your Nitro code that affect the State Transition Function, or STF (you may refer to the [Customize STF docs](/launch-orbit-chain/customize-your-chain/customize-stf#introduction)), and
    
2.  If your desired changes need to be made to a live and operational Orbit chain
    

If your changes meet both those 2 points, then you will need a custom ArbOS upgrade.

Also, if you made changes to a live and operational chain and want to upgrade them later in the future, then you will likely need an ArbOS upgrade to facilitate the upgrade.

Where should I insert ArbOS Upgrade related code?[​](#where-should-i-insert-arbos-upgrade-related-code "Direct link to Where should I insert ArbOS Upgrade related code?")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Below, you will find 4 examples of ArbOS-related code changes and, generally, how to make them:

### 1\. Add a new method to existing precompile on a specific ArbOS version:[​](#1-add-a-new-method-to-existing-precompile-on-a-specific-arbos-version "Direct link to 1. Add a new method to existing precompile on a specific ArbOS version:")

After you add `sayHi()` to `ArbSys.go` according to the guide in [customize precompile option 1](/launch-orbit-chain/customize-your-chain/customize-precompile#option-1-add-new-methods-to-an-existing-precompile), you need continue to modify [precompile.go](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/precompile.go).

For example, the original code is:

```rust
ArbSys := insert(MakePrecompile(pgen.ArbSysMetaData, &ArbSys{Address: types.ArbSysAddress}))
arbos.ArbSysAddress = ArbSys.address
arbos.L2ToL1TransactionEventID = ArbSys.events["L2ToL1Transaction"].template.ID
arbos.L2ToL1TxEventID = ArbSys.events["L2ToL1Tx"].template.ID
```

You need to append the following code to it:

```rust
ArbSys := insert(MakePrecompile(pgen.ArbSysMetaData, &ArbSys{Address: types.ArbSysAddress}))
arbos.ArbSysAddress = ArbSys.address
arbos.L2ToL1TransactionEventID = ArbSys.events["L2ToL1Transaction"].template.ID
arbos.L2ToL1TxEventID = ArbSys.events["L2ToL1Tx"].template.ID
// The arbos version control logic
ArbOwner.methodsByName["SayHi"].arbosVersion = ${The arbos version you want to activate this method}
```

In this way, this method will be executed normally and return results only after you update ArbOS to the target version.

### 2\. Create a new precompile contract on a specific ArbOS version[​](#2-create-a-new-precompile-contract-on-a-specific-arbos-version "Direct link to 2. Create a new precompile contract on a specific ArbOS version")

After you add a new precompile named `ArbHi` according to the guide in [customize precompile option 2](/launch-orbit-chain/customize-your-chain/customize-precompile#option-2-create-a-new-precompile) and make changes to [precompile.go](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/precompile.go), you also need to make the following changes:

```rust
ArbHi := insert(MakePrecompile(pgen.ArbHiMetaData, &ArbHi{Address: types.ArbHiAddress})) // types.ArbHiAddress here is an example address
// Set activate version to the precompile
ArbHi.arbosVersion = ${The arbos version you want to activate this precompile}
// Set activate version to all method
for _, method := range ArbHi.methods {
   method.arbosVersion = ${The arbos version you want to activate this precompile}
}
```

In this way, ArbHi and all its methods will be activated after the ArbOS version you set.

### 3\. Create a new ArbOS state on a specific ArbOS version[​](#3-create-a-new-arbos-state-on-a-specific-arbos-version "Direct link to 3. Create a new ArbOS state on a specific ArbOS version")

After you add a new state `myNumber` according to the guide in [customize precompile Option 5](/launch-orbit-chain/customize-your-chain/customize-precompile#option-5-call-and-modify-state), you also need to rewrite [UpgradeArbosVersion](https://github.com/OffchainLabs/nitro/blob/v3.1.0/arbos/arbos/arbosState/arbosstate.go#L253) in [arbosstate.go](https://github.com/OffchainLabs/nitro/blob/v3.1.0/arbos/arbosState/arbosstate.go): Add your expected ArbOS version to the switch case statement of nextArbosVersion. Here we will take ArbOS V21 as an example:

```rust
ensure := func(err error) {
    if err != nil {
        message := fmt.Sprintf(
            "Failed to upgrade ArbOS version %v to version %v: %v",
            state.arbosVersion, state.arbosVersion+1, err,
        )
        panic(message)
    }
}
nextArbosVersion := state.arbosVersion + 1
switch nextArbosVersion {
    case 1:
        //.....
    case 2:
        //....
    //.....
    case 21:
        // Set your new ArbOS state value here
        ensure(state.SetNewMyNumber(${random number}))
    //....
}
```

Here, we will ensure that the initial value of $(a random number) after ArbOS is upgraded to V21.

caution

It should be noted that when you initialize the state (initial code is in [customize precompile Option 5](/launch-orbit-chain/customize-your-chain/customize-precompile#option-5-call-and-modify-state)), you need to initialize it to 0 or null value first to avoid a potential re-org on your chain.

Also, please make sure your program cannot call the `state.SetNewMyNumber` or other functions may change the value of `myNumber` before ArbOS V21. To prevent this, if you are using an external call to the precompile contract to change the value, you can refer to [point 1](/launch-orbit-chain/customize-your-chain/customize-arbos#1-add-a-new-method-to-existing-precompile-on-a-specific-arbos-version) or [point 2](/launch-orbit-chain/customize-your-chain/customize-arbos#2-create-a-new-precompile-contract-on-a-specific-arbos-version) to set the activation time of the precompile contract method. If your nitro code needs to call this method to change the state, you can continue reading [point 4](/launch-orbit-chain/customize-your-chain/customize-arbos#4-any-changes-in-the-stf-logic-that-will-affect-the-final-execution-result).

### 4\. Any changes in the STF logic that will affect the final execution result[​](#4-any-changes-in-the-stf-logic-that-will-affect-the-final-execution-result "Direct link to 4. Any changes in the STF logic that will affect the final execution result")

If you change the logic in STF, it will cause the execution result of the transaction to be different, you need to keep the original execution logic and put the new logic into another branch. You can use an `if else` statement to control it.

For example, we change the `SayHi` return after upgrading the ArbOS version:

```rust
// The method in ArbHi precompile
func (con *ArbHi) SayHi(c ctx, evm mech) (string, error) {
    if p.state.ArbOSVersion() >= ${The arbos you want to upgrade to} {
        // Your new logic code
        return "hi, new ArbOS version", nil
    } else {
        // The old logic code needs to be kept
        return "hi", nil
    }
}
```

In the above code, we use precompiles as an example. Some logic might also affect the STF, such as the methods in [block\_process.go](https://github.com/OffchainLabs/nitro/blob/v3.5.1/arbos/block_processor.go), [internal\_tx.go](https://github.com/OffchainLabs/nitro/blob/v3.5.1/arbos/internal_tx.go), [tx\_processor.go](https://github.com/OffchainLabs/nitro/blob/v3.5.1/arbos/tx_processor.go) and so on. The aforementioned ArbOS control methods will be needed for interacting with different versions of the STF logic.

Backward compatibility

Wasm module roots are backward compatible, so upgrading them before an ArbOS version upgrade will not disrupt your chain's functionality.

Upgrade WASM Module Root on the parent chain[​](#upgrade-wasm-module-root-on-the-parent-chain "Direct link to Upgrade WASM Module Root on the parent chain")
------------------------------------------------------------------------------------------------------------------------------------------------------------

After you have made your custom ArbOS changes, you will need to update the WASM Module root recorded on the parent chain. This is because an Arbitrum chain may execute the validation and fraud proofs on the parent chain. Please continue reading [customize stf](/launch-orbit-chain/customize-your-chain/customize-stf#step-3-run-the-node-without-fraud-proofs) for follow-up operations.

Schedule ArbOS upgrade[​](#schedule-arbos-upgrade "Direct link to Schedule ArbOS upgrade")
------------------------------------------------------------------------------------------

After you add ArbOS version control to the Nitro code, you can update ArbOS. You can refer to the document [ArbOS upgrade](/launch-orbit-chain/configure-your-chain/common-configurations/arbos-upgrade) to upgrade. It is recommended that teams who opt to version control their custom ArbOS version choose an ArbOS version number that builds on top of the canonical releases shipped by Offchain Labs. As an example, if your team is customizing ArbOS 31, we recommend versioning your ArbOS version as ArbOS 32. It should be noted that if you set a higher ArbOS version as the upgrade target, all the features added between the current and target versions will be activated. For example, if your current version is ArbOS v18 and you set the target version to v25, all the features between v18 and v25 will be loaded.

---

# How to customize your Orbit chain's precompiles | Arbitrum Docs

## How to customize your Orbit chain's precompiles

caution

### Customizations require expertise[​](#customizations-require-expertise "Direct link to Customizations require expertise")

Customizing your chain is a core benefit of building with Arbitrum Orbit. We strongly recommend that teams interested in customizations work alongside a partner with ArbOS and Nitro software expertise, such as a Rollup-as-a-Service team.

Working alongside an experienced Orbit operator can help your team navigate the complex tradeoff space of rollup customizations, which can include performance, security, and cost considerations. Offchain Labs is positioned to train and enable Rollup-as-a-Service in their work with clients to scale support to the Orbit ecosystem as a whole. As such, Offchain Labs does not necessarily have the capacity to review code changes made by individual Orbit chains.

We encourage you to leverage your in-house expertise, collaborate with expert partners, and allocate appropriate resources for both an initial implementation (including an audit) and ongoing maintenance and security management of your customization.

caution

The guidance in this document will only work if you use `eth_call` to call the new precompiles. If you call them from other contracts or add non-view/pure methods, this approach will break the block validation.

To support these additional use-cases, follow the instructions described in [How to customize your Orbit chain's behavior](/launch-orbit-chain/customize-your-chain/customize-stf).

There are five primary ways to customize your chain's precompiles:

1.  Add new methods to an existing [precompile](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/).
2.  Create a new precompile.
3.  Define a new event.
4.  Customize gas usage for a specific method.
5.  Call and modify state.

### Prerequisites[​](#prerequisites "Direct link to Prerequisites")

Clone the Nitro repository before you begin:

```rust
git clone --branch v3.5.1 <https://github.com/OffchainLabs/nitro.git>
cd nitro
git submodule update --init --recursive --force
```

Option 1: Add new methods to an existing precompile[​](#option-1-add-new-methods-to-an-existing-precompile "Direct link to Option 1: Add new methods to an existing precompile")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Using your favorite code editor, open an existing precompile from the [precompiles implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/) directory, `/precompiles`. We'll use `ArbSys.go` as an example. Open the corresponding Go implementation file (`ArbSys.go`) and add a simple `SayHi` method:

```rust
func (con *ArbSys) SayHi(c ctx, evm mech) (string, error) {
	return "hi", nil
}
```

Then, open the corresponding Solidity interface file (`ArbSys.sol`) from the [precompiles interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/) directory, `/src/precompiles`, and add the required interface. Ensure that the method name on the interface matches the name of the function you introduced in the previous step, `camelCased`:

```rust
function sayHi() external view returns(string memory);
```

Next, follow the steps in [How to customize your Orbit chain's behavior](/launch-orbit-chain/customize-your-chain/customize-stf#step-3-run-the-node-without-fraud-proofs) to build a modified Arbitrum Nitro node docker image and run it.

info

Note that the instructions provided in [How to run a full node](/run-arbitrum-node/run-full-node) **will not** work with your Orbit node. See [Optional parameters (Orbit)](/node-running/how-tos/running-an-orbit-node#optional-parameters) for Orbit-specific CLI flags.

Once your node is running, you can call `ArbSys.sol` either directly using `curl`, or through Foundry's `cast call`.

### Call your function directly using `curl`[​](#call-your-function-directly-using-curl "Direct link to call-your-function-directly-using-curl")

```rust
curl http://localhost:8449 \
-X POST \
-H "Content-Type: application/json" \
--data '{"method":"eth_call","params":[{"from":null,"to":"0x0000000000000000000000000000000000000064","data":"0x0c49c36c"}, "latest"],"id":1,"jsonrpc":"2.0"}'
```

You should see something like this:

```rust
{"jsonrpc":"2.0","id":1,"result":"0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000026869000000000000000000000000000000000000000000000000000000000000"}
```

`0x6869` is the hex-encoded utf8 representation of `hi`, which you'll see embedded in the `result` hex string.

### Call your function using Foundry's `cast call`[​](#call-your-function-using-foundrys-cast-call "Direct link to call-your-function-using-foundrys-cast-call")

```rust
cast call 0x0000000000000000000000000000000000000064 "sayHi()(string)”
```

You should see something like this:

```rust
hi
```

Option 2: Create a new precompile[​](#option-2-create-a-new-precompile "Direct link to Option 2: Create a new precompile")
--------------------------------------------------------------------------------------------------------------------------

First, navigate to the [precompiles implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/) directory, `/precompiles`, and create a new precompile implementation file called `ArbHi.go`. We'll define a new method, and we'll give it an address:

```rust
package precompiles

// ArbHi provides a friendly greeting to anyone who calls it.
type ArbHi struct {
	Address addr // 0x11a, for example
}

func (con *ArbHi) SayHi(c ctx, evm mech) (string, error) {
	return "hi", nil
}
```

Then, update [precompile.go](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/precompile.go) to register the new precompile under the `Precompiles()` method:

```rust
insert(MakePrecompile(pgen.ArbHiMetaData, &ArbHi{Address: hex("11a")})) // 0x011a here is an example address
```

Navigate to the [precompiles interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/) directory, `/src/precompiles`, create `ArbHi.sol`, and add the required interface. Ensure that the method name on the interface matches the name of the function you introduced in the previous step, `camelCased`:

```rust
pragma solidity >=0.4.21 <0.9.0;

/// @title Say hi.
/// @notice just for test
/// This custom contract will set on 0x000000000000000000000000000000000000011a since we set it in precompile.go.
interface ArbHi {
    function sayHi() external view returns(string memory);
}
```

Next, follow the steps in [How to customize your Orbit chain's behavior](/launch-orbit-chain/customize-your-chain/customize-stf#step-3-run-the-node-without-fraud-proofs) to build a modified Arbitrum Nitro node docker image and run it.

info

Note that the instructions provided in [How to run a full node](/run-arbitrum-node/run-full-node) **will not** work with your Orbit node. See [Optional parameters (Orbit)](/node-running/how-tos/running-an-orbit-node#optional-parameters) for Orbit-specific CLI flags.

Once your node is running, you can call `ArbHi.sol` either directly using `curl`, or through Foundry's `cast call`.

### Call your function directly using `curl`[​](#call-your-function-directly-using-curl-1 "Direct link to call-your-function-directly-using-curl-1")

```rust
curl http://localhost:8449 \
-X POST \
-H "Content-Type: application/json" \
--data '{"method":"eth_call","params":[{"from":null,"to":"0x000000000000000000000000000000000000011a","data":"0x0c49c36c"}, "latest"],"id":1,"jsonrpc":"2.0"}'
```

You should see something like this:

```rust
{"jsonrpc":"2.0","id":1,"result":"0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000026869000000000000000000000000000000000000000000000000000000000000"}
```

### Call your function using Foundry's `cast call`[​](#call-your-function-using-foundrys-cast-call-1 "Direct link to call-your-function-using-foundrys-cast-call-1")

```rust
cast call 0x000000000000000000000000000000000000011a "sayHi()(string)”
```

You should see something like this:

```rust
hi
```

Option 3: Define a new event[​](#option-3-define-a-new-event "Direct link to Option 3: Define a new event")
-----------------------------------------------------------------------------------------------------------

We'll reuse the `Arbsys` precompile from Option 1 above to demonstrate how to emit a simple `Hi` event from the `SayHi` method in `ArbSys.sol`.

First, go to the [precompiles implementation](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/) directory, find `ArbSys.go`, and edit the `ArbSys` struct:

```rust
// ArbSys provides system-level functionality for interacting with L1 and understanding the call stack.
type ArbSys struct {
	Address                 addr // 0x64
	L2ToL1Tx                func(ctx, mech, addr, addr, huge, huge, huge, huge, huge, huge, []byte) error
	L2ToL1TxGasCost         func(addr, addr, huge, huge, huge, huge, huge, huge, []byte) (uint64, error)
	SendMerkleUpdate        func(ctx, mech, huge, bytes32, huge) error
	SendMerkleUpdateGasCost func(huge, bytes32, huge) (uint64, error)
	InvalidBlockNumberError func(huge, huge) error

	// deprecated event
	L2ToL1Transaction        func(ctx, mech, addr, addr, huge, huge, huge, huge, huge, huge, huge, []byte) error
	L2ToL1TransactionGasCost func(addr, addr, huge, huge, huge, huge, huge, huge, huge, []byte) (uint64, error)

	// Add your customize event here:
	Hi						       func(ctx, mech, addr) error
	// This is needed and will tell you how much gas it will cost, the param is the same as your event but without the first two (ctx, mech), the return param is always (uint64, error)
	HiGasCost				    func(addr) (uint64, error)
}
```

Then add the event to the `SayHi` method:

```rust
func (con *ArbSys) SayHi(c ctx, evm mech) (string, error) {
	err := con.Hi(c, evm, c.caller)
	return "hi", err
}
```

Now navigate to the [precompiles interface](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/precompiles/) directory, open `Arbsys.sol`, and add the required interface. Ensure that the event name on the interface matches the name of the function you introduced in `ArbSys` struct in the previous step:

```rust
event Hi(address caller);
```

If you want to [index the parameter](https://docs.soliditylang.org/en/latest/contracts.html#events) of the event (if you want to filter by that parameter in the future, for example), just add `indexed` to the Solidity interface:

```rust
event Hi(address indexed caller);
```

Our function now emits an event, which means that when calling it, the state will change and a gas cost will be incurred. So we have to remove the `view` function behavior:

```rust
function sayHi() external returns(string memory);
```

Next, build Nitro by following the instructions in [How to build Nitro locally](/run-arbitrum-node/nitro/build-nitro-locally). Note that if you've already built the Docker image, you still need run the last step to rebuild.

Run Nitro with the following command:

```rust
docker run --rm -it  -v /some/local/dir/arbitrum:/home/user/.arbitrum -p 0.0.0.0:8547:8547 -p 0.0.0.0:8548:8548 offchainlabs/nitro-node:v3.5.1-8f247fd --parent-chain.connection.url=<YourParentChainUrl> --chain.id=<YourOrbitChainId> --http.api=net,web3,eth,debug --http.corsdomain=* --http.addr=0.0.0.0 --http.vhosts=*
```

info

Note that the instructions provided in [How to run a full node](/run-arbitrum-node/run-full-node) **will not** work with your Orbit node. See [Optional parameters (Orbit)](/node-running/how-tos/running-an-orbit-node#optional-parameters) for Orbit-specific CLI flags.

### Send the transaction and get the transaction receipt[​](#send-the-transaction-and-get-the-transaction-receipt "Direct link to Send the transaction and get the transaction receipt")

To send a transaction to `ArbSys`, we need to include a gas cost, because the function is no longer a view/pure function:

```rust
cast send 0x0000000000000000000000000000000000000064 "sayHi()(string)"
```

Call `eth_getTransactionReceipt` with the returned transaction hash result. You should see something like this:

```rust
{"jsonrpc":"2.0","id":1,"result":{"blockHash":"Your_blockHash","blockNumber":"Your_blockNumber","contractAddress":null,"cumulativeGasUsed":"0x680b","effectiveGasPrice":"0x5f5e100","from":"Your_address","gasUsed":"0x680b","gasUsedForL1":"0xe35","l1BlockNumber":"l1_blockNumber","logs":[{"address":"0x0000000000000000000000000000000000000064","topics":["0xa9378d5bd800fae4d5b8d4c6712b2b64e8ecc86fdc831cb51944000fc7c8ecfa","0x000000000000000000000000{Your_address}"],"data":"0x","blockNumber":"Your_blockNumber","transactionHash":"Your_txHash","transactionIndex":"0x1","blockHash":"Your_blockHash","logIndex":"0x0","removed":false}],"logsBloom":"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000100000000000000040000000000000080004000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000004000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000","status":"0x1","to":"0x0000000000000000000000000000000000000064","transactionHash":"Your_txHash","transactionIndex":"0x1","type":"0x2"}}
```

Note the `logs` field within the transaction receipt:

```rust
"logs":[
         {
            "address":"0x0000000000000000000000000000000000000064",
            "topics":[
               "0xa9378d5bd800fae4d5b8d4c6712b2b64e8ecc86fdc831cb51944000fc7c8ecfa",
               "0x000000000000000000000000{Your_address}"
            ],
            "data":"0x",
            "blockNumber":"0x40",
            "transactionHash":"{Your_txHash}",
            "transactionIndex":"0x1",
            "blockHash":"0x0b367d705002b3575db99354a0964c033f929f26f4442ed347e47ae43a8f28e4",
            "logIndex":"0x0",
            "removed":false
         }
      ]
```

Option 4: Customize gas usage for a specific method[​](#option-4-customize-gas-usage-for-a-specific-method "Direct link to Option 4: Customize gas usage for a specific method")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The above instructions demonstrate how you can define a new precompile function. However, if this new function is simply defined without performing gas collection within the function, your precompile will be vulnerable to Denial-of-Service (DOS) attacks. These attacks exploit the function by flooding it with excessive requests without bearing the computational cost.

To deter this type of attack, you can implement a gas collection mechanism within your precompile. The event itself doesn't need to specify the gas cost; the program will calculate the gas cost when the event's execution is initially triggered.

In addition to introducing gas costs where they don't exist, you can also customize gas costs where they're already being incurred. To demonstrate, consider the `GetBalance` method in `ArbInfo.go`:

```rust
// GetBalance retrieves an account's balance
func (con ArbInfo) GetBalance(c ctx, evm mech, account addr) (huge, error) {
	if err := c.Burn(params.BalanceGasEIP1884); err != nil {
		return nil, err
	}
	return evm.StateDB.GetBalance(account), nil
}
```

The purpose of this method is to retrieve the balance of an address. As defined in [EIP1884](https://eips.ethereum.org/EIPS/eip-1884), the operation code (opcode) for obtaining the address balance has an associated gas cost of 700 gas. The function accounts for this cost by deducting the specified amount of gas, indicated by the protocol constant `BalanceGasEIP1884`, which is set to `700`, through the call to `c.Burn(int64)`.

To customize the gas cost, let's implement an alternative to `GetBalance`, called `GetBalanceCustom`:

```rust
// GetBalance retrieves an account's balance
func (con ArbInfo) GetBalanceCustom(c ctx, evm mech, account addr) (huge, error) {
	gasForBalanceCall := uint64(300)
	if err := c.Burn(gasForBalanceCall); err != nil {
		return evm.StateDB.GetBalance(account), err
	}
	return balance, nil
}
```

To register this new precompile method, refer to Option 1 above.

Next, build Nitro by following the instructions in [How to build Nitro locally](/run-arbitrum-node/nitro/build-nitro-locally). Note that if you've already built the Docker image, you still need run the last step to rebuild.

Run Nitro with the following command:

```rust
docker run --rm -it  -v /some/local/dir/arbitrum:/home/user/.arbitrum -p 0.0.0.0:8547:8547 -p 0.0.0.0:8548:8548 offchainlabs/nitro-node:v3.5.1-8f247fd --parent-chain.connection.url=<YourParentChainUrl> --chain.id=<YourOrbitChainId> --http.api=net,web3,eth,debug --http.corsdomain=* --http.addr=0.0.0.0 --http.vhosts=*
```

info

Note that the instructions provided in [How to run a full node](/run-arbitrum-node/run-full-node) **will not** work with your Orbit node. See [Optional parameters (Orbit)](/node-running/how-tos/running-an-orbit-node#optional-parameters) for Orbit-specific CLI flags.

### Send the transaction and get the transaction receipt[​](#send-the-transaction-and-get-the-transaction-receipt-1 "Direct link to Send the transaction and get the transaction receipt")

In order to obtain the gas used, we can use the `eth_sendRawTransaction` RPC method to test execution on the chain. First, call:

```rust
cast send 0x0000000000000000000000000000000000000065 "GetBalance()({Any_Address})"
```

Then, call:

```rust
cast send 0x0000000000000000000000000000000000000065 "GetBalanceCustom()({Any_Address})"
```

The two responses will look like this, respectively:

Result 1:

```rust
{
   "jsonrpc":"2.0",
   "id":1,
   "result":{
      "blockHash":"{Your_blockHash}",
      "blockNumber":"0x15",
      "contractAddress":null,
      "cumulativeGasUsed":"0x638f",
      "effectiveGasPrice":"0x5f5e100",
      "from":"{Your_address}",
      "gasUsed":"0x638f",
      "gasUsedForL1":"0x9f5",
      "l1BlockNumber":"0x979a02",
      "logs":[

      ],
      "logsBloom":"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "status":"0x1",
      "to":"0x0000000000000000000000000000000000000065",
      "transactionHash":"{Your_txHash}",
      "transactionIndex":"0x1",
      "type":"0x2"
   }
}
```

Result 2:

```rust
{
   "jsonrpc":"2.0",
   "id":1,
   "result":{
      "blockHash":"{Your_blockHash}",
      "blockNumber":"0x16",
      "contractAddress":null,
      "cumulativeGasUsed":"0x61ff",
      "effectiveGasPrice":"0x5f5e100",
      "from":"{Your_address}",
      "gasUsed":"0x61ff",
      "gasUsedForL1":"0x9f5",
      "l1BlockNumber":"0x979a08",
      "logs":[

      ],
      "logsBloom":"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "status":"0x1",
      "to":"0x0000000000000000000000000000000000000065",
      "transactionHash":"{Your_txHash}",
      "transactionIndex":"0x1",
      "type":"0x2"
   }
}
```

Here we can see that the gas cost incurred by the execution of the first transaction is `gasUsed - gasUsedForL1 = 22938`. Similarly, the gas cost incurred by the execution of the second transaction is `22538`. If you subtract the two, the result is `400`, as expected.

To learn more about the gas cost model, see [how to estimate gas](/build-decentralized-apps/how-to-estimate-gas).

Option 5: Call and modify state[​](#option-5-call-and-modify-state "Direct link to Option 5: Call and modify state")
--------------------------------------------------------------------------------------------------------------------

In this example, we'll demonstrate how to _read from_ and _write to_ a precompile contract's [ArbOS state](https://github.com/OffchainLabs/nitro/blob/v2.2.0/arbos/arbosState/arbosstate.go#L38).

First, open the [arbosstate.go](https://github.com/OffchainLabs/nitro/blob/v3.5.1/arbos/arbosState/arbosstate.go) file and locate the [ArbosState](https://github.com/OffchainLabs/nitro/blob/v2.2.0/arbos/arbosState/arbosstate.go#L38) structure. This is where ArbOS state is defined.

Define a state key called `myNumber` of type `storage.StorageBackedUint64`. You can find more types in [storage.go](https://github.com/OffchainLabs/nitro/blob/v3.5.1/arbos/storage/storage.go):

```rust
type ArbosState struct {
	// Other states
	infraFeeAccount        storage.StorageBackedAddress
	brotliCompressionLevel storage.StorageBackedUint64 // brotli compression level used for pricing
	backingStorage         *storage.Storage
	Burner                 burn.Burner
	myNumber               storage.StorageBackedUint64 // this is what we added
}
```

Next, define the offset of your newly added state (tip: add it to the end so it won't affect other states):

```rust
const (
	versionOffset Offset = iota
	upgradeVersionOffset
	upgradeTimestampOffset
	networkFeeAccountOffset
	chainIdOffset
	genesisBlockNumOffset
	infraFeeAccountOffset
	brotliCompressionLevelOffset
	myNumberOffset // define the offset of your new state here
)
```

Then, initialize the state under the [OpenArbosState](https://github.com/OffchainLabs/nitro/blob/v2.2.0/arbos/arbosState/arbosstate.go#L89) and [InitializeArbosState](https://github.com/OffchainLabs/nitro/blob/v2.2.0/arbos/arbosState/arbosstate.go#L212) methods:

OpenArbosState:

```rust
return &ArbosState{
		// other states
		backingStorage.OpenStorageBackedAddress(uint64(infraFeeAccountOffset)),
		backingStorage.OpenStorageBackedUint64(uint64(brotliCompressionLevelOffset)),
		backingStorage,
		burner,
		backingStorage.OpenStorageBackedUint64(uint64(myNumberOffset)), // define your new state here
	}, nil
```

InitializeArbosState:

```rust
	_ = sto.SetUint64ByUint64(uint64(versionOffset), 1) // initialize to version 1; upgrade at end of this func if needed
	_ = sto.SetUint64ByUint64(uint64(upgradeVersionOffset), 0)
	_ = sto.SetUint64ByUint64(uint64(upgradeTimestampOffset), 0)
	_ = sto.SetUint64ByUint64(uint64(myNumberOffset), 0) // initialize your new state around here
```

Next, define your getter and setter::

```rust
func (state *ArbosState) SetNewMyNumber(
	newNumber uint64,
) error {
	return state.myNumber.Set(newNumber)
}

func (state *ArbosState) GetMyNumber() (uint64, error) {
	return state.myNumber.Get()
}
```

Next, head back to the [precompiles directory](https://github.com/OffchainLabs/nitro/blob/v3.5.1/precompiles/) and create a new `ArbHi.go` (introduced in Option 2). This time, we'll add two new methods to read and write the ArbOS state:

```rust
package precompiles

// ArbHi provides a friendly greeting to anyone who calls it.
type ArbHi struct {
	Address addr // 0x11a, for example
}

func (con *ArbHi) SayHi(c ctx, evm mech) (string, error) {
	return "hi", nil
}

func (con *ArbHi) GetNumber(c ctx, evm mech) (uint64, error) {
	return c.State.GetMyNumber()
}

func (con *ArbHi) SetNumber(c ctx, evm mech, newNumber uint64) error {
	return c.State.SetNewMyNumber(newNumber)
}
```

Follow the procedure detailed in Option 2 in order to add this new precompile contract, and then run your node.

Your smart contract interface should look like this:

```rust
pragma solidity >=0.4.21 <0.9.0;

/// @title Say hi.
/// @notice just for test
/// This custom contract will set on 0x000000000000000000000000000000000000011a since we set it in precompile.go.
interface ArbHi {
    function sayHi() external view returns(string memory);
    function getNumber() external view returns(uint64);
    function setNumber(uint64) external;
}
```

### Send the transaction and get the transaction receipt[​](#send-the-transaction-and-get-the-transaction-receipt-2 "Direct link to Send the transaction and get the transaction receipt")

To send a transaction to `ArbSys`, we need to include a gas cost, because the function is no longer a view/pure function:

```rust
cast send 0x000000000000000000000000000000000000011a "setNumber()" "2"
```

### Get results from foundry cast[​](#get-results-from-foundry-cast "Direct link to Get results from foundry cast")

```rust
cast call 0x000000000000000000000000000000000000011a "getNumber()(uint64)”
```

You should see something like this:

```rust
2
```

Incorporate your changes to precompile into the ArbOS upgrade[​](#incorporate-your-changes-to-precompile-into-the-arbos-upgrade "Direct link to Incorporate your changes to precompile into the ArbOS upgrade")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

If you do not customize the precompile before launching your Orbit network, please continue to follow \[customize arbos\] to perform an ArbOS version control to avoid blockchain reorg.

---

# How to customize your Orbit chain's behavior | Arbitrum Docs

## How to customize your Orbit chain's behavior

caution

### Customizations require expertise[​](#customizations-require-expertise "Direct link to Customizations require expertise")

Customizing your chain is a core benefit of building with Arbitrum Orbit. We strongly recommend that teams interested in customizations work alongside a partner with ArbOS and Nitro software expertise, such as a Rollup-as-a-Service team.

Working alongside an experienced Orbit operator can help your team navigate the complex tradeoff space of rollup customizations, which can include performance, security, and cost considerations. Offchain Labs is positioned to train and enable Rollup-as-a-Service in their work with clients to scale support to the Orbit ecosystem as a whole. As such, Offchain Labs does not necessarily have the capacity to review code changes made by individual Orbit chains.

We encourage you to leverage your in-house expertise, collaborate with expert partners, and allocate appropriate resources for both an initial implementation (including an audit) and ongoing maintenance and security management of your customization.

Introduction[​](#introduction "Direct link to Introduction")
------------------------------------------------------------

Before customizing your Orbit chain, it's important to understand what the State Transition Function (aka the STF) is. The STF defines how new blocks are produced from input messages (i.e. transactions). This guide is only necessary for changes that modify the State Transition Function. To customize other node behavior, such as RPC behavior or the sequencer's ordering policy, you can simply [build your own node](/run-arbitrum-node/nitro/build-nitro-locally) without worrying about the rest of this guide. However, changes that modify the STF require updating the fraud proving system to recognize the new behavior as correct. Otherwise, the fraud prover would side with unmodified nodes, which would win fraud proofs against your modified node.

Here's some examples of modifications that affect the STF:

*   Adding a new EVM opcode or precompile: This modifies the STF because a node with this change would disagree about the outcome of EVM execution compared to an unmodified Nitro node when the new opcode or precompile is invoked.
*   Rewarding the deployer of a smart contract with a portion of gas spent in the smart contract's execution: This modifies the STF because a node which has this change applied would disagree about the balance of the deployer after transactions. Such changes would lead to disagreements about block hashes compared to unmodified Nitro nodes.

Here's some examples of modifications that don't affect the STF:

*   Adding a new RPC method to query an address's balance across multiple blocks: This doesn't modify the STF because it doesn't change on-chain balances or block hashes.
*   Changing the sequencer to order blocks by tip: The sequencer is trusted to order transactions in Arbitrum Nitro, and it can choose any ordering it wants. Nodes (and the fraud proofs) will simply accept the new transaction ordering as there is no single ordering they think is correct.

### Modification compatibility with Arbitrum Nitro[​](#modification-compatibility-with-arbitrum-nitro "Direct link to Modification compatibility with Arbitrum Nitro")

Some potential modifications are incompatible with Arbitrum Nitro and would not result in a functioning blockchain. Here are some requirements for the Arbitrum Nitro State Transition Function:

*   The STF must be deterministic. For instance, if you gave an address a random balance using the Go randomness library, every node would disagree on the correct amount of balance and the blockchain would not function correctly. However, it is acceptable to take a non-deterministic path to a deterministic output. For instance, if you randomly shuffled a list of addresses, and then gave them each 1 Ether, that would be fine, because no matter how the list of addresses is shuffled the result is the same and all addresses are given 1 Ether.
*   The STF must not reach a new result for old blocks. For instance, if you have been running an Arbitrum Nitro chain for a while, and then you decide to modify the STF to not charge for gas, a new node that syncs the blockchain will reach a different result for historical blocks. It's also important to synchronize between nodes when an upgrade takes effect. A common mechanism for doing this is having an upgrade take effect at a certain timestamp, by which all nodes must be upgraded.
*   The STF must be "pure" and not use external resources. For instance, it must not use the filesystem, make external network calls, or launch processes. That's because the fraud proving system does not (and for the most part, cannot) support these resources. For instance, it's impossible to fraud prove what the result of an external network call is, because the fraud prover smart contracts on L1 are unable to do networking.
*   The STF must not carry state between blocks outside of the "global state". In practice this means persistent state must be stored within block headers or the Ethereum state trie. For instance, ArbOS stores all retryables in contract storage under a special ArbOS address.
*   The STF must not modify Ethereum state outside of a transaction. This is important to ensure that replaying old blocks reaches the same result, both for tracing and for validation. The ArbOS internal transaction is useful to modify state at the start of blocks.
*   The STF must reach a result in under a second. This is a rough rule, but for nodes to keep in sync it's highly recommended to keep blocks quick. It's also important for the fraud proofs that execution reliably finishes in a relatively short amount of time. A block gas limit of 32 million gas should safely fit within this limit.
*   The STF must not fail or panic. It's important that the STF always produces a new block, even if user input is malformed. For instance, if the STF receives an invalid transaction as input, it'll still produce an empty block.

Building the modified node[​](#building-the-modified-node "Direct link to Building the modified node")
------------------------------------------------------------------------------------------------------

To modify the State Transition Function, you'll need to build a modified Arbitrum Nitro node Docker image. This guide covers how to build the node and enable fraud proofs by building a new replay binary.

### Step 1. Download the Nitro source code[​](#step-1-download-the-nitro-source-code "Direct link to Step 1. Download the Nitro source code")

Clone the Nitro repository before you begin:

```rust
git clone --branch v3.5.1 https://github.com/OffchainLabs/nitro.git
cd nitro
git submodule update --init --recursive --force
```

### Step 2. Apply modifications[​](#step-2-apply-modifications "Direct link to Step 2. Apply modifications")

Next, make your changes to the State Transition Function. For example, you could [add a custom precompile](/launch-orbit-chain/customize-your-chain/customize-precompile).

After this step, you should visit [Customize ArbOS version](/launch-orbit-chain/customize-your-chain/customize-arbos) to see if your changes need to upgrade the ArbOS version. If so, please continue follow that document to add an ArbOS upgrade logic to your code.

### Step 3. Run the node without fraud proofs[​](#step-3-run-the-node-without-fraud-proofs "Direct link to Step 3. Run the node without fraud proofs")

To build the Arbitrum Nitro node image, you'll first need to install Docker. You can confirm if it's already setup by running `docker version` in a terminal. If not, try following [Docker's getting started guide](https://www.docker.com/get-started/), or if you're on Linux, install Docker from your distribution's package manager and start the Docker service.

Once you have Docker installed, you can simply run `docker build . --tag custom-nitro-node` in the `nitro` folder to build your custom node.

Once you've built your new Nitro node image, you have to modify the configuration file of your node to add a new parameter, `--node.staker.dangerous.without-block-validator`, which disables fraud proof verification.

To do that, open your `nodeConfig.json` file (stored by default in the `config` folder) and add the new parameter inside the `staker` element:

```rust
...
"staker": {
  ...
  "dangerous": {
    "without-block-validator": true
  }
  ...
},
...
```

With that, you have now two ways of running your node.

**1\. Using the docker-compose file**

This is the recommended way if you're running your Orbit chain locally through the provided [docker-compose file](https://github.com/OffchainLabs/orbit-setup-script/blob/main/docker-compose.yaml#L39). In `docker-compose.yml`, modify the Docker image used for the Nitro container:

```rust
...
nitro:
  image: custom-nitro-node
  ports:
...
```

And run `docker compose up` to run all of your containers.

**2\. Use `docker run` to run your Nitro node only**

This method will only run the customized Nitro node (i.e., it will not run Blockscout, or the DA server if you're using an AnyTrust chain). Use the following command:

```rust
docker run --rm -it -v /path/to/your/node/dir:/home/user/.arbitrum -p 0.0.0.0:8449:8449 custom-nitro-node --conf.file /home/user/.arbitrum/nodeConfig.json
```

info

Note that the instructions provided in [How to run a full node](/run-arbitrum-node/run-full-node) **will not** work with your Orbit node. See [Optional parameters (Orbit)](/node-running/how-tos/running-an-orbit-node#optional-parameters) for Orbit-specific CLI flags.

Once your node is running, you can try out your modifications to the State Transition Function and confirm they work as expected.

### Step 4. Enable fraud proofs[​](#step-4-enable-fraud-proofs "Direct link to Step 4. Enable fraud proofs")

To enable fraud proofs, you'll need to build the "replay binary", which defines the State Transition Function for the fraud prover. The replay binary (sometimes called the machine) re-executes the State Transition Function against input messages to determine the correct output block. It has three forms:

*   The `replay.wasm` binary is the Go replay binary compiled to WASM. It's used by the JIT validator to verify blocks against the fraud prover.
*   The `machine.wavm.br` binary is a compressed binary containing the Go replay binary and all its dependencies, compiled to WASM, then translated to the Arbitrum fraud proving variant WAVM. It's used by Arbitrator when actually entering a challenge and performing the fraud proofs, and has identical behavior to `replay.wasm`.
*   The WASM module root (stored in `module-root.txt`) is a 32 byte hash usually expressed in hexadecimal which is a merkelization of `machine.wavm.br`. The replay binary is much too large to post on-chain, so this hash is set in the L1 rollup contract to determine the correct replay binary during fraud proofs.

To run a validator node with fraud proofs enabled, the validator node's Docker image will need to contain all three of these versions of the replay binary.

#### 4.1 Build a dev image[​](#41-build-a-dev-image "Direct link to 4.1 Build a dev image")

The simplest way to build a Docker image with the new replay binary is to build a dev image. These images contain a freshly built replay binary, but note that the replay binary and corresponding WASM module root will generally change when the code is updated, even if the State Transition Function has equivalent behavior. It's important that the validator's WASM module root matches the on-chain WASM module root, which is why this approach is harder to maintain. Over the longer term, you'll want to maintain a separate build of the replay binary that matches the one currently on-chain, usable by any node image.

To build the dev node image and get the WASM module root, run:

```rust
docker build . --target nitro-node-dev --tag custom-nitro-node-dev
docker run --rm --entrypoint cat custom-nitro-node-dev target/machines/latest/module-root.txt
```

Once you have the WASM module root, you can put it on-chain by calling `setWasmModuleRoot(newWasmModuleRoot)` through the upgradeExecutor contract's method `executeCall()` as the owner. To call this method, you need to set `target` as your rollup contract address. Ensure that `targetCallData` starts with `0x89384960` (this is the signature of `setWasmModuleRoot(byte32)`), and that it's followed by your WASM module root. The `upgradeExecutor` contract address and rollup contract address can be found in the chain deployment info JSON. You can confirm that the WASM module root was updated by calling `wasmModuleRoot()` on the rollup contract.

Once you have set the new WASM module root on-chain, you can re-enable fraud proofs and run your node.

To re-enable fraud proofs, open your `nodeConfig.json` file again, and remove the `"dangerous"` section (containing the `without-block-validator` property) that you previously added.

After that, you'll have, again, two ways of running your node.

**1\. Using the docker-compose file**

As mentioned before, this is the recommended way if you're running your Orbit chain locally through the provided [docker-compose file](https://github.com/OffchainLabs/orbit-setup-script/blob/main/docker-compose.yaml#L39). In `docker-compose.yml`, modify the Docker image used for the Nitro container. Notice that we'll now use the `custom-nitro-node-dev` you just created:

```rust
...
nitro:
  image: custom-nitro-node-dev
  ports:
...
```

And run `docker compose up` to run all of your containers.

**2\. Use `docker run` to run your Nitro node only**

This method will only run the customized Nitro node (i.e., it will not run Blockscout, or the DA server if you're using an AnyTrust chain). Use the following command:

```rust
docker run --rm -it -v /path/to/your/node/dir:/home/user/.arbitrum -p 0.0.0.0:8449:8449 custom-nitro-node-dev --conf.file /home/user/.arbitrum/nodeConfig.json
```

#### 4.2 Preserving the replay binary[​](#42-preserving-the-replay-binary "Direct link to 4.2 Preserving the replay binary")

The primary issue with simply using a nitro-node-dev build is that, whenever the code changes at all, the replay binary will also change.

If the node is missing the replay binary corresponding to the on-chain WASM module root, it will be unable to act as a validator. Therefore, when releasing new node Docker images it's important to include the currently on-chain WASM module root.

To do that, you'll need to first extract the replay binary from the `nitro-node-dev` Docker image built earlier:

```rust
docker run --rm --name replay-binary-extractor --entrypoint sleep custom-nitro-node-dev infinity
docker cp replay-binary-extractor:/home/user/target/machines/latest extracted-replay-binary
docker stop replay-binary-extractor
cat extracted-replay-binary/module-root.txt
mv extracted-replay-binary "target/machines/$(cat extracted-replay-binary/module-root.txt)"
```

These commands will output the new WASM module root, and create the directory `target/machines/<wasm module root>`. There you'll find the three versions of the replay binary mentioned earlier: `replay.wasm`, `machine.wavm.br`, and `module-root.txt`, along with some other optional files. Now that you've extracted the replay binary, there are two ways to add it to future Docker images, including non-dev image builds. You can either keep it locally and copy it in, or host it on the web.

##### Option 1: Store the extracted replay binary locally[​](#option-1-store-the-extracted-replay-binary-locally "Direct link to Option 1: Store the extracted replay binary locally")

Now that we've extracted the replay binary, we can modify the Dockerfile to copy it into new Docker builds. Edit the `Dockerfile` file in the root of the nitro folder, and after all the `RUN ./download-machines.sh ...` lines, add:

```rust
COPY target/machines/<wasm module root> <wasm module root>
RUN ln -sfT <wasm module root> latest
```

Replace each `<wasm module root>` with the WASM module root you got earlier.

##### Option 2: Host the replay binary on the web[​](#option-2-host-the-replay-binary-on-the-web "Direct link to Option 2: Host the replay binary on the web")

To support building the Docker image on other computers without this local machine directory, you'll need to either commit the machine to git, or preferably, host the replay binary on the web.

To host the replay binary on the web, you'll need to host the `replay.wasm` and `machine.wavm.br` files somewhere. One good option is GitHub releases, but any hosting service works.

Once you have those two files hosted, instead of the `COPY` and `RUN` command mentioned in option 1, you'll need to add these new lines to the `Dockerfile` file in the root of the nitro folder, after all the `RUN ./download-machines.sh ...` lines:

```rust
RUN wasm_module_root="<wasm module root>" && \
    mkdir "$wasm_module_root" && \
    wget <url of replay.wasm> -O "$wasm_module_root/replay.wasm" && \
    wget <url of machine.wavm.br> -O "$wasm_module_root/machine.wavm.br" && \
    echo "$wasm_module_root" > "$wasm_module_root/module-root.txt" && \
    ln -sfT "$wasm_module_root" latest
```

Replace the `<wasm module root>` with the WASM module root you got earlier, the `<url of replay.wasm>` with the direct link to the `replay.wasm` file (it must be a direct link to the file and not just a download site), and the `<url of machine.wavm.br>` with the direct link to the `machine.wavm.br` file.

### Step 5. Verify the fraud proofs[​](#step-5-verify-the-fraud-proofs "Direct link to Step 5. Verify the fraud proofs")

In theory, fraud proofs should now be working with your newly built Docker images. Make some transactions on your new blockchain, test out your modifications to the State Transition Function, wait for a batch to be posted, and you should be seeing "validation succeeded" log lines!

If you see "Error during validation", then the replay binary is likely not up-to-date with your modifications to the State Transition Function. Ensure that the replay binary is freshly built, not missing any modifications, and that the WASM module root set in the rollup contract matches your replay binary.

---

# Canonical Factory Contracts | Arbitrum Docs

## Canonical Factory Contracts

---

# How to configure your Orbit chain using the Orbit SDK | Arbitrum Docs

## How to configure your Orbit chain using the Orbit SDK

In this how-to, you'll learn how to configure your Orbit chain using the Orbit SDK.

UNDER CONSTRUCTION

This document is under construction and may change significantly as we incorporate [style guidance](/for-devs/contribute#document-type-conventions) and feedback from readers. Feel free to request specific clarifications by clicking the `Request an update` button at the top of this document.

Orbit chains have three areas of configuration:

1.  [](#1-parent-chain-configuration) configuration
2.  [**Node** configuration](#2-node-configuration)
3.  [](#3-child-chain-parameter-configuration) configuration

1\. Parent chain configuration[​](#1-parent-chain-configuration "Direct link to 1. Parent chain configuration")
---------------------------------------------------------------------------------------------------------------

Configuring the parent chain is the initial step to setting up your Orbit chain. Most of the parent chain configurations are specified during the setup phase. Detailed instructions can be found in the [Rollup Deployment Parameters](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain#rollup-deployment-parameters) section of the Rollup deployment guide.

After the initial setup, the chain owner can modify configurations as needed. For instance, the validator set can be updated by invoking the [`setValidKeyset`](https://github.com/OffchainLabs/nitro-contracts/blob/90037b996509312ef1addb3f9352457b8a99d6a6/src/bridge/SequencerInbox.sol#L751) function with a new set of validators. This adaptability facilitates your chain's optimization and management.

2\. Node configuration[​](#2-node-configuration "Direct link to 2. Node configuration")
---------------------------------------------------------------------------------------

As a chain deployer, you can configure a node during the node config generation process with the `nodeConfig.json` file. `nodeConfig.json` allows you to set up a node as a validator or a sequencer and specify requirements or performance criteria. For more information, refer to the [Node Configuration Preparation](/launch-orbit-chain/how-tos/orbit-sdk-preparing-node-config) documentation.

3\. Child chain parameter configuration[​](#3-child-chain-parameter-configuration "Direct link to 3. Child chain parameter configuration")
------------------------------------------------------------------------------------------------------------------------------------------

The child chain configuration can be performed after the chain has been initialized and the token bridge has been deployed. Child chains' parameters are configurable via setter functions in the [`ArbOwner precompile`](https://github.com/OffchainLabs/nitro-contracts/blob/main/src/precompiles/ArbOwner.sol). Additionally, there are various getter functions in the `ArbOwner precompile` that you can use to read the current configuration.

Below, we explain several methods in the `ArbOwner precompile` that you can use to configure the parameters or read their current state.

### Setter functions[​](#setter-functions "Direct link to Setter functions")

You can use these setter functions to configure the child chain parameters:

Parameter

Description

`addChainOwner`

Adds a new chain owner to your Orbit chain.

`removeChainOwner`

Removes an existing owner from the list of chain owners.

`setMinimumL2BaseFee`

Sets the minimum base fee on the child chain. The minimum base fee is the lowest amount that the base fee on the child chain can ever be. For example, the current minimum base fee on Arbitrum One and Arbitrum Nova is 0.01 gwei.

`setSpeedLimit`

The fee mechanism on the Arbitrum Nitro stack differs from the Ethereum blockchain. The Nitro stack has a parameter called the speed limit, which targets the number of gas consumed on the child chain per second. If the amount of gas per second exceeds this pre-specified amount, the base fee on the child chain will increase, and vice versa. The current speed limit on Arbitrum One is 7 million gas per second, meaning if the Arbitrum One chain consumes more than 7 million gas per second, its base fee will increase. For more information on the speed limit, please refer to this [document explaining the concept of speed limit in the Nitro stack](https://docs.arbitrum.io/inside-arbitrum-nitro/#the-speed-limit).

`setInfraFeeAccount`

Sets the infrastructure fee account address, which receives all fees collected on the child chain. It is meant to receive the minimum base fee, with any amount above that going to the network fee account.

`setNetworkFeeAccount`

Sets the network fee account address. As mentioned, this address collects all fees above the base fee. Note that if you set this amount to the 0 address on your chain, all fees will be deposited into the infrastructure fee account.

`scheduleArbOSUpgrade`

If you plan to upgrade the  version of your chain, this method can help you schedule the upgrade. For a complete guide, please refer to the explanation for the [arbos upgrade](/launch-orbit-chain/configure-your-chain/common-configurations/arbos-upgrade).

`setChainConfig`

We discussed the `chainConfig` in the [Rollup deployment guide](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain#4-chainconfig) in detail. If you wish to change any field of the `chainConfig`, you need to use this method on the child chain.

### Getter functions[​](#getter-functions "Direct link to Getter functions")

Parameter

Description

`getAllChainOwners`

Provides the list of all current chain owners.

`isChainOwner`

Allows you to check whether an address is on the list of chain owners.

`getInfraFeeAccount`

Returns the infrastructure fee account address.

`getNetworkFeeAccount`

Returns the network fee account address.

### Configuring the child chain using the Orbit SDK[​](#configuring-the-child-chain-using-the-orbit-sdk "Direct link to Configuring the child chain using the Orbit SDK")

In the Orbit SDK, we use the [Client Extension](https://viem.sh/docs/clients/custom#extending-with-actions-or-configuration) feature of Viem to extend the public client. In the Orbit SDK, we defined `arbOwnerPublicActions` to use it and extend the client on [Viem](https://viem.sh/docs/clients/custom#extending-with-actions-or-configuration). An example of creating a public client extended with `arbOwner` public actions is:

```rust
import { createPublicClient, http } from 'viem';
import { arbOwnerPublicActions } from '@arbitrum/orbit-sdk';

const client = createPublicClient({
  chain: arbitrumLocal,
  transport: http(),
}).extend(arbOwnerPublicActions);
```

With `arbOwnerPublicActions` and the public client in the Orbit SDK, we've added two new methods to the public clients:

#### 1\. arbOwnerReadContract[​](#1-arbownerreadcontract "Direct link to 1. arbOwnerReadContract")

This method can be used to read the parameters of the child chain discussed in the [previous section](#getter-functions). An example of using this method with the `client` defined in the previous section is:

```rust
const result = await client.arbOwnerReadContract({
  functionName: 'getAllChainOwners',
});
```

The other parameters can be obtained by changing the function names in the [the Getter functions section](#getter-functions) list.

#### 2\. `arbOwnerPrepareTransactionRequest`[​](#2-arbownerpreparetransactionrequest "Direct link to 2-arbownerpreparetransactionrequest")

This method can be used to configure the parameters on the `ArbOwner` precompile, which are listed in [the Setter functions section](#setter-functions). An example of utilizing this method to configure parameters using the `client` defined in the previous section is:

```rust
// Adding a random address as chain owner using the upgrade executor
const transactionRequest = await client.arbOwnerPrepareTransactionRequest({
  functionName: 'addChainOwner',
  args: [randomAccountAddress],
  upgradeExecutor: false,
  account: owner.address,
});

// Submitting the transaction to add a chain owner
await client.sendRawTransaction({
  serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

To use this method, as shown in the example above, some inputs need to be defined:

Parameter

Description

`functionName`

The name of the method you want to use to set the parameter, which can be found in [the Setter functions section](#setter-functions).

`args`

The arguments for the defined function.

`upgradeExecutor`

Specifies whether a `upgradeExecutor` contract governs your chain. If it is not using a `upgradeExecutor`, you can set it to `false`, similar to the example above.

`account`

Defines the chain owner if an `upgradeExecutor` does not govern the chain.

If a `upgradeExecutor` contract governs your chain, then you need to use the `arbOwnerPrepareTransactionRequest` method, similar to the example below:

```rust
// Adding a random address as chain owner using the upgrade executor
const transactionRequest = await client.arbOwnerPrepareTransactionRequest({
  functionName: 'addChainOwner',
  args: [randomAccountAddress],
  upgradeExecutor: upgradeExecutorAddress,
  account: owner.address,
});

// Submitting the transaction to add a chain owner
await client.sendRawTransaction({
  serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

In this example, all the fields are the same as in the first example, except the `upgradeExecutor` field, which you need to set to the `upgradeExecutor` address, and the `account` parameter, which needs to be set to the owner of the `upgradeExecutor` contract.

---

# How to Deploy an AnyTrust chain using the Orbit SDK | Arbitrum Docs

## How to Deploy an AnyTrust chain using the Orbit SDK

This section explains how to initiate an  using [Arbitrum's Orbit SDK](https://github.com/OffchainLabs/arbitrum-orbit-sdk).

UNDER CONSTRUCTION

This document is under construction and may change significantly as we incorporate [style guidance](/for-devs/contribute#document-type-conventions) and feedback from readers. Feel free to request specific clarifications by clicking the `Request an update` button at the top of this document.

info

See the ["set-valid-keyset" example](https://github.com/OffchainLabs/arbitrum-orbit-sdk/blob/main/examples/set-valid-keyset/index.ts) in the Orbit SDK repository for additional guidance.

### About AnyTrust Orbit[​](#about-anytrust-orbit "Direct link to About AnyTrust Orbit")

AnyTrust chains implement the Arbitrum AnyTrust protocol, an alternative to the Arbitrum Rollup protocol. AnyTrust reduces transaction fees by introducing a minor trust assumption in the form of a permissioned set of parties responsible for managing data availability. For an overview of Orbit chain types, please refer to the [Orbit SDK introduction](/launch-orbit-chain/orbit-sdk-introduction).

### Deployment steps[​](#deployment-steps "Direct link to Deployment steps")

The deployment process of AnyTrust chains is very similar to that of [Rollup chains](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain#rollup-configuration-parameters), but with some differences that we'll discuss in this guide.

Here are the steps involved in the deployment process:

1.  **[Setting up the chain parameters](#1-setting-up-the-chain-parameters)**
2.  **[Deploying your AnyTrust chain](#2-deploying-your-anytrust-chain)**
3.  **[Getting the AnyTrust Orbit chain information after deployment](#3-getting-the-anytrust-orbit-chain-information-after-deployment)**
4.  **[Setting valid keyset on parent chain](#4-setting-valid-keyset-on-parent-chain)**

The deployment of an AnyTrust Orbit chain involves defining and setting up the  keyset. This keyset includes keys from the appointed members of the DAC. They are required to ensure the chain's data availability and integrity. Once you have selected your committee members and gathered their keys, the Orbit SDK helps you configure these keys into a keyset. This keyset is then embedded into the chain, serving as a verification mechanism.

Let's go through each deployment step:

### 1\. Setting up the chain parameters[​](#1-setting-up-the-chain-parameters "Direct link to 1. Setting up the chain parameters")

Similarly to the Rollup chain, you'll need to prepare the AnyTrust chain configuration, including the core contracts and operational parameters that govern the chain's functionality, focusing on parameters specific to AnyTrust chains.

```rust
struct Config {
    uint64 confirmPeriodBlocks;
    uint64 extraChallengeTimeBlocks;
    address stakeToken;
    uint256 baseStake;
    bytes32 wasmModuleRoot;
    address owner;
    address loserStakeEscrow;
    uint256 chainId;
    string chainConfig;
    uint64 genesisBlockNum;
    ISequencerInbox.MaxTimeVariation sequencerInboxMaxTimeVariation;
}
```

You can create the `chainConfig` parameter within the `Config` using `prepareChainConfig`. You can find more details on that function [here](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain#41-preparechainconfig).

```rust
import { prepareChainConfig } from '@arbitrum/orbit-sdk';

const chainConfig = prepareChainConfig({
  chainId: 123_456,
  arbitrum: {
    InitialChainOwner: deployer,
    DataAvailabilityCommittee: true,
  },
});
```

Other than the required `chainId` and `arbitrum.InitialChainOwner` params, `arbitrum.DataAvailabilityCommittee` needs to be set to `true` for AnyTrust.

### 2\. Deploying your AnyTrust chain[​](#2-deploying-your-anytrust-chain "Direct link to 2. Deploying your AnyTrust chain")

After configuring your chain with the `createRollupPrepareDeploymentParamsConfig` API, the next step is to use the `createRollupPrepareTransactionRequest` API. This API is designed to take the parameters defined in the `RollupDeploymentParams`, along with the configuration generated by the `createRollupPrepareDeploymentParamsConfig` API, to prepare a transaction request. This request is then used to invoke the `createRollup` function of the `RollupCreator` contract, which effectively deploys and initializes the core contracts of your AnyTrust Orbit chain.

For instance, to deploy using the Orbit SDK with a Config equal to `config`, a single batch poster in `[batchPoster]`, and a single validator in `[validator]`, the process would look like this:

```rust
import { createRollupPrepareTransactionRequest } from '@arbitrum/orbit-sdk';

const request = await createRollupPrepareTransactionRequest({
  params: {
    config,
    batchPosters: [batchPoster],
    validators: [validator],
  },
  account: deployer_address,
  publicClient,
});
```

After creating the raw transaction, you can sign and broadcast it to the network.

### 3\. Getting the AnyTrust Orbit chain information after deployment[​](#3-getting-the-anytrust-orbit-chain-information-after-deployment "Direct link to 3. Getting the AnyTrust Orbit chain information after deployment")

To extract detailed information about your AnyTrust Orbit chain post-deployment, you can use the same API and steps as you would for a Rollup Orbit chain. Here's a reminder of the example:

```rust
import { createRollupPrepareTransactionReceipt } from '@arbitrum/orbit-sdk';

const data = createRollupPrepareTransactionReceipt(txReceipt);
```

In this example, `txReceipt` refers to the transaction receipt you received after deploying the AnyTrust chain. By inputting this receipt into the `createRollupPrepareTransactionReceipt` function, you can access comprehensive data about your deployment, including details about the core contracts and configuration settings.

### 4\. Setting valid keyset on parent chain[​](#4-setting-valid-keyset-on-parent-chain "Direct link to 4. Setting valid keyset on parent chain")

The final step is to set up a valid keyset for your Data Availability Committee (DAC) on the parent chain. See [How to configure a DAC](/run-arbitrum-node/data-availability-committees/configure-dac) for instructions.

Once created, your keyset needs to be established on your Orbit chain's `SequencerInbox` contract on the parent chain. To facilitate this, we provide an API in Orbit SDK named `setValidKeysetPrepareTransactionRequest`. This API requires specific information you can gather at [step three](#3-getting-the-anytrust-orbit-chain-information-after-deployment). This includes the `upgradeExecutor` and `sequencerInbox` addresses of your Orbit chain, the generated keyset for your committee, and the owner's account.

Here's an example of how you can use the Orbit SDK to write your keyset:

```rust
const txRequest = await setValidKeysetPrepareTransactionRequest({
  coreContracts: {
    upgradeExecutor: 'upgradeExecutor_address',
    sequencerInbox: 'sequencerInbox_address',
  },
  keyset,
  account: deployer.address,
  publicClient: parentChainPublicClient,
});
```

In this example, `upgradeExecutor_address` and `sequencerInbox_address` are placeholders for the Orbit chain's contract addresses. `keyset` is the keyset you generated for your committee, and `deployer.address` refers to the owner's account address.

Once you've created the transaction request using the above API, the next step is to sign and send the transaction. This transaction writes the keyset to the parent chain, enabling it to recognize and verify the valid keyset for your AnyTrust Orbit chain.

---

# How to deploy a custom gas token chain using the Orbit SDK | Arbitrum Docs

## How to deploy a custom gas token chain using the Orbit SDK

UNDER CONSTRUCTION

This document is under construction and may change significantly as we incorporate [style guidance](/for-devs/contribute#document-type-conventions) and feedback from readers. Feel free to request specific clarifications by clicking the `Request an update` button at the top of this document.

info

See the ["create a rollup custom fee token" example](https://github.com/OffchainLabs/arbitrum-orbit-sdk/blob/main/examples/create-rollup-custom-fee-token/index.ts) in the Orbit SDK repository for additional guidance.

This guide will help you configure and deploy a custom gas token Orbit chain.

Custom gas token orbit chains let participants pay transaction fees in `ERC-20` token instead of `ETH`, which is ideal for use cases requiring this feature and low transaction fees. You can learn more on our page covering [custom gas token requirements and configuration](/launch-orbit-chain/configure-your-chain/common-configurations/use-a-custom-gas-token).

Deploying a custom gas token Orbit chain is similar to deploying an AnyTrust Orbit chain but with additional steps. To take advantage of all the chains configurations supported by Orbit, we recommend reading our short guides about [Rollup](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain) and [AnyTrust](/launch-orbit-chain/deploy-an-orbit-chain/deploying-anytrust-chain) configuration.

note

*   Custom gas tokens are **not supported yet** on Rollup Orbit chains, only on Orbit AnyTrust chains.
*   `ERC-20` tokens need 18 decimals to operate as gas tokens on Orbit chains.

1\. Custom gas token specification[​](#1-custom-gas-token-specification "Direct link to 1. Custom gas token specification")
---------------------------------------------------------------------------------------------------------------------------

The difference between custom gas token chains and other Orbit chains is the use of an `ERC-20` token as the gas token. Enabling this feature requires that you select an existing `ERC-20` token or deploy a new one on the parent chain.

2\. Chain configuration[​](#2-chain-configuration "Direct link to 2. Chain configuration")
------------------------------------------------------------------------------------------

Chain configuration is the same as for any other AnyTrust chain. See more [here](/launch-orbit-chain/deploy-an-orbit-chain/deploying-anytrust-chain#1-setting-up-the-chain-parameters).

3\. Token approval before deployment process[​](#3-token-approval-before-deployment-process "Direct link to 3. Token approval before deployment process")
---------------------------------------------------------------------------------------------------------------------------------------------------------

In Custom gas token Orbit chains, the owner needs to give allowance to the `rollupCreator` contract before starting the deployment process so that `rollupCreator` can spend enough tokens for the deployment process. For this purpose, we defined two APIs on the Orbit SDK:

#### A. createRollupEnoughCustomFeeTokenAllowance[​](#a-createrollupenoughcustomfeetokenallowance "Direct link to A. createRollupEnoughCustomFeeTokenAllowance")

This API gets related inputs and checks if the `rollupCreator` contract has enough token `Allowance` from the owner:

```rust
import { createRollupEnoughCustomFeeTokenAllowance } from '@arbitrum/orbit-sdk';

const allowanceParams = {
  nativeToken,
  account: deployer.address,
  publicClient: parentChainPublicClient,
};

const enoughAllowance = await createRollupEnoughCustomFeeTokenAllowance(allowanceParams);
```

To build the `allowanceParams` object as shown in the example above, you need to provide with the following:

Parameter

Type

Description

`nativeToken`

`Address`

The contract address on the parent chain of the `ERC-20` token your chain will use for `gas` fees.

`account`

`Address`

The address of the Orbit chain's deployer.

`publicClient`

`PublicClient`

The `PublicClient` object [as defined by the Viem library](https://viem.sh/docs/clients/public.html).

#### B. createRollupPrepareCustomFeeTokenApprovalTransactionRequest[​](#b-createrolluppreparecustomfeetokenapprovaltransactionrequest "Direct link to B. createRollupPrepareCustomFeeTokenApprovalTransactionRequest")

This API gets related inputs and creates the transaction request to secure enough allowance from the owner to the `RollupCreator` to spend `nativeToken` on the deployment process.

Example:

```rust
import { createRollupEnoughCustomFeeTokenAllowance } from '@arbitrum/orbit-sdk';

const allowanceParams = {
  nativeToken,
  account: deployer.address,
  publicClient: parentChainPublicClient,
};

const approvalTxRequest = await createRollupPrepareCustomFeeTokenApprovalTransactionRequest(
  allowanceParams,
);
```

4\. Deployment process[​](#4-deployment-process "Direct link to 4. Deployment process")
---------------------------------------------------------------------------------------

The overall deployment process, including the use of APIs like `createRollupPrepareDeploymentParamsConfig` and `createRollupPrepareTransactionRequest`, remains similar to the [AnyTrust deployment](/launch-orbit-chain/deploy-an-orbit-chain/deploying-anytrust-chain) process. However, attention must be given to incorporating the `ERC-20` token details into these configurations.

note

When using the API, you also need to specify `nativeToken` as a param.

Example:

```rust
const txRequest = await createRollupPrepareTransactionRequest({
  params: {
    config,
    batchPosters: [batchPoster],
    validators: [validator],
    nativeToken,
  },
  account: deployer.address,
  publicClient: parentChainPublicClient,
});
```

All other parts would be the same as explained in the [Rollup Orbit chain deployment page](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain).

---

# How to Deploy a Rollup chain using the Orbit SDK | Arbitrum Docs

## How to Deploy a Rollup chain using the Orbit SDK

This document explains how to use the Orbit SDK to deploy a .

UNDER CONSTRUCTION

This document is under construction and may change significantly as we incorporate [style guidance](/for-devs/contribute#document-type-conventions) and feedback from readers. Feel free to request specific clarifications by clicking the `Request an update` button at the top of this document.

info

See the ["create-rollup-eth" example](https://github.com/OffchainLabs/arbitrum-orbit-sdk/blob/main/examples/create-rollup-eth/index.ts) in the Orbit SDK repository for additional guidance.

The main benefit of the Orbit SDK lies in facilitating the deployment and fine-tuning of Orbit chains core Smart-Contracts.

These contracts are deployed on , they are:

*   Rollup contracts
*   
*   Contracts handling 

Core contracts are the backbone of Arbitrum's , ensuring its robust and efficient operation. You can explore their code in the [nitro-contracts GitHub repository](https://github.com/OffchainLabs/nitro-contracts).

### Rollup deployment parameters[​](#rollup-deployment-parameters "Direct link to Rollup deployment parameters")

[`createRollup`](https://github.com/OffchainLabs/nitro-contracts/blob/acb0ef919cce9f41da531f8dab1b0b31d9860dcb/src/rollup/RollupCreator.sol#L107) is the function that will deploy your core contracts on the parent chain. `createRollup` takes a complex input named `deployParams`, which defines the characteristics of an Orbit Rollup chain.

The following will walk you through the methods and properties you will use to configure your chain.

#### 1\. RollupDeploymentParams struct[​](#1-rollupdeploymentparams-struct "Direct link to 1. RollupDeploymentParams struct")

```rust
struct RollupDeploymentParams {
    Config config;
    address[] validators;
    uint256 maxDataSize;
    address nativeToken;
    bool deployFactoriesToL2;
    uint256 maxFeePerGasForRetryables;
    address[] batchPosters;
    address batchPosterManager;
}
```

This Solidity struct includes key settings like the chain configuration (`Config`), validator addresses, maximum data size, the native token of the chain, and more.

#### 2\. Config struct[​](#2-config-struct "Direct link to 2. Config struct")

```rust
struct Config {
    uint64 confirmPeriodBlocks;
    uint64 extraChallengeTimeBlocks;
    address stakeToken;
    uint256 baseStake;
    bytes32 wasmModuleRoot;
    address owner;
    address loserStakeEscrow;
    uint256 chainId;
    string chainConfig;
    uint64 genesisBlockNum;
    ISequencerInbox.MaxTimeVariation sequencerInboxMaxTimeVariation;
}
```

The `Config` struct defines the chain's core settings, including block confirmation periods, stake parameters, and the chain ID.

#### 3\. MaxTimeVariation struct[​](#3-maxtimevariation-struct "Direct link to 3. MaxTimeVariation struct")

```rust
struct MaxTimeVariation {
    uint256 delayBlocks;
    uint256 futureBlocks;
    uint256 delaySeconds;
    uint256 futureSeconds;
}
```

This nested struct within `Config` specifies time variations related to block sequencing, providing control over block delay and future block settings.

#### 4\. chainConfig[​](#4-chainconfig "Direct link to 4. chainConfig")

The `chainConfig` parameter within the `Config` struct allows you to customize your Orbit chain. It's a stringified `JSON` object containing various configuration options that dictate how the Orbit chain behaves and interacts with the parent chain network.

Here's a brief overview of `chainConfig`:

```rust
{
    chainId: number;
    homesteadBlock: number;
    daoForkBlock: null;
    daoForkSupport: boolean;
    eip150Block: number;
    eip150Hash: string;
    eip155Block: number;
    eip158Block: number;
    byzantiumBlock: number;
    constantinopleBlock: number;
    petersburgBlock: number;
    istanbulBlock: number;
    muirGlacierBlock: number;
    berlinBlock: number;
    londonBlock: number;
    clique: {
        period: number;
        epoch: number;
    };
    arbitrum: {
        EnableArbOS: boolean;
        AllowDebugPrecompiles: boolean;
        DataAvailabilityCommittee: boolean;
        InitialArbOSVersion: number;
        InitialChainOwner: Address;
        GenesisBlockNum: number;
        MaxCodeSize: number;
        MaxInitCodeSize: number;
    };
}
```

Out of `chainConfig`'s parameters, a few are particularly important and are likely to be configured by the chain owner: `chainId`, `arbitrum.InitialChainOwner`, `arbitrum.InitialArbOSVersion`, `arbitrum.DataAvailabilityCommittee`, `arbitrum.MaxCodeSize`, and `arbitrum.MaxInitCodeSize`.

#### 4.1. `prepareChainConfig`[​](#41-preparechainconfig "Direct link to 41-preparechainconfig")

For easier config preparation, the Orbit SDK provides the `prepareChainConfig` function, which takes config parameters as arguments and returns a full `chainConfig`. Any parameters not provided will default to standard values, which are detailed [here](https://github.com/OffchainLabs/arbitrum-orbit-sdk/blob/main/src/prepareChainConfig.ts).

Here are the parameters you can use with `prepareChainConfig`:

Parameter

Type

Required

Default Value

Description

`chainId`

Number

**Yes**

/

Your chain's unique identifier. It differentiates your chain from others in the ecosystem.

`arbitrum.InitialChainOwner`

Address

**Yes**

/

Specifies who owns and controls the chain.

`arbitrum.InitialArbOSVersion`

Number

No

latest

Specifies which version of ArbOS should the chain run.

`arbitrum.DataAvailabilityCommittee`

Boolean

No

false

When set to `false`, your chain will run as a Rollup chain, and when set to `true` it will run as an AnyTrust chain.

`arbitrum.MaxCodeSize`

Number

No

24,576 (bytes)

Sets the maximum size for contract bytecodes on the chain.

`arbitrum.MaxInitCodeSize`

Number

No

49,152 (bytes)

Similar to `arbitrum.MaxCodeSize`, defines the maximum size for your chain's **initialization** code.

Below is an example of how to use `prepareChainConfig` to set up a Rollup chain with a specific `chainId`, an `InitialChainOwner` (named as `deployer`):

```rust
import { prepareChainConfig } from '@arbitrum/orbit-sdk';

const chainConfig = prepareChainConfig({
  chainId: 123_456,
  arbitrum: {
    InitialChainOwner: deployer,
    DataAvailabilityCommittee: false,
  },
});
```

### Rollup configuration parameters[​](#rollup-configuration-parameters "Direct link to Rollup configuration parameters")

In this section, we'll provide detailed explanations of the various chain configuration parameters used in the deployment of Orbit chains.

Parameter

Description

`batchPosters`

Array of batch poster addresses. Batch posters batch and compress transactions on the Orbit chain and transmit them back to the parent chain.

`batchPosterManager`

Account address responsible for managing currently active batch posters. Not mandatory, as these actions can also be taken by the chain owner.

`validators`

Array of  addresses. Validators are responsible for validating the chain state and posting assertions (`RBlocks`) back to the parent chain. They also monitor the chain and initiate challenges against potentially faulty assertions submitted by other validators.

`nativeToken`

Determines the token used for paying gas fees on the Orbit chain. It can be set to `ETH` for regular chains or to any `ERC-20` token for **gas fee token network** Orbit chains.

`confirmPeriodBlocks`

Sets the challenge period in terms of blocks, which is the time allowed for validators to dispute or challenge state assertions. On Arbitrum One and Arbitrum Nova, this is currently set to approximately seven days in block count. `confirmPeriodBlocks` is measured in L1 blocks, we recommend a value of `45818`

`baseStake`

Orbit chain validator nodes must stake a certain amount to incentivize honest participation. The `basestake` parameter specifies this amount.

`stakeToken`

Token in which the `basestake` is required. It represents the token's address on the parent chain. Can be `ETH` or a `ERC-20`token. Note that the use of an `ERC-20` token as the `stakeToken` is currently not supported by Nitro, but will be soon.

`owner`

Account address responsible for deploying, owning, and managing your Orbit chain's base contracts on its parent chain.

`chainId`

Sets the unique chain ID of your Orbit chain.

note

`chainId` and owner parameters must be equal to the chain ID and `InitialOwner` defined in the `chainConfig` section.

While other configurable parameters exist, they are set to defaults, and it's generally not anticipated that a chain deployer would need to modify them. However, if you believe there's a need to alter any other parameters not listed here, please feel free to [contact us on our Discord server](https://discord.com/channels/585084330037084172/1116812793606328340/1205801459518804018) for further details and support.

### Configuration and deployment helpers[​](#configuration-and-deployment-helpers "Direct link to Configuration and deployment helpers")

The Orbit SDK provides two APIs, `createRollupPrepareDeploymentParamsConfig` and `createRollupPrepareTransactionRequest` to facilitate the configuration and deployment of Rollup parameters for an Orbit chain. These APIs simplify the process of setting up and deploying the core contracts necessary for an Orbit chain.

#### **createRollupPrepareDeploymentParamsConfig API**:[​](#createrolluppreparedeploymentparamsconfig-api "Direct link to createrolluppreparedeploymentparamsconfig-api")

This API is designed to take parameters defined in the Config struct and fill in the rest with default values. It outputs a complete Config struct that is ready for use.

For example, to create a Config struct with a specific chain ID (`chainId`), an owner address (`deployer_address`), and a `chainConfig` as described in the [previous section](#rollup-configuration-parameters), you would use the Orbit SDK as follows:

```rust
import { createPublicClient, http } from 'viem';
import { arbitrumSepolia } from 'viem/chains';
import { createRollupPrepareDeploymentParamsConfig } from '@arbitrum/orbit-sdk';

const parentPublicClient = createPublicClient({
  chain: arbitrumSepolia,
  transport: http(),
});

const config = createRollupPrepareDeploymentParamsConfig(parentPublicClient, {
  chainId: BigInt(chainId),
  owner: deployer.address,
  chainConfig,
});
```

#### createRollupPrepareTransactionRequest API:[​](#createrolluppreparetransactionrequest-api "Direct link to createRollupPrepareTransactionRequest API:")

This API accepts parameters defined in the `RollupDeploymentParams` struct, applying defaults where necessary, and generates the `RollupDeploymentParams`. This struct is then used to create a raw transaction which calls the `createRollup` function of the `RollupCreator` contract. As discussed in previous sections, this function deploys and initializes all core Orbit contracts.

For instance, to deploy using the Orbit SDK with a Config equal to `config`, a single batch poster in `[batchPoster]`, and a single validator in `[validator]`, the process would look like this:

```rust
import { createRollupPrepareTransactionRequest } from '@arbitrum/orbit-sdk';

const request = await createRollupPrepareTransactionRequest({
  params: {
    config,
    batchPosters: [batchPoster],
    validators: [validator],
  },
  account: deployer_address,
  publicClient,
});
```

After creating the raw transaction, you need to sign and broadcast it to the network.

### Getting the Orbit chain information after deployment[​](#getting-the-orbit-chain-information-after-deployment "Direct link to Getting the Orbit chain information after deployment")

Once you've successfully deployed your Orbit chain, the next step is to retrieve detailed information about the deployment, which you can do with the `createRollupPrepareTransactionReceipt` API.

After sending the signed transaction and receiving the transaction receipt, you can use the `createRollupPrepareTransactionReceipt` API to parse this receipt and extract the relevant data. This process will provide comprehensive details about the deployed chain, such as contract addresses, configuration settings, and other information.

Here's an example of how to use the Orbit SDK to get data from a deployed Orbit chain:

```rust
import { createRollupPrepareTransactionReceipt } from '@arbitrum/orbit-sdk';

const data = createRollupPrepareTransactionReceipt(txReceipt);
```

In this example, `txReceipt` refers to the transaction receipt you received after deploying the chain. You can access your Orbit chain's information by passing this receipt to the `createRollupPrepareTransactionReceipt` function. This feature of the Orbit SDK simplifies the post-deployment process, allowing you to quickly and efficiently gather all necessary details about your chain for further use or reference.

---

# Deploy a token bridge using the Orbit SDK | Arbitrum Docs

## Deploy a token bridge using the Orbit SDK

The  doesn't natively support specific token bridging standards at the protocol level. Instead, Offchain Labs designed a "canonical bridge" that ensures seamless token transfers between the parent and child chains.

The token bridge architecture includes contracts deployed on the  and on the . These entities communicate via the  protocol, ensuring efficient and secure interactions.

UNDER CONSTRUCTION

This document is under construction and may change significantly as we incorporate [style guidance](/for-devs/contribute#document-type-conventions) and feedback from readers. Feel free to request specific clarifications by clicking the `Request an update` button at the top of this document.

info

See the [`ERC-20` token bridge overview](/build-decentralized-apps/token-bridging/token-bridge-erc20) for more information about the token bridge's design and operational dynamics, and the ["create-token-bridge-eth" example](https://github.com/OffchainLabs/arbitrum-orbit-sdk/tree/main/examples/create-token-bridge-eth) for additional guidance.

### Prerequisites[​](#prerequisites "Direct link to Prerequisites")

*   A running **sequencer node**. See steps 1-2 in the [orbit-setup-script](https://github.com/OffchainLabs/orbit-setup-script) to start the related Docker containers (note that you don't need the `orbitSetupScriptConfig.json` file here). Use `docker-compose logs -f nitro` to verify that your node is running.

### Token Bridge Deployment Steps[​](#token-bridge-deployment-steps "Direct link to Token Bridge Deployment Steps")

Once an Orbit chain has been deployed and initialized, the bridge contracts need to be deployed on both the parent and child chains. This process involves several steps:

1.  **[Token approval](#1-token-approval)**
2.  **[Token bridge contract deployment](#2-token-bridge-contract-deployment)**
3.  **[Transaction recipient and checking for deployment on child chain](#3-transaction-recipient-and-checking-for-deployment-on-child-chain)**
4.  **[Deployment information and contract addresses](#4-deployment-information-and-contract-addresses)**
5.  **[Setting up the WETH gateway](#5-setting-up-the-weth-gateway)**

info

The token bridge deployment process is the same for all Orbit chains types except for the following:

*   **Custom fee token Orbit chains** which require [token approval](#1-token-approval).
*   **`ETH`\-based Orbit chains**, for which you need to [set up a WETH gateway](#5-setting-up-the-weth-gateway).

### 1\. Token approval[​](#1-token-approval "Direct link to 1. Token approval")

note

This step is only required for custom fee token Orbit chains.

Initiating the deployment of a token bridge for **[Custom Fee Token](/launch-orbit-chain/concepts/custom-gas-token-sdk)** on orbit chains begins with ensuring the `TokenBridgeCreator` contract is granted sufficient approvals of the native token. To facilitate this process, the Orbit SDK provides two APIs:

1.  **`createTokenBridgeEnoughCustomFeeTokenAllowance`**: This method verifies that the deployer's address has enough allowance to pay for the fees associated with the token bridge deployment.
2.  **`createTokenBridgePrepareCustomFeeTokenApprovalTransactionRequest`**: This function assists in generating the raw transaction required to approve the native token for the `TokenBridgeCreator` contract.

The following example demonstrates how to leverage these APIs effectively to check for and, if necessary, grant approval to the `TokenBridgeCreator` contract:

```rust
const allowanceParams = {
  nativeToken,
  owner: rollupOwner.address,
  publicClient: parentChainPublicClient,
};
if (!(await createTokenBridgeEnoughCustomFeeTokenAllowance(allowanceParams))) {
  const approvalTxRequest = await createTokenBridgePrepareCustomFeeTokenApprovalTransactionRequest(
    allowanceParams,
  );
}
```

In this scenario, `allowanceParams` includes:

*   The native token's details: `nativeToken`.
*   The Rollup owner's address: `rollupOwner.address`.
*   The parent chain's publicClient: `parentChainPublicClient`.

First, `createTokenBridgeEnoughCustomFeeTokenAllowance` checks if the deployer has been granted enough allowance.

If the allowance is insufficient, `createTokenBridgePrepareCustomFeeTokenApprovalTransactionRequest` is called to create the necessary approval transaction.

Please note that after generating the raw transaction, the deployer must still sign and broadcast it to the network to finalize the approval process.

### 2\. Token bridge contract deployment[​](#2-token-bridge-contract-deployment "Direct link to 2. Token bridge contract deployment")

Deploying token bridge contracts is the first step in creating a bridge between the parent and the Orbit chain.

The deployment process is the same as Orbit chain contracts', where a primary contract facilitates the deployment of core contracts. The token bridge contracts are deployed on the parent and child chains by `TokenBridgeCreator`. `TokenBridgeCreator` does it in a single transaction using the [Retryable Tickets protocol](/how-arbitrum-works/l1-to-l2-messaging#retryable-tickets) .

Orbit SDK provides an API that automates the deployment by interacting with the `TokenBridgeCreator` contract. The API is `createTokenBridgePrepareTransactionRequest`, which processes the necessary inputs and generates a transaction request tailored for token bridge deployment.

Example:

```rust
const txRequest = await createTokenBridgePrepareTransactionRequest({
  params: {
    rollup: rollupContractAddress,
    rollupOwner: rollupOwnerAddress,
  },
  parentChainPublicClient,
  orbitChainPublicClient,
  account: rollupOwnerAddress,
});
```

Here are the parameters used in the above example:

Parameter

Description

`rollupContractAddress`

Orbit chain's Rollup contract address.

`rollupOwnerAddress`

Rollup owner's address.

`parentChainPublicClient`

Parent chain's public client, as defined by Viem.

`orbitChainPublicClient`

Orbit chain's public client, as defined by Viem.

For more insights into these variables and their usage, consider exploring this [token bridge deployment example](https://github.com/OffchainLabs/arbitrum-orbit-sdk/blob/main/examples/create-token-bridge-eth/index.ts).

Following the creation of the raw transaction, the next steps involve signing it and broadcasting it to the relevant blockchain network to complete the deployment process.

### 3\. Transaction recipient and checking for deployment on child chain[​](#3-transaction-recipient-and-checking-for-deployment-on-child-chain "Direct link to 3. Transaction recipient and checking for deployment on child chain")

After sending the deployment transaction, you will need to retrieve the transaction receipt and verify the successful deployment of the contracts on both the parent and child chains.

Our Orbit SDK includes a dedicated API for this purpose, named `createTokenBridgePrepareTransactionReceipt`, which simplifies the process of obtaining the deployment transaction's recipient.

Example:

```rust
const txReceipt = createTokenBridgePrepareTransactionReceipt(
  await parentChainPublicClient.waitForTransactionReceipt({ hash: txHash }),
);
```

In this scenario, `txHash` represents the hash of the deployment transaction initiated in the previous step. The `waitForTransactionReceipt` API from Viem captures the transaction's recipient on the parent chain. The `createTokenBridgePrepareTransactionReceipt` API enhances the basic functionality provided by Viem's `waitForTransactionReceipt`, introducing a specialized method named `waitForRetryables` to handle the outcome (in this case, `txReceipt`).

By employing the `waitForRetryables` method, you can ensure the success of Retryable Tickets on the parent chain.

Example:

```rust
const orbitChainRetryableReceipts = await txReceipt.waitForRetryables({
  orbitPublicClient: orbitChainPublicClient,
});

if (orbitChainRetryableReceipts[0].status !== 'success') {
  throw new Error(
    `Retryable status is not success: ${orbitChainRetryableReceipts[0].status}. Aborting...`,
  );
}

console.log(`Retryable executed successfully`);
```

In this example, the `waitForRetryables` method is invoked on the `txReceipt` to monitor the execution of Retryable Tickets and verify their status. A `success` status indicates that the Retryable Tickets have been executed successfully, ensuring the contracts' deployment. It's important to note that this process involves two Retryable Tickets. You can check out a [more comprehensive walkthrough](https://github.com/OffchainLabs/arbitrum-orbit-sdk/blob/1e39d21eef57d204bfa609c4c29284528ddf05ac/examples/create-token-bridge-eth/index.ts#L78-L104) of the example. This enhanced approach not only simplifies the retrieval of transaction receipts but also provides a reliable method for verifying contract deployment across chains.

### 4\. Deployment information and contract addresses[​](#4-deployment-information-and-contract-addresses "Direct link to 4. Deployment information and contract addresses")

Once you have completed the deployment and are assured that the Retryable Tickets are successful, you can use `getTokenBridgeContracts` to retrieve the deployment information and all the token bridge contracts' addresses.

Here's an example of how to get the contract addresses from the `txReceipt` generated in the previous steps:

```rust
const tokenBridgeContracts = await txReceipt.getTokenBridgeContracts({
  parentChainPublicClient,
});
```

### 5\. Setting up the WETH gateway[​](#5-setting-up-the-weth-gateway "Direct link to 5. Setting up the WETH gateway")

The last step in spinning up the token bridge for an `ETH`\- based Orbit chain is setting up the `WETH` Gateway.

note

That step only applies to `ETH`\-based Orbit chains, not Custom fee token orbit chains. Our canonical bridge design has a separate custom gateway for `WETH` to bridge it in and out of the Orbit chain.

You can find more info about `WETH` gateways in our ["other gateways flavors" documentation](https://docs.arbitrum.io/for-devs/concepts/token-bridge/token-bridge-erc20#other-flavors-of-gateways).

So, after the token bridge has been deployed and you have secured a successful deployment on both parent and child chains, it's time to set the `WETH` gateway on both parent and child chains. To handle that, we have two APIs on our Orbit SDK:

#### 1\. `createTokenBridgePrepareSetWethGatewayTransactionRequest`:[​](#1-createtokenbridgepreparesetwethgatewaytransactionrequest "Direct link to 1-createtokenbridgepreparesetwethgatewaytransactionrequest")

This API helps you create the raw transaction which handles the `WETH` gateway on both parent and child chains.

Example:

```rust
const setWethGatewayTxRequest = await createTokenBridgePrepareSetWethGatewayTransactionRequest({
  rollup: rollupContractAddress,
  parentChainPublicClient,
  orbitChainPublicClient,
  account: rollupOwnerAddress,
  retryableGasOverrides: {
    gasLimit: {
      percentIncrease: 200n,
    },
  },
});
```

In this example, `rollupContractAddress` is the address of Orbit chain's Rollup contract, and `rollupOwnerAddress` is the address of the Rollup owner. **parentChainPublicClient** and **orbitChainPublicClient** are the public clients of the parent and orbit chains. This API also has optional fields to override the Retryable ticket setups. In this example, **percentIncrease** is the buffer to increase the gas limit, thus securing successful retryable tickets.

After creating the raw transaction, you need to use Viem to sign it and broadcast it to the network.

#### 2\. `createTokenBridgePrepareSetWethGatewayTransactionReceipt`[​](#2-createtokenbridgepreparesetwethgatewaytransactionreceipt "Direct link to 2-createtokenbridgepreparesetwethgatewaytransactionreceipt")

After sending the transaction, you need to assess if the Retryable Tickets you just created have been successful. To do that we are using `createTokenBridgePrepareSetWethGatewayTransactionReceipt` API and the`waitForRetryables` method of it to check for the success status of retryable tickets. For the example in this doc we can use this API as follow:

```rust
const setWethGatewayTxReceipt = createTokenBridgePrepareSetWethGatewayTransactionReceipt(
  await parentChainPublicClient.waitForTransactionReceipt({
    hash: setWethGatewayTxHash,
  }),
);
const orbitChainSetWethGatewayRetryableReceipt = await setWethGatewayTxReceipt.waitForRetryables({
  orbitPublicClient: orbitChainPublicClient,
});
if (orbitChainSetWethGatewayRetryableReceipt[0].status !== 'success') {
  throw new Error(
    `Retryable status is not success: ${orbitChainSetWethGatewayRetryableReceipt[0].status}. Aborting...`,
  );
}
console.log(`Retryables executed successfully`);
```

In this example **`setWethGatewayTxHash`** is the hash of the transaction you sent, setting the `WETH` gateway on your Orbit chain.

---

# Monitoring tools and considerations | Arbitrum Docs

## Monitoring tools and considerations

When deploying and maintaining an Orbit chain, there are several key elements that need to be monitored. This page lists tools that are available for chain maintainers, as well as other considerations to keep in mind when monitoring an Orbit chain.

Orbit verification script[​](#orbit-verification-script "Direct link to Orbit verification script")
---------------------------------------------------------------------------------------------------

The [Orbit verification script](https://github.com/OffchainLabs/arbitrum-orbit-sdk/tree/feat-add-verification-scripts/examples/verify-rollup) retrieves information from an Orbit chain and its parent chain to verify that all parameters are configured correctly. After gathering the data, it generates a comprehensive report and issues warnings for any discrepancies detected. This tool is particularly useful after deploying and configuring an Orbit chain, to make sure that the on-chain information has been correctly set.

The Orbit verification script is a Work-in-progress (WIP)

The Orbit Verification Script is currently under active development and is considered a work-in-progress (WIP). Consequently, its findings should be approached with caution, as there is a potential for false positives.

Orbit retryables tracker[​](#orbit-retryables-tracker "Direct link to Orbit retryables tracker")
------------------------------------------------------------------------------------------------

[Retryable tickets](/how-arbitrum-works/l1-to-l2-messaging) are messages sent from a parent chain and executed on the Orbit chain. Due to their asynchronous nature (they are executed several minutes after being created), if insufficient funds are provided at the time of creation, they might not automatically redeem (execute) upon arrival at the Orbit chain. When this occurs, a manual redemption of the ticket is required. The [Orbit retryables tracker](https://github.com/OffchainLabs/Orbit-retryable-tracker) is designed to assist in identifying and displaying the status of retryable tickets sent from a parent chain to the Orbit chain, and it reports any tickets that have not been automatically redeemed.

Data Availability Server (DAS) health checks[​](#data-availability-server-das-health-checks "Direct link to Data Availability Server (DAS) health checks")
----------------------------------------------------------------------------------------------------------------------------------------------------------

If you've deployed an AnyTrust chain with a Data Availability Committee, it is recommended to actively monitor the endpoints of the different configured DA servers. The [How to deploy a DAS](/run-arbitrum-node/data-availability-committees/deploy-das#testing-the-das) guide contains a section for testing both the RPC and REST endpoints of any given DAS, by using the `datool` available in .

Further monitoring considerations[​](#further-monitoring-considerations "Direct link to Further monitoring considerations")
---------------------------------------------------------------------------------------------------------------------------

Following is a non-comprehensive list of other elements of the network that should be monitored.

*   **Sequencer's transaction backlog size**: This can be considered as a sign of the network health. In some edge cases, a large and growing backlog might cause the sequencer to experience issues when posting batches on the parent chain.
    
*   **Batches posted in the SequencerInbox contract on the parent chain**: The sequencer regularly posts batches on the parent chain, as long as it receives transactions on the Orbit chain. If batches are not being posted in the SequencerInbox for any reason, further analysis should be conducted to understand why.
    
*   **RBlocks (nodes) created in the Rollup contract on the parent chain**: RBlocks are created by validators and contain assertions of the current state of the chain (viewed by the validators). If RBlocks are not being created or confirmed on the parent chain, further analysis should be conducted to understand why.
    
*   **High periods of inactivity**: As an extension of the previous point, if no RBlocks (nodes) are created for a certain period of time (due to having no activity in the chain, or any other reason), the validator whitelist mechanism of the Rollup contract can be [permissionlessly disabled](https://github.com/OffchainLabs/nitro-contracts/blob/main/src/rollup/RollupUserLogic.sol#L62). That period of time is determined by `confirmPeriodBlocks` + the constant `45818` since the last RBlock (node) created. In this case, time is measured in L1 blocks (around 7 days + the `confirmPeriodBlocks` period) for Orbit chains settling to Ethereum or an Arbitrum chain, or measured in the parent chain's block time when settling to other chains.
    
*   **Batch poster balance**: The batch poster account needs to be well funded to be able to post batches. There's no automatic mechanism to keep it funded, so its balance should be monitored and actions should be taken whenever it passes a certain threshold. The recommendation is to keep the account overfunded.
    
*   **Validators' balance**: Validators are in charge of posting and confirming assertions of the state of the Orbit chain on the parent chain. Their balance should be monitored to make sure they are able to perform those actions.

---

# How to add your Orbit chain to Arbitrum's bridge | Arbitrum Docs

## How to add your Orbit chain to Arbitrum's bridge

This how-to will walk you through the process of adding your Orbit chain to the [Arbitrum bridge](https://bridge.arbitrum.io/). There's one section for mainnet Orbit chains, and another for local testnet Orbit chains. You can access either section using the links on the right column.

Request adding a mainnet Orbit chain to the Arbitrum bridge[​](#request-adding-a-mainnet-orbit-chain-to-the-arbitrum-bridge "Direct link to Request adding a mainnet Orbit chain to the Arbitrum bridge")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Mainnet Orbit chains can be added to the Arbitrum Bridge by filling out [this form](https://github.com/OffchainLabs/arbitrum-token-bridge/issues/new/choose).

Once receiving your request, our team will review and apply internal criteria to include your chain in the bridge. Here are some of the criteria that a chain must follow to be added to the bridge:

*   The use case must fall within existing legal and marketing guidelines
*   The core rollup / token bridge contracts must not have been modified, except the cases where modifications have been done with a certified partnership and communicated to Offchain Labs
*   The infrastructure and core contracts are hosted by one of our partnered RaaS teams

Add a local testnet Orbit chain to the Arbitrum bridge[​](#add-a-local-testnet-orbit-chain-to-the-arbitrum-bridge "Direct link to Add a local testnet Orbit chain to the Arbitrum bridge")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Currently, adding a testnet Orbit chain to the Arbitrum bridge must be done locally. This means that you will configure the UI to display the desired chain, but this change will only apply to you.

### Prerequisites[​](#prerequisites "Direct link to Prerequisites")

*   A local testnet Orbit chain's configuration. See the [Orbit quickstart](/launch-orbit-chain/orbit-quickstart) to deploy a local Orbit chain, or use an existing JSON configuration.
*   A browser-based Ethereum wallet (i.e., [MetaMask](https://metamask.io/) or [OKX Wallet](https://www.okx.com/web3))

### Procedure[​](#procedure "Direct link to Procedure")

1.  Navigate to [https://bridge.arbitrum.io/](https://bridge.arbitrum.io/).
2.  Connect to the bridge UI using your wallet. The bridge UI will automatically switch to the correct testnet view.
3.  Activate "Testnet mode", by clicking on your address in the top right corner -> Settings -> Turn on testnet mode.
4.  In the same screen, scroll down to "Add Testnet Orbit Chain":
    
    ![Orbit bridge](/img/orbit-bridge-testnet-mode.png)
    
5.  Copy and paste the JSON configuration (for Orbit chains deployed locally, use the configuration in your generated `outputInfo.json` file).
6.  Click "Add Chain".

Congratulations! Your chain should now appear in both the network dropdown in the top navigation pane, and as an option in the bridging UI directly.

---

# Get listed on Orbit platforms | Arbitrum Docs

## Get listed on Orbit platforms

---

# Orbit Portal | Arbitrum Docs

## Orbit Portal

---

# Orbit FAQ | Arbitrum Docs

## Orbit FAQ

### Can I use Orbit to deploy a mainnet chain?[​](#can-i-use-orbit-to-deploy-a-mainnet-chain "Direct link to Can I use Orbit to deploy a mainnet chain?")

Yes! Arbitrum Orbit's core technology has undergone a comprehensive audit and is now able to support deployments to mainnet. You can read more about it [here](https://docs.arbitrum.io/launch-orbit-chain/concepts/public-preview-expectations#arbitrum-orbit-is-mainnet-ready-but-deploy-to-testnet-first).

### How can I deploy an Orbit-based Layer 3 (L3) chain?[​](#how-can-i-deploy-an-orbit-based-layer-3-l3-chain "Direct link to How can I deploy an Orbit-based Layer 3 (L3) chain?")

Check our [Quickstart](https://docs.arbitrum.io/launch-orbit-chain/orbit-quickstart) to learn how to launch your own Orbit chain today.

### Do I need permission/license to launch an Orbit chain?[​](#do-i-need-permissionlicense-to-launch-an-orbit-chain "Direct link to Do I need permission/license to launch an Orbit chain?")

You can launch any Orbit chain permissionlessly.

Nitro is licensed under a [Business Source license](https://github.com/OffchainLabs/nitro?tab=License-1-ov-file), similar to DeFi protocols like Uniswap and Aave, among others. This license contains an Additional Use Grant that permits the permissionless deployment of Nitro software on blockchains that settle to Arbitrum One or Nova.

However, Orbit chains that settle to a parent chain other than Arbitrum One or Nova are subject to additional licensing guidelines under the [AEP](https://docs.arbitrum.foundation/aep/ArbitrumExpansionProgramTerms.pdf).

### Does Arbitrum officially deploy and/or maintain L3s for external teams?[​](#does-arbitrum-officially-deploy-andor-maintain-l3s-for-external-teams "Direct link to Does Arbitrum officially deploy and/or maintain L3s for external teams?")

No. Teams are required to deploy and maintain their Orbit chains. There are, however, several RaaS (Rollup as a Service) providers that can deploy and maintain the Orbit chain for you.

### Can I modify Orbit's underlying technology to customize my chain?[​](#can-i-modify-orbits-underlying-technology-to-customize-my-chain "Direct link to Can I modify Orbit's underlying technology to customize my chain?")

Yes, you can make any changes you require to the underlying Nitro code base.

### What Data Availability (DA) solutions are currently available for Orbit chains?[​](#what-data-availability-da-solutions-are-currently-available-for-orbit-chains "Direct link to What Data Availability (DA) solutions are currently available for Orbit chains?")

Arbitrum Orbit currently supports 3 different DA solutions:

*   Rollup, posting data to the parent chain which ultimately posts the data to Ethereum.
*   AnyTrust, posting data to a Data Availability Committee, selected by the chain owner.
*   Celestia, posting data to [Celestia network](https://blog.celestia.org/celestia-is-first-modular-data-availability-network-to-integrate-with-arbitrum-orbit/).

Note that using AnyTrust gives the chain owner the most flexibility and cheapest fees.

### What token is used to pay gas fees on Orbit chains?[​](#what-token-is-used-to-pay-gas-fees-on-orbit-chains "Direct link to What token is used to pay gas fees on Orbit chains?")

By default, Orbit chains pay gas in ETH. However, Orbit chains using AnyTrust can be configured to use any ERC-20 token as the gas fee token of the chain.

### Can I use Ethereum toolkits to develop on my Orbit chain?[​](#can-i-use-ethereum-toolkits-to-develop-on-my-orbit-chain "Direct link to Can I use Ethereum toolkits to develop on my Orbit chain?")

Orbit chains are fully EVM-compatible. Most tools that support Ethereum should be able to support an Orbit chain. There are, however, certain differences that developers need to keep in mind when building on an Orbit chain. You can find them [here](https://docs.arbitrum.io/for-devs/concepts/differences-between-arbitrum-ethereum/overview).

### Do Orbit chains have any built-in AA solution?[​](#do-orbit-chains-have-any-built-in-aa-solution "Direct link to Do Orbit chains have any built-in AA solution?")

Not by default, but they can be customized to have native AA.

### Is there any cross-chain bridging solution between two Orbit chains?[​](#is-there-any-cross-chain-bridging-solution-between-two-orbit-chains "Direct link to Is there any cross-chain bridging solution between two Orbit chains?")

There is currently no Orbit-to-Orbit native bridging solution, other than going through the parent chain (if they share the same parent chain). However, there are many third-party bridges that have expressed interest in supporting Orbit chains.

### Is there an official block explorer for Orbit chains?[​](#is-there-an-official-block-explorer-for-orbit-chains "Direct link to Is there an official block explorer for Orbit chains?")

Orbit chains deployments usually come with an open-source blockscout explorer by default, but there are many third-party solutions that have expressed interest in supporting Orbit chains.

### Is there any indexing solution that supports Orbit chains?[​](#is-there-any-indexing-solution-that-supports-orbit-chains "Direct link to Is there any indexing solution that supports Orbit chains?")

Similar to bridges and block explorers, there are many third-party indexing solutions that have expressed interest in supporting Orbit chains.

### Can I increase the maximum contract size for my Orbit chain?[​](#can-i-increase-the-maximum-contract-size-for-my-orbit-chain "Direct link to Can I increase the maximum contract size for my Orbit chain?")

Yes, Orbit supports an increased smart contract size limit of up to 96kB. You can use our [Orbit SDK](https://github.com/OffchainLabs/arbitrum-orbit-sdk) and configure the parameters [MaxCodeSize and MaxInitCodeSize](https://github.com/OffchainLabs/arbitrum-orbit-sdk/blob/main/src/prepareChainConfig.ts#L29) when calling [prepareNodeConfig](https://github.com/OffchainLabs/arbitrum-orbit-sdk/blob/main/examples/prepare-node-config/index.ts#L43). Note that the smart contract size limit parameters can't be changed via upgrade after deployment.

### How can I modify Nitro to force posting an invalid assertion and test the fraud proof mechanism?[​](#how-can-i-modify-nitro-to-force-posting-an-invalid-assertion-and-test-the-fraud-proof-mechanism "Direct link to How can I modify Nitro to force posting an invalid assertion and test the fraud proof mechanism?")

Forcing an invalid assertion in the chain is not supported at the moment. However, if you're building Nitro locally, you can run the following test that goes through the whole rollup/challenge mechanism:

```rust
go test ./system_tests/ -tags=challengetest -run=TestChallenge

```

### What fee collectors can be configured on my chain?[​](#what-fee-collectors-can-be-configured-on-my-chain "Direct link to What fee collectors can be configured on my chain?")

There are 4 fee types that can be configured on an Orbit chain:

*   L2 base fee: L2 execution fees corresponding to the minimum base price of the chain. This is paid to the infraFeeAccount, which can be set by calling `ArbOwner.setInfraFeeAccount()`.
*   L2 surplus fee: L2 execution fees above the minimum base price (in the case of congestion). This is paid to the networkFeeAccount, which can be set by calling `ArbOwner.setNetworkFeeAccount()`.
*   L1 base fee: Relative fees for posting a transaction on the parent chain. This is paid ultimately to the fee collector of the active batch poster. The batch poster can be set by calling `SequencerInbox.setIsBatchPoster()` on the parent chain. And a different fee collector for that batch poster can be specified by calling `ArbAggregator.setFeeCollector()`.
*   L1 surplus fee: Any extra fees rewarded to the batch poster. This is paid to a specific L1RewardRecipient, which can be set by calling `ArbOwner.setL1PricingRewardRecipient()`

More detailed information about fees can be found in the [L1 fees](https://docs.arbitrum.io/arbos/l1-pricing) and [L2 fees](https://docs.arbitrum.io/arbos/gas) pages.

Information about the precompiles methods can be found in the [Precompiles reference page](https://docs.arbitrum.io/build-decentralized-apps/precompiles/reference).

---

# How to customize your Orbit chain's deployment configuration | Arbitrum Docs

## How to customize your Orbit chain's deployment configuration

When you visit the [Orbit chain deployment portal](https://orbit.arbitrum.io/) to launch your Orbit chain, you'll be prompted to complete a form that looks like this:

Chain ID

Chain name

Challenge period (blocks)

Stake token

Base stake

Owner

This form will be prefilled with default values that usually don't need to be changed. However, there are some cases where you may want to customize the configuration values. This how-to explains how and when to modify these default values.

Let's briefly review each of the deployment configuration parameters, the rationale underlying the default values, and the tradeoffs that you should consider when modifying them.

### Chain ID[​](#chain-id "Direct link to Chain ID")

Don't worry about this; it's inconsequential for devnets. In production scenarios, you'll want to use a unique integer identifier that represents your chain's network on chain indexes like [Chainlist.org](http://chainlist.org).

### Chain name[​](#chain-name "Direct link to Chain name")

This name provides a way for people to distinguish your Orbit chain from other Orbit chains. You’ll want to make this a name that you can easily remember, and that your users and developers will recognize.

### Challenge period (blocks)[​](#challenge-period-blocks "Direct link to Challenge period (blocks)")

The `Challenge period (blocks)` parameter determines the amount of time your chain's validators have to dispute - or "challenge" - the current state of the chain posted to your Orbit chain's base chain on L2.

A longer challenge period means that your chain's nodes will have more time to dispute fraudulent states, but it also means that your chain's users will have to wait longer to withdraw their assets from your chain. This is one of the many tradeoffs that Orbit allows you to make when configuring your chain.

Note that the challenge period is measured in blocks on the underlying L1 chain, not the base (L2) chain. For example, if your Orbit chain settles to Arbitrum Sepolia, the challenge period window would be the number of `Challenge period (blocks)` multiplied by the L1 Sepolia block time (~12 seconds).

### Gas token[​](#gas-token "Direct link to Gas token")

The `Gas Token` parameter specifies the token (ETH or an ERC-20 token) that is natively used for gas payments on the network. On Ethereum, Arbitrum One, and Arbitrum Nova the gas token is ETH. Orbit chains that are configured as AnyTrust chains can specify a different gas token as long as it falls within certain requirements.

The main requirement for custom gas tokens is that they are natively deployed on the parent chain. For example, if a team deploying an Orbit chain wants to use a specific ERC-20 as the gas token, that token must be deployed on the parent chain first (i.e. Arbitrum One or Nova). During chain deployment, that token is "natively bridged" and then properly configured as the native gas token on the new network.

There are other important considerations to keep in mind when deciding to use a custom gas token. Restrictions on the ERC-20 token include:

*   In this version, only tokens with **18** decimals are permitted to be the native token.
*   The token can't be rebasing or have a transfer fee.
*   The token must only be transferrable via a call to the token address itself.
*   The token must only be able to set allowance via a call to the token address itself.
*   The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert.

It is worth reiterating that currently this feature is only supported on **Orbit AnyTrust chains**. Additionally, using a gas token other than ETH adds additional overhead when it comes to ensuring chains are funded properly when posting data to their parent chain.

### Stake token[​](#stake-token "Direct link to Stake token")

Your Orbit chain will be supported by at least one validator node. In order for your chain's validators to post assertions of the state of the chain on the base chain (L2), they're required to stake some value as a way to incentivize honest participation.

This `Stake token` parameter specifies the token that your chain's validators must deposit into this contract when they stake. This is specified using the token's contract address on the L2 chain that your chain is settling to, or `0x0000000000000000000000000000000000000000` if you want to use ETH as the stake token.

### Base stake[​](#base-stake "Direct link to Base stake")

The `Base stake` parameter specifies the amount of the stake token (ETH or an ERC-20 token) that your chain's validators must deposit in order to post assertions of the state of your Orbit chain on the base chain's rollup contracts. This is specified using a float value.

If your `Base stake` is low, the barrier to participation will be low, but your chain will be more vulnerable to certain types of attacks.

For example, an Orbit chain with a base stake of 0.01 ETH could be halted by an adversary who can afford to deploy sacrificial validators that maliciously challenge every assertion submitted to your Orbit chain's base chain.

The malicious challenges would result in slashed Orbit chain validators (one slashed validator per malicious challenge), but from the adversary's perspective, periodic slashing is just the price they have to pay to keep your chain offline.

A higher base stake incentivize honest participation by making it more expensive to launch these types of attacks. However, a higher base stake also translates to a higher barrier to entry for your chain's validators. This is another tradeoff to consider.

### Owner[​](#owner "Direct link to Owner")

This account address is responsible for deploying, owning, and updating your Orbit chain's base contracts on its base chain.

In production scenarios, this is a high-stakes address that's often controlled by a DAO's governance protocol or multisig. For your Orbit devnet chain, think of this as a low-stakes administrative service account.

Note that **you'll have to fund this address** with enough ETH to cover the gas costs of deploying your core contracts to L2.

When deploying your Orbit chain, this address must be a standard Ethereum wallet address (precisely speaking, an EOA); it can't be a smart contract/wallet contract.

Additional configuration parameters[​](#additional-configuration-parameters "Direct link to Additional configuration parameters")
---------------------------------------------------------------------------------------------------------------------------------

There are a number of [additional parameters](/launch-orbit-chain/reference/orbit-configuration-parameters) that are not presented in the deployment UI, but are still configurable for more advanced chain deployers.

---

# Guidance on how to configure your Orbit chain | Arbitrum Docs

## Guidance on how to configure your Orbit chain

---

# How to manage the fee parameters of your Orbit chain | Arbitrum Docs

## How to manage the fee parameters of your Orbit chain

Different fees get collected for every transaction as part of an Orbit chain activity. These fees are collected as a single amount (the transaction fees) but split internally into different components depending on their purpose. Each component is transferrable to a different fee collector address that is configurable on your chain.

This guide describes the different collected fees and explains how to specify the fee collector address on your chain for each fee type. This guide describes the different fees collected on your chain, how to configure them, and how to specify the fee collector address for each type.

What fees are collected on an Orbit chain?[​](#what-fees-are-collected-on-an-orbit-chain "Direct link to What fees are collected on an Orbit chain?")
-----------------------------------------------------------------------------------------------------------------------------------------------------

There are four fee types that are collected on every transaction of an Orbit chain:

*   **Orbit base fee**: fees paid for executing the transaction on the chain based on the minimum base price configured.
    
*   **Orbit surplus fee**: if the chain is congested (i.e., the base price paid for the transaction is higher than the minimum base price), these fees account for executing the transaction on the chain based on any gas price paid above the minimum base price configured.
    
*   **Parent chain base fee**: relative fees paid for posting the transaction on the parent chain. This amount is calculated based on the transaction's estimated size and the current view of the parent chain's base fee.
    
*   **Parent chain surplus fee**: if configured, these are extra fees rewarded to the batch poster.
    

You can find more detailed information about these fee types in these pages:

*   [L2 fees](/how-arbitrum-works/gas-fees#child-chain-gas-pricing) for the Orbit base fee and surplus fee
*   [L1 fees](/how-arbitrum-works/gas-fees#parent-chain-gas-pricing) for the Parent chain base fee and surplus fee

How to configure the fees collected?[​](#how-to-configure-the-fees-collected "Direct link to How to configure the fees collected?")
-----------------------------------------------------------------------------------------------------------------------------------

Let's see in what ways we can configure each fee type:

### Orbit (minimum) base fee[​](#orbit-minimum-base-fee "Direct link to Orbit (minimum) base fee")

Your chain is configured with a minimum base fee for execution. This value can be obtained by calling the method `getMinimumGasPrice()(uint256)` of the [ArbGasInfo](/build-decentralized-apps/precompiles/reference#arbgasinfo) precompile.

```rust
cast call --rpc-url $ORBIT_CHAIN_RPC 0x000000000000000000000000000000000000006C "getMinimumGasPrice() (uint256)"
```

Alternatively, you can use the Orbit SDK to retrieve the minimum Orbit base fee configured:

```rust
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbGasInfoPublicActions);

const orbitMinimumBaseFee = await orbitChainClient.arbGasInfoReadContract({
    functionName: 'getMinimumGasPrice',
});
```

::: note This minimum base fee defines the minimum value that the chain's base fee can have. However, in periods of congestion, the actual base fee might be higher than this minimum. Check the next section "Orbit surplus fee" for more information. :::

To set a new minimum base fee, use the method `setMinimumL2BaseFee(uint256)` of the [ArbOwner](/build-decentralized-apps/precompiles/reference#arbowner) precompile, and pass the new minimum base fee in wei. For example:

```rust
cast send --rpc-url $ORBIT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY 0x0000000000000000000000000000000000000070 "setMinimumL2BaseFee(uint256) ()" $NEW_MINIMUM_BASE_FEE_IN_WEI
```

Or using the Orbit SDK:

```rust
const owner = privateKeyToAccount(<OwnerPrivateKey>);
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbOwnerPublicActions);

const transactionRequest = await orbitChainClient.arbOwnerPrepareTransactionRequest({
    functionName: 'setMinimumL2BaseFee',
    args: [<NewMinimumBaseFeeInWei>],
    upgradeExecutor: false,
    account: owner.address,
});

await orbitChainClient.sendRawTransaction({
    serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

### Orbit surplus fee[​](#orbit-surplus-fee "Direct link to Orbit surplus fee")

In periods of congestion, the actual base fee of your Orbit chain might be higher than the configured minimum. You can see the current base fee of your chain by calling the method `getPricesInWei()(uint256,uint256,uint256,uint256,uint256,uint256)` of the [ArbGasInfo](/build-decentralized-apps/precompiles/reference#arbgasinfo) precompile, and check the last result of the returned tuple.

```rust
cast call --rpc-url $ORBIT_CHAIN_RPC 0x000000000000000000000000000000000000006C "getPricesInWei() (uint256,uint256,uint256,uint256,uint256,uint256)"
```

You can then calculate the current Orbit surplus fees as `currentBaseFee - minimumBaseFee`.

_Note: `getPricesInWei()` also returns the correspondent fees due to congestion in the second-to-last result of the returned tuple._

Orbit surplus fees are automatically adjusted

Orbit chains automatically adjust the Orbit surplus fee based on the traffic of the chain. If the gas consumed goes over the speed limit, the chain's base fee will start increasing. Likewise, the base fee will gradually go down if demand of gas returns to below the configured speed limit, until it reaches the minimum base fee configured.

### Parent chain base fee[​](#parent-chain-base-fee "Direct link to Parent chain base fee")

To obtain the current parent chain base fee of your chain, you can call the method `getL1BaseFeeEstimate()(uint256)` of the [ArbGasInfo](/build-decentralized-apps/precompiles/reference#arbgasinfo) precompile.

```rust
cast call --rpc-url $ORBIT_CHAIN_RPC 0x000000000000000000000000000000000000006C "getL1BaseFeeEstimate() (uint256)"
```

Alternatively, you can use the Orbit SDK to retrieve the current parent chain base fee:

```rust
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbGasInfoPublicActions);

const parentChainBaseFee = await orbitChainClient.arbGasInfoReadContract({
    functionName: 'getL1BaseFeeEstimate',
});
```

You can modify the current estimate of the parent chain base fee by calling the method `setL1PricePerUnit(uint256)` of the [ArbOwner](/build-decentralized-apps/precompiles/reference#arbowner) precompile. For example:

```rust
cast send --rpc-url $ORBIT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY 0x0000000000000000000000000000000000000070 "setL1PricePerUnit(uint256) ()" $NEW_PARENT_CHAIN_BASE_FEE
```

Or using the Orbit SDK:

```rust
const owner = privateKeyToAccount(<OwnerPrivateKey>);
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbOwnerPublicActions);

const transactionRequest = await orbitChainClient.arbOwnerPrepareTransactionRequest({
    functionName: 'setL1PricePerUnit',
    args: [<NewParentChainBaseFee>],
    upgradeExecutor: false,
    account: owner.address,
});

await orbitChainClient.sendRawTransaction({
    serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

Parent chain base fees are automatically adjusted

Orbit chains are configured to automatically adjust the current parent chain base fee estimation based on the batch poster reports sent from the parent chain. That means that even though you can set a new parent chain base fee, the chain will automatically adjust it based on the reports received afterwards.

Parent chain base fee configuration for chains using a custom gas token

Orbit chains that use a custom gas token should have their parent chain base fees disabled (set to 0), to avoid charging users for a non-existent parent chain's base fee, as explained in [How to use a custom gas token](/launch-orbit-chain/configure-your-chain/common-configurations/use-a-custom-gas-token#configuration-of-the-orbit-chain-when-using-a-custom-gas-token).

### Parent chain surplus fee[​](#parent-chain-surplus-fee "Direct link to Parent chain surplus fee")

The parent chain surplus fee collected is based on a reward rate configured in the chain. To obtain this parameter, you can call the method `getL1RewardRate()(uint64)` of the [ArbGasInfo](/build-decentralized-apps/precompiles/reference#arbgasinfo) precompile. This function will return the amount of wei per gas unit paid to the appropriate fee collector. For example:

```rust
cast call --rpc-url $ORBIT_CHAIN_RPC 0x000000000000000000000000000000000000006C "getL1RewardRate() (uint64)"
```

Alternatively, you can obtain this information using the Orbit SDK:

```rust
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbGasInfoPublicActions);

const parentChainRewardRate = await orbitChainClient.arbGasInfoReadContract({
    functionName: 'getL1RewardRate',
});
```

To change the reward rate, you can use the method `setL1PricingRewardRate(uint64)` of the [ArbOwner](/build-decentralized-apps/precompiles/reference#arbowner) precompile and pass the amount of wei per gas unit to reward. For example:

```rust
cast send --rpc-url $ORBIT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY 0x0000000000000000000000000000000000000070 "setL1PricingRewardRate(uint64) ()" $NEW_REWARD_RATE
```

Or using the Orbit SDK:

```rust
const owner = privateKeyToAccount(<OwnerPrivateKey>);
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbOwnerPublicActions);

const transactionRequest = await orbitChainClient.arbOwnerPrepareTransactionRequest({
    functionName: 'setL1PricingRewardRate',
    args: [<NewRewardRate>],
    upgradeExecutor: false,
    account: owner.address,
});

await orbitChainClient.sendRawTransaction({
    serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

How to configure the fee collector addresses?[​](#how-to-configure-the-fee-collector-addresses "Direct link to How to configure the fee collector addresses?")
--------------------------------------------------------------------------------------------------------------------------------------------------------------

Let's now look at how to configure the collector addresses for each fee type.

### Orbit base fee[​](#orbit-base-fee "Direct link to Orbit base fee")

Orbit base fees are paid to the `infraFeeAccount` configured in your chain. You can retrieve the current configured address by calling the method `getInfraFeeAccount()(address)` of the [ArbOwnerPublic](/build-decentralized-apps/precompiles/reference#arbownerpublic) precompile. For example:

```rust
cast call --rpc-url $ORBIT_CHAIN_RPC 0x000000000000000000000000000000000000006B "getInfraFeeAccount() (address)"
```

_Note: The [ArbOwner](/build-decentralized-apps/precompiles/reference#arbowner) precompile also has a `getInfraFeeAccount()(address)` method that can be used, but only by the owner of the chain._

Alternatively, you can use the Orbit SDK to retrieve the current address configured as `infraFeeAccount`:

```rust
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbOwnerPublicActions);

const infraFeeAccount = await orbitChainClient.arbOwnerReadContract({
    functionName: 'getInfraFeeAccount',
});
```

To set a new `infraFeeAccount`, use the method `setInfraFeeAccount(address)` of the [ArbOwner](/build-decentralized-apps/precompiles/reference#arbowner) precompile. For example:

```rust
cast send --rpc-url $ORBIT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY 0x0000000000000000000000000000000000000070 "setInfraFeeAccount(address) ()" $NEW_INFRAFEEACCOUNT_ADDRESS
```

Or using the Orbit SDK:

```rust
const owner = privateKeyToAccount(<OwnerPrivateKey>);
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbOwnerPublicActions);

const transactionRequest = await orbitChainClient.arbOwnerPrepareTransactionRequest({
    functionName: 'setInfraFeeAccount',
    args: [<NewInfraFeeAccountAddress>],
    upgradeExecutor: false,
    account: owner.address,
});

await orbitChainClient.sendRawTransaction({
    serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

### Orbit surplus fee[​](#orbit-surplus-fee-1 "Direct link to Orbit surplus fee")

Orbit surplus fees are paid to the `networkFeeAccount` configured in your chain. You can retrieve the current configured address by calling the method `getNetworkFeeAccount()(address)` of the [ArbOwnerPublic](/build-decentralized-apps/precompiles/reference#arbownerpublic) precompile. For example:

```rust
cast call --rpc-url $ORBIT_CHAIN_RPC 0x000000000000000000000000000000000000006B "getNetworkFeeAccount() (address)"
```

_Note: The [ArbOwner](/build-decentralized-apps/precompiles/reference#arbowner) precompile also has a `getNetworkFeeAccount()(address)` method that can be used, but only by the owner of the chain._

Alternatively, you can use the Orbit SDK to retrieve the current address configured as `networkFeeAccount`:

```rust
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbOwnerPublicActions);

const networkFeeAccount = await orbitChainClient.arbOwnerReadContract({
    functionName: 'getNetworkFeeAccount',
});
```

To set a new `networkFeeAccount`, use the method `setNetworkFeeAccount(address)` of the [ArbOwner](/build-decentralized-apps/precompiles/reference#arbowner) precompile. For example:

```rust
cast send --rpc-url $ORBIT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY 0x0000000000000000000000000000000000000070 "setNetworkFeeAccount(address) ()" $NEW_NETWORKFEEACCOUNT_ADDRESS
```

Or using the Orbit SDK:

```rust
const owner = privateKeyToAccount(<OwnerPrivateKey>);
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbOwnerPublicActions);

const transactionRequest = await orbitChainClient.arbOwnerPrepareTransactionRequest({
    functionName: 'setNetworkFeeAccount',
    args: [<NewNetworkFeeAccountAddress>],
    upgradeExecutor: false,
    account: owner.address,
});

await orbitChainClient.sendRawTransaction({
    serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

### Parent chain base fee[​](#parent-chain-base-fee-1 "Direct link to Parent chain base fee")

Parent chain base fees are paid to the fee collector of the active batch poster configured in your chain. The current configured batch posters can be obtained by calling the method `getBatchPosters()(address[])` of the [ArbAggregator](/build-decentralized-apps/precompiles/reference#arbaggregator) precompile. For example:

```rust
cast call --rpc-url $ORBIT_CHAIN_RPC 0x000000000000000000000000000000000000006D "getBatchPosters() (address[])"
```

This list has to also be verified against the `SequencerInbox` contract living on the parent chain. This contract needs to have any of those addresses in its `isBatchPoster` mapping. To verify a specific address, you can check the mapping directly like this:

```rust
cast call --rpc-url $PARENT_CHAIN_RPC $SEQUENCER_INBOX_ADDRESS "isBatchPoster(address) (bool)" $BATCH_POSTER_ADDRESS
```

Alternatively, you can use the Orbit SDK to retrieve the current configured batch posters. This method will not use the ArbAggregator precompile, but instead will rely on events emitted when configuring a new batch poster in the SequencerInbox contract.

```rust
const parentChainClient = createPublicClient({
    chain: <ParentChainDefinition>,
    transport: http(),
});

const batchPosters = await getBatchPosters(parentChainClient, {
    rollup: rollupAddress,
    sequencerInbox: sequencerInboxAddress,
});
```

Once you have the current batch poster, you can obtain the fee collector address configured for that batch poster by calling the method `getFeeCollector(address)(address)` of the [ArbAggregator](/build-decentralized-apps/precompiles/reference#arbaggregator) precompile and passing the address of the batch poster.

```rust
cast call --rpc-url $ORBIT_CHAIN_RPC 0x000000000000000000000000000000000000006D "getFeeCollector(address) (address)" $BATCH_POSTER_ADDRESS
```

You can also use the Orbit SDK to retrieve the current fee collector configured for a specific batch poster:

```rust
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbAggregatorActions);

const networkFeeAccount = await orbitChainClient.arbAggregatorReadContract({
    functionName: 'getFeeCollector',
    args: [<BatchPosterAddress>],
});
```

To set a new fee collector for a specific batch poster, use the method `setFeeCollector(address, address)` of the [ArbAggregator](/build-decentralized-apps/precompiles/reference#arbaggregator) precompile and pass the address of the batch poster and the address of the new fee collector.

```rust
cast send --rpc-url $ORBIT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY 0x000000000000000000000000000000000000006D "setFeeCollector(address,address) ()" $BATCH_POSTER_ADDRESS $NEW_FEECOLLECTOR_ADDRESS
```

Or using the Orbit SDK:

```rust
const owner = privateKeyToAccount(<OwnerPrivateKey>);
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbAggregatorReadContract);

const transactionRequest = await orbitChainClient.arbAggregatorPrepareTransactionRequest({
    functionName: 'setFeeCollector',
    args: [<BatchPosterAddress>, <NewFeeCollectorAddress>],
    upgradeExecutor: false,
    account: owner.address,
});

await orbitChainClient.sendRawTransaction({
    serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

Finally, if you want to set a new batch poster, you can call the method `addBatchPoster(address)` of the [ArbAggregator](/build-decentralized-apps/precompiles/reference#arbaggregator) precompile and pass the address of the new batch poster, and later call the method `setIsBatchPoster(address,bool)` of the SequencerInbox contract on the parent chain.

```rust
cast send --rpc-url $ORBIT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY 0x000000000000000000000000000000000000006D "addBatchPoster(address) ()" $NEW_BATCH_POSTER_ADDRESS
```

```rust
cast send --rpc-url $PARENT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY $SEQUENCER_INBOX_ADDRESS "setIsBatchPoster(address,bool) ()" $NEW_BATCH_POSTER_ADDRESS true
```

_Note: When setting a new batch poster, its fee collector will be configured to the same address by default._

### Parent chain surplus fee[​](#parent-chain-surplus-fee-1 "Direct link to Parent chain surplus fee")

Parent chain surplus fees are paid to a specific `L1RewardRecipient` address that is configured individually per chain. The current fee collector address can be obtained by calling the method `getL1RewardRecipient()(address)` of the [ArbGasInfo](/build-decentralized-apps/precompiles/reference#arbgasinfo) precompile. For example:

```rust
cast call --rpc-url $ORBIT_CHAIN_RPC 0x000000000000000000000000000000000000006C "getL1RewardRecipient() (address)"
```

Alternatively, you can obtain this information using the Orbit SDK:

```rust
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbGasInfoPublicActions);

const parentChainRewardRecipient = await orbitChainClient.arbGasInfoReadContract({
    functionName: 'getL1RewardRecipient',
});
```

To set a new `L1RewardRecipient` address, you can call the method `setL1PricingRewardRecipient(address)` of the [ArbOwner](/build-decentralized-apps/precompiles/reference#arbowner) precompile, and pass the address of the new reward recipient. For example:

```rust
cast send --rpc-url $ORBIT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY 0x0000000000000000000000000000000000000070 "setL1PricingRewardRecipient(address) ()" $NEW_L1REWARDRECIPIENT_ADDRESS
```

Alternatively, you can use the Orbit SDK to set the new address:

```rust
const owner = privateKeyToAccount(<OwnerPrivateKey>);
const orbitChainClient = createPublicClient({
    chain: <OrbitChainDefinition>,
    transport: http(),
}).extend(arbOwnerPublicActions);

const transactionRequest = await orbitChainClient.arbOwnerPrepareTransactionRequest({
    functionName: 'setL1PricingRewardRecipient',
    args: [<NewL1RewardRecipientAddress>],
    upgradeExecutor: false,
    account: owner.address,
});

await orbitChainClient.sendRawTransaction({
    serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

How to use the fee distribution contracts?[​](#how-to-use-the-fee-distribution-contracts "Direct link to How to use the fee distribution contracts?")
-----------------------------------------------------------------------------------------------------------------------------------------------------

In the previous section we described how to set the individual collector addresses for each fee type. Some chains may require multiple addresses to receive the collected fees of any of the available types. In those cases, there's the possibility of using a distributor contract that can gather all fees of a specific type and distribute those among multiple addresses.

This section shows how to configure a distributor contract to manage the fees of a specific type.

Example scripts available in the Orbit SDK

This section will explain the process of deploying and configuring a distribution contract manually, but the Orbit SDK includes an [example to perform this process through a script](https://github.com/OffchainLabs/arbitrum-orbit-sdk/tree/main/examples/setup-fee-distributor-contract).

### Step 1. Deploy the distributor contract[​](#step-1-deploy-the-distributor-contract "Direct link to Step 1. Deploy the distributor contract")

An example implementation of a distributor contract can be found [here](https://github.com/OffchainLabs/fund-distribution-contracts/blob/main/src/RewardDistributor.sol). You'll have to deploy this contract on your Orbit chain.

### Step 2. Set the contract address as the desired fee type collector address[​](#step-2-set-the-contract-address-as-the-desired-fee-type-collector-address "Direct link to Step 2. Set the contract address as the desired fee type collector address")

Use the instructions provided in the previous section to set the address of the deployed distributor contract as the collector of the desired fee type. For example, if you want the distributor contract to manage the Orbit surplus fees, set the `networkFeeAccount` to the address of the deployed contract.

### Step 3. Configure the recipients of fees in the contract[​](#step-3-configure-the-recipients-of-fees-in-the-contract "Direct link to Step 3. Configure the recipients of fees in the contract")

Now you can set the different addresses that will be receiving fees from that distributor contract. To do that, you can call the method `setRecipients(address[], uint256[])` of the distributor contract, and specify the list of addresses that will be receiving fees, and the proportion of fees for each address.

For example, if you want to set two addresses as receivers, with the first one receiving 80% of the fees and the second one receiving 20% of the fees, you'll use the following parameters:

```rust
cast send --rpc-url $ORBIT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY $DISTRIBUTOR_CONTRACT_ADDRESS "setRecipients(address[],uint256[]) ()" "[$RECEIVER_1, $RECEIVER_2]" "[8000, 2000]"
```

### Step 4. Trigger the distribution of fees[​](#step-4-trigger-the-distribution-of-fees "Direct link to Step 4. Trigger the distribution of fees")

With the recipients configured in the distributor contract, and with the contract having collected some fees, you can now trigger the distribution of fees to the recipients by using the method `distributeRewards(address[], uint256[])` of the distributor contract, and specifying the list of addresses that are configured, and the proportion of fees for each address. The parameters passed must match the information that is set in the contract (i.e., you can't specify different addresses or proportions than what's been configured beforehand).

For example, if you want to distribute the fees to the two addresses specified before, you'll use the following parameters:

```rust
cast send --rpc-url $ORBIT_CHAIN_RPC --private-key $OWNER_PRIVATE_KEY $DISTRIBUTOR_CONTRACT_ADDRESS "distributeRewards(address[],uint256[]) ()" "[$RECEIVER_1, $RECEIVER_2]" "[8000, 2000]"
```

---

# How to configure delayed inbox finality | Arbitrum Docs

## How to configure delayed inbox finality

Child chain transactions[​](#child-chain-transactions "Direct link to Child chain transactions")
------------------------------------------------------------------------------------------------

Generally, transactions executed through the sequencer on Orbit chains [achieve finality](/how-arbitrum-works/transaction-lifecycle) equivalent to their parent chain once the relevant transaction data has been [posted in a batch](/how-arbitrum-works/optimistic-rollup). This means that transactions on Orbit chains are considered final in minutes.

Parent chain → child chain transactions[​](#parent-chain--child-chain-transactions "Direct link to Parent chain → child chain transactions")
--------------------------------------------------------------------------------------------------------------------------------------------

Messages being sent through the delayed inbox of a parent chain as [retryable tickets](/how-arbitrum-works/l1-to-l2-messaging#retryable-tickets), including deposits through token bridges, are released by the [sequencer](/how-arbitrum-works/sequencer) once it has reasonable confidence of finality on the parent chain. For example, on an L2 chain settling to Ethereum, the sequencer will release delayed messages to the inbox after 40 blocks. Following this, the transaction must complete another finality period for the Ethereum transaction that prompted it to achieve finality.

Orbit L3s may configure the finality of transactions executed through the delayed inbox to depend on different layers of finality. By default, Orbit chains will rely on the number of L1 block confirmations, effectively finalizing an L3 deposit as soon as L1 finalizes the batch posted by  or when a  is posted by . This would be on the order of tens of minutes.

However, in the instance of an L3 settling to Arbitrum One or Nova an L3 may also choose to rely only on L2 finality by configuring their sequencer as follows:

```rust
--node.delayed-sequencer.use-merge-finality=false
```

Additionally, the delay in L3 finalization can be decreased to achieve extremely fast (<1 min) deposits by configuring the sequencer to wait for fewer L2 block confirmations:

```rust
--node.delayed-sequencer.finalize-distance=1
```

Note, however, that if you choose to enable fast bridging, a re-org of un-finalized blocks on the L3 may occur if Arbitrum One/Nova (or the settlement chain of choice) experiences a re-org.

Child chain → parent chain transactions[​](#child-chain--parent-chain-transactions "Direct link to Child chain → parent chain transactions")
--------------------------------------------------------------------------------------------------------------------------------------------

Normally, [outgoing transactions](/how-arbitrum-works/l2-to-l1-messaging) must wait until the assertion that includes their L2 message is confirmed (~one week) before a client can execute the message on L1. However, in the near future [Anytrust](/how-arbitrum-works/anytrust-protocol) chains will be able to leverage their DAC to enable fast confirmations of withdrawals through the native token bridge. By immediately confirming assertions that have been signed by the DAC, finality can be reduced to ~fifteen minutes.

---

# How to configure your Orbit chain using the Orbit SDK | Arbitrum Docs

## How to configure your Orbit chain using the Orbit SDK

In this how-to, you'll learn how to configure your Orbit chain using the Orbit SDK.

UNDER CONSTRUCTION

This document is under construction and may change significantly as we incorporate [style guidance](/for-devs/contribute#document-type-conventions) and feedback from readers. Feel free to request specific clarifications by clicking the `Request an update` button at the top of this document.

Orbit chains have three areas of configuration:

1.  [](#1-parent-chain-configuration) configuration
2.  [**Node** configuration](#2-node-configuration)
3.  [](#3-child-chain-parameter-configuration) configuration

1\. Parent chain configuration[​](#1-parent-chain-configuration "Direct link to 1. Parent chain configuration")
---------------------------------------------------------------------------------------------------------------

Configuring the parent chain is the initial step to setting up your Orbit chain. Most of the parent chain configurations are specified during the setup phase. Detailed instructions can be found in the [Rollup Deployment Parameters](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain#rollup-deployment-parameters) section of the Rollup deployment guide.

After the initial setup, the chain owner can modify configurations as needed. For instance, the validator set can be updated by invoking the [`setValidKeyset`](https://github.com/OffchainLabs/nitro-contracts/blob/90037b996509312ef1addb3f9352457b8a99d6a6/src/bridge/SequencerInbox.sol#L751) function with a new set of validators. This adaptability facilitates your chain's optimization and management.

2\. Node configuration[​](#2-node-configuration "Direct link to 2. Node configuration")
---------------------------------------------------------------------------------------

As a chain deployer, you can configure a node during the node config generation process with the `nodeConfig.json` file. `nodeConfig.json` allows you to set up a node as a validator or a sequencer and specify requirements or performance criteria. For more information, refer to the [Node Configuration Preparation](/launch-orbit-chain/how-tos/orbit-sdk-preparing-node-config) documentation.

3\. Child chain parameter configuration[​](#3-child-chain-parameter-configuration "Direct link to 3. Child chain parameter configuration")
------------------------------------------------------------------------------------------------------------------------------------------

The child chain configuration can be performed after the chain has been initialized and the token bridge has been deployed. Child chains' parameters are configurable via setter functions in the [`ArbOwner precompile`](https://github.com/OffchainLabs/nitro-contracts/blob/main/src/precompiles/ArbOwner.sol). Additionally, there are various getter functions in the `ArbOwner precompile` that you can use to read the current configuration.

Below, we explain several methods in the `ArbOwner precompile` that you can use to configure the parameters or read their current state.

### Setter functions[​](#setter-functions "Direct link to Setter functions")

You can use these setter functions to configure the child chain parameters:

Parameter

Description

`addChainOwner`

Adds a new chain owner to your Orbit chain.

`removeChainOwner`

Removes an existing owner from the list of chain owners.

`setMinimumL2BaseFee`

Sets the minimum base fee on the child chain. The minimum base fee is the lowest amount that the base fee on the child chain can ever be. For example, the current minimum base fee on Arbitrum One and Arbitrum Nova is 0.01 gwei.

`setSpeedLimit`

The fee mechanism on the Arbitrum Nitro stack differs from the Ethereum blockchain. The Nitro stack has a parameter called the speed limit, which targets the number of gas consumed on the child chain per second. If the amount of gas per second exceeds this pre-specified amount, the base fee on the child chain will increase, and vice versa. The current speed limit on Arbitrum One is 7 million gas per second, meaning if the Arbitrum One chain consumes more than 7 million gas per second, its base fee will increase. For more information on the speed limit, please refer to this [document explaining the concept of speed limit in the Nitro stack](https://docs.arbitrum.io/inside-arbitrum-nitro/#the-speed-limit).

`setInfraFeeAccount`

Sets the infrastructure fee account address, which receives all fees collected on the child chain. It is meant to receive the minimum base fee, with any amount above that going to the network fee account.

`setNetworkFeeAccount`

Sets the network fee account address. As mentioned, this address collects all fees above the base fee. Note that if you set this amount to the 0 address on your chain, all fees will be deposited into the infrastructure fee account.

`scheduleArbOSUpgrade`

If you plan to upgrade the  version of your chain, this method can help you schedule the upgrade. For a complete guide, please refer to the explanation for the [arbos upgrade](/launch-orbit-chain/configure-your-chain/common-configurations/arbos-upgrade).

`setChainConfig`

We discussed the `chainConfig` in the [Rollup deployment guide](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain#4-chainconfig) in detail. If you wish to change any field of the `chainConfig`, you need to use this method on the child chain.

### Getter functions[​](#getter-functions "Direct link to Getter functions")

Parameter

Description

`getAllChainOwners`

Provides the list of all current chain owners.

`isChainOwner`

Allows you to check whether an address is on the list of chain owners.

`getInfraFeeAccount`

Returns the infrastructure fee account address.

`getNetworkFeeAccount`

Returns the network fee account address.

### Configuring the child chain using the Orbit SDK[​](#configuring-the-child-chain-using-the-orbit-sdk "Direct link to Configuring the child chain using the Orbit SDK")

In the Orbit SDK, we use the [Client Extension](https://viem.sh/docs/clients/custom#extending-with-actions-or-configuration) feature of Viem to extend the public client. In the Orbit SDK, we defined `arbOwnerPublicActions` to use it and extend the client on [Viem](https://viem.sh/docs/clients/custom#extending-with-actions-or-configuration). An example of creating a public client extended with `arbOwner` public actions is:

```rust
import { createPublicClient, http } from 'viem';
import { arbOwnerPublicActions } from '@arbitrum/orbit-sdk';

const client = createPublicClient({
  chain: arbitrumLocal,
  transport: http(),
}).extend(arbOwnerPublicActions);
```

With `arbOwnerPublicActions` and the public client in the Orbit SDK, we've added two new methods to the public clients:

#### 1\. arbOwnerReadContract[​](#1-arbownerreadcontract "Direct link to 1. arbOwnerReadContract")

This method can be used to read the parameters of the child chain discussed in the [previous section](#getter-functions). An example of using this method with the `client` defined in the previous section is:

```rust
const result = await client.arbOwnerReadContract({
  functionName: 'getAllChainOwners',
});
```

The other parameters can be obtained by changing the function names in the [the Getter functions section](#getter-functions) list.

#### 2\. `arbOwnerPrepareTransactionRequest`[​](#2-arbownerpreparetransactionrequest "Direct link to 2-arbownerpreparetransactionrequest")

This method can be used to configure the parameters on the `ArbOwner` precompile, which are listed in [the Setter functions section](#setter-functions). An example of utilizing this method to configure parameters using the `client` defined in the previous section is:

```rust
// Adding a random address as chain owner using the upgrade executor
const transactionRequest = await client.arbOwnerPrepareTransactionRequest({
  functionName: 'addChainOwner',
  args: [randomAccountAddress],
  upgradeExecutor: false,
  account: owner.address,
});

// Submitting the transaction to add a chain owner
await client.sendRawTransaction({
  serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

To use this method, as shown in the example above, some inputs need to be defined:

Parameter

Description

`functionName`

The name of the method you want to use to set the parameter, which can be found in [the Setter functions section](#setter-functions).

`args`

The arguments for the defined function.

`upgradeExecutor`

Specifies whether a `upgradeExecutor` contract governs your chain. If it is not using a `upgradeExecutor`, you can set it to `false`, similar to the example above.

`account`

Defines the chain owner if an `upgradeExecutor` does not govern the chain.

If a `upgradeExecutor` contract governs your chain, then you need to use the `arbOwnerPrepareTransactionRequest` method, similar to the example below:

```rust
// Adding a random address as chain owner using the upgrade executor
const transactionRequest = await client.arbOwnerPrepareTransactionRequest({
  functionName: 'addChainOwner',
  args: [randomAccountAddress],
  upgradeExecutor: upgradeExecutorAddress,
  account: owner.address,
});

// Submitting the transaction to add a chain owner
await client.sendRawTransaction({
  serializedTransaction: await owner.signTransaction(transactionRequest),
});
```

In this example, all the fields are the same as in the first example, except the `upgradeExecutor` field, which you need to set to the `upgradeExecutor` address, and the `account` parameter, which needs to be set to the owner of the `upgradeExecutor` contract.

---

# How to configure your Orbit chain's node using the Orbit SDK | Arbitrum Docs

## How to configure your Orbit chain's node using the Orbit SDK

This guide will walk you through configuring an Orbit node supporting a  or  chain.

UNDER CONSTRUCTION

This document is under construction and may change significantly as we incorporate [style guidance](/for-devs/contribute#document-type-conventions) and feedback from readers. Feel free to request specific clarifications by clicking the `Request an update` button at the top of this document.

info

See the ["prepare-node-config" example](https://github.com/OffchainLabs/arbitrum-orbit-sdk/tree/main/examples/prepare-node-config) in the Orbit SDK repository for additional guidance.

*   Prerequisite: having deployed an Orbit chain. If you haven't done so yet, you can find detailed instructions in the [Rollup Deployment Parameters](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain) section of the rollup deployment guide.

Once you have successfully deployed and initialized the Orbit core contracts, the next step is configuring and running your Orbit chain using a Node Config `JSON` file describing all the configurations for the Arbitrum Node, including settings for the Batch-poster, Validator, and the chain itself.

Example for a Rollup Orbit Chain:

```rust
{
  'chain': {
    'info-json': stringifyInfoJson([...]),
    'name': chainName,
    // Additional chain-specific configurations
  },
  'parent-chain': {
    connection: {
      url: parentChainRpcUrl,
    },
  },
  'http': {
    addr: '0.0.0.0',
    port: 8449,
    vhosts: '*',
    corsdomain: '*',
    api: ['eth', 'net', 'web3', 'arb', 'debug'],
  },
  'node': {
    // Node-specific settings including sequencer, batch-poster, staker configurations
  },
};
```

Here are some inputs details from the example above:

Parameters

Description

`chain`

Details about the hosted chain, including chain ID, name, and core contracts.

`parent-chain`

Information for connecting to the parent chain.

`http`

Configuration parameters for the HTTP server.

`node`

Specific node settings, including sequencer and batch-poster configurations.

### Additional configuration for AnyTrust Orbit chains:[​](#additional-configuration-for-anytrust-orbit-chains "Direct link to Additional configuration for AnyTrust Orbit chains:")

For AnyTrust Orbit chains, the Node Config `JSON` has an additional segment under the `node` field. This addition includes settings specific to the AnyTrust model, such as:

*   Sequencer's inbox address
*   Parent chain node URL
*   RPC aggregators

Example addition for AnyTrust Node Config:

```rust
{
  ...
  'node': {
    ...
    'sequencer-inbox-address': coreContracts.sequencerInbox,
    'parent-chain-node-url': parentChainRpcUrl,
    'rest-aggregator': {
      enable: true,
      urls: 'http://localhost:9876',
    },
    'rpc-aggregator': {
      'enable': true,
      'assumed-honest': 1,
      'backends': stringifyBackendsJson([...]),
    },
  }
  ...
};
```

### Preparing your node config file[​](#preparing-your-node-config-file "Direct link to Preparing your node config file")

The Node Config file includes three fields types:

1.  **Information from the Orbit deployment chain**: Such as the addresses of the core contracts.
2.  **Parameters configurable by the chain deployer**: These parameters, like `max-block-speed`, can be adjusted to modify your chain's behavior.
3.  **Fields not typically configured**: Like the HTTP section, which usually remains standard.

Let's explore the parameters allowing you to set up a stable, and secure Orbit chain tailored to your project's requirements:

### Node config generation with Orbit SDK[​](#node-config-generation-with-orbit-sdk "Direct link to Node config generation with Orbit SDK")

Generating a Node Config `JSON` file to initiate your Orbit chain is a step in the deployment process. The Orbit SDK simplifies this task with an API named `prepareNodeConfig`. This API takes specific parameters for your Orbit chain and returns a `JSON` file that can be used as the Node Config to initiate the chain.

Here’s an example of using the `prepareNodeConfig` API to generate the node config:

```rust
const nodeConfig = prepareNodeConfig({
  chainName: 'My Orbit Chain',
  chainConfig,
  coreContracts,
  batchPosterPrivateKey: 'BATCH_POSTER_PRIVATE_KEY_HERE',
  validatorPrivateKey: 'VALIDATOR_PRIVATE_KEY_HERE',
  parentChainId: parentChain_chain_id,
  parentChainRpcUrl: parentChain_RPC_URL,
});
```

Here are some details about the parameters used in the example above:

Parameters

Description

`chainName`

The name you have chosen for your Orbit chain.

`chainConfig`

Configuration used for [chain deployment](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain#4-chainconfig), returned from the [createRollupPrepareTransactionReceipt](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain#createrolluppreparetransactionrequest-api) API.

`coreContracts`

Addresses of your newly deployed Orbit chain's, also returned from the `createRollupPrepareTransactionReceipt` API.

`batchPosterPrivateKey`

Private key of the batch-poster account, used for signing batch-posting transactions and related functions.

`validatorPrivateKey`

Private key of the validator(s), used for validating state, posting assertions (`RBlocks`) to the parent chain, and initiating challenges if necessary.

`parentChainId`

Chain ID of the parent chain where your Orbit chain is deployed.

`parentChainRpcUrl`

Parent chain's RPC URL.

If you don't have the `chainConfig` and `coreContracts` readily available, you can obtain them using the `createRollupPrepareTransaction` and `createRollupPrepareTransactionReceipt` APIs.

Here's an example of how to extract `chainConfig` and `coreContracts` using just the transaction hash from your deployment:

```rust
import {
  ChainConfig,
  createRollupPrepareTransaction,
  createRollupPrepareTransactionReceipt,
} from '@arbitrum/orbit-sdk';

const tx = createRollupPrepareTransaction({ hash: txHash });
const txReceipt = createRollupPrepareTransactionReceipt({ hash: txHash });
const chainConfig: ChainConfig = JSON.parse(tx.getInputs()[0].config.chainConfig);
const coreContracts = txReceipt.getCoreContracts();
```

This process ensures that all necessary configurations and contract details are included in your Node Config.

---

# Bridging | Arbitrum Docs

## Bridging

---

# Decentralization and Security | Arbitrum Docs

## Decentralization and Security

---

# Guidance on AltDA | Arbitrum Docs

## Guidance on AltDA

---

# Managing state growth & corresponding issues | Arbitrum Docs

## Managing state growth & corresponding issues

As the Orbit ecosystem grows, more and more teams are choosing to build on the Arbitrum tech stack. Orbit offers a feature-rich and scalable rollup stack that allows teams to focus on their ecosystem growth and build great products. As a result, many Orbit chains are seeing usage and throughput increase rapidly, often with sustained transaction load at the chain’s throughput limit for months on end.

This page aims to educate Orbit chain operators and owners on safely operating a high throughput chain. Amongst all the factors, the primary consideration is **state growth rate** and **state size**. We’ll discuss how increased state size affects the performance of different components in the Orbit stack and how certain metrics can be used to indicate a need to upgrade various infrastructure components.

### Understanding state size and state growth rate[​](#understanding-state-size-and-state-growth-rate "Direct link to Understanding state size and state growth rate")

When we say ‘state size’, we mean the total amount of data recorded on the blockchain; state size is a critical metric for node performance as a larger state creates higher infrastructure requirements on nodes for storage and searching through existing states.

The state growth rate is simply the rate at which state size increases. A high state growth rate creates higher requirements for nodes to process state transitions and perform operations needed to keep up with the tip of the chain.

The critical Nitro stack parameter affecting state growth and state growth rate is the **gas speed limit**. Offchain Labs has set the gas speed limit to a default (7,000,000 gas/s), ensuring a safe, sustained operating limit for Orbit chains. You can read more about the nuances of the gas speed limit [here](https://docs.arbitrum.io/how-arbitrum-works/inside-arbitrum-nitro#the-speed-limit).

The default gas speed limit is designed to ensure Orbit chains operate performantly and sustainably.

### Behaviour at ultra-high throughput[​](#behaviour-at-ultra-high-throughput "Direct link to Behaviour at ultra-high throughput")

At high state growth rates, especially in cases where a chain is pushing past prescribed limits, an Orbit chain may display certain behaviors that either indicate or result from the chain load being higher than its infrastructure can support. The following is a list of such behaviors.

#### 1\. Read Operation Bottleneck at High Disk Latency[​](#1-read-operation-bottleneck-at-high-disk-latency "Direct link to 1. Read Operation Bottleneck at High Disk Latency")

As the number of read requests on a chain grows, the impact of disk latency on performance becomes more pronounced. The performance impact can be considered the total amount of read requests made as a multiple of the disk latency. High read request volumes may necessitate switching to using low-latency local NVMe drives.

#### 2\. Increased single-core CPU and RAM Utilization[​](#2-increased-single-core-cpu-and-ram-utilization "Direct link to 2. Increased single-core CPU and RAM Utilization")

Observing high utilization on single-core CPU and RAM indicates that you may require more performant hardware. As this trend continues, hardware investments become prohibitively expensive for the ecosystem or require increasingly custom solutions, which decreases accessibility for node runners.

#### 3\. Increased Total State Database Size[​](#3-increased-total-state-database-size "Direct link to 3. Increased Total State Database Size")

The accelerated state database growth rate, on the order of multiple terabytes of data per month, indicates that your chain may require increasing drive sizes. Played out over time, this may force node runners on the chain to adopt prohibitively expensive or hard-to-procure drives (e.g., those notes available on major cloud providers).

#### 4\. Increased Disk Write Operations per Second[​](#4-increased-disk-write-operations-per-second "Direct link to 4. Increased Disk Write Operations per Second")

The number of write operations per second directly correlates to state size growth. As the state growth rate increases, ecosystem nodes that aren’t properly resourced may fall out of sync with the chain.

#### 5\. Sync from Genesis Time[​](#5-sync-from-genesis-time "Direct link to 5. Sync from Genesis Time")

As state size increases, the time a new node needs to catch up to the chain also increases. A large state size and state growth rate can result in new nodes catching up to the chain in the worst case.

### Summary of symptoms, mitigations, risks[​](#summary-of-symptoms-mitigations-risks "Direct link to Summary of symptoms, mitigations, risks")

The general trend with any issue in the table below is as follows:

*   The simple resolutions involve moving to more expensive infrastructure.
*   When simple resolutions are exhausted, infrastructure becomes both expensive and bespoke (options that available cloud providers do not support)
*   The long-term risk (and point of no return) is when infrastructure requirements are too expensive or too inaccessible for node runners.

Behaviour

Risk

Mitigations & Considerations

Performance degradation due to storage reads at high disk latency

An increase in read operations causes nodes to spend more accessing disk state. As the number of read operations increases, these delays can degrade chain performance.

Upgrade drives to local NVMe (PCIe Gen4/Gen5, not configured with RAID) with higher speeds. In the short term, NVMe usage will greatly increase the cost of node runners. In the extreme, you may run out of usable drive specifications on available infrastructure vendors.

Growing or constant sequencer backlog (using `arb_sequencer_backlog`) over a sustained period.

Seeing a growing or persistent backlog implies that nodes cannot keep up with the transaction load accepted by the sequencer.

Large state database size and high growth rate of the state database

A large state database size will require that nodes run more expensive disks. This reduces the economic feasibility for node runners. In extreme cases, the required disk size may be unsupported by accessible cloud service providers.

The primary resolution is to upgrade the disk size requirement for nodes on your chain.

High utilization of single-core CPU and RAM

As with the cases above, this symptom implies a need to upgrade hardware. The main risk is the economic feasibility and long-term accessibility of new hardware options.

The only resolution is to upgrade your node’s CPU and RAM.

---

# Guidance for Orbit chains gas speed limit | Arbitrum Docs

## Guidance for Orbit chains gas speed limit

### What is the speed limit on an Orbit chain?[​](#what-is-the-speed-limit-on-an-orbit-chain "Direct link to What is the speed limit on an Orbit chain?")

The parameter that governs an Orbit chain's throughput limit is known as the `gas speed limit`.

The gas speed limit is measured in _gas per second_ and is used as a threshold for increasing gas prices.

For example, Arbitrum One and Arbitrum Nova have a gas speed limit of 7 million gas per second. This means that when cumulative usage onchain exceeds 7 million gas per second, the `L2 base fee` rises to increase the amount of gwei charged per unit of gas. This happens using a similar approach to [Ethereum's EIP-1559 pricing algorithm](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md).

### Why do we have throughput limits on blockchains?[​](#why-do-we-have-throughput-limits-on-blockchains "Direct link to Why do we have throughput limits on blockchains?")

The effect of raising gas prices at the speed limit is to curb user demand when the chain is congested. Doing so protects the chain's underlying infrastructure from being overloaded.

This is because blockchain nodes have computation constraints that should not be exceeded. Charging more during congested periods ensures that high-priority transactions can still be processed while deterring users and apps from submitting low-priority transactions until a lower activity period.

The speed limit, therefore, is fundamentally a protective mechanism. If the chain load exceeds what a Nitro validator node can process, then a chain risks halting due to validator downtime. It's important to note here that the security and liveness of an Orbit chain are always maintained through its parent chain contracts, but undoubtedly, the best user experience requires the validators and sequencer to be online.

### What is the recommended speed limit for Orbit chains?[​](#what-is-the-recommended-speed-limit-for-orbit-chains "Direct link to What is the recommended speed limit for Orbit chains?")

**Please note: We recommend against teams raising their chain's default speed target beyond 7 million gas per second.**

### What are the risks of increasing my gas speed limit?[​](#what-are-the-risks-of-increasing-my-gas-speed-limit "Direct link to What are the risks of increasing my gas speed limit?")

An increase in the speed target allows users and apps to perform more on-chain actions without incurring additional costs. This makes it possible for a chain's nodes to experience higher and unexpected loads. When faced with high, sustained demand, the additional load could eventually lead to undesirable increases in infrastructure costs, cause nodes to lag behind the chain, and risk halting if the demand exceeds the resources of validator nodes.

See [State Growth & Corresponding Issues](https://www.notion.so/State-Growth-Size-Guidance-10301a3f59f880fba7ade76c2f7af0c7?pvs=21).

Is Offchain Labs working on software improvements to allow Orbit chain owners to _safely_ raise their chain's speed target?[​](#is-offchain-labs-working-on-software-improvements-to-allow-orbit-chain-owners-to-safely-raise-their-chains-speed-target "Direct link to is-offchain-labs-working-on-software-improvements-to-allow-orbit-chain-owners-to-safely-raise-their-chains-speed-target")
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Yes. Offchain Labs is currently working on several key initiatives to improve the core Nitro node software that would result in a safe and formally endorsed increase in the speed targets for Arbitrum chains. These initiatives include migrations to PathDB and PebbleDB (alongside their respective optimizations for Arbitrum chains) and alternative execution layer client implementations for Nitro (e.g., Reth). We will share updates and news on these initiatives when we have them - stay tuned!

---

# Monitoring | Arbitrum Docs

## Monitoring

---

# Ownership Structure and Access Control | Arbitrum Docs

## Ownership Structure and Access Control

---

# The Orbit license | Arbitrum Docs

## The Orbit license

---

# Orbit Node Providers | Arbitrum Docs

## Orbit Node Providers

---

# Quickstart: Launch an Orbit chain | Arbitrum Docs

## Quickstart: Launch an Orbit chain

This quickstart is for developers who want to launch their own Arbitrum Orbit chain using the [Orbit chain deployment portal](https://orbit.arbitrum.io/).

Not for Mainnet Production

This quickstart is intended for development purposes only and is not suitable for deploying production-grade mainnet chains.

By the end of this quickstart, you'll have a **local devnet chain** that hosts EVM-compatible smart contracts. Your chain will process transactions locally while settling to the public **Arbitrum Sepolia testnet**. Familiarity with Ethereum, Ethereum's testnets, and Arbitrum is expected.

If you're looking for a conceptual introduction to Orbit chains, see the [Gentle introduction to Orbit chains](/launch-orbit-chain/a-gentle-introduction).

Prerequisites[​](#prerequisites "Direct link to Prerequisites")
---------------------------------------------------------------

*   [Docker](https://docs.docker.com/get-docker/)
*   A browser-based Ethereum wallet (e.g., [MetaMask](https://metamask.io/) and click View MetaMask web or [OKX Wallet](https://www.okx.com/web3) and click Connect Wallet to install.
*   At least 1.2 testnet ETH (for custom gas token chains, 0.8 ETH and 0.4 native tokens)

Step 1: Acquire Arbitrum Testnet $ETH (and the native token for Orbit chains with custom gas tokens)[​](#step-1-acquire-arbitrum-testnet-eth-and-the-native-token-for-orbit-chains-with-custom-gas-tokens "Direct link to Step 1: Acquire Arbitrum Testnet $ETH (and the native token for Orbit chains with custom gas tokens)")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

You'll need at least 1.2 testnet $ETH for regular Orbit chains or 0.8 $ETH plus 0.4 of your desired native token for Orbit chains with a custom gas token. The funds are needed to cover the cost of deploying your Orbit chain's **base contracts** to its **base chain** (Arbitrum Sepolia).

At the time of this quickstart's writing, the easiest way to acquire $ETH is to bridge testnet $ETH from Ethereum's L1 Sepolia network to Arbitrum Sepolia L2 testnet:

1.  Use an L1 testnet $ETH faucet like [sepoliafaucet.com](https://sepoliafaucet.com/) to acquire some testnet $ETH on an L1 testnet.
2.  Bridge your L1 testnet $ETH into Arbitrum L2 using [the Arbitrum bridge](https://bridge.arbitrum.io/).

Step 2: Choose your chain type: AnyTrust or Rollup[​](#step-2-choose-your-chain-type-anytrust-or-rollup "Direct link to Step 2: Choose your chain type: AnyTrust or Rollup")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 is an Optimistic Rollup protocol; it's  and permissionless. These properties are achieved by requiring all chain data to be posted on Ethereum's "Layer 1" (L1) chain. This means the availability of this data follows directly from the security properties of Ethereum itself, and, in turn, that any party can participate in validating the chain and ensuring its safety.

By contrast,  introduces a trust assumption in exchange for lower fees. Instead of requiring all Arbitrum nodes to have access to the data of every L2 transaction in the Arbitrum chain's inbox, AnyTrust relies on an external  to store data and provide it on demand, reducing the costs of batching and posting all L2 transaction data to L1. Visit our [FAQ docs](/learn-more/faq) to learn more.

We generally recommend using Rollup chains for use-cases that demand the highest level of security (like decentralized exchanges and other DeFi dApps). AnyTrust chains are suitable for use-cases that require lower fees and generate lots of transactions (like gaming and social dApps).

Step 3: Configure your Orbit chain's deployment[​](#step-3-configure-your-orbit-chains-deployment "Direct link to Step 3: Configure your Orbit chain's deployment")
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

Visit the [Orbit chain deployment portal](https://orbit.arbitrum.io/). You'll be prompted to connect your wallet. You may be prompted to add the **Arbitrum Sepolia** network to your wallet and/or to switch your wallet to this network; approve this.

The deployment portal will then display a form that looks like this:

Chain ID

Chain name

Challenge period (blocks)

Stake token

Base stake

Owner

The below table provides a brief description of each of these configuration parameters. We recommend sticking to the defaults; to learn more about customizing your Orbit chain's deployment configuration, visit [How (and when) to customize your Orbit chain's deployment config](/launch-orbit-chain/configure-your-chain/common-configurations/use-a-custom-gas-token):

Parameter

Description

**Chain ID**

A unique integer identifier that represents your chain's network. Your `Chain ID` can be submitted to chain indexes like [Chainlist.org](http://chainlist.org). For devnets, this is randomly generated for each deployment - don't worry about it for now.

**Chain name**

A human-readable way to distinguish your Orbit chain from other Orbit chains. Users, developers and the wider community will refer to your chain by your `Chain name` and/or your `Chain ID`.

**Challenge period (blocks)**

The amount of time that your Orbit chain's nodes have to dispute the current state of the chain before it's confirmed (and ultimately finalized) on the underlying L2 chain (e.g. Arbitrum Sepolia). Note that this refers to the number of blocks on the underlying L1 chain (e.g. Ethereum's Sepolia chain).

**Stake token**

The token that your chain's validators must stake in order to participate in your chain. This is hardcoded to $ETH for now, but future versions of Orbit chains will let you specify an arbitrary ERC-20 token contract here.

**Base stake**

The amount of your configured `Stake token` that your chain's validators must stake in order to participate in your chain. Should be greater than 0.

**Owner**

The administrative Ethereum address that will deploy, own, and update your chain's base contracts. This will default to your connected wallet's address. This needs to be a standard Ethereum wallet account - an EOA, not a contract address. Note that you'll have to specify this wallet's private key within a local JSON file later.

**Gas token**

The address of the ERC-20 token on the parent chain that is intended to be used as the native gas token on the Orbit chain. This token must already be deployed natively on the parent chain and is bridged to the Orbit chain during chain deployment. This feature is only supported on AnyTrust chains currently, and more information around token restrictions can be found [here](https://docs.arbitrum.io/launch-orbit-chain/how-tos/customize-deployment-configuration).

Step 4: Configure your chain's validator(s)[​](#step-4-configure-your-chains-validators "Direct link to Step 4: Configure your chain's validator(s)")
-----------------------------------------------------------------------------------------------------------------------------------------------------

You should see a `Configure Validators` section appear, with a form that looks like this:

Number of Validators

Validator 1 (0x...)

\[...\]

Validator n (0x...)

The first input field is an integer value that determines **the number of validators that will support your initial deployment**. Subsequent fields allow you to specify each of these validators' addresses.

The first validator address is randomly generated and can't be changed. Its private key will be automatically generated and stored within one of the JSON configuration files that will be generated in a moment.

Your chain's validators are responsible for validating the integrity of transactions and posting assertions of the current state of your Orbit chain to its base chain. In production scenarios, your Orbit chain would likely be hosted by a network of validator nodes working together. For your local Orbit chain, you can stick to the auto-generated single validator address.

Each of the validator addresses specified in this step will be added to an allow-list in one of your chain's **base contracts**, allowing them each to **stake** and validate transactions submitted to your Orbit chain.

NEW TERMINOLOGY

When we say "base contracts" and "base chain", we're referring to your Orbit chain's L2 contracts and the L2 chain that they're deployed to, respectively. We'll use these terms throughout the rest of this guide.

Once your validator addresses are configured, click `Next` to proceed the next step: **batch poster configuration**.

Step 5: Configure your chain's batch poster[​](#step-5-configure-your-chains-batch-poster "Direct link to Step 5: Configure your chain's batch poster")
-------------------------------------------------------------------------------------------------------------------------------------------------------

You should see a `Configure Batch Poster` section appear, with a form that looks like this:

Batch Poster Address

Your batch poster address is responsible for posting batches of transactions from your Orbit chain to its base contracts on its base chain. An address will automatically be generated for you; its private key will be automatically generated and stored within one of the JSON configuration files that will be generated in a moment.

Once your batch poster address is configured, click `Next` to proceed to the next step: **review & deploy your Orbit chain**.

Step 6: Review & Deploy your Orbit chain[​](#step-6-review--deploy-your-orbit-chain "Direct link to Step 6: Review & Deploy your Orbit chain")
----------------------------------------------------------------------------------------------------------------------------------------------

Deploy your chain's base contracts to Arbitrum Sepolia

Click the `Deploy` button located below the config form. Your wallet should prompt you to submit a transaction to the Arbitrum testnet. You'll have to pay a little gas; your wallet may denominate this in $ETH; as long as you see your chosen Arbitrum testnet in the transaction details, this gas fee will be paid in testnet $ETH.

Before proceeding, let's briefly review what just happened:

*   You submitted a deployment transaction to an Orbit "factory" smart contract on the Arbitrum testnet, the public L2 chain that your local Orbit chain will settle transactions to.
*   This Orbit smart contract then initialized your Orbit chain's base contracts with the values that you specified in the previous step, and deployed these base contracts to the Arbitrum testnet.

Your Orbit chain's base contracts are responsible for facilitating the exchange of information between your chain's node(s) and its base chain's nodes. This includes the batch posting of transactions from your Orbit chain to its base chain, the staking of tokens by your Orbit chain's validators, the challenge mechanism, bridging mechanisms, and more.

Once your transaction is complete, if you deployed an AnyTrust chain, you'll next be asked to configure your keyset. Otherwise, continue to [Step 8](#step-8-download-your-chains-configuration-files-and-launch-your-chain) to download your chain's configuration files and launch your chain.

Step 7: Configure keyset (AnyTrust chains only)[​](#step-7-configure-keyset-anytrust-chains-only "Direct link to Step 7: Configure keyset (AnyTrust chains only)")
------------------------------------------------------------------------------------------------------------------------------------------------------------------

Not applicable to Rollup chains

Skip this step if you're deploying a Rollup chain.

For the Batch Poster to function correctly, it's essential that the keyset corresponding to its current configuration is active within the `SequencerInbox` contract. The production of the keyset and keyset hash binary blobs is mandatory, which should then be used as inputs for the `SetValidKeyset` method on the `SequencerInbox` contract.

The current version of Orbit AnyTrust chains uses a single Data Availability Server and assigns a null value to its private key in order to generate an initial keyset. As part of this transaction process, you'll assign this initial keyset to your recently generated `SequencerInbox` contract.

Click the `Deploy` button located below the Deployment Summary. Again, your wallet should prompt you to submit a transaction to the Arbitrum testnet. Gas fees will be handled similarly to the previous transaction.

Once the transaction completes, you'll be directed to the download page to continue your chain deployment.

Step 8: Download your chain's configuration files and launch your chain[​](#step-8-download-your-chains-configuration-files-and-launch-your-chain "Direct link to Step 8: Download your chain's configuration files and launch your chain")
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

You should see two JSON code blocks appear labeled `Rollup Config` and `L3 Config`. Use the download buttons at the top right of each code block to save it locally.

1.  **Download Rollup JSON**: This will generate `nodeConfig.json`, which contains your **chain's node configuration**. Note that this includes the private keys for your validator (staker) and batch poster, which are used to sign transactions that post RBlocks and batches to your chain's base contracts on L2.
2.  **Download L3Config JSON**: This will generate `orbitSetupScriptConfig.json`, which contains your **chain's configuration**, including that which supports your **Token Bridge contracts**.

Step 9: Clone the setup script repository and add your configuration files[​](#step-9-clone-the-setup-script-repository-and-add-your-configuration-files "Direct link to Step 9: Clone the setup script repository and add your configuration files")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  Clone the [orbit-setup-script](https://github.com/OffchainLabs/orbit-setup-script) repository: `git clone https://github.com/OffchainLabs/orbit-setup-script.git`
2.  Move the `nodeConfig.json` file that you downloaded into the `config` directory in the root of your cloned `orbit-setup-script` repository.
3.  Move the `orbitSetupScriptConfig.json` file you downloaded into the `config` directory in the root of your cloned `orbit-setup-script` repository.
4.  Install dependencies by running `yarn install` from the root of the `orbit-setup-script` repository.

Step 10: Run your chain's node and block explorer[​](#step-10-run-your-chains-node-and-block-explorer "Direct link to Step 10: Run your chain's node and block explorer")
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Run Docker, then run `docker-compose up -d` from the root of the `orbit-setup-script` repository.

A Nitro node and BlockScout explorer instance will be started. Visit [http://localhost/](http://localhost/) to access your BlockScout explorer instance - this will allow you to view your chain's transactions and blocks, which can be useful for debugging.

Step 11: Finish setting up your chain[​](#step-11-finish-setting-up-your-chain "Direct link to Step 11: Finish setting up your chain")
--------------------------------------------------------------------------------------------------------------------------------------

We've provided a Hardhat script that handles the following tasks:

1.  Fund the **batch-poster** and **validator** (staker) accounts on your underlying L2 chain.
2.  Deposit ETH into your account on the chain using your chain's newly deployed bridge.
3.  Deploy your Token Bridge contracts on both L2 and local Orbit chains.
4.  Configure parameters on the chain.

To run this script, issue the following command from the root of the `orbit-setup-script` repository, replacing `OxYourPrivateKey` with the private key of the `Owner` account you used to deploy your chain's contracts, and replacing `http://localhost:8449` with the RPC URL of your chain's node.

Using Arbitrum Sepolia:

```rust
PRIVATE_KEY="0xYourPrivateKey" L2_RPC_URL="https://sepolia-rollup.arbitrum.io/rpc" L3_RPC_URL="http://localhost:8449" yarn run setup
```

Congratulations[​](#congratulations "Direct link to Congratulations")
---------------------------------------------------------------------

Your local Orbit chain is now running. You'll see an `outputInfo.json` file in the main directory of your script folder - this contains more information about your chain, including the addresses of your chain's base contracts.

### Appendix A: Logging[​](#appendix-a-logging "Direct link to Appendix A: Logging")

Run this command in the root directory of your cloned orbit setup script repo to view your chain's logs:

```rust
docker-compose logs -f nitro
```

### Appendix B: Depositing ETH/native token[​](#appendix-b-depositing-ethnative-token "Direct link to Appendix B: Depositing ETH/native token")

If you need to deposit more ETH (or native tokens) into your Orbit chain account, run this command on the base directory of the setup script, replacing `0xYourPrivateKey` with the private key of the originating account, and `<AMOUNT>` with the amount to send:

Using Arbitrum Sepolia:

```rust
PRIVATE_KEY="0xYourPrivateKey" L2_RPC_URL="https://sepolia-rollup.arbitrum.io/rpc" L3_RPC_URL="http://localhost:8449"
AMOUNT="<AMOUNT>" yarn run deposit
```

### Appendix C: Troubleshooting[​](#appendix-c-troubleshooting "Direct link to Appendix C: Troubleshooting")

*   You may see `error getting latest batch count` in your node's output logs (from Appendix A). This is usually safe to ignore. It's usually displayed when your Orbit chain's base contract deployment isn't yet finalized on the L1 chain. This finalization can take 15-20 minutes, but don't worry - the deployment doesn't need to be L1-finalized in order for your chain to function properly.

---

# Get started with the Arbitrum Orbit SDK | Arbitrum Docs

## Get started with the Arbitrum Orbit SDK

The Arbitrum Orbit SDK lets you programmatically create and manage your own Orbit chain(s). Its capabilities include:

*   Configuration and deployment of your Orbit chain's core contracts
*   Initialization of your chain and management of its configuration post-deployment

1\. Select a chain type[​](#1-select-a-chain-type "Direct link to 1. Select a chain type")
------------------------------------------------------------------------------------------

There are three types of Orbit chains. Review the following table to determine which type best fits your needs:

Chain Type

Description

Use Case

**Rollup**

Offers Ethereum-grade security by batching, compressing, and posting data to the parent chain, similarly to [Arbitrum One](https://arbitrum.io/).

Ideal for applications that require high security guarantees.

**AnyTrust**

Implements the [AnyTrust protocol](/how-arbitrum-works/anytrust-protocol), relying on an external [Data Availability Committee (DAC)](/intro/glossary#data-availability-committee-dac) to store data and provide it on-demand instead of using their [parent chain](https://docs.arbitrum.io/intro/glossary#parent-chain) as the Data Availability (DA) layer.

Suitable for applications that require lower transaction fees.

**Custom gas token**

An AnyTrust Orbit chain with the ability to specify a custom `ERC-20` gas token.

Ideal for applications that require custom gas fee tokens and lower transaction fees.

2\. Deploy your chain[​](#2-deploy-your-chain "Direct link to 2. Deploy your chain")
------------------------------------------------------------------------------------

After selecting a chain type, you need to deploy your Orbit chain. Visit the deployment guide for your selected chain type:

*   [Deploy a Rollup Orbit chain](/launch-orbit-chain/deploy-an-orbit-chain/deploying-rollup-chain)
*   [Deploy an AnyTrust Orbit chain](/launch-orbit-chain/deploy-an-orbit-chain/deploying-anytrust-chain)
*   [Deploy a Custom Gas Token Orbit chain](/launch-orbit-chain/deploy-an-orbit-chain/deploying-custom-gas-token-chain)

3\. Configure your Orbit chain's node[​](#3-configure-your-orbit-chains-node "Direct link to 3. Configure your Orbit chain's node")
-----------------------------------------------------------------------------------------------------------------------------------

After selecting a chain type, you need to specify your Orbit chain's node configuration by creating a `JSON` file. Visit [Configure your Orbit chain's node](/launch-orbit-chain/how-tos/orbit-sdk-preparing-node-config), then proceed to the next step.

4\. Deploy your Orbit chain's token bridge[​](#4-deploy-your-orbit-chains-token-bridge "Direct link to 4. Deploy your Orbit chain's token bridge")
--------------------------------------------------------------------------------------------------------------------------------------------------

Your Orbit chain's token bridge contracts allow ERC-20 tokens to move between your Orbit chain and its underlying parent chain. See [Deploy your Orbit chain's token bridge](/launch-orbit-chain/deploy-an-orbit-chain/deploying-token-bridge), then proceed to the next step.

5\. Configure your Orbit chain[​](#5-configure-your-orbit-chain "Direct link to 5. Configure your Orbit chain")
---------------------------------------------------------------------------------------------------------------

With your node configuration specified and token bridge deployed, you'll be ready to configure your Orbit chain. Visit [Configure your Orbit chain](/launch-orbit-chain/deploy-an-orbit-chain/configuring-orbit-chain) to complete this final step.

See also[​](#see-also "Direct link to See also")
------------------------------------------------

*   Learn more about the [AnyTrust consensus mechanism](/how-arbitrum-works/anytrust-protocol)
*   Learn more about the [`ERC-20` token bridge architecture](/build-decentralized-apps/token-bridging/token-bridge-erc20)

---

# Supported parent chains | Arbitrum Docs

## Supported parent chains

This page lists the parent chains that are officially supported in Orbit, including mainnets, testnets, and options for local development. While the Orbit SDK provides functionality to enable custom parent chains, support is limited to the chains explicitly listed on this page. Developers are welcome to use the Orbit SDK to configure and deploy custom parent chains; however, such setups, including deploying the required creator and template contracts, are beyond the scope of our official support.

Supported Chains Only

Please note that we cannot guarantee compatibility or offer assistance for custom configurations outside of the supported chains detailed below.

#### Supported chains[​](#supported-chains "Direct link to Supported chains")

*   **Ethereum Mainnet**  
    **Chain ID:** `1`
    
*   **Arbitrum One**  
    **Chain ID:** `42161`
    
*   **Arbitrum Nova**  
    **Chain ID:** `42170`
    
*   **Base**  
    **Chain ID:** `8453`
    
*   **Sepolia**  
    **Chain ID:** `11155111`
    
*   **Holesky**  
    **Chain ID:** `17000`
    
*   **Arbitrum Sepolia**  
    **Chain ID:** `421613`
    
*   **Base Sepolia**  
    **Chain ID:** `84531`
    
*   **Nitro Testnode L1**  
    **Chain ID:** `1337`
    
*   **Nitro Testnode L2**  
    **Chain ID:** `412346`
    
*   **Nitro Testnode L3**  
    **Chain ID:** `333333`
    

### Adding custom parent chains[​](#adding-custom-parent-chains "Direct link to Adding custom parent chains")

Although Orbit primarily supports a predefined set of chains, it provides developers with the flexibility to add custom parent chains through [the `registerCustomParentChain` function of the Orbit SDK](https://github.com/OffchainLabs/arbitrum-orbit-sdk/blob/729facd4d50156d7a84cf1204552c900eb86655c/src/chains.ts#L102). This capability enables integration with chains beyond the officially supported list, offering opportunities for customization and expanding the Orbit ecosystem.

However, adding a custom chain requires deploying essential contracts, such as the creator contract and template contract, on the target chain. These contracts are fundamental for ensuring the proper functioning of the Orbit framework on the custom chain.

---

# Additional configuration parameters: Orbit chains | Arbitrum Docs

## Additional configuration parameters: Orbit chains

The following configuration parameters can be used when deploying or managing your Orbit chain:

Parameter

Description

How to set

**Extra challenge period blocks**

Amount of time to wait before a challenge period expires. Like the challenge period parameter, this is measured in blocks on the underlying L1 chain, not the base (L2) chain. The default for this parameter is 200 blocks, or roughly 40 minutes.

Either in the `extraChallengeTimeBlocks` field in the `RollupCreator` config, or by calling `Rollup.setExtraChallengeTimeBlocks()`.

**Loser stake escrow**

The address where funds staked by a validator that has lost a challenge are sent to be escrowed. It is recommended that this be set to an address that is controlled by the chain owners or to the burn address if the desire is for escrowed funds to be lost.

Either in the `loserStakeEscrow` field in the `RollupCreator` config, or by calling `Rollup.setLoserStakeEscrow()`.

**WASM module root**

Hash of the WASM module root to be used when validating. The WASM module root is a 32 byte hash usually expressed in hexadecimal which is a merkelization of the replay binary, which is too large to be posted on-chain. This hash is set in the L1 rollup contract to determine the correct replay binary during fraud proofs. Unless the STF has been customized, the default WASM module root in the latest consensus release should be used.

Either in the `wasmModuleRoot` field in the `RollupCreator` confid, or by calling `Rollup.setWasmModuleRoot()`.

**Gas speed limit**

Target gas usage per second, over which the congestion mechanism activates. This parameter is set to 7 million on Arbitrum One and Nova, and alterations to this should be considered carefully, as setting it too high may resuly in state bloat that impacts the performance of the chain.

Call `ArbOwner.setSpeedLimit()` passing in the maximum number of gas units to be executed per second.

**Block gas limit**

Maximum amount of gas that can be consumed by all of the transactions within a block. On Arbitrum One this is set to 30 million. It can comfortably be set higher, but may harm UX as the processing time of a block will increase correspondingly.

Call `ArbOwner.setMaxTxGasLimit()` passing in the maximum number of gas units to be executed per block and transaction.

**Gas price floor**

Minimum gas price and is defaulted to 0.1 gwei. This can be set lower or higher as needed, and will impact the willingness of users to transact on the network.

Either in the `minL2BaseFee` field in the orbit setup script config or by calling `ArbOwner.setMinimumL2BaseFee()` passing in the minimum base fee in wei.

**Network fee account**

Account that will receive the L2 surplus fees. It is recommended this is set to an address controlled by the chain owners, or the burn address if fees are intended to be burned. If set to zero, this defaults to the owner address.

Either in the `networkFeeReceiver` field in the orbit setup script config or by calling `ArbOwner.setNetworkFeeAccount()`.

**Infrastructure fee account**

Account that will receive the L2 base fees. It is recommended this is set to an address controlled by the chain owners, or the burn address if fees are intended to be burned. If set to zero, this defaults to the owner address.

Either in the `infrastructureFeeCollector` field in the orbit setup script config or by calling `ArbOwner.setInfraFeeAccount()`.

**L1 pricing reward recipient**

Address that will receive the rewards from the L1 fees. It is recommended this is set to an address controlled by the chain owners, or the burn address if fees are intended to be burned. By default, this is set to the owner address.

Call `ArbOwner.setL1PricingRewardRecipient()`.

**L1 pricing reward per unit (rate)**

Amount of rewards per unit to send to the L1 pricing reward recipient (multiplied by the unitsAllocated). The default for this parameter is 15 wei.

Call `ArbOwner.setL1PricingRewardRate()` passing in the amount of wei per unit to reward.

**Sequencer inbox maximum time variation**

Boundaries of the sequencer to manipulate blocks and timestamps. The default values are as follows, and are set as such on Arbitrum One:

*   `delayBlocks`: 5760
*   `futureBlocks`: 12
*   `delaySeconds`: 86400
*   `futureSeconds`: 3600

Either in the `sequencerInboxMaxTimeVariation` field in the `RollupCreator` config or by calling `SequencerInbox.setMaxTimeVariation` on the parent chain.

**Force-include period**

Length of the period after which a delayed message can be included into the inbox without any action from the sequencer, measured in L1 block time.

Corresponds to `delayBlocks` and `delaySeconds` in the sequencer inbox maximum time variation above.

**Batch posting minimum frequency**

Maximum time to wait after a transaction is sent to post a batch containing it. Note that if no transactions are sent, no batches will be posted, regardless of this setting. The default setting is 1 hour, and can be set lower but may reduce efficiency in the case of low activity on the Orbit chain.

`--node.batch-poster.max-delay` in the batch poster config.

**Validator node (branch) creation frequency**

Minimum time to wait since the last assertion to post a new assertion, if configured to post new assertions (”MakeNodes”). This is bypassed if there is an incorrect assertion and a dispute needs to be made by making a new assertion. Note that if no new batches are posted (and no force inclusion happens), no new assertions will be posted, regardless of this setting. The default setting is 1 hour and is alterable but should always be greater than the rollup contract's `minimumAssertionPeriod`, which is measured in L1 blocks and is defaulted to 75 blocks, or roughly 15 minutes.

`--node.staker.make-assertion-interval` in the validator config.

---

# Orbit chains: batch poster configuration parameters | Arbitrum Docs

## Orbit chains: batch poster configuration parameters

---

# Configuration parameters: Orbit chains | Arbitrum Docs

## Configuration parameters: Orbit chains

---

# Configuration: fast block times | Arbitrum Docs

## Configuration: fast block times

---

# Orbit chains: sequencer configuration parameters | Arbitrum Docs

## Orbit chains: sequencer configuration parameters

---

# Smart contract size limit | Arbitrum Docs

## Smart contract size limit

---

# Start your journey into Orbit | Arbitrum Docs

## Start your journey into Orbit

---

# How to adopt the bridged USDC standard on your Orbit chain | Arbitrum Docs

## How to adopt the bridged USDC standard on your Orbit chain

Circle’s [Bridged USDC Standard](https://www.circle.com/blog/bridged-usdc-standard) is a specification and process for deploying a bridged form of USDC on EVM blockchains with optionality for Circle to seamlessly upgrade to native issuance in the future.

Why adopt the bridged USDC standard?[​](#why-adopt-the-bridged-usdc-standard "Direct link to Why adopt the bridged USDC standard?")
-----------------------------------------------------------------------------------------------------------------------------------

When USDC is bridged into an Orbit chain, the default path is to use the chain’s [canonical gateway contracts for ERC-20s](/build-decentralized-apps/token-bridging/token-bridge-erc20). By way of example, when a user bridges USDC from Arbitrum One to an Orbit chain, their Arbitrum One USDC tokens are locked into the Orbit chain’s parent side bridge, and a representative USDC token is minted to the user’s address on the Orbit chain, via the child side bridge.

The challenge with this user flow is twofold.

1.  **Native vs. non-Native USDC:** The USDC tokens issued by Circle (’native USDC’) are locked in the parent side bridge contract. Conversely, the USDC tokens on the Orbit chain aren’t native USDC but are collateralized by the locked tokens in the bridge. As such, Circle will not recognize these tokens across their product suite.
2.  **Fragmented UX:** If Circle were to provide native support for USDC by deploying a USDC contract on the Orbit chain, there would be two forms of USDC on the chain (native and non-native USDC). This leads to a fragmented user experience, and users with non-native USDC would have to withdraw to the parent chain to be able to turn their tokens into native USDC.

By deploying the bridged USDC standard from the start, all USDC tokens that are bridged are locked in a gateway contract that can be adopted by Circle should a chain upgrade its USDC into native USDC. This allows USDC adoption on Orbit chains today without encountering either of the two problems above.

How to implement the bridged USDC Standard[​](#how-to-implement-the-bridged-usdc-standard "Direct link to How to implement the bridged USDC Standard")
------------------------------------------------------------------------------------------------------------------------------------------------------

We provide a custom USDC gateway implementation (for parent and child chains) that follows the Bridged USDC Standard. These contracts can be used by new Orbit chains. This solution will NOT be used in existing Arbitrum chains that are governed by the DAO.

*   On a parent chain the contract `L1USDCGateway` is used in case the child chain uses ETH as native currency, or `L1OrbitUSDCGateway` in case the child chain uses a custom fee token.
*   On a child chain, `L2USDCGateway` is used.
*   For the USDC token contracts, Circle's reference [implementation](https://github.com/circlefin/stablecoin-evm/blob/master/doc/bridged_USDC_standard.md) is used.

This page describes how to deploy a USDC bridge compatible with both the Orbit token bridge and Circle’s Bridged USDC Standard.

Steps for a transition to native USDC issuance are also provided. Note that both Circle and the Orbit chain owner must agree to transition to native USDC issuance.

Requirements[​](#requirements "Direct link to Requirements")
------------------------------------------------------------

*   Recommended token bridge version 1.2.0
*   No additional dependencies with Nitro or Nitro contract version

Other requirements:

*   It is assumed there is already a USDC token deployed and used on the parent chain.
*   Also, it is assumed that the standard Orbit chain ownership system is used, i.e., `UpgradeExecutor` is the owner of the `ownable` contracts, and there is an EOA or multi-sig that has the executor role on the `UpgradeExecutor`.
*   Refer to the [token bridge overview page](/launch-orbit-chain/deploy-an-orbit-chain/deploying-token-bridge) for more information about the token bridge design and operational dynamics. You can learn more in our [overview of gateways operating models](/build-decentralized-apps/token-bridging/token-bridge-erc20#other-flavors-of-gateways).

Deployment steps[​](#deployment-steps "Direct link to Deployment steps")
------------------------------------------------------------------------

Throughout the docs and code, the terms `L1` and `L2` are used interchangeably with `parent chain` and `child chain`. They have the same meaning, i.e., if an Orbit chain is deployed on top of ArbitrumOne, then ArbitrumOne is `L1`/`parent chain`, while Orbit is `L2`/`child chain`.

You can find more details by consulting the [usdc bridge deployment script and its README](https://github.com/OffchainLabs/token-bridge-contracts/tree/v1.2.3/scripts/usdc-bridge-deployment).

Checkout target code, install dependencies, and build

```rust
cd token-bridge-contracts
yarn install
yarn build
```

Populate your `.env` file based on `env.example` in the project's root directory

```rust
PARENT_RPC=
PARENT_DEPLOYER_KEY=
CHILD_RPC=
CHILD_DEPLOYER_KEY=
L1_ROUTER=
L2_ROUTER=
INBOX=
L1_USDC=
## OPTIONAL arg. If set, the script will register the gateway. Otherwise, it will store the transaction's payload in a file
ROLLUP_OWNER_KEY=
```

Run the script

```rust
yarn deploy:usdc-token-bridge
```

The script will do the following:

*   load deployer wallets for L1 and L2
*   register L1 and L2 networks in SDK
*   deploy new L1 and L2 proxy admins
*   deploy bridged (L2) USDC using the Circle's implementation
*   init L2 USDC
*   deploy L1 USDC gateway
*   deploy L2 USDC gateway
*   init both gateways
*   if `ROLLUP_OWNER_KEY` is provided, register the gateway in the router through the UpgradeExecutor
*   if `ROLLUP_OWNER_KEY` is not provided, prepare calldata and store it in the `registerUsdcGatewayTx.json` file
*   set minter role to L2 USDC gateway with max allowance

Now, new USDC gateways can be used to deposit/withdraw USDC. Everything is now in place to support transition to native USDC issuance if Circle and the Orbit chain owner agree to it.

Transitioning to native USDC[​](#transitioning-to-native-usdc "Direct link to Transitioning to native USDC")
------------------------------------------------------------------------------------------------------------

Once a transition to native USDC is agreed upon, the following steps are required:

*   L1 gateway owner pauses deposits on the parent chain by calling `pauseDeposits()`
*   L2 gateway owner pauses withdrawals on the child chain by calling `pauseWithdrawals()`
*   master minter removes the minter role from the child chain gateway
    *   NOTE: there should be no in-flight deposits when the minter role is revoked. If there are any, they should be finalized first. Anyone can do that by claiming the failed retryable tickets that execute a USDC deposit
*   L1 gateway owner sets Circle's account as burner on the parent chain gateway using `setBurner(address)`
*   L1 gateway owner reads the total supply of USDC on the child chain and then invokes `setBurnAmount(uint256)` on the parent/child gateway where the amount matches the total supply
*   USDC `masterMinter` gives the minter role with `0` allowance to the L1 gateway so that the burn can be executed
*   on the child chain, the L2 gateway owner calls the `setUsdcOwnershipTransferrer(address)` to set the account (provided and controlled by Circle), which will be able to transfer the bridged USDC ownership and proxy admin
*   if not already owned by the gateway, the L2 USDC owner transfers ownership to the gateway, and proxy admin transfers admin rights to the gateway
*   Circle uses the `usdcOwnershipTransferrer` account to trigger `transferUSDCRoles(address)`, which will set the caller as USDC proxy admin and will transfer USDC ownership to the provided address
*   Circle calls `burnLockedUSDC()` on the L1 gateway using the `burner` account to burn the `burnAmount` of USDC
    *   remaining USDC will be cleared off when remaining in-flight USDC withdrawals are executed, if any
    *   The L1 gateway owner is trusted to not front-run this transaction to modify the burning amount

---

# Integrations | Arbitrum Docs

## Integrations

Compatible third-party integrations[​](#compatible-third-party-integrations "Direct link to Compatible third-party integrations")
---------------------------------------------------------------------------------------------------------------------------------

LayerZero OFT[​](#layerzero-oft "Direct link to LayerZero OFT")
---------------------------------------------------------------

xERC20 Gateway[​](#xerc20-gateway "Direct link to xERC20 Gateway")
------------------------------------------------------------------

---

# Third-party Orbit infrastructure providers | Arbitrum Docs

## Third-party Orbit infrastructure providers

This document provides an overview of third-party Orbit chain infrastructure providers that support production-grade Orbit chain deployments. Note that this list is not exhaustive, and will be continuously updated as the Orbit ecosystem evolves.

Rollup-as-a-Service (RaaS) providers[​](#rollup-as-a-service-raas-providers "Direct link to Rollup-as-a-Service (RaaS) providers")
----------------------------------------------------------------------------------------------------------------------------------

For most production use-cases, we encourage Orbit chain operators to work with one of the following RaaS (Rollup as a Service) providers. These providers manage the infrastructure required to maintain high-performance, secure Orbit chain deployments:

*   [QuickNode](https://www.quicknode.com/rollup?utm_source=arb-docs)
*   [Caldera](https://www.caldera.xyz/)
*   [Conduit](https://conduit.xyz/)
*   [AltLayer](https://altlayer.io/)
*   [Gelato](https://www.gelato.network/)
*   [Asphere](https://www.ankr.com/rollup-as-a-service-raas)
*   [Alchemy](https://www.alchemy.com/rollups)
*   [Zeeve](https://www.zeeve.io)

Chain explorers[​](#chain-explorers "Direct link to Chain explorers")
---------------------------------------------------------------------

Chain explorers let you view transactions, blocks, addresses, and network activity associated with your Orbit chain. The following explorers support Orbit chains, and can be used to monitor and analyze your chain's activity:

*   [Blockscout](https://www.blockscout.com/)
*   [Socialscan](https://socialscan.io/)
*   [Lore](https://www.lorescan.com/)
*   [Routescan](https://routescan.io/)

Additionally, Orbit chains leveraging blobs for data availability may use tools like [Blobscan](https://blobscan.com/) to see which blob/block includes a given transaction.

Bridges[​](#bridges "Direct link to Bridges")
---------------------------------------------

You can easily launch an Orbit chain with a canonical token bridge, which allows transfers to and from the chain via , , or the parent chain to which your Orbit chain settles transactions.

For applications that require the ability to transfer assets to chains outside of the Orbit ecosystem or in an expedited manner (without waiting for complete finality), the following third-party bridging providers can be used:

*   [LayerZero](https://layerzero.network/)
*   [Connext](https://www.connext.network/)
*   [Hyperlane](https://www.hyperlane.xyz/)
*   [Axelar](https://axelar.network/)
*   [Across](https://across.to/)
*   [Decent](https://www.decent.xyz/)

Data availability providers for AnyTrust Chains[​](#data-availability-providers-for-anytrust-chains "Direct link to Data availability providers for AnyTrust Chains")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

AnyTrust protocol offers native support data availability. If you are turning on Fast Withdrawals, we recommend having at least 3 members as part of your Data Availability Committee. Here are some providers we recommend:

*   [Chainbase](https://chainbase.com/)
*   [Ankr](https://www.ankr.com/)
*   [Kiln](https://www.kiln.fi/)
*   [Chainstack](https://chainstack.com/)
*   [Nansen](https://www.nansen.ai/)
*   [Unifra](https://unifra.io/)
*   [BCW Group](https://bcw.group/)
*   [Caldera](https://www.caldera.xyz/)

Indexers[​](#indexers "Direct link to Indexers")
------------------------------------------------

Indexers provide a convenient way to retrieve historic or application-specific data without having to interface with your chain through an RPC endpoint. The following third-party providers offer indexing services that can be used with Orbit chains:

*   [Alchemy](https://www.alchemy.com/)
*   [Chainstack](https://chainstack.com/)
*   [Goldsky](https://goldsky.com/)
*   [Ormi](https://www.ormilabs.xyz/)
*   [The Graph](https://thegraph.com/)
*   [Traceye](https://traceye.io/)
*   [QuickNode](https://www.quicknode.com/streams?utm_source=arb-docs)
*   [Sequence](https://sequence.xyz/indexer)

Oracles[​](#oracles "Direct link to Oracles")
---------------------------------------------

The following Oracle providers can be used to integrate off-chain data with your Orbit chain's smart contracts:

*   [Chainlink](https://chain.link/)
*   [Chronicle](https://chroniclelabs.org/)
*   [Pyth](https://pyth.network/)
*   [Redstone](https://redstone.finance/)
*   [Randomizer](http://Randomizer.ai) (VRF only)
*   [Supra](https://supra.com/)
*   [RedStone](https://redstone.finance/)

RPC endpoints[​](#rpc-endpoints "Direct link to RPC endpoints")
---------------------------------------------------------------

RPC endpoints are the primary interface through which users and developers interact with any chain, whether it be for transaction submission, reading state, or indexing historical data. The following third-party providers offer RPC endpoint services compatible with Orbit chains:

*   [Alchemy](https://www.alchemy.com/)
*   [Ankr](https://www.ankr.com/)
*   [Chainstack](https://chainstack.com/)
*   [QuickNode](https://www.quicknode.com?utm_source=arb-docs)
*   [Sequence](https://sequence.xyz/node-gateway)

Alternative data availability[​](#alternative-data-availability "Direct link to Alternative data availability")
---------------------------------------------------------------------------------------------------------------

One way to reduce transaction fees for Orbit chains is to configure a Data Availability (DA) solution that stores chain data off-chain. Although the AnyTrust protocol offers native support for this functionality (and is configurable by default on Orbit AnyTrust chains), the following third-party providers give you another way to store data off-chain. Note that using these services will limit your chain's ability to leverage AnyTrust protocol improvements as they relate to transaction fee and DA configurability:

*   [Celestia](https://celestia.org/)
*   [EigenDA](https://www.eigenlayer.xyz/)
*   [AvailDA](https://www.availproject.org/)
*   [EspressoDA](https://docs.espressosys.com/network)
*   [Near](https://near.org/data-availability) (coming soon)

---

# Contribute docs | Arbitrum Docs

## Contribute docs

Thank you for considering to contribute to the Arbitrum documentation! We're excited to have you on board.

The [`docs.arbitrum.io`](https://docs.arbitrum.io/) docs portal is the **single source of truth** for documentation that supports Offchain Labs' product portfolio. Contributions are welcome from the entire Ethereum community.

This document shows you how to craft and publish Arbitrum documentation. Familiarity with [Markdown](https://www.markdownguide.org/basic-syntax/) syntax, Github, and [Docusaurus](https://docusaurus.io/docs) is expected.

### Add a new core document[​](#add-a-new-core-document "Direct link to Add a new core document")

If a document isn't in a `Third-party content` sidebar node, it's a **core document**. To contribute a new core doc:

1.  Begin by creating a branch (internal) or fork (external) of the [Arbitrum docs repo](https://github.com/OffchainLabs/arbitrum-docs).
2.  Issue a `Draft` pull request into `master`. Pull requests into `master` generate a preview of your changes via a PR-specific Docusaurus deployment; this preview will update as you push commits to your remote.
3.  Include answers to the following questions in your PR description:
    
    ```rust
    1. Audience: Who am I writing for?
    2. Problem: What specific problem are they trying to solve?
    3. Discovery: How are they looking for a solution to this problem? What search terms are they using?
    4. Document type: Which document type is most suitable?
    5. Policy acknowledgment (Third-party docs only): Do you agree to the third-party content policy outlined within "Contribute docs"?
    ```
    
4.  As you craft your contribution, refer to the [document types](#document-type-conventions), [Style guidance](#style-conventions), and other conventions below.
5.  Mark your PR as `Open` when it's ready for review.

### Add a new third-party document[​](#add-a-new-third-party-document "Direct link to Add a new third-party document")

**Third-party docs** are documents that help readers of Arbitrum docs use other products, services, and protocols (like the ones listed in the [Arbitrum portal](https://portal.arbitrum.io/)) with Arbitrum products.

See [Contribute third-party docs](/for-devs/third-party-docs/contribute) for detailed instructions.

### Request an update[​](#request-an-update "Direct link to Request an update")

If you'd like to request an update or share a suggestion related to an **existing document** without submitting a pull request to implement the improvement yourself, click the `Request an update` button located at the top of each published document. This button will lead you to a prefilled Github issue that you can use to elaborate on your request or suggestion.

### Add a new translation page[​](#add-a-new-translation-page "Direct link to Add a new translation page")

If you would like to participate in translating the Arbitrum docs, you can:

1.  Check whether `/website/i18n` has a corresponding language (currently there are `ja` and `zh`). If not, you can use the following command to add it (we take adding French as an example):

```rust
cd ./website
npm run write-translations -- --locale fr
```

It will help generate folder `website/i18n/fr`.

2.  Create the folders `current` and `translated` under the newly generated folder `website/i18n/fr/docusaurus-plugin-content-docs`:

```rust
mkdir i18n/{Your_language}/docusaurus-plugin-content-docs/current && mkdir i18n/{Your_language}/docusaurus-plugin-content-docs/translated
```

3.  Translate one of more docs files located in `/arbitrum-docs`.
    
4.  Place the translated document into the folder `i18n/{Your_language}/docusaurus-plugin-content-docs/translated` according to its relative path in `arbitrum-docs`. For example, if you translated `/arbitrum-docs/how-arbitrum-works/arbos/introduction.md`, then its path in i18n should be `i18n/{Your_language}/docusaurus-plugin-content-docs/translated/how-arbitrum-works/arbos/introduction.md`.
    

Test run:

1.  Check that the i18n settings in `website/docusaurus.config.js` have included your new language:

```rust
i18n: {
    defaultLocale: 'en',
    // locales: ['en', 'ja', 'zh'],
    locales: ['en'], // You can add your new language to this array
  },
```

2.  Check whether the `locale Dropdown` component exists in navbar, if not, add it:

```rust
navbar: {
    title: 'Arbitrum Docs',
    logo: {
        alt: 'My Site Logo',
        src: 'img/logo.svg',
        href: '/welcome/arbitrum-gentle-introduction',
    },
    items: [
        // note:  we can uncomment this when we want to display the locale dropdown in the top navbar
        //        if we enable this now, the dropdown will appear above every document; if `ja` is selected for a document that isn't yet translated, it will 404
        //        there may be a way to show the dropdown only on pages that have been translated, but that's out of scope for the initial version
        {
        type: 'localeDropdown',
        position: 'right',
        }
    ],
},
```

2.  Build translation and docs:

```rust
yarn build_translation && yarn build
```

6.  Start docs:

```rust
npm run serve
```

  

* * *

### Document type conventions[​](#document-type-conventions "Direct link to Document type conventions")

Every document should be a specific _type_ of document. Each type of document has its own purpose:

Document type

Purpose

Gentle introduction

Onboard a specific reader audience with tailored questions and answers

Quickstart

Onboard a specific reader audience with step-by-step "learn by doing" instructions

| How-to | Provide task-oriented procedural guidance | | Concept | Explain what things are and how they work | | FAQ | Address frequently asked questions | | Troubleshooting | List common troubleshooting scenarios and solutions | | Reference | Lists and tables of things, such as API endpoints and developer resources |

This isn't an exhaustive list, but it includes most of the document types that we use.

### Style conventions[​](#style-conventions "Direct link to Style conventions")

The following style guidelines provide a number of loose recommendations that help us deliver **a consistent content experience** across our docs:

1.  **Casing**
    *   Sentence-case "content labels": document titles, sidebar titles, menu items, section headers, etc.
2.  **Linking**
    *   Avoid anchoring links to words like "here" or "this". Descriptive anchor text can help set expectations for readers who may hesitate to click on ambiguous links. When linking to docs, try to link to the document's title verbatim.
3.  **Titling**
    *   Titles should balance brevity with precision - _Node running overview_ is preferred to _Overview_. This helps with SEO and reader UX.
4.  **Separate procedural from conceptual (most of the time)**
    *   Within procedural docs like how-tos and quickstarts, avoid including too much conceptual content. Provide only the conceptual information that the target reader _needs_ in order to complete the task at hand. Otherwise, organize conceptual information within conceptual docs, and link to them "just in case" from other docs.
5.  **Voice**
    *   Address the reader as "you".
    *   Write like you'd speak to a really smart friend who's in a rush.
    *   Opt for short, clear sentences that use translation-friendly, plain language.
    *   Use contractions wherever it feels natural - this can help convey a friendly and conversational tone.
6.  **Formality**
    *   Don't worry too much about formality. The most valuable writing is writing that provides value to readers, and readers generally want to "flow" through guidance.
    *   Aim at "informal professionalism" that prioritizes **audience-tailored problem-solving** and **consistent style and structure**.
7.  **Targeting**
    *   Don't try to write for everyone; write for a _specific reader persona_ (also referred to as "audience" in this document) who has a _specific need_.
    *   Make assumptions about prior knowledge (or lack thereof) and make these assumptions explicit in the beginning of your document.
8.  **Flow**
    *   **Set expectations**: Begin documents by setting expectations. Who is the document for? What value will it provide to your target audience? What assumptions are you making about their prior knowledge? Are there any prerequisites?
    *   **Value up front**: Lead with what matters most to the reader persona you're targeting. Then, progressively build a bridge that carries them towards task completion as efficiently as possible.
9.  **Cross-linking**
    *   We want to maintain both **high discoverability** and **high relevance**. As a general rule of thumb, links to other docs should be "very likely to be useful for most readers". Every link is a subtle call to action; we want to avoid CTA overload.
10.  **Things to avoid**
    *   **Symbols where words will do**: Minimize usage of `&` and `/` - spell out words like "_and_" and "_or_".
    *   **Jargon**: Using precise technical terminology is ok, as long as your target audience is likely to understand the terminology. When in doubt, opt for clear, unambiguous, _accessible_ language.

Don't stress too much about checking off all of these boxes; we periodically review and edit our most heavily-trafficked docs, bringing them up to spec with the latest style guidelines.

Some important disclaimers:

*   **This isn't an exhaustive list**. These are just the min-bar guidelines that will be applied to all new content moving forward.
*   **Many of our docs don't yet follow this guidance**. Our small-but-mighty team is working on it! If you notice an obvious content bug, feel free to submit an [issue](https://github.com/OffchainLabs/arbitrum-docs/issues) or [PR](https://github.com/OffchainLabs/arbitrum-docs/pulls).

### Banner conventions[​](#banner-conventions "Direct link to Banner conventions")

You can use banners (Docusaurus refers to them as ["admonitions"](https://docusaurus.io/docs/markdown-features/admonitions)) to set expectations for your readers and to emphasize important callouts. Use these conservatively, as they interrupt the flow of the document.

#### Under construction banner[​](#under-construction-banner "Direct link to Under construction banner")

Example:

UNDER CONSTRUCTION

The following steps are under construction and will be updated with more detailed guidance soon. Stay tuned, and don't hesitate to click the `Request an update` at the top of this document if you have any feedback along the way.

Usage:

```rust
:::caution[UNDER CONSTRUCTION]

The following steps are under construction and will be updated with more detailed guidance soon. Stay tuned, and don't hesitate to click the `Request an update` at the top of this document if you have any feedback along the way.

:::
```

  

#### Community member contribution banner[​](#community-member-contribution-banner "Direct link to Community member contribution banner")

Example:

Community member contribution

The following document was contributed by @todo-twitter-handle. Give them a shoutout if you find it useful!

Usage:

```rust
:::info[Community member contribution]

The following document was contributed by @todo-twitter-handle. Give them a shoutout if you find it useful!

:::
```

### Frequently asked questions[​](#frequently-asked-questions "Direct link to Frequently asked questions")

#### Can I point to my product from core docs? For example - if my product hosts a public RPC endpoint, can I add it to your [RPC endpoints and providers](/build-decentralized-apps/reference/node-providers) page?[​](#can-i-point-to-my-product-from-core-docs-for-example---if-my-product-hosts-a-public-rpc-endpoint-can-i-add-it-to-your-rpc-endpoints-and-providers-page "Direct link to can-i-point-to-my-product-from-core-docs-for-example---if-my-product-hosts-a-public-rpc-endpoint-can-i-add-it-to-your-rpc-endpoints-and-providers-page")

These types of contributions are generally **not merged** unless they're submitted by employees of Offchain Labs.

Instead of opening a PR for this type of contribution, click the `Request an update` button at the top of the published document to create an issue. Generally, third-party services are included in core docs only if we can confidently assert that the services are "**trustworthy, highly relevant to the core document at hand, and battle-tested by Arbitrum developers**" under a reasonable scrutiny.

#### How long does it take for my third-party content contribution to be reviewed?[​](#how-long-does-it-take-for-my-third-party-content-contribution-to-be-reviewed "Direct link to How long does it take for my third-party content contribution to be reviewed?")

Our small-but-mighty team is continuously balancing competing priorities, so we can't guarantee a specific turnaround time for third-party docs PRs. They're processed in the order in which they're received, generally within a week or two.

#### Is there any way to expedite third-party content contribution reviews?[​](#is-there-any-way-to-expedite-third-party-content-contribution-reviews "Direct link to Is there any way to expedite third-party content contribution reviews?")

The most effective way to expedite processing is to ensure that your PR incorporates the conventions outlined in this document. Please don't ask for status updates - if you've submitted a PR, it's on our radar!

---

# Arbitrum FAQ | Arbitrum Docs

## Arbitrum FAQ

### Why do I need ETH to use the Arbitrum network?[​](#why-do-i-need-eth-to-use-the-arbitrum-network "Direct link to Why do I need ETH to use the Arbitrum network?")

ETH is the currency used to pay gas fees on Arbitrum, and all Arbitrum transactions are powered by ETH. You can bridge ETH (and other tokens) from Ethereum to Arbitrum through **[Arbitrum's bridge](https://bridge.arbitrum.io/)**.

### Do I need to pay a tip or priority fee for my Arbitrum transactions?[​](#do-i-need-to-pay-a-tip-or-priority-fee-for-my-arbitrum-transactions "Direct link to Do I need to pay a tip or priority fee for my Arbitrum transactions?")

Since transactions are processed in the order that the Sequencer receives them, no priority fee is necessary for Arbitrum transactions; if a transaction does include a priority fee, it will be refunded to the transaction's origin address at the end of the execution.

### How can I see the balance of ETH and other tokens in my wallet on Arbitrum?[​](#how-can-i-see-the-balance-of-eth-and-other-tokens-in-my-wallet-on-arbitrum "Direct link to How can I see the balance of ETH and other tokens in my wallet on Arbitrum?")

Most wallets are "connected" to one given network at a time. To view your ETH or token balances, ensure that you are connected to the appropriate Arbitrum chain. In MetaMask and OKX Wallet, you can switch networks via the "networks" dropdown. In this dropdown, select your desired network (either Arbitrum One or Arbitrum Nova for our mainnet networks). If your desired network hasn't been added to your wallet yet, you can add it at [](https://bridge.arbitrum.io/)[https://bridge.arbitrum.io/](https://bridge.arbitrum.io/).

### What happens if I send my funds to an exchange that doesn't support Arbitrum?[​](#what-happens-if-i-send-my-funds-to-an-exchange-that-doesnt-support-arbitrum "Direct link to What happens if I send my funds to an exchange that doesn't support Arbitrum?")

If you send the funds and the receiving wallet/exchange doesn't support the Arbitrum network you are sending funds through, there is unfortunately nothing that we can do to recover your funds. You would need to contact the wallet/exchange support and see if they can do anything to help you retrieve the funds.

### Does Arbitrum have a mempool?[​](#does-arbitrum-have-a-mempool "Direct link to Does Arbitrum have a mempool?")

The Arbitrum Sequencer orders transactions on a first come, first served basis; the Sequencer inserts transactions into a queue based on the order they are received and executes them accordingly. This queue thus exists in lieu of a mempool. The Sequencer's queue has no space limit; transactions on the queue will eventually timeout and be discarded if not executed in time. Under normal conditions, the queue is empty, since transactions are executed near-instantaneously.

### What's the difference between Arbitrum Rollup and Arbitrum AnyTrust?[​](#whats-the-difference-between-arbitrum-rollup-and-arbitrum-anytrust "Direct link to What's the difference between Arbitrum Rollup and Arbitrum AnyTrust?")

Arbitrum Rollup is an Optimistic Rollup protocol; it is trustless and permissionless. Part of how these properties are achieved is by requiring all chain data to be posted on layer 1. This means the availability of this data follows directly from the security properties of Ethereum itself, and, in turn, that any party can participate in validating the chain and ensuring its safety. For more information, see [How Arbitrum works](https://docs.arbitrum.io/how-arbitrum-works/a-gentle-introduction).

By contrast, Arbitrum AnyTrust introduces a trust assumption in exchange for lower fees; data availability is managed by a Data Availability Committee (DAC), a fixed, permissioned set of entities. We introduce some threshold, `K`, with the assumption that at least `K` members of the committee are honest. For simplicity, we'll hereby assume a committee of size 20 and a `K` value of 2:

If 19 out of the 20 committee members _and_ the Sequencer are malicious and colluding together, they can break the chain's safety (and, e.g., steal users' funds); this is the new trust assumption.

If anywhere between 2 and 18 of the committee members are well behaved, the AnyTrust chain operates in "Rollup mode"; i.e., data gets posted on L1.

In what should be the common and happy case, however, in which at least 19 of the 20 committee members are well behaved, the system operates without posting the L2 chain's data on L1, and thus, users pay significantly lower fees. This is the core upside of AnyTrust chains over rollups.

Variants of the AnyTrust model in which the new trust assumption is minimized are under consideration; stay tuned.

For more, see [AnyTrust protocol](https://docs.arbitrum.io/how-arbitrum-works/anytrust-protocol).

### How can I check the status of my cross chain message?[​](#how-can-i-check-the-status-of-my-cross-chain-message "Direct link to How can I check the status of my cross chain message?")

You can check the status of _any_ Arbitrum cross chain message at [](https://retryable-dashboard.arbitrum.io/)[https://retryable-dashboard.arbitrum.io/](https://retryable-dashboard.arbitrum.io/) (you will also be able to execute the cross chain message there, if applicable).

You'll need the transaction hash of the "initiating transaction": the L1 transaction hash for an L1-to-L2 message (e.g., a deposit), or the L2 transaction hash for an L2-to-L1 message (e.g., a withdrawal).

If you cross-chain message was initiated from [](https://bridge.arbitrum.io/)[https://bridge.arbitrum.io/](https://bridge.arbitrum.io/), you can also check its status / execute it at that site in the transaction history tab.

### If there is a dispute, can my L2 transaction get reorged / thrown out / "yeeted"?[​](#if-there-is-a-dispute-can-my-l2-transaction-get-reorged--thrown-out--yeeted "Direct link to If there is a dispute, can my L2 transaction get reorged / thrown out / \"yeeted\"?")

Nope; once an Arbitrum transaction is included on L1, there is no way it can be reorged (unless the L1 itself reorgs, of course). A "dispute" involves Validators disagreeing over execution, i.e., the outputted state of a chain. The inputs, however, can't be disputed; they are determined by the Inbox on L1. (See [Transaction Lifecycle](https://docs.arbitrum.io/how-arbitrum-works/transaction-lifecycle))

### ...okay but if there's a dispute, will my transaction get delayed?[​](#okay-but-if-theres-a-dispute-will-my-transaction-get-delayed "Direct link to ...okay but if there's a dispute, will my transaction get delayed?")

The only thing that a dispute can add delay to is the confirmation of L2-to-L1 messages. All other transactions continue to be processed, even while a dispute is still undergoing. (Additionally: in practice, most L2-to-L1 messages represent withdrawals of fungible assets; these can be trustlessly completed _even during a dispute_ via trustless fast "liquidity exit" applications. See [L2-to-L1 Messages](https://docs.arbitrum.io/how-arbitrum-works/l2-to-l1-messaging)).

### Are "Sequencers" the same entities as "Validators"? Can a centralized Sequencer act maliciously (e.g., steal all my money)?[​](#are-sequencers-the-same-entities-as-validators-can-a-centralized-sequencer-act-maliciously-eg-steal-all-my-money "Direct link to Are \"Sequencers\" the same entities as \"Validators\"? Can a centralized Sequencer act maliciously (e.g., steal all my money)?")

No and no!

An Arbitrum Chain's Sequencer(s) and Validators and completely distinct entities, with their own distinct roles.

The [Sequencer](https://developer.arbitrum.io/sequencer) is the entity granted specific privileges over ordering transactions; once the Sequencer commits to an ordering (by posting a batch on Ethereum), it has no say over what happens next (i.e., execution). A malicious/faulty Sequencer can do things like reordering transactions or _temporarily_ delaying a transaction's inclusion — things which could be, to be sure, annoying and bad — but can do nothing to compromise the chain's safety.

The _Validators_ are the ones responsible for the safety of the chain; i.e., making staked claims about the chain state, disputing each other, etc.

Currently, on Arbitrum One, the Sequencer is a centralized entity maintained by Offchain Labs. Eventually, we expect the single Sequencer to be replaced by a distributed committee of Sequencers who come to consensus on transaction ordering. This upgrade will be an improvement; we don't want you to have to trust us not to reorder your transactions. However, it also isn't _strictly_ necessary for Arbitrum One to achieve its most fundamental properties.

In other words: _**An Arbitrum Rollup chain with a centralized Sequencer could theoretically still be trustless!**_

Which is to say — the more important thing than decentralizing the Sequencer, i.e., the thing you ought to care more about — is decentralizing the _Validators_.

Arbitrum One's validator set is currently allowlisted; over time, we expect [governance](https://docs.arbitrum.foundation/) to expand the allowlist and eventually be removed entirely.

For more info see ["State of Progressive Decentralization"](https://docs.arbitrum.foundation/state-of-progressive-decentralization).

### Why was "one week" chosen for Arbitrum One's dispute window?[​](#why-was-one-week-chosen-for-arbitrum-ones-dispute-window "Direct link to Why was \"one week\" chosen for Arbitrum One's dispute window?")

Generally, some amount of time is necessary for the Arbitrum validators to dispute an invalid assertion.

A week is expected to be more than enough time for validators to carry out an interactive dispute, assuming they don't encounter difficulty in getting their transactions included on L1. One week was chosen following the general consensus among the Ethereum research community — as well as other layer 2 projects — to provide enough time for the community to socially coordinate in the case of a coordinated Ethereum-staker censorship attack.

### What's the state of Arbitrum One's decentralization?[​](#whats-the-state-of-arbitrum-ones-decentralization "Direct link to What's the state of Arbitrum One's decentralization?")

See **["State of Progressive Decentralization"](https://docs.arbitrum.foundation/state-of-progressive-decentralization)**, or check out the work of our friends at **[L2BEAT](https://l2beat.com/scaling/risk/)****.**

### Are there any Fiat on-ramps that support Arbitrum?[​](#are-there-any-fiat-on-ramps-that-support-arbitrum "Direct link to Are there any Fiat on-ramps that support Arbitrum?")

Yes, you can find a list of Fiat on-ramps that support Arbitrum [on our portal](https://portal.arbitrum.io/one?categories=fiat-on-ramp).

### How many blocks are needed for a transaction to be confirmed/finalized in Arbitrum?[​](#how-many-blocks-are-needed-for-a-transaction-to-be-confirmedfinalized-in-arbitrum "Direct link to How many blocks are needed for a transaction to be confirmed/finalized in Arbitrum?")

There are two levels of finality in a [transaction lifecycle](https://developer.arbitrum.io/tx-lifecycle):

*   Soft finality: once the Sequencer receives and processes a transaction, it emits a receipt through the Sequencer's feed. At this point, if the Sequencer is trusted, the transaction will not be reordered and the state of the chain after processing the transaction can be determined.
*   Hard finality: at this stage, assuming there's at least one well-behaved active Arbitrum validator, the client can treat their transaction's finality as equivalent to an ordinary Ethereum transaction.

### Where can I find stats for Arbitrum?[​](#where-can-i-find-stats-for-arbitrum "Direct link to Where can I find stats for Arbitrum?")

Although we currently don't maintain any stats dashboard for Arbitrum, you can find many [community created dashboards](https://dune.com/browse/dashboards?q=arbitrum) in Dune.

### Will transactions with a higher "gas price bid" be confirmed first?[​](#will-transactions-with-a-higher-gas-price-bid-be-confirmed-first "Direct link to Will transactions with a higher \"gas price bid\" be confirmed first?")

There is no notion of mempool on Arbitrum, transactions are processed on a first come first served basis by the Sequencer. Thus, the gas price bid parameter does not influence the order in which a transaction is processed.

### Where can I find a list of the current validators of the Arbitrum chains?[​](#where-can-i-find-a-list-of-the-current-validators-of-the-arbitrum-chains "Direct link to Where can I find a list of the current validators of the Arbitrum chains?")

Validation on both Arbitrum One and Arbitrum Nova is currently allow-listed to a committee of public entities. You can see the list of validators **[here](https://docs.arbitrum.foundation/state-of-progressive-decentralization#allowlisted-validators)**. Governance currently has the power to change this status.

### Where can I find the current Data Availability Committee members?[​](#where-can-i-find-the-current-data-availability-committee-members "Direct link to Where can I find the current Data Availability Committee members?")

The Arbitrum Nova chain has a 7-party DAC, whose members can be seen **[here](https://docs.arbitrum.foundation/state-of-progressive-decentralization#data-availability-committee-members)**. Governance has the ability to remove or add members to the committee.

### Can I withdraw my funds from Arbitrum back to Ethereum without going through the Sequencer? What about funds that are in a contract?[​](#can-i-withdraw-my-funds-from-arbitrum-back-to-ethereum-without-going-through-the-sequencer-what-about-funds-that-are-in-a-contract "Direct link to Can I withdraw my funds from Arbitrum back to Ethereum without going through the Sequencer? What about funds that are in a contract?")

Yes, it is possible to permissionlessly send a message from Ethereum to be executed on Arbitrum, while bypassing the Sequencer. You can do this by using the DelayedInbox contract and force-including the message after a certain amount of time has passed (currently ~24 hours). You can find more information about this behavior [here](https://docs.arbitrum.io/sequencer#unhappyuncommon-case-sequencer-isnt-doing-its-job).

Keep in mind that you can execute any message in this way, be it a withdrawal of funds back to Ethereum, or a call to a contract.

You can also find an example of force-inclusion in [this tutorial](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/delayedInbox-l2msg).

### Are there any plans to reduce the time a transaction needs to wait before being able to be force-included from Ethereum into the Arbitrum chain, bypassing the sequencer? (Currently 24 hours)[​](#are-there-any-plans-to-reduce-the-time-a-transaction-needs-to-wait-before-being-able-to-be-force-included-from-ethereum-into-the-arbitrum-chain-bypassing-the-sequencer-currently-24-hours "Direct link to Are there any plans to reduce the time a transaction needs to wait before being able to be force-included from Ethereum into the Arbitrum chain, bypassing the sequencer? (Currently 24 hours)")

The mechanism that allows force-including transactions from Ethereum (bypassing the sequencer) is intended to be used in very rare cases, especially when it is expected that the sequencer will not be operational again, so that users have a way of interacting with Arbitrum in a trustless way.

When using this mechanism, if the sequencer is down for longer than the time window for force-including transactions from Ethereum, the moment it is online again, it can lead to a reorganization of blocks in Arbitrum (it would have received transactions timestamped before the force-included one).

24 hours was chosen because it provides a comfortable period of time for the team running the sequencer infrastructure to fix any bugs that may cause the sequencer to not work. While there aren't any active initiatives to lower that time, the decision ultimately falls in the hands of the Arbitrum DAO, who has discussed the topic in their governance forum ([see here for more information](https://forum.arbitrum.foundation/t/proposal-decrease-censorship-delay-from-24-hours-to-4-hours/13047)).

In any case, we could also analyze why would someone use this mechanism having an honest and functional sequencer. For instance, if the reason is a distrust of the sequencer, a centralised agent as of now, one potential solution could be to [decentralize the sequencer](https://medium.com/@espressosys/offchain-labs-partnership-improving-transaction-ordering-for-arbitrum-technology-chains-beyond-de2b6018acb2) instead of reducing the force-inclusion delay time.

### What is the difference between an L2 block and an assertion?[​](#what-is-the-difference-between-an-l2-block-and-an-assertion "Direct link to What is the difference between an L2 block and an assertion?")

An L2 block is very similar to the concept of an L1 block. These blocks are generated by validator nodes of Arbitrum by executing the state transition function on sequenced transactions. The structure of an L2 block is similar to that of an Ethereum block, with a few differences that you can [see here](https://docs.arbitrum.io/for-devs/concepts/differences-between-arbitrum-ethereum/rpc-methods#blocks).

On the other hand, an assertion is a distinctive block that is transmitted back to L1 to serve as a fingerprint of the most recent state of the Arbitrum chain. It comprises an assertion of the present state root of the Arbitrum chain and other essential information pertaining to withdrawals and challenges. The structure of assertions can be viewed [here](https://github.com/OffchainLabs/nitro/blob/2436da3fbf339ce72b02f761254aff5b86efafac/contracts/src/rollup/Node.sol#L7).

These assertions are also generated by validators, but they are appended to the L1 chain. Other validators can [challenge them](https://docs.arbitrum.io/how-arbitrum-works/interactive-fraud-proofs) during a specific time frame of approximately one week if they discover that the current state hash of the chain varies from the one that was initially claimed. Once the challenge period elapses, the assertion is confirmed on L1.

### Why do Arbitrum chains enforce a speed limit? Isn't it better that the speed grows without limits?[​](#why-do-arbitrum-chains-enforce-a-speed-limit-isnt-it-better-that-the-speed-grows-without-limits "Direct link to Why do Arbitrum chains enforce a speed limit? Isn't it better that the speed grows without limits?")

The transaction lifecycle sets a limit that we have to take into account: validators have to execute each transaction, get the status of the chain, and post an assertion to Ethereum every certain amount of time. If the speed of the chain increases too much, there is a risk that validators won't have enough computation power to process all transactions in a timely manner, and will fall behind on validating them, which would cause the chain to delay confirmations of its state.

---

# Contribute docs | Arbitrum Docs

## Contribute docs

Thank you for considering to contribute to the Arbitrum documentation! We're excited to have you on board.

The [`docs.arbitrum.io`](https://docs.arbitrum.io/) docs portal is the **single source of truth** for documentation that supports Offchain Labs' product portfolio. Contributions are welcome from the entire Ethereum community.

This document shows you how to craft and publish Arbitrum documentation. Familiarity with [Markdown](https://www.markdownguide.org/basic-syntax/) syntax, Github, and [Docusaurus](https://docusaurus.io/docs) is expected.

### Add a new core document[​](#add-a-new-core-document "Direct link to Add a new core document")

If a document isn't in a `Third-party content` sidebar node, it's a **core document**. To contribute a new core doc:

1.  Begin by creating a branch (internal) or fork (external) of the [Arbitrum docs repo](https://github.com/OffchainLabs/arbitrum-docs).
2.  Issue a `Draft` pull request into `master`. Pull requests into `master` generate a preview of your changes via a PR-specific Docusaurus deployment; this preview will update as you push commits to your remote.
3.  Include answers to the following questions in your PR description:
    
    ```rust
    1. Audience: Who am I writing for?
    2. Problem: What specific problem are they trying to solve?
    3. Discovery: How are they looking for a solution to this problem? What search terms are they using?
    4. Document type: Which document type is most suitable?
    5. Policy acknowledgment (Third-party docs only): Do you agree to the third-party content policy outlined within "Contribute docs"?
    ```
    
4.  As you craft your contribution, refer to the [document types](#document-type-conventions), [Style guidance](#style-conventions), and other conventions below.
5.  Mark your PR as `Open` when it's ready for review.

### Add a new third-party document[​](#add-a-new-third-party-document "Direct link to Add a new third-party document")

**Third-party docs** are documents that help readers of Arbitrum docs use other products, services, and protocols (like the ones listed in the [Arbitrum portal](https://portal.arbitrum.io/)) with Arbitrum products.

See [Contribute third-party docs](/for-devs/third-party-docs/contribute) for detailed instructions.

### Request an update[​](#request-an-update "Direct link to Request an update")

If you'd like to request an update or share a suggestion related to an **existing document** without submitting a pull request to implement the improvement yourself, click the `Request an update` button located at the top of each published document. This button will lead you to a prefilled Github issue that you can use to elaborate on your request or suggestion.

### Add a new translation page[​](#add-a-new-translation-page "Direct link to Add a new translation page")

If you would like to participate in translating the Arbitrum docs, you can:

1.  Check whether `/website/i18n` has a corresponding language (currently there are `ja` and `zh`). If not, you can use the following command to add it (we take adding French as an example):

```rust
cd ./website
npm run write-translations -- --locale fr
```

It will help generate folder `website/i18n/fr`.

2.  Create the folders `current` and `translated` under the newly generated folder `website/i18n/fr/docusaurus-plugin-content-docs`:

```rust
mkdir i18n/{Your_language}/docusaurus-plugin-content-docs/current && mkdir i18n/{Your_language}/docusaurus-plugin-content-docs/translated
```

3.  Translate one of more docs files located in `/arbitrum-docs`.
    
4.  Place the translated document into the folder `i18n/{Your_language}/docusaurus-plugin-content-docs/translated` according to its relative path in `arbitrum-docs`. For example, if you translated `/arbitrum-docs/how-arbitrum-works/arbos/introduction.md`, then its path in i18n should be `i18n/{Your_language}/docusaurus-plugin-content-docs/translated/how-arbitrum-works/arbos/introduction.md`.
    

Test run:

1.  Check that the i18n settings in `website/docusaurus.config.js` have included your new language:

```rust
i18n: {
    defaultLocale: 'en',
    // locales: ['en', 'ja', 'zh'],
    locales: ['en'], // You can add your new language to this array
  },
```

2.  Check whether the `locale Dropdown` component exists in navbar, if not, add it:

```rust
navbar: {
    title: 'Arbitrum Docs',
    logo: {
        alt: 'My Site Logo',
        src: 'img/logo.svg',
        href: '/welcome/arbitrum-gentle-introduction',
    },
    items: [
        // note:  we can uncomment this when we want to display the locale dropdown in the top navbar
        //        if we enable this now, the dropdown will appear above every document; if `ja` is selected for a document that isn't yet translated, it will 404
        //        there may be a way to show the dropdown only on pages that have been translated, but that's out of scope for the initial version
        {
        type: 'localeDropdown',
        position: 'right',
        }
    ],
},
```

2.  Build translation and docs:

```rust
yarn build_translation && yarn build
```

6.  Start docs:

```rust
npm run serve
```

  

* * *

### Document type conventions[​](#document-type-conventions "Direct link to Document type conventions")

Every document should be a specific _type_ of document. Each type of document has its own purpose:

Document type

Purpose

Gentle introduction

Onboard a specific reader audience with tailored questions and answers

Quickstart

Onboard a specific reader audience with step-by-step "learn by doing" instructions

| How-to | Provide task-oriented procedural guidance | | Concept | Explain what things are and how they work | | FAQ | Address frequently asked questions | | Troubleshooting | List common troubleshooting scenarios and solutions | | Reference | Lists and tables of things, such as API endpoints and developer resources |

This isn't an exhaustive list, but it includes most of the document types that we use.

### Style conventions[​](#style-conventions "Direct link to Style conventions")

The following style guidelines provide a number of loose recommendations that help us deliver **a consistent content experience** across our docs:

1.  **Casing**
    *   Sentence-case "content labels": document titles, sidebar titles, menu items, section headers, etc.
2.  **Linking**
    *   Avoid anchoring links to words like "here" or "this". Descriptive anchor text can help set expectations for readers who may hesitate to click on ambiguous links. When linking to docs, try to link to the document's title verbatim.
3.  **Titling**
    *   Titles should balance brevity with precision - _Node running overview_ is preferred to _Overview_. This helps with SEO and reader UX.
4.  **Separate procedural from conceptual (most of the time)**
    *   Within procedural docs like how-tos and quickstarts, avoid including too much conceptual content. Provide only the conceptual information that the target reader _needs_ in order to complete the task at hand. Otherwise, organize conceptual information within conceptual docs, and link to them "just in case" from other docs.
5.  **Voice**
    *   Address the reader as "you".
    *   Write like you'd speak to a really smart friend who's in a rush.
    *   Opt for short, clear sentences that use translation-friendly, plain language.
    *   Use contractions wherever it feels natural - this can help convey a friendly and conversational tone.
6.  **Formality**
    *   Don't worry too much about formality. The most valuable writing is writing that provides value to readers, and readers generally want to "flow" through guidance.
    *   Aim at "informal professionalism" that prioritizes **audience-tailored problem-solving** and **consistent style and structure**.
7.  **Targeting**
    *   Don't try to write for everyone; write for a _specific reader persona_ (also referred to as "audience" in this document) who has a _specific need_.
    *   Make assumptions about prior knowledge (or lack thereof) and make these assumptions explicit in the beginning of your document.
8.  **Flow**
    *   **Set expectations**: Begin documents by setting expectations. Who is the document for? What value will it provide to your target audience? What assumptions are you making about their prior knowledge? Are there any prerequisites?
    *   **Value up front**: Lead with what matters most to the reader persona you're targeting. Then, progressively build a bridge that carries them towards task completion as efficiently as possible.
9.  **Cross-linking**
    *   We want to maintain both **high discoverability** and **high relevance**. As a general rule of thumb, links to other docs should be "very likely to be useful for most readers". Every link is a subtle call to action; we want to avoid CTA overload.
10.  **Things to avoid**
    *   **Symbols where words will do**: Minimize usage of `&` and `/` - spell out words like "_and_" and "_or_".
    *   **Jargon**: Using precise technical terminology is ok, as long as your target audience is likely to understand the terminology. When in doubt, opt for clear, unambiguous, _accessible_ language.

Don't stress too much about checking off all of these boxes; we periodically review and edit our most heavily-trafficked docs, bringing them up to spec with the latest style guidelines.

Some important disclaimers:

*   **This isn't an exhaustive list**. These are just the min-bar guidelines that will be applied to all new content moving forward.
*   **Many of our docs don't yet follow this guidance**. Our small-but-mighty team is working on it! If you notice an obvious content bug, feel free to submit an [issue](https://github.com/OffchainLabs/arbitrum-docs/issues) or [PR](https://github.com/OffchainLabs/arbitrum-docs/pulls).

### Banner conventions[​](#banner-conventions "Direct link to Banner conventions")

You can use banners (Docusaurus refers to them as ["admonitions"](https://docusaurus.io/docs/markdown-features/admonitions)) to set expectations for your readers and to emphasize important callouts. Use these conservatively, as they interrupt the flow of the document.

#### Under construction banner[​](#under-construction-banner "Direct link to Under construction banner")

Example:

UNDER CONSTRUCTION

The following steps are under construction and will be updated with more detailed guidance soon. Stay tuned, and don't hesitate to click the `Request an update` at the top of this document if you have any feedback along the way.

Usage:

```rust
:::caution[UNDER CONSTRUCTION]

The following steps are under construction and will be updated with more detailed guidance soon. Stay tuned, and don't hesitate to click the `Request an update` at the top of this document if you have any feedback along the way.

:::
```

  

#### Community member contribution banner[​](#community-member-contribution-banner "Direct link to Community member contribution banner")

Example:

Community member contribution

The following document was contributed by @todo-twitter-handle. Give them a shoutout if you find it useful!

Usage:

```rust
:::info[Community member contribution]

The following document was contributed by @todo-twitter-handle. Give them a shoutout if you find it useful!

:::
```

### Frequently asked questions[​](#frequently-asked-questions "Direct link to Frequently asked questions")

#### Can I point to my product from core docs? For example - if my product hosts a public RPC endpoint, can I add it to your [RPC endpoints and providers](/build-decentralized-apps/reference/node-providers) page?[​](#can-i-point-to-my-product-from-core-docs-for-example---if-my-product-hosts-a-public-rpc-endpoint-can-i-add-it-to-your-rpc-endpoints-and-providers-page "Direct link to can-i-point-to-my-product-from-core-docs-for-example---if-my-product-hosts-a-public-rpc-endpoint-can-i-add-it-to-your-rpc-endpoints-and-providers-page")

These types of contributions are generally **not merged** unless they're submitted by employees of Offchain Labs.

Instead of opening a PR for this type of contribution, click the `Request an update` button at the top of the published document to create an issue. Generally, third-party services are included in core docs only if we can confidently assert that the services are "**trustworthy, highly relevant to the core document at hand, and battle-tested by Arbitrum developers**" under a reasonable scrutiny.

#### How long does it take for my third-party content contribution to be reviewed?[​](#how-long-does-it-take-for-my-third-party-content-contribution-to-be-reviewed "Direct link to How long does it take for my third-party content contribution to be reviewed?")

Our small-but-mighty team is continuously balancing competing priorities, so we can't guarantee a specific turnaround time for third-party docs PRs. They're processed in the order in which they're received, generally within a week or two.

#### Is there any way to expedite third-party content contribution reviews?[​](#is-there-any-way-to-expedite-third-party-content-contribution-reviews "Direct link to Is there any way to expedite third-party content contribution reviews?")

The most effective way to expedite processing is to ensure that your PR incorporates the conventions outlined in this document. Please don't ask for status updates - if you've submitted a PR, it's on our radar!

---

# Frequently asked questions: Run a node | Arbitrum Docs

## Frequently asked questions: Run a node

### How do I run a node?[​](#how-do-i-run-a-node "Direct link to How do I run a node?")

See instructions [here](https://developer.arbitrum.io/node-running/how-tos/running-a-full-node)!

### How to verify the integrity of the Nitro database I currently have?[​](#how--to-verify-the-integrity-of-the-nitro-database-i-currently-have "Direct link to How  to verify the integrity of the Nitro database I currently have?")

We have an accumulator hash on all messages, which means that a message can't be added to the database without the previous message being correct.

To confirm that everything's working properly, you could just make sure that it's [syncing](https://docs.arbitrum.io/node-running/faq#how-can-i-verify-that-my-node-is-fully-synced) and that the latest block is consistent with other Arbitrum nodes; e.g., you could check it against [Arbiscan](https://arbiscan.io/) (note that Arbiscan's search field doesn't support searching by block hash).

### How can I check if the node is running properly and diagnose the issue if it is not?[​](#how-can-i-check-if-the-node-is-running-properly-and-diagnose-the-issue-if-it-is-not "Direct link to How can I check if the node is running properly and diagnose the issue if it is not?")

We have trace-level logging RPC request implemented on our node. You could use it to log all requests and responses at the trace level. (The performance impact of this should be negligible compared to the network overhead of an RPC request in the first place, especially considering that the request/response will only be serialized for logging if that log level is enabled.)

### Why do I need an L1 node to run an Arbitrum node?[​](#why-do-i-need-an-l1-node-to-run-an-arbitrum-node "Direct link to Why do I need an L1 node to run an Arbitrum node?")

On the node syncing stage, Arbitrum nodes read transactions from batches that were previously posted on L1 and have been executed. They then connect to the Sequencer feed to receive new incoming batched transactions that have not yet been posted on L1.

When fully synced, the Arbitrum node uses the State Transition Function (STF) to consume transactions coming from the Sequencer feed and creates a new state. It also waits for the L1 batch to be posted. If the L1 batch that is finalized on L1 is different from what the Sequencer published, the node will change the state based on the L1 batched transactions.

### Can I run an Arbitrum node in p2p mode?[​](#can-i-run-an-arbitrum-node-in-p2p-mode "Direct link to Can I run an Arbitrum node in p2p mode?")

Arbitrum doesn't have a consensus mechanism, so "p2p mode" doesn't apply. For nodes to sync to the latest chain state, they connect to an L1 node to sync the chain's history that's been posted in calldata and connect to the Sequencer feed for the transactions that have yet to be posted in batches. In no case do nodes need to peer up and sync with each other.

### How do I read messages from the Sequencer feed?[​](#how-do-i-read-messages-from-the-sequencer-feed "Direct link to How do I read messages from the Sequencer feed?")

Running an Arbitrum relay locally as a [Feed Relay](https://docs.arbitrum.io/node-running/how-tos/running-a-feed-relay) lets you subscribe to the Sequencer feed for real-time data as the Sequencer accepts and orders transactions off-chain. Visit [How to read the sequencer feed](https://docs.arbitrum.io/node-running/how-tos/read-sequencer-feed) for a detailed how-to.

### How do I run a node locally for development?[​](#how-do-i-run-a-node-locally-for-development "Direct link to How do I run a node locally for development?")

See instructions [here](https://developer.arbitrum.io/node-running/how-tos/local-dev-node).

We recommend running nitro nodes via docker; to compile directly / run without docker, you can follow the steps in [How to build Nitro locally](https://docs.arbitrum.io/node-running/how-tos/build-nitro-locally).

### Is there any way to retrieve pre-Nitro archive data from a Nitro node?[​](#is-there-any-way-to-retrieve-pre-nitro-archive-data-from-a-nitro-node "Direct link to Is there any way to retrieve pre-Nitro archive data from a Nitro node?")

The pre-nitro stack is also referred to as the "classic" stack. Full nitro nodes start with a database that contains the information from the "classic" era.

However, it is not possible for a nitro node to query archive information contained in "classic" blocks right away. To do that, you need to also run a classic node ([instructions here](https://developer.arbitrum.io/node-running/how-tos/running-a-classic-node)) and set the parameter `—node.rpc.classic-redirect=your-classic-node-RPC`.

Keep in mind that this information only applies to Arbitrum One nodes. Arbitrum Nova and Arbitrum Sepolia nodes started with a Nitro stack from the beginning, so they don't have "classic" data.

### How can I verify that my node is syncing at a desirable speed?[​](#how-can-i-verify-that-my-node-is-syncing-at-a-desirable-speed "Direct link to How can I verify that my node is syncing at a desirable speed?")

Syncing speed can vary depending on multiple factors. You can find the minimum hardware requirements to run your node [in this page](https://developer.arbitrum.io/node-running/how-tos/running-a-full-node#minimum-hardware-configuration). You should also verify your network and disk speed, and make sure that the L1 node is running correctly.

### How can I verify that my node is fully synced?[​](#how-can-i-verify-that-my-node-is-fully-synced "Direct link to How can I verify that my node is fully synced?")

You can make an `eth_syncing` RPC call to your node. When a nitro node is fully synced, `eth_syncing` returns the value `false` (just like a normal Geth node).

When a nitro node is still syncing, `eth_syncing` returns a map of values to help understand why the node is not synced. Nitro execution and bottleneck are different from a normal Geth node, so `eth_syncing` output is unique to nitro.

You can find information to understand the output of `eth_syncing` in the [RPC methods](https://docs.arbitrum.io/for-devs/concepts/differences-between-arbitrum-ethereum/rpc-methods#eth_syncing) page.

### Is there an alternative to Docker when running a node?[​](#is-there-an-alternative-to-docker-when-running-a-node "Direct link to Is there an alternative to Docker when running a node?")

We recommend running Nitro nodes via Docker, using the guides provided within our documentation. However, you can try to compile the code directly by following the steps described in [this guide](https://developer.arbitrum.io/node-running/how-tos/build-nitro-locally).

### What are the minimum hardware requirements to run a full node?[​](#what-are-the-minimum-hardware-requirements-to-run-a-full-node "Direct link to What are the minimum hardware requirements to run a full node?")

You can see the minimum hardware configuration [in this section](https://developer.arbitrum.io/node-running/how-tos/running-a-full-node#minimum-hardware-configuration).

### How can I migrate the date of one synced node to a new one?[​](#how-can-i-migrate-the-date-of-one-synced-node-to-a-new-one "Direct link to How can I migrate the date of one synced node to a new one?")

From a fully synced node, you can copy its database (the `.arbitrum` directory in a default setup) to the same database folder of the new node, and it will start from the same state.

Keep in mind that this must be done after a clean shutdown, while the node is not running.

### When querying Classic transactions from a Nitro node, I sometimes get incorrect data, like the zero address as the sender. Why is that?[​](#when-querying-classic-transactions-from-a-nitro-node-i-sometimes-get-incorrect-data-like-the-zero-address-as-the-sender-why-is-that "Direct link to When querying Classic transactions from a Nitro node, I sometimes get incorrect data, like the zero address as the sender. Why is that?")

Some old Nitro genesis database snapshots didn't properly set the retry sender for Classic blocks and contain said error. If you need to access that information, you can either resync your nitro node with one of the [current snapshots](https://snapshot.arbitrum.foundation/index.html), or [run a Classic node](https://docs.arbitrum.io/node-running/how-tos/running-a-classic-node) along with your nitro node and configure a redirection for requests to Classic blocks. Please note that this only happens on Arbitrum One.

---

# How to run a full node for an Orbit chain | Arbitrum Docs

## How to run a full node for an Orbit chain

This how-to provides step-by-step instructions for running an Orbit node on your local machine.

Prerequisites[​](#prerequisites "Direct link to Prerequisites")
---------------------------------------------------------------

Latest Docker Image: `offchainlabs/nitro-node:v3.5.1-8f247fd`

Minimum Hardware Configuration

**RAM**: 8-16 GB

**CPU**: 2-4 core CPU (For AWS: t3 xLarge

**Storage**: Depends on the Orbit chain and its traffic overtime

Required parameters[​](#required-parameters "Direct link to Required parameters")
---------------------------------------------------------------------------------

### 1\. Parent chain parameters[​](#1-parent-chain-parameters "Direct link to 1. Parent chain parameters")

The `parent-chain` argument needs to provide a standard RPC endpoint for an EVM node, whether self-hosted or obtained from a node service provider:

```rust
--parent-chain.connection.url=<Parent chain RPC URL>
```

note

[Public Arbitrum RPC endpoints](/build-decentralized-apps/reference/node-providers#arbitrum-public-rpc-endpoints) rate-limit connections. To avoid hitting a bottleneck, you can run a local node for the parent chain or rely on third-party RPC providers.

### 2\. Child chain parameters[​](#2-child-chain-parameters "Direct link to 2. Child chain parameters")

In the Arbitrum Orbit context, the child chain is an L2 or an L3 Orbit chain, and the required parameters are `chain.info-json` and `chain.name`

#### 1\. `chain.info-json`[​](#1-chaininfo-json "Direct link to 1-chaininfo-json")

`--chain.info-json` is a JSON string that contains required information about the Orbit chain.

```rust
--chain.info-json=<Orbit Chain's chain info>
```

An example of `chain.info-json` is available in the next section.

#### 2\. `chain.name`[​](#2-chainname "Direct link to 2-chainname")

`--chain.name` is a mandatory flag that needs to match the chain name used in `--chain.info-json`:

```rust
--chain.name=<My Arbitrum L3 Chain>
```

#### 3\. `execution.forwarding-target`[​](#3-executionforwarding-target "Direct link to 3-executionforwarding-target")

You need to set the --execution.forwarding-target flag if you are running a regular full node (Not sequencer).

```rust
--execution.forwarding-target=<Your Sequencer node endpoint url>
```

#### 4\. AnyTrust chains[​](#4-anytrust-chains "Direct link to 4. AnyTrust chains")

For , you need to to add the following flags to the command or configuration:

```rust
--node.data-availability.enable
--node.data-availability.rest-aggregator.enable
```

And:

```rust
--node.data-availability.rest-aggregator.urls=<A list of DAS REST endpoints>
```

Or:

```rust
--node.data-availability.rest-aggregator.online-url-list=<A url that returns a list of the DAS REST endpoints>
```

### 3.Important ports[​](#3important-ports "Direct link to 3.Important ports")

Protocol

Port

`RPC`/`http`

`8547`

`RPC`/`websocket`

`8548`

`Sequencer Feed`

`9642`

*   Please note: the `RPC`/`websocket` protocol requires some ports to be enabled, you can use the following flags:
    *   `--ws.port=8548`
    *   `--ws.addr=0.0.0.0`
    *   `--ws.origins=\*`

### 4\. Putting it all together[​](#4-putting-it-all-together "Direct link to 4. Putting it all together")

*   When running a Docker image, an external volume should be mounted to persist the database across restarts. The mount point inside the Docker image should be `/home/user/.arbitrum`
    
*   Example:
    
    ```rust
    docker run --rm -it  -v /some/local/dir/arbitrum:/home/user/.arbitrum -p 0.0.0.0:8547:8547 -p 0.0.0.0:8548:8548 offchainlabs/nitro-node:v3.5.1-8f247fd --parent-chain.connection.url=<Parent chain RPC URL> --chain.id=<OrbitChainId> --chain.name=<My Arbitrum Orbit Chain> --http.api=net,web3,eth --http.corsdomain=* --http.addr=0.0.0.0 --http.vhosts=* --chain.info-json=<Orbit Chain's chain info> --execution.forwarding-targe=<Your Sequencer node endpoint url>
    ```
    
    *   Ensure that `/some/local/dir/arbitrum` already exists otherwise the directory might be created with `root` as owner, and the Docker container won't be able to write to it
        
    *   When using the flag `--chain.info-json=<Orbit Chain's chain info>`, replace `<Orbit Chain's chain info>` with the specific `chain info` JSON string of the Orbit chain for which you wish to run the node:
        
*   Example:
    
    ```rust
    --chain.info-json="[{\"chain-id\":94692861356,\"parent-chain-id\":421614,\"chain-name\":\"My Arbitrum L3 Chain\",\"chain-config\":{\"chainId\":94692861356,\"homesteadBlock\":0,\"daoForkBlock\":null,\"daoForkSupport\":true,\"eip150Block\":0,\"eip150Hash\":\"0x0000000000000000000000000000000000000000000000000000000000000000\",\"eip155Block\":0,\"eip158Block\":0,\"byzantiumBlock\":0,\"constantinopleBlock\":0,\"petersburgBlock\":0,\"istanbulBlock\":0,\"muirGlacierBlock\":0,\"berlinBlock\":0,\"londonBlock\":0,\"clique\":{\"period\":0,\"epoch\":0},\"arbitrum\":{\"EnableArbOS\":true,\"AllowDebugPrecompiles\":false,\"DataAvailabilityCommittee\":false,\"InitialArbOSVersion\":10,\"InitialChainOwner\":\"0xAde4000C87923244f0e95b41f0e45aa3C02f1Bb2\",\"GenesisBlockNum\":0}},\"rollup\":{\"bridge\":\"0xde835286442c6446E36992c036EFe261AcD87F6d\",\"inbox\":\"0x0592d3861Ea929B5d108d915c36f64EE69418049\",\"sequencer-inbox\":\"0xf9d77199288f00440Ed0f494Adc0005f362c17b1\",\"rollup\":\"0xF5A42aDA664E7c2dFE9DDa4459B927261BF90E09\",\"validator-utils\":\"0xB11EB62DD2B352886A4530A9106fE427844D515f\",\"validator-wallet-creator\":\"0xEb9885B6c0e117D339F47585cC06a2765AaE2E0b\",\"deployed-at\":1764099}}]"
    ```
    
*   When shutting down the Docker image, it is important to allow a graceful shutdown so that the current state can be saved to disk. Here is an example of how to do a graceful shutdown of all Docker images currently running
    
    ```rust
    docker stop --time=300 $(docker ps -aq)
    ```
    

### Note on permissions[​](#note-on-permissions "Direct link to Note on permissions")

*   The Docker image is configured to run as non-root `UID 1000`. If you are running Linux or macOS and you are getting permission errors when trying to run the Docker image, run this command to allow all users to update the persistent folders:
    
    ```rust
    mkdir /data/arbitrum
    chmod -fR 777 /data/arbitrum
    ```
    

### Note on Sequencer feed[​](#note-on-sequencer-feed "Direct link to Note on Sequencer feed")

Nitro nodes can be configured to receive real time ordered transactions from the sequencer feed. If you don't set the feed input url, your node will listen to the parent chain's inbox contract to get the ordered transactions, which will cause your node to be unable to synchronize the latest state.

Set the following configurations to your fullnode to make it can receive the sequencer feed:

```rust
--node.feed.input.url=<Sequencer feed url>
```

After that, your node can synchronize the latest state from the sequencer feed.

(Chain owners only) In order for a node to read the sequencer feed, the chain's sequencer needs to be configured with the following parameters:

```rust
--node.feed.output.enable=true --node.feed.output.addr=<Sequencer feed url> --node.feed.output.port=<Sequencer feed port>
```

Optional parameters[​](#optional-parameters "Direct link to Optional parameters")
---------------------------------------------------------------------------------

We show here a list of the parameters that are most commonly used when running your Orbit node. You can also use the flag `--help` for a full comprehensive list of the available parameters.

Flag

Description

`--execution.rpc.classic-redirect=<RPC>`

Redirects archive requests for pre-nitro blocks to this RPC of an Arbitrum Classic node with archive database. Only for Arbitrum One.

`--http.api`

Offered APIs over the HTTP-RPC interface. Default: `net,web3,eth,arb`. Add `debug` for tracing.

`--http.corsdomain`

Accepts cross origin requests from these comma-separated domains (browser enforced).

`--http.vhosts`

Accepts requests from these comma-separated virtual hostnames (server enforced). Default: `localhost`. Accepts `*`.

`--http.addr`

Address to bind RPC to. May require `0.0.0.0` for Docker networking.

`--execution.caching.archive`

Retains past block state. For archive nodes.

`--node.feed.input.url=<feed address>`

Default: `wss://<chainName>.arbitrum.io/feed`. ⚠️ One feed relay per datacenter is advised. See [feed relay guide](/run-arbitrum-node/sequencer/run-feed-relay).

`--execution.forwarding-target=<RPC>`

Defaults to the L2 Sequencer RPC based on provided L1 and L2 chain IDs.

`--execution.rpc.evm-timeout`

Default: `5s`. Timeout for `eth_call`. (0 == no timeout).

`--execution.rpc.gas-cap`

Default: `50000000`. Gas cap for `eth_call`/`estimateGas`. (0 = no cap).

`--execution.rpc.tx-fee-cap`

Default: `1`. Transaction fee cap (in ether) for RPC APIs. (0 = no cap).

`--ipc.path`

Filename for IPC socket/pipe within datadir. 🔉 Not supported on macOS. Note the path is within the Docker container.

`--init.prune`

Prunes database before starting the node. Can be "full" or "validator".

`--init.url="<snapshot file>"`

(Non-Orbit Nitro nodes only) URL to download the genesis database from. Required only for the first startup of an Arbitrum One node. Reference to [snapshots](https://snapshot.arbitrum.foundation/index.html) and [archive node guide](/run-arbitrum-node/more-types/run-archive-node).

`--init.download-path="/path/to/dir"`

(Non-Orbit Nitro nodes only) Temporarily saves the downloaded database snapshot. Defaults to `/tmp/`. Used with `--init.url`.

`--node.batch-poster.post-4844-blobs`

Boolean. Default: `false`. Used to enable or disable the posting of transaction data using Blobs to L1 Ethereum. If using calldata is more expensive and if the parent chain supports EIP4844 blobs, the batch poster will use blobs when this flag is set to `true`. Can be `true` or `false`.

`--node.batch-poster.ignore-blob-price`

Boolean. Default: `false`. If the parent chain supports EIP4844 blobs and `ignore-blob-price` is set to `true`, the batch poster will use EIP4844 blobs even if using calldata is cheaper. Can be `true` or `false`.

`--init.latest`

string. if set, searches for the latest snapshot of the given kind (accepted values: "archive" , "pruned" , "genesis")

`--init.latest-base`

string. Default: "[https://snapshot.arbitrum.foundation/](https://snapshot.arbitrum.foundation/)". Base url used when searching for the latest. (If you are running orbit chains you might need to check with orbit chain team to get the url)

`--init.then-quit`

Allows any `--init.*` parameters to complete, and then the node will automatically quit. It doesn't initiate pruning by itself but works in conjunction with other `--init.*` parameters, making it easier to script tasks like database backups after initialization processes finish.

---

# ArbOS 11 | Arbitrum Docs

## ArbOS 11

ArbOS 11 is shipped via Nitro v2.2.0, which is available on Docker hub with the image tag: `offchainlabs/nitro-node:v2.2.0-f7dc9de`. This release of Nitro is a mandatory upgrade for Arbitrum One and Nova validators. For Arbitrum One and Nova, the ArbOS 11 upgrade requires a governance vote to activate.

Formal release notes can be found [here](https://github.com/OffchainLabs/nitro/releases/tag/v2.2.0).

### Requirements:[​](#requirements "Direct link to Requirements:")

*   [Nitro v2.2.0](https://github.com/OffchainLabs/nitro/releases/tag/v2.2.0) or higher
*   [nitro-contracts v1.1.0](https://github.com/OffchainLabs/nitro-contracts/releases/tag/v1.1.0) or higher
*   Wasm module root: `0x6b94a7fc388fd8ef3def759297828dc311761e88d8179c7ee8d3887dc554f3c3`

### High-level description of ArbOS 11 changes[​](#high-level-description-of-arbos-11-changes "Direct link to High-level description of ArbOS 11 changes")

*   Addition of all EVM changes made on the parent chain Ethereum as part of the [Shanghai upgrade](https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md#included-eips). This includes:
    *   [EIP-3651: Warm COINBASE](https://eips.ethereum.org/EIPS/eip-3651)
    *   [EIP-3855: PUSH0 instruction](https://eips.ethereum.org/EIPS/eip-3855)
    *   [EIP-3860: Limit and meter initcode](https://eips.ethereum.org/EIPS/eip-3860)
    *   [EIP-6049: Deprecate SELFDESTRUCT](https://eips.ethereum.org/EIPS/eip-6049)
*   Improvements and fixes for [retryable tickets](/how-arbitrum-works/l1-to-l2-messaging) to ensure that the fee calculation to redeem retryable tickets will take into account both the infrastructure fee and the network fee. The infrastructure fee is the minimum child chain base fee only, while the network fee collects child chain congestion charges. This is important for [AnyTrust chains](/how-arbitrum-works/anytrust-protocol) like Arbitrum Nova because members of the Data Availability Committee (DAC) gets paid a percentage of the infrastructure fee but not the network fee. Previously, the calculations to determine the fee for redeeming retryable tickets did not consider the infrastructure fee.
*   Fixes an issue where the [`ArbOwnerPublic` precompile](/build-decentralized-apps/precompiles/reference#arbownerpublic) returned the incorrect list of chain owners. This does not change the parties who are able to perform chain owner actions. As intended, only the Arbitrum DAO is able to take chain owner actions for Arbitrum One and Nova.
*   Resolves an issue where the [`arbBlockHash` method](/build-decentralized-apps/precompiles/reference#arbsys) would take up all the gas when reverting. The previous incorrect behavior meant that if a transaction calls `arbBlockHash` with an out-of-range block number, then the transaction would consume all the gas when reverting.
*   Addition of the [`L1RewardReceipient`](/build-decentralized-apps/precompiles/reference#arbgasinfo) and [`L1RewardRate`](/build-decentralized-apps/precompiles/reference#arbgasinfo) precompile methods to view the parent chain pricing parameters and make it easier to view the current chain configuration.
*   Fix the `ArbOwner` precompile to disallow emitting logs in `STATICCALL` contexts, bringing this in line with how the EVM is expected to behave as `STATICCALL` invocations should never be able to emit logs. The previous incorrect behavior would mean that a log was emitted when a chain owner made a `STATICCALL` on the `ArbOwner` precompile.

### Reference links for ArbOS 11[​](#reference-links-for-arbos-11 "Direct link to Reference links for ArbOS 11")

*   [Nitro v2.2.0 Release details on Github](https://github.com/OffchainLabs/nitro/releases/tag/v2.2.0)
*   Original DAO proposal: [AIP: ArbOS Version 11](https://forum.arbitrum.foundation/t/aip-arbos-version-11/19696)
*   [AIP: ArbOS Version 11 Snapshot Vote](https://snapshot.org/#/arbitrumfoundation.eth/proposal/0xa635e39a2c527f7a1eabf5ea22bdec6f4a265d6c69a06076e65fde0ae0a5941b)
*   [Formal Tally (on-chain) vote for AIP: ArbOS Version 11](https://www.tally.xyz/gov/arbitrum/proposal/77069694702187027448745871790562515795432836429094222862498991082283032976814)
*   [ArbOS 11 Audit Report by Trail of Bits](https://drive.google.com/file/d/1N3197Z7DuqBpu9qdt-GWPewe8HQakfLY/view)

---

# ArbOS 20 Atlas | Arbitrum Docs

## ArbOS 20 Atlas

ArbOS 20 Atlas is shipped via Nitro v2.3.1, which is available on Docker hub with the image tag: `offchainlabs/nitro-node:v2.3.1-26fad6f`. This release of Nitro is a mandatory upgrade for Arbitrum One and Nova validators. For Arbitrum One and Nova, the ArbOS 20 upgrade requires a governance vote to activate.

### Requirements:[​](#requirements "Direct link to Requirements:")

*   [Nitro v2.3.1](https://github.com/OffchainLabs/nitro/releases/tag/v2.3.1) or higher
*   [nitro-contracts v1.2.1](https://github.com/OffchainLabs/nitro-contracts/releases/tag/v1.2.1) or higher
*   Wasm module root: `0x8b104a2e80ac6165dc58b9048de12f301d70b02a0ab51396c22b4b4b802a16a4`
*   Access to the [Ethereum Beacon Chain APIs](https://ethereum.github.io/beacon-APIs/#/), either from your own self-managed parent chain Ethereum node or from a 3rd party provider like [those on this list](/run-arbitrum-node/l1-ethereum-beacon-chain-rpc-providers).

### High-level description of ArbOS 20 changes[​](#high-level-description-of-arbos-20-changes "Direct link to High-level description of ArbOS 20 changes")

ArbOS 20 is an upgrade to enable Arbitrum's support for the parent chain Ethereum's [Dencun upgrade](https://eips.ethereum.org/EIPS/eip-7569) scheduled for March 2024. As a result, all of the ArbOS specific changes revolve around implementing the majority of the [Cancun EIPs](https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/cancun.md) on Arbitrum:

*   Enable Arbitrum chains to batch and post transaction data in the form of Blobs to the parent chain Ethereum, to support [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844). This includes updates to the Sequencer Inbox contract to support posting transactions in the form of blobs, updating Nitro's fraud prover to support proving additional hashes (KZG and SHA256 preimages), and updates to the core Nitro node software to handle parsing data from EIP-4844 blobs.
*   Addition of the `TSTORE` and `TLOAD` EVM opcodes introduced in [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153) offering a cheaper option than storage for data that’s discarded at the end of a transaction.
*   Addition of the `MCOPY` EVM opcode introduced in [EIP-5656](https://eips.ethereum.org/EIPS/eip-5656) for cheaper memory copying.
*   Changes to the `SELFDESTRUCT` EVM opcode to reflect the behavior on the parent chain Ethereum, as outlined in [EIP-6780](https://eips.ethereum.org/EIPS/eip-6780).
*   Addition of a batch poster manager role that will have the ability to grant and revoke batch-posting affordances. This role is assigned to the operator of the sequencer to allow the batch poster manager perform key rotations for the batch posters. The DAO will continue to have the ability to revoke the seqauencer role, meaning there is no change to the current system's trust model since the DAO ca update the batch poster manager at any time (along with any batch posters).
*   Increasing the max block height that a batch can be posted, relative to the current block, to 64 bringing this in line with Ethereum's finality guarantees. The current value of 12 was set prior to the Ethereum merge and could mean that a small parent chain reorg can cause an otherwise valid batch to revert.
*   Fix Sequencer Inbox bug: when posting a batch, the Sequencer provides the "newMessageCount” value as a parameter; if the Sequencer is malicious, it can provide the max uint256 value which in turn would make subsequent calls to forceInclusion revert with an overflow error. Atlas’s upgrade to the Sequencer inbox includes a [change](https://github.com/OffchainLabs/nitro-contracts/blob/dcc51066b26b84cb157cbeba2f9f492ab33f9093/src/bridge/SequencerInbox.sol#L327)) in which forceInclusion does not modify the message count, fixing this bug. This bug had been disclosed to Arbitrum RaaS providers and to the Arbitrum DAO Security Council.

### Special notes on ArbOS 20: Atlas support for EIP-4844[​](#special-notes-on-arbos-20-atlas-support-for-eip-4844 "Direct link to Special notes on ArbOS 20: Atlas support for EIP-4844")

*   Upgrading to **the Atlas ArbOS release will require access to the parent chain's Ethereum beacon chain endpoints to retrieve blob data. For nodes of a chain that come online 18 days after Atlas gets activated on their chain will need access to historical data to sync up to the latest state.** If you are not operating your own Ethereum consensus client, [please visit this page to view a list of beacon chain RPC providers](/run-arbitrum-node/l1-ethereum-beacon-chain-rpc-providers) where you can access blob data.
*   Applications on Arbitrum will not have to be modified or take any explicit action to get the benefits of using EIP-4844 (i.e. the whole chain opts-in with ArbOS 20 “Atlas”).
*   ArbOS 20 “Atlas” adds support for Arbitrum chains to send data in a blob storage format to data availability layers, like the parent chain Ethereum, that support the blob transaction type. This includes Arbitrum One and Arbitrum Nova. ArbOS 20 “Atlas” does not add support for Arbitrum chains to receive data in a blob storage format. This means that an L3 Orbit chain on top of an Arbitrum L2 will use calldata when posting L3 transaction data to the underlying L2. The child chain (L2) Arbitrum chain will then be able to post data to a parent chain data availability layer like Ethereum using blobs.
*   There currently aren’t estimates on what the end-user gas savings of using blob data will be. This topic is something being actively worked on and monitored. Without Mainnet data, the estimates for blob gas prices will not be accurate enough to reliably predict the cost reductions that users will experience - and even with Mainnet data, the savings will vary by use case (i.e. no current way to predict the price impacts from all blob gas market participants yet). In general, however, the use of blobs will reduce the cost of using Arbitrum L2s. To learn more about what EIP-4844 will mean for the child chain users, please checkout this [blog post on Medium by Offchain Lab's Co-foudner and Chief Scientist Ed Felten](https://medium.com/offchainlabs/eip-4844-what-does-it-mean-for-l2-users-5e86ebc4c028).

### Block explorers[​](#block-explorers "Direct link to Block explorers")

Below is a non-comprehensive list of explorers that support querying and viewing blob data on Ethereum that get posted by Arbitrum child chain chains.

*   [Blockscout](https://www.blockscout.com/). For self-deployment, blobs are supported as of blockscout v6.2.0 and blockscout-frontend v1.2.6.
*   [Arbiscan](https://arbiscan.io/)
*   [Blobscan](https://blobscan.com/)
*   [Beaconcha.in](https://beaconcha.in/)

### Additional requirement for Arbitrum Orbit L2 chain operators: enabling blob batch posting[​](#additional-requirement-for-arbitrum-orbit-l2-chain-operators-enabling-blob-batch-posting "Direct link to Additional requirement for Arbitrum Orbit L2 chain operators: enabling blob batch posting")

This section maps to [Step 4 in the guide on _How to upgrade ArbOS on your Arbitrum Orbit L2 chain_](/launch-orbit-chain/configure-your-chain/common-configurations/arbos-upgrade#step-4-enable-arbos-specific-configurations-or-feature-flags-not-always-required) and contains additional instructions for Arbitrum Orbit L2 chain operators for ArbOS 20 Atlas. Specifically, the details below are meant to help Arbitrum Orbit L2 chain operators enable blob batch posting to L1 Ethereum following their successful upgrade to the ArbOS 20 Atlas release.

caution

Before proceeding, make sure you have successfully completed Steps 1 through 3 of the guide on [How to upgrade ArbOS on your Orbit chain](/launch-orbit-chain/configure-your-chain/common-configurations/arbos-upgrade).

To enable the posting of transaction data in Blobs to L1 Ethereum, you must set `node.batch-poster.post-4844-blobs=true` on the batch poster.

#### Full list of ArbOS Atlas specific configuration options for Orbit chains[​](#full-list-of-arbos-atlas-specific-configuration-options-for-orbit-chains "Direct link to Full list of ArbOS Atlas specific configuration options for Orbit chains")

Flag

Description

`--node.batch-poster.post-4844-blobs`

Boolean. Default: `false`. Used to enable or disable the posting of transaction data using Blobs to L1 Ethereum. If using calldata is more expensive and if the parent chain supports EIP4844 blobs, the batch poster will use blobs when this flag is set to `true`. Can be `true` or `false`.

`--node.batch-poster.ignore-blob-price`

Boolean. Default: `false`. If the parent chain supports EIP4844 blobs and `ignore-blob-price` is set to `true`, the batch poster will use EIP4844 blobs even if using calldata is cheaper. Can be `true` or `false`.

The above configurations are also available in the [Orbit command line options reference section](/node-running/how-tos/running-an-orbit-node#optional-parameters) and can be set using the command line or using the JSON node configuration below:

```rust
 "node": {
    ...
    "batch-poster": {
    ...
      "post-4844-blobs": true,
      "ignore-blob-price": false,
    ...
    },
  }

```

### Reference links for ArbOS 20 Atlas[​](#reference-links-for-arbos-20-atlas "Direct link to Reference links for ArbOS 20 Atlas")

*   [Nitro v2.3.1 Release details on Github](https://github.com/OffchainLabs/nitro/releases/tag/v2.3.1)
*   Original DAO proposal: [AIP: ArbOS Version 20 "Atlas"](https://forum.arbitrum.foundation/t/aip-arbos-version-20-atlas/20957)
*   [AIP: ArbOS Version 20 "Atlas" Snapshot Vote](https://snapshot.org/#/arbitrumfoundation.eth/proposal/0x813a366e287a872ada13d4f8348e771c7aa2d8c3cb00b2be31539ceab5627513)
*   [Formal Tally (on-chain) vote for AIP: ArbOS Version 20](https://www.tally.xyz/gov/arbitrum/proposal/46905320292877192134536823079608810426433248493109520384601548724615383601450)
*   [ArbOS 20 Atlas Audit Report by Trail of Bits](https://github.com/trailofbits/publications/blob/master/reviews/2024-02-offchainlabsarbos-securityreview.pdf)

---

# ArbOS 32 Bianca | Arbitrum Docs

## ArbOS 32 Bianca

caution

Please upgrade directly to ArbOS 32 from ArbOS 20 and not to ArbOS 30 or ArbOS 31. The ArbOS 32 release builds upon ArbOS 30 and ArBbOS 31 and includes critical fixes & optimizations coming out of rigorous testing and feedback from Stylus teams. ArbOS 32 “Bianca” will be the canonical ArbOS version for the “Bianca” family of releases.

Future versions of Nitro may remove support for Orbit chains which have historically upgraded to, and remain on, ArbOS 30 or ArbOS 31. Due to this, we highly recommend upgrading immediately and directly to ArbOS 32.

The minimum Nitro version that supports ArbOS 32 "Bianca" is [Nitro v3.3.1](https://github.com/OffchainLabs/nitro/releases/tag/v3.3.1), which is available on Docker hub with the image tag: `offchainlabs/nitro-node:v3.3.1-e326369`. This release of Nitro is a mandatory upgrade for Arbitrum One and Nova validators. For Arbitrum One and Nova, the ArbOS 32 "Bianca" upgrade required a governance vote to activate.

Please note that it is important that you only run the Nitro v3.3.1 against trusted databases. If you want to use an untrusted database, you can first remove the `wasm` directory if it exists (it might be inside the `nitro` folder). Otherwise, the database may have malicious, unvalidated code that can result in remote code execution. This is also mitigated by ensuring you run the Arbitrum Nitro node inside Docker.

The Arbitrum docs will remain the canonical home for information regarding ArbOS releases, with more details found on the [ArbOS Software Releases Overview page](/run-arbitrum-node/arbos-releases/overview).

### Requirements:[​](#requirements "Direct link to Requirements:")

*   [Nitro v3.3.1](https://github.com/OffchainLabs/nitro/releases/tag/v3.3.1) or higher
*   [nitro-contracts v2.1.0](https://github.com/OffchainLabs/nitro-contracts/releases/tag/v2.1.0) or higher
*   WASM module root: `0x184884e1eb9fefdc158f6c8ac912bb183bf3cf83f0090317e0bc4ac5860baa39`

### High-level description of ArbOS 32 changes[​](#high-level-description-of-arbos-32-changes "Direct link to High-level description of ArbOS 32 changes")

ArbOS 32 Bianca is a major upgrade for Arbitrum chains. As a refresher, ArbOS upgrades can be treated as Arbitrum’s equivalent of a hard fork - more can be read about this subject over in [Arbitrum ArbOS upgrades](https://forum.arbitrum.foundation/t/arbitrum-arbos-upgrades/19695). Please note that ArbOS 21 Bianca is an upgrade that builds upon [ArbOS 20 Atlas](/run-arbitrum-node/arbos-releases/arbos20).

ArbOS 32 Bianca brings many features, improvements, and bug fixes to Arbitrum chains. A full list of changes can be found in the Nitro release notes for [Nitro v3.3.1](https://github.com/OffchainLabs/nitro/releases/tag/v3.3.1) or higher (as Nitro 3.3.1 is the endorsed Nitro node version for ArbOS 32 Bianca). Highlighted below are a few of the most impactful and critical features that are introduced with ArbOS 32 Bianca:

*   Addition and subsequent activation of [Stylus](/stylus/gentle-introduction) on Arbitrum chains through the addition of a new WebAssembly-based (WASM) virtual machine that runs alongside the EVM. Stylus enables developers to write smart contracts in new programming languages that compile to WASM, like Rust, that are more efficient and safer than Solidity smart contracts while retaining complete interoperability.
*   Adding support for [RIP-7212](https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md) decreases the costs of verifying the secp256r1 curve on-chain [by 99% when compared to current implementations](https://www.alchemy.com/blog/what-is-rip-7212), making secp256r1 verification more feasible for everyday use and enabling dApp developers and protocols to offer their users improved UX on Arbitrum One and Arbitrum Nova. Without this precompile, verifying this signature on-chain is extremely expensive. Passkey-based wallets offer better security than a typical EOA and seamless cross-device support. Many wallets, notably apps using embedded wallets, have been requesting this feature for over a year.
*   \[Only relevant to Arbitrum Nova\] Updated the transaction fee router contracts on Arbitrum Nova to allow for fees collected to be automatically sent to the ArbitrumDAO Treasury on Arbitrum One. Currently, the ArbitrumDAO receives Arbitrum Nova transaction fees that are sent to an ArbitrumDAO-controlled address that requires a constitutional proposal to move, which is less efficient. This change is specific to Arbitrum Nova and is not expected to impact Orbit chains.
*   Introduction of a new Fast Withdrawals feature for Orbit chains to achieve fast finality. This feature allows for transactions processed by a committee of validators to be unanimously confirmed as quickly as 15 minutes, as opposed to the default 6.4-day challenge period. While any Orbit chain can adopt Fast Withdrawals, we only recommend Fast Withdrawals for AnyTrust chains. Note that to enable this feature, separate steps must be followed (below).

### Additional requirement for Arbitrum Orbit chains who wish to take advantage of the Stylus Cache Manager[​](#additional-requirement-for-arbitrum-orbit-chains-who-wish-to-take-advantage-of-the-stylus-cache-manager "Direct link to Additional requirement for Arbitrum Orbit chains who wish to take advantage of the Stylus Cache Manager")

Stylus Cache Manager

It is strongly recommended that teams upgrading to ArbOS 32 also spend the time following the instructions described below to deploy and enable the Stylus Cache Manager. Even if your team does not intend to build with Stylus in the immediate term, enabling the Cache Manager ensures that future usage of Arbitrum Stylus on your chain is smooth and provides a consistent UX with the developer experience of building with Arbitrum Stylus on Arbitrum One.

Specific to Stylus and ArbOS 32 "Bianca", we have developed a caching strategy that stores frequently accessed contracts in memory to reduce the costs and time associated with contract execution from repeated initializations. Check out the [Stylus caching strategy docs](/stylus/how-tos/caching-contracts) to learn more.

In order to take advantage of this caching strategy, an additional step is required to deploy and enable it's use on your Orbit chain.

### Additional requirement for Arbitrum Orbit chains who wish to enable Fast Withdrawals[​](#additional-requirement-for-arbitrum-orbit-chains-who-wish-to-enable-fast-withdrawals "Direct link to Additional requirement for Arbitrum Orbit chains who wish to enable Fast Withdrawals")

After you have upgraded your Orbit chain to ArbOS 32 "Bianca" (i.e. you have fully completed [Step 3 in the "How to upgrade ArbOS on your Orbit chain" guide](/launch-orbit-chain/configure-your-chain/common-configurations/arbos-upgrade#step-3-schedule-the-arbos-version-upgrade) for your Orbit chain), please follow [these additional instructions](https://github.com/OffchainLabs/orbit-actions/tree/main/scripts/foundry/fast-confirm) in the `orbit-actions` repository to deploy the Safe contract for the fast confirmation committee and set the Safe contract to be both the validator and fast confirmer on your rollup, note that Fast Withdrawals is disabled by default unless explicitly set up and enabled by the Orbit chain owner/maintainer.

### Reference links for ArbOS 32 Bianca[​](#reference-links-for-arbos-32-bianca "Direct link to Reference links for ArbOS 32 Bianca")

*   [Nitro v3.3.1](https://github.com/OffchainLabs/nitro/releases/tag/v3.3.1)
*   [ArbOS 32 "Bianca" on-chain Tally vote](https://www.tally.xyz/gov/arbitrum/proposal/108288822474129076868455956066667369439381709547570289793612729242368710728616)
*   [AIP: Activate Stylus and Enable Next-Gen WebAssembly Smart Contracts (ArbOS 32)](https://forum.arbitrum.foundation/t/aip-activate-stylus-and-enable-next-gen-webassembly-smart-contracts-arbos-30/22970)
*   [AIP: Support RIP-7212 for Account Abstraction Wallets (ArbOS 32)](https://forum.arbitrum.foundation/t/aip-support-rip-7212-for-account-abstraction-wallets-arbos-30/23298)
*   [AIP: Nova Fee Router Proposal (ArbOS 32)](https://forum.arbitrum.foundation/t/aip-nova-fee-router-proposal-arbos-30/23310)
*   [Arbitrum Stylus Audit Report by Trail of Bits](/audit-reports)

---

# ArbOS software releases: Overview | Arbitrum Docs

## ArbOS software releases: Overview

info

This document provides an overview of Nitro node software releases that upgrade ArbOS. Visit the [Nitro Github repository](https://github.com/OffchainLabs/nitro/releases) for a detailed index of Nitro releases.

Arbitrum chains are powered by Arbitrum nodes running the Nitro software stack. The Nitro software stack includes [ArbOS](https://forum.arbitrum.foundation/t/arbitrum-arbos-upgrades/19695), the child chain EVM hypervisor that facilitates the execution environment of an Arbitrum chain.

Although new Nitro releases are shipped regularly, only a subset of Nitro releases carry ArbOS upgrades. These special Nitro releases are significant because ArbOS upgrades are Arbitrum's equivalent to a ["hard fork"](https://ethereum.org/en/history/) - an upgrade that alters a node's ability to produce valid Arbitrum blocks. This is why validator nodes supporting a public Arbitrum chain (One, Nova) **must update Nitro** whenever a new ArbOS version is released and voted for adoption by the ArbitrumDAO.

Note that every Nitro release is backwards compatible. In other words, the latest version of Nitro will support all previous ArbOS releases. This means that your validator's Nitro version must be greater than or equal to the version that includes the latest ArbOS upgrade.

How often should I be upgrading my ArbOS version?

It is strongly recommended to keep your Nitro's node software up-to-date as best you can to ensure you are benefting from the latest improvements to the Arbitrum technology stack. ArbOS version bumps are especially important because these upgrades change how Arbitrum nodes produce and validate assertions on a rollup's state.

ArbOS upgrades are carried out by the chain's owner; in the case of Arbitrum One and Nova, the owner is the Arbitrum DAO and so an upgrade will require a governance proposal and vote to pass to complete the upgrade. [This is an example of a Nitro release that contains an ArbOS version bump, specifically to ArbOS 11](https://github.com/OffchainLabs/nitro/releases/tag/v2.2.0).

Visit [How Arbitrum works](/how-arbitrum-works/a-gentle-introduction) to learn more about Nitro's architecture; more information about ArbOS software releases is available on [the Arbitrum DAO forum](https://forum.arbitrum.foundation/t/arbitrum-arbos-upgrades/19695).

List of available ArbOS releases[​](#list-of-available-arbos-releases "Direct link to List of available ArbOS releases")
------------------------------------------------------------------------------------------------------------------------

*   [ArbOS 32 "Bianca"](/run-arbitrum-node/arbos-releases/arbos32)
*   [ArbOS 20 "Atlas"](/run-arbitrum-node/arbos-releases/arbos20)
*   [ArbOS 11](/run-arbitrum-node/arbos-releases/arbos11)

Naming and numbering scheme[​](#naming-and-numbering-scheme "Direct link to Naming and numbering scheme")
---------------------------------------------------------------------------------------------------------

Beginning with ArbOS 20, ArbOS releases use the name of planetary moons in our solar system, ascending in alphabetical order (i.e. the next ArbOS upgrade after ArbOS 20 "Atlas" will be a planetary moon that begins with the letter "B").

The number used to denote each upgrade will increment by 10, starting from ArbOS 20 (i.e., the next ArbOS upgrade after ArbOS 20 will be ArbOS 31). This was done because there are teams who have customized their Orbit chain's [behavior](/launch-orbit-chain/customize-your-chain/customize-stf) or [precompiles](/launch-orbit-chain/customize-your-chain/customize-precompile) and who may wish to use ArbOS's naming schema between official ArbOS version bumps (e.g. ArbOS 12 could be the name of a customized version of ArbOS for a project's L3 Orbit chain).

Note that there may be cases where special optimizations or critical fixes are needed for a specific family of ArbOS releases that will diverge from the standard numbering scheme described above. For example, ArbOS 32 will be the canonical ArbOS version for the “Bianca” family of releases. Node operators and chain owners are expected to upgrade from ArbOS 20 directly to ArbOS 32 (instead of ArbOS 30 or ArbOS 31).

Network status[​](#network-status "Direct link to Network status")
------------------------------------------------------------------

To view the status and timeline of network upgrades on Arbitrum One and Nova, [please visit this page](https://docs.arbitrum.foundation/network-upgrades).

Expectations for Orbit chain owners[​](#expectations-for-orbit-chain-owners "Direct link to Expectations for Orbit chain owners")
---------------------------------------------------------------------------------------------------------------------------------

For Orbit chain owners or maintainers: it is important to note that _before_ upgrading your Orbit chain(s) to the newest ArbOS release, we strongly encourage waiting at least 2 weeks after the new ArbOS release has been activated on Arbitrum One and Nova before attempting the upgrade yourself. The rationale behind this short time buffer is to allow the Offchain Labs team to address any upgrade issues or stability concerns that may arise with the initial rollout so that we can minimize the chances of your chain(s) hitting the same or similar issues and to maximize the likelihood of an eventual smooth, seamless upgrade. Arbitrum Orbit chains, as always, can pick up new features & enable new customizations as they see fit. ArbOs 31 "Bianca" which unlocks Stylus for use, is no exception to this rule. However, we believe this delay ensures consistent UX across all Orbit chain owners and managers for these critical upgrades.

Note that enabling an ArbOS upgrade is not as simple as bumping your chain’s Nitro node version. Instead, there are other steps required that are outlined in our docs on [How to upgrade ArbOS on your Orbit chain](/launch-orbit-chain/configure-your-chain/common-configurations/arbos-upgrade). Please be sure to follow them and let us know if you encounter any issues.

Stay up to date[​](#stay-up-to-date "Direct link to Stay up to date")
---------------------------------------------------------------------

To stay up to date with proposals, timelines, and statuses of network upgrades to Arbitrum One and Nova:

*   Subscribe to the [Arbitrum Node Upgrade Announcement channel on Telegram](https://t.me/arbitrumnodeupgrade)
*   Join both the `#dev-announcements` and `#node-runners` Discord channels in the [Arbitrum Discord server](https://discord.gg/arbitrum)
*   Follow the official Arbitrum ([`@Arbitrum`](https://twitter.com/arbitrum)) and Arbitrum Developers ([`@ArbitrumDevs`](https://twitter.com/ArbitrumDevs)) X accounts, formerly Twitter.

---

# How to configure the Data Availability Committee (DAC) in your chain | Arbitrum Docs

## How to configure the Data Availability Committee (DAC) in your chain

 chains rely on an external Data Availability Committee (DAC) to store data and provide it on-demand instead of using its  as the Data Availability (DA) layer. The members of the DAC run a Data Availability Server (DAS) to handle these operations. Once the DA servers are running, the chain needs to be configured with their information to effectively store and retrieve data from them.

In this how-to, you'll learn how to configure the DAC in your chain. Refer to the _[Introduction](/run-arbitrum-node/data-availability-committees/get-started)_ for the full process of running DA servers and configuring the chain.

This how-to assumes that you're familiar with:

*   The DAC's role in the AnyTrust protocol. Refer to _[Inside AnyTrust](/how-arbitrum-works/anytrust-protocol)_ for a refresher.
*   [Kubernetes](https://kubernetes.io/). The examples in this guide use Kubernetes to containerize your DAS.
*   [How to deploy a Data Availability Server (DAS)](/run-arbitrum-node/data-availability-committees/deploy-das). This is needed to understand where the data we'll be handling in this guide comes from.
*   The [Foundry toolkit](https://github.com/foundry-rs/foundry)

Step 0: Prerequisites[​](#step-0-prerequisites "Direct link to Step 0: Prerequisites")
--------------------------------------------------------------------------------------

Before starting to generate the keyset and configuring the nodes and chain, you'll need to gather the following information from all the DA servers run by the DAC members:

*   Public BLS Key
*   URL of the RPC endpoint
*   URL(s) of the REST endpoint(s)

You should also make sure that at least one DAS is running as an [archive DAS](/run-arbitrum-node/data-availability-committees/deploy-das#archive-da-servers), otherwise the information will not be available after the expiry time.

Step 1: Generate the keyset and keyset hash with all the information from the servers[​](#step-1-generate-the-keyset-and-keyset-hash-with-all-the-information-from-the-servers "Direct link to Step 1: Generate the keyset and keyset hash with all the information from the servers")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### What is a keyset?[​](#what-is-a-keyset "Direct link to What is a keyset?")

The AnyTrust protocol assumes that for the `n` members of the DAC, a minimum of `h` members maintain integrity. So `h` is then the minimum number of trusted committee members on an AnyTrust chain. In scenarios where `k = (n + 1) - h` members of the DAC pledge to grant access to a specific piece of information, these `k` members must sign and attest they have stored the data to be considered successful.

To perform this signing operation, each DAC member must generate their own set of BLS public and private keys. They should do this independently and ensure these keys are random and only used by them. You can find more information about how to generate a BLS pair of keys in [Generating BLS Keys](/run-arbitrum-node/data-availability-committees/deploy-das#step-1-generate-the-bls-keypair).

An Anytrust chain needs to know all DAC members' public keys to validate the integrity of the data being batched and posted. A _keyset_ is a list of all DAC members' RPC endpoint and BLS public key. Additionally, it also contains information about how many signatures are needed to approve a , via a special `assumed-honest` parameter (i.e., the `h` parameter we mentioned above). This design lets the chain owner modify the DAC membership over time, and DAC members change their keys if needed. See _[Inside AnyTrust](/how-arbitrum-works/anytrust-protocol)_ for more information.

We use this keyset, and its hash to configure the SequencerInbox contract with the valid keyset, and also the batch poster (to request storing information) and full nodes (to request information already stored).

### How to generate a keyset and a keyset hash[​](#how-to-generate-a-keyset-and-a-keyset-hash "Direct link to How to generate a keyset and a keyset hash")

Nitro comes with a special tool to generate both the keyset and the keyset hash. To use it, you need to first structure the keyset information in a JSON object with the following structure:

```rust
{
    "keyset": {
      "assumed-honest": h,
      "backends": [
        {
          "url": "https://rpc-endpoint-of-member-1/",
          "pubkey":"PUBLIC_KEY_OF_MEMBER_1"
        },
        {
          "url": "https://rpc-endpoint-of-member-2/",
          "pubkey":"PUBLIC_KEY_OF_MEMBER_2"
        },

        ...

        {
          "url": "https://rpc-endpoint-of-member-n/",
          "pubkey":"PUBLIC_KEY_OF_MEMBER_N"
        }
      ]
    }
}
```

The JSON fields represent the following:

*   `assumed_honest` is the amount of members that we assume are honest from the `n` members of the DAC. This is the `h` variable we mentioned in the previous section.
*   `backends` contain information about each member of the DAC:
    *   `url` contains the RPC endpoint of the DAS run by that member
    *   `pubkey` contains the base64-encoded BLS public key used in the DAS run by that member

Once you have the JSON structure, save it into a file, for example, `keyset-info.json`.

Finally, we'll use Nitro's `datool dumpkeyset` utility inside Docker to generate the keyset and keyset hash.

```rust
docker run -v $(pwd):/data/keyset --entrypoint datool offchainlabs/nitro-node:v3.5.1-8f247fd dumpkeyset --conf.file /data/keyset/keyset-info.json
```

This command will output two results: `Keyset` and `KeysetHash`. Save them to use in the next steps.

### Example with mocked-up data[​](#example-with-mocked-up-data "Direct link to Example with mocked-up data")

Here's an example that uses mocked-up data:

The JSON file is:

```rust
{
  "keyset": {
    "assumed-honest": 2,
    "backends": [
      {
        "url": "http://example",
        "pubkey": "YAbcteVnZLty5qRebeswHKhdjEMVwdou+imSfyrI+yVXHOMdLWA3Nf4DGW9tVry/mhmZqJp01TaYIsREXWdsFe1S5QCNqnddyag5yZ/5Y6GZRqx0BXmHTaxPY5kHrhvGnwxmlJVbUk1xjKRFgxxTdTk3c0AfM3JaeWYTed3avV//KGGdwHC+/Z7XPWmeXCNsGhY75YuoEAK2EwcJvAZK9de6lHEwtyBWvxcmOADxo6siacalEO+OdBL9VtHvG5FqEwbjsdnILAmTcb2YYVgqyq2joW6d/uXQ685hCWWYqC8RLQqTXoyrXEjYLjEEsMe6eRV9rRoBmj5/atB3uOYwixFv7A9YI5YiRjw2MfoB4rQnJAkhW4AJQiwWcV2+3lkJBg=="
      },
      {
        "url": "http://example",
        "pubkey": "YAg1+ZXyR48kiS0FDaoon4trnBsYW80oUy+I1hDCZCotxvNQl0AjbTPD4tkTaqsX+BnIxnEpO7ondxd2Lo0cH3usnhfdKNKTmpWbs45QD5wRw4zrvEJuLeqXxAF1plXRdACubHX/SeiEx5RpJJ5wlTJYhUtk+oRFxYWtRdxtxpdVAcavfP9wdCAsaH+Ke/GjrBkmiXVfIyJ1tMhCGxpWaem5BMKaKSzflht4OnwLTOc2kA3k2MY8X4WmXLRK80vvhArO+Eq3X0TEyRN2ELaBB6/zu9zBkRnHqSfBFbe5v7J9hcUA7nfRPsWpejrmv1HTtwpVAuhBbee1646f7uN2QRyjXIp/P1l8dgZXjPlqRxXOWjXPSOOcCh+qLe4i105oGQ=="
      }
    ]
  }
}
```

And when running the command we obtain:

```rust
$ docker run -v $(pwd):/data/keyset --entrypoint datool offchainlabs/nitro-node:v3.5.1-8f247fd dumpkeyset --conf.file /data/keyset/keyset-info.json
Keyset: 0x0000000000000002000000000000000201216006dcb5e56764bb72e6a45e6deb301ca85d8c4315c1da2efa29927f2ac8fb25571ce31d2d603735fe03196f6d56bcbf9a1999a89a74d5369822c4445d676c15ed52e5008daa775dc9a839c99ff963a19946ac740579874dac4f639907ae1bc69f0c6694955b524d718ca445831c5375393773401f33725a79661379dddabd5fff28619dc070befd9ed73d699e5c236c1a163be58ba81002b6130709bc064af5d7ba947130b72056bf17263800f1a3ab2269c6a510ef8e7412fd56d1ef1b916a1306e3b1d9c82c099371bd9861582acaada3a16e9dfee5d0ebce61096598a82f112d0a935e8cab5c48d82e3104b0c7ba79157dad1a019a3e7f6ad077b8e6308b116fec0f58239622463c3631fa01e2b4272409215b8009422c16715dbede5909060121600835f995f2478f24892d050daa289f8b6b9c1b185bcd28532f88d610c2642a2dc6f3509740236d33c3e2d9136aab17f819c8c671293bba277717762e8d1c1f7bac9e17dd28d2939a959bb38e500f9c11c38cebbc426e2dea97c40175a655d17400ae6c75ff49e884c79469249e70953258854b64fa8445c585ad45dc6dc6975501c6af7cff7074202c687f8a7bf1a3ac192689755f232275b4c8421b1a5669e9b904c29a292cdf961b783a7c0b4ce736900de4d8c63c5f85a65cb44af34bef840acef84ab75f44c4c9137610b68107aff3bbdcc19119c7a927c115b7b9bfb27d85c500ee77d13ec5a97a3ae6bf51d3b70a5502e8416de7b5eb8e9feee376411ca35c8a7f3f597c7606578cf96a4715ce5a35cf48e39c0a1faa2dee22d74e6819
KeysetHash: 0xfdca3e4e2de25f0a56d0ced68fd1cc64f91b20cde67c964c55105477c02f49be
```

Step 2: Update the SequencerInbox contract[​](#step-2-update-the-sequencerinbox-contract "Direct link to Step 2: Update the SequencerInbox contract")
-----------------------------------------------------------------------------------------------------------------------------------------------------

Once we have the keyset and its hash, we can configure the SequencerInbox contract so it accepts DACerts signed by the DAC members.

The SequencerInbox can be configured with the new keyset by invoking the [setValidKeyset](https://github.com/OffchainLabs/nitro-contracts/blob/763bd77906b7677da691eaa31c6e195d455197a4/src/bridge/SequencerInbox.sol#L751) method. Note that only the chain owner can call this method.

Here's an example of how to use Foundry to configure the SequencerInbox with the keyset generated in the previous step:

```rust
cast send --rpc-url $PARENT_CHAIN_RPC --private-key $CHAIN_OWNER_PRIVATE_KEY $SEQUENCERINBOX_ADDRESS "setValidKeyset(bytes)" 0x0000000000000002000000000000000201216006dcb5e56764bb72e6a45e6deb301ca85d8c4315c1da2efa29927f2ac8fb25571ce31d2d603735fe03196f6d56bcbf9a1999a89a74d5369822c4445d676c15ed52e5008daa775dc9a839c99ff963a19946ac740579874dac4f639907ae1bc69f0c6694955b524d718ca445831c5375393773401f33725a79661379dddabd5fff28619dc070befd9ed73d699e5c236c1a163be58ba81002b6130709bc064af5d7ba947130b72056bf17263800f1a3ab2269c6a510ef8e7412fd56d1ef1b916a1306e3b1d9c82c099371bd9861582acaada3a16e9dfee5d0ebce61096598a82f112d0a935e8cab5c48d82e3104b0c7ba79157dad1a019a3e7f6ad077b8e6308b116fec0f58239622463c3631fa01e2b4272409215b8009422c16715dbede5909060121600835f995f2478f24892d050daa289f8b6b9c1b185bcd28532f88d610c2642a2dc6f3509740236d33c3e2d9136aab17f819c8c671293bba277717762e8d1c1f7bac9e17dd28d2939a959bb38e500f9c11c38cebbc426e2dea97c40175a655d17400ae6c75ff49e884c79469249e70953258854b64fa8445c585ad45dc6dc6975501c6af7cff7074202c687f8a7bf1a3ac192689755f232275b4c8421b1a5669e9b904c29a292cdf961b783a7c0b4ce736900de4d8c63c5f85a65cb44af34bef840acef84ab75f44c4c9137610b68107aff3bbdcc19119c7a927c115b7b9bfb27d85c500ee77d13ec5a97a3ae6bf51d3b70a5502e8416de7b5eb8e9feee376411ca35c8a7f3f597c7606578cf96a4715ce5a35cf48e39c0a1faa2dee22d74e6819
```

Step 3: Craft the new configuration for the batch poster[​](#step-3-craft-the-new-configuration-for-the-batch-poster "Direct link to Step 3: Craft the new configuration for the batch poster")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

To configure the batch poster, we'll use the JSON structure we created in Step 1. This will allow the batch poster to send RPC requests to all the DA servers (to store the information of the transactions being included in the next batch), craft the DACert, and store it in the SequencerInbox.

The configuration to enable the DAC in the batch poster looks like this:

```rust
{
  ...

  "data-availability": {
    "enable": true,
    "rpc-aggregator": {
      "enable": true,
      "assumed-honest": h,
      "backends": [
        {
          "url": "https://rpc-endpoint-of-member-1/",
          "pubkey":"PUBLIC_KEY_OF_MEMBER_1"
        },
        {
          "url": "https://rpc-endpoint-of-member-2/",
          "pubkey":"PUBLIC_KEY_OF_MEMBER_2"
        },

        ...

        {
          "url": "https://rpc-endpoint-of-member-n/",
          "pubkey":"PUBLIC_KEY_OF_MEMBER_N"
        }
      ]
    }
  },

  ...
}
```

The following parameters are used:

*   `data-availability.enable`: tells the batch poster to handle information stored in a DAC
*   `data-availability.rpc-aggregator`: includes information of the RPC endpoints of all the DA servers run by DAC members.
    *   `enable`: tells the batch poster that the RPC aggregator will be used
    *   `assumed` and `backends`: include information from the DA servers (following the same format as specified in Step 1)

Once the configuration is in place, you can restart your batch poster so it begins communicating with the DA servers to store transaction data, while storing the DACert in the SequencerInbox.

Step 4: Craft the new configuration for your chain's nodes[​](#step-4-craft-the-new-configuration-for-your-chains-nodes "Direct link to Step 4: Craft the new configuration for your chain's nodes")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Finally, we also need to configure all other nodes so they can communicate with the DAC. To do that, we'll also use the JSON structure we created in Step 1.

The configuration to enable the DAC in a full node looks like this:

```rust
{
  ...

  "data-availability": {
    "enable": true,
    "rest-aggregator": {
      "enable": true,
      "urls": [
          "https://rest-endpoint-of-member-1/",
          "https://rest-endpoint-of-member-2/",
          ...
          "https://rest-endpoint-of-member-n/",
      ],
      "online-url-list": "https://url-of-list-of-rest-endpoints"
    }
  },

  ...
}
```

The following parameters are used:

*   `data-availability.enable`: tells the node to query information from the DAC
*   `data-availability.rest-aggregator`: includes information on the REST endpoints of all the DA servers run by DAC members.
    *   `enable`: tells the node that the REST aggregator will be used
    *   `urls` or `online-url-list`: usually only one of these is used, although both parameters can be used and the information will be aggregated together. `urls` is a list of all REST endpoints of the DA servers, and `online-url-list` is a URL to a list of URLs of the REST endpoints of the DA servers.

Once the configuration is in place, you can restart your node so it begins communicating with the DA servers to retrieve transaction data.

---

# How to deploy a Data Availability Server (DAS) | Arbitrum Docs

## How to deploy a Data Availability Server (DAS)

 chains rely on an external Data Availability Committee (DAC) to store data and provide it on-demand instead of using its  as the Data Availability (DA) layer. The members of the DAC run a Data Availability Server (DAS) to handle these operations.

In this how-to, you'll learn how to deploy a DAS that exposes:

1.  **An RPC interface** that the sequencer uses to store batches of data on the DAS.
2.  **An HTTP REST interface** that lets the DAS respond to requests for those batches of data.

For more information related to configuring a DAC, refer to the _[Introduction](/run-arbitrum-node/data-availability-committees/get-started)_.

This how-to assumes that you're familiar with:

*   The DAC's role in the AnyTrust protocol. Refer to _[Inside AnyTrust](/how-arbitrum-works/anytrust-protocol)_ for a refresher.
*   [Kubernetes](https://kubernetes.io/). The examples in this guide use Kubernetes to containerize your DAS.

How does a DAS work?[​](#how-does-a-das-work "Direct link to How does a DAS work?")
-----------------------------------------------------------------------------------

A Data Availability Server (DAS) allows storage and retrieval of transaction data batches for an AnyTrust chain. It's the software that the members of the DAC run in order to provide the Data Availability service.

DA servers accept time-limited requests to store data batches from the sequencer of an AnyTrust chain, and return a signed certificate promising to store that data during the established time. They also respond to requests to retrieve the data batches.

Configuration options[​](#configuration-options "Direct link to Configuration options")
---------------------------------------------------------------------------------------

When setting up a DAS, there are certain options you can configure to suit your infrastructure needs:

### Interfaces available in a DAS[​](#interfaces-available-in-a-das "Direct link to Interfaces available in a DAS")

There are two main interfaces that can be enabled in a DAS: an **RPC interface** to store data in the DAS, intended to be used only by the AnyTrust sequencer; and a **REST interface** that supports only GET operations and is intended for public use.

DA servers listen on two primary interfaces:

1.  Its **RPC interface** listens for `das_store` RPC messages coming from the sequencer. Messages are signed by the sequencer, and the DAS checks this signature upon receipt.
2.  Its **REST interface** respond to HTTP GET requests pointed at `/get-by-hash/<hex encoded data hash>`. This uses the hash of the data batch as a unique identifier, and will always return the same data for a given hash.

### Storage options[​](#storage-options "Direct link to Storage options")

A DAS can be configured to use one or more of four storage backends:

*   [AWS S3](https://aws.amazon.com/s3/) bucket
*   Files on local disk
*   (**EXPERIMENTAL**) [Google Cloud Storage](https://cloud.google.com/storage) bucket
*   (**DEPRECATED**) [Badger](https://dgraph.io/docs/badger/) database on local disk

Google Cloud Storage is experimental

The Google Cloud Storage option (set with `google-cloud-storage`) is experimental and hasn't been tested thoroughly. It is recommended to not rely solely on this storage option and to use it alongside other storage options.

Local Badger database deprecated

The local Badger DB storage option (set with `local-db-storage`) has been deprecated and should be replaced with the local files storage option (set with `local-file-storage`).

A migration tool has been included in Nitro to migrate all data from the local badger db to local files. You can activate it by using the parameter `--data-availability.migrate-local-db-to-file-storage`.

If more than one option is selected, store requests must succeed to all of them for it to be considered successful, while retrieve requests only require one of them to succeed.

If there are other storage backends you'd like us to support, send us a message on [Discord](https://discord.gg/arbitrum), or contribute directly to the [Nitro repository](https://github.com/OffchainLabs/nitro/).

### Caching[​](#caching "Direct link to Caching")

An in-memory cache can be enabled to avoid needing to access underlying storage for retrieve requests.

Requests sent to the REST interface (to retrieve data from the DAS) always return the same data for a given hash, so the result is cacheable. It also contains a `cache-control` header specifying that the object is immutable and to cache it for up to 28 days.

### State synchronization[​](#state-synchronization "Direct link to State synchronization")

DA servers also have an optional REST aggregator which, when a data batch is not found in cache or storage, requests that batch to other REST servers defined in a list and stores that batch upon receiving it. This is how a DAS that misses storing a batch (the AnyTrust protocol doesn't require all of them to report success in order to post the batch's certificate to the parent chain) can automatically repair gaps in the data it stores, and also how a [mirror DAS](#running-a-mirror-das) can sync its data. A public list of REST endpoints is published online, which the DAS can be configured to download and use, and additional endpoints can be specified in the configuration.

How to deploy the DAS[​](#how-to-deploy-the-das "Direct link to How to deploy the DAS")
---------------------------------------------------------------------------------------

### Step 0: Prerequisites[​](#step-0-prerequisites "Direct link to Step 0: Prerequisites")

Gather the following information:

*   The latest Nitro docker image: `offchainlabs/nitro-node:v3.5.1-8f247fd`
*   An RPC endpoint for the . It is recommended to use a [third-party provider RPC](/build-decentralized-apps/reference/node-providers#third-party-rpc-providers) or [run your own node](/node-running/how-tos/running-an-orbit-node) to prevent being rate limited.
*   The SequencerInbox contract address in the parent chain.
*   If you wish to configure a [REST aggregator for your DAS](#state-synchronization), you'll need the URL where the list of REST endpoints is kept.

### Step 1: Generate the BLS keypair[​](#step-1-generate-the-bls-keypair "Direct link to Step 1: Generate the BLS keypair")

Next, we'll generate a BLS keypair. The private key will be used to sign the  when receiving requests to store data, and the public key will be used to prove that the DACert was signed by the DAS. The BLS private key is sensitive and care must be taken to ensure it is generated and stored in a safe environment.

The BLS keypair must be generated using the `datool keygen` utility. Later, it will be passed to the DAS by file or command line.

When running the key generator, we'll specify the `--dir` parameter with the absolute path to the directory inside the volume to store the keys in.

Here's an example of how to use the `datool keygen` utility inside Docker and store the key that will be used by the DAS in the next step.

```rust
docker run -v $(pwd)/bls_keys:/data/keys --entrypoint datool \
offchainlabs/nitro-node:v3.5.1-8f247fd keygen --dir /data/keys
```

### Step 2: Deploy the DAS[​](#step-2-deploy-the-das "Direct link to Step 2: Deploy the DAS")

To run the DAS, we'll use the `daserver` tool and we'll configure the following parameters:

Parameter

Description

\--data-availability.parent-chain-node-url

RPC endpoint of a parent chain node

\--data-availability.sequencer-inbox-address

Address of the SequencerInbox in the parent chain

\--data-availability.key.key-dir

The absolute path to the directory inside the volume to read the BLS keypair ('das\_bls.pub' and 'das\_bls') from

\--enable-rpc

Enables the HTTP-RPC server listening on --rpc-addr and --rpc-port

\--rpc-addr

HTTP-RPC server listening interface (default "localhost")

\--rpc-port

(Optional) HTTP-RPC server listening port (default 9876)

\--enable-rest

Enables the REST server listening on --rest-addr and --rest-port

\--rest-addr

REST server listening interface (default "localhost")

\--rest-port

(Optional) REST server listening port (default 9877)

\--log-level

Log level: 1 - ERROR, 2 - WARN, 3 - INFO, 4 - DEBUG, 5 - TRACE (default 3)

To enable caching, you can use the following parameters:

Parameter

Description

\--data-availability.local-cache.enable

Enables local in-memory caching of sequencer batch data

\--data-availability.local-cache.capacity

Maximum number of entries (up to 64KB each) to store in the cache. (default 20000)

To enable the REST aggregator, use the following parameters:

Parameter

Description

\--data-availability.rest-aggregator.enable

Enables retrieval of sequencer batch data from a list of remote REST endpoints

\--data-availability.rest-aggregator.online-url-list

A URL to a list of URLs of REST DAS endpoints that is checked at startup. This option is additive with the urls option

\--data-availability.rest-aggregator.urls

List of URLs including 'http://' or 'https://' prefixes and port numbers to REST DAS endpoints. This option is additive with the online-url-list option

\--data-availability.rest-aggregator.sync-to-storage.check-already-exists

When using a REST aggregator, checks if the data already exists in this DAS's storage. Must be disabled for fast sync with an IPFS backend (default true)

\--data-availability.rest-aggregator.sync-to-storage.eager

When using a REST aggregator, eagerly syncs batch data to this DAS's storage from the REST endpoints, using the parent chain as the index of batch data hashes; otherwise only syncs lazily

\--data-availability.rest-aggregator.sync-to-storage.eager-lower-bound-block

When using a REST aggregator that's eagerly syncing, starts indexing forward from this block from the parent chain. Only used if there is no sync state.

\--data-availability.rest-aggregator.sync-to-storage.retention-period

When using a REST aggregator, period to retain the synced data (defaults to forever)

\--data-availability.rest-aggregator.sync-to-storage.state-dir

When using a REST aggregator, directory to store the sync state in, i.e. the block number currently synced up to, so that it doesn't sync from scratch each time

Finally, for the storage backends you wish to configure, use the following parameters. Toggle between the different options to see all available parameters.

*   AWS S3 bucket
*   Local files
*   (Experimental) Google Cloud Storage
*   (Deprecated) Local Badger database

Parameter

Description

\--data-availability.s3-storage.enable

Enables storage/retrieval of sequencer batch data from an AWS S3 bucket

\--data-availability.s3-storage.access-key

S3 access key

\--data-availability.s3-storage.bucket

S3 bucket

\--data-availability.s3-storage.region

S3 region

\--data-availability.s3-storage.secret-key

S3 secret key

\--data-availability.s3-storage.object-prefix

Prefix to add to S3 objects

\--data-availability.s3-storage.discard-after-timeout

Whether to discard data after its expiry timeout (setting it to false, activates the “archive” mode)

Create the local directory before launching your DAS

Make sure you create the directory specified in `local-file-storage.data-dir` before launching your DAS to avoid potential permission issues with Docker or Kubernetes.

Parameter

Description

\--data-availability.local-file-storage.enable

Enables storage/retrieval of sequencer batch data from a directory of files, one per batch

\--data-availability.local-file-storage.data-dir

Absolute path of the directory inside the volume in which to store the data (it must exist)

\--data-availability.local-file-storage.enable-expiry

Enables expiry of batches

\--data-availability.local-file-storage.max-retention

Store requests with expiry times farther in the future than max-retention will be rejected (default: 504h0m0s)

Parameter

Description

\--data-availability.google-cloud-storage.enable

Enables storage/retrieval of sequencer batch data from a Google Cloud Storage bucket

\--data-availability.google-cloud-storage.access-token

Google Cloud Storage access token

\--data-availability.google-cloud-storage.bucket

Google Cloud Storage bucket

\--data-availability.google-cloud-storage.object-prefix

Prefix to add to Google Cloud Storage objects

\--data-availability.google-cloud-storage.enable-expiry

Enable expiry of batches (setting it to false, activates the "archive" mode)

\--data-availability.google-cloud-storage.max-retention

Store requests with expiry times farther in the future than max-retention will be rejected

Parameter

Description

\--data-availability.local-db-storage.enable

Enables storage/retrieval of sequencer batch data from a database on the local filesystem

\--data-availability.local-db-storage.data-dir

Absolute path of the directory inside the volume in which to store the database (it must exist)

\--data-availability.local-db-storage.discard-after-timeout

Whether to discard data after its expiry timeout (setting it to false, activates the “archive” mode)

\--data-availability.migrate-local-db-to-file-storage

Migrate all data on startup from local-db-storage to local-file-storage, then mark local-db-storage as unusable

Here's an example `daserver` command for a DAS that:

*   Enables both interfaces: RPC and REST
*   Enables local cache
*   Enables a [REST aggregator](#state-synchronization)
*   Enables AWS S3 bucket storage
*   Enables local files storage

```rust
daserver
    --data-availability.parent-chain-node-url "<YOUR PARENT CHAIN RPC ENDPOINT>"
    --data-availability.sequencer-inbox-address "<ADDRESS OF SEQUENCERINBOX ON PARENT CHAIN>"
    --data-availability.key.key-dir /home/user/data/keys
    --enable-rpc
    --rpc-addr '0.0.0.0'
    --log-level 3
    --enable-rest
    --rest-addr '0.0.0.0'
    --data-availability.local-cache.enable
    --data-availability.rest-aggregator.enable
    --data-availability.rest-aggregator.online-url-list "<URL TO LIST OF REST ENDPOINTS>"
    --data-availability.s3-storage.enable
    --data-availability.s3-storage.access-key "<YOUR ACCESS KEY>"
    --data-availability.s3-storage.bucket "<YOUR BUCKET>"
    --data-availability.s3-storage.region "<YOUR REGION>"
    --data-availability.s3-storage.secret-key "<YOUR SECRET KEY>"
    --data-availability.s3-storage.object-prefix "<YOUR OBJECT KEY PREFIX>/"
    --data-availability.local-file-storage.enable
    --data-availability.local-file-storage.data-dir /home/user/data/das-data
```

And here's an example of how to use a k8s deployment to run that command:

```rust
apiVersion: apps/v1
kind: Deployment
metadata:
name: das-server
spec:
replicas: 1
selector:
    matchLabels:
    app: das-server
strategy:
    rollingUpdate:
    maxSurge: 0
    maxUnavailable: 50%
    type: RollingUpdate
template:
    metadata:
    labels:
        app: das-server
    spec:
    containers:
    - command:
        - bash
        - -c
        - |
        mkdir -p /home/user/data/badgerdb
        /usr/local/bin/daserver --data-availability.parent-chain-node-url "<YOUR PARENT CHAIN RPC ENDPOINT>" --data-availability.sequencer-inbox-address "<ADDRESS OF SEQUENCERINBOX ON PARENT CHAIN>" --data-availability.key.key-dir /home/user/data/keys --enable-rpc --rpc-addr '0.0.0.0' --log-level 3 --enable-rest --rest-addr '0.0.0.0' --data-availability.local-cache.enable --data-availability.rest-aggregator.enable --data-availability.rest-aggregator.online-url-list "<URL TO LIST OF REST ENDPOINTS>" --data-availability.s3-storage.enable --data-availability.s3-storage.access-key "<YOUR ACCESS KEY>" --data-availability.s3-storage.bucket "<YOUR BUCKET>" --data-availability.s3-storage.region "<YOUR REGION>" --data-availability.s3-storage.secret-key "<YOUR SECRET KEY>" --data-availability.s3-storage.object-prefix "<YOUR OBJECT KEY PREFIX>/" --data-availability.s3-storage.discard-after-timeout false --data-availability.local-file-storage.enable --data-availability.local-file-storage.data-dir /home/user/data/das-data
        image: offchainlabs/nitro-node:v3.5.1-8f247fd
        imagePullPolicy: Always
        resources:
        limits:
            cpu: "4"
            memory: 10Gi
        requests:
            cpu: "4"
            memory: 10Gi
        ports:
        - containerPort: 9876
        hostPort: 9876
        protocol: TCP
        - containerPort: 9877
        hostPort: 9877
        protocol: TCP
        volumeMounts:
        - mountPath: /home/user/data/
        name: data
        readinessProbe:
        failureThreshold: 3
        httpGet:
            path: /health/
            port: 9877
            scheme: HTTP
        initialDelaySeconds: 5
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 1
    volumes:
    - name: data
        persistentVolumeClaim:
        claimName: das-server
```

Archive DA servers[​](#archive-da-servers "Direct link to Archive DA servers")
------------------------------------------------------------------------------

Archive DA servers are servers that don't discard any data after expiring. Each DAC should have at the very least one archive DAS to ensure all historical data is available.

To activate the "archive mode" in your DAS, set the parameter `discard-after-timeout` to `false` in your storage method. For example:

```rust
--data-availability.s3-storage.discard-after-timeout=false
```

Note that `local-file-storage` doesn't discard data after expiring by default, but expiration can be enabled with `enable-expiry`.

Archive servers should make use of the `--data-availability.rest-aggregator.sync-to-storage` options described above to pull in any data that they don't have.

Helm charts[​](#helm-charts "Direct link to Helm charts")
---------------------------------------------------------

A helm chart is available at [ArtifactHUB](https://artifacthub.io/packages/helm/offchainlabshelm/das). It supports running a DAS by providing the BLS key and the parameters for your server. Find more information in the [OCL community Helm charts repository](https://github.com/OffchainLabs/community-helm-charts/tree/main/charts/das).

Testing the DAS[​](#testing-the-das "Direct link to Testing the DAS")
---------------------------------------------------------------------

Once the DAS is running, we can test if everything is working correctly using the following methods.

### Test 1: RPC health check[​](#test-1-rpc-health-check "Direct link to Test 1: RPC health check")

The RPC interface enabled in the DAS has a health check for the underlying storage that can be invoked by using the RPC method  `das_healthCheck` that returns a status `200` if the DAS is active.

Example:

```rust
curl -X POST \
     -H 'Content-Type: application/json' \
     -d '{"jsonrpc":"2.0","id":0,"method":"das_healthCheck","params":[]}' \
     <YOUR RPC ENDPOINT>
```

### Test 2: Store and retrieve data[​](#test-2-store-and-retrieve-data "Direct link to Test 2: Store and retrieve data")

The RPC interface of the DAS validates that requests to store data are signed by the sequencer's ECDSA key, identified via a call to the `SequencerInbox` contract on the parent chain. It can also be configured to accept store requests signed with another ECDSA key of your choosing. This could be useful for running load tests, canaries, or troubleshooting your own infrastructure.

Using this facility, a load test could be constructed by writing a script to store arbitrary amounts of data at an arbitrary rate; a canary could be constructed to store and retrieve data on some interval. We show here a short guide on how to do that.

#### Step 1: Generate an ECDSA keypair[​](#step-1-generate-an-ecdsa-keypair "Direct link to Step 1: Generate an ECDSA keypair")

First we'll generate an ECDSA keypair with `datool keygen`. Create a folder inside `/some/local/dir` to store the ECDSA keypair, for example `/some/local/dir/keys`. Then run `datool keygen`:

```rust
datool keygen --dir /some/local/dir/keys --ecdsa
```

You can also use the `docker run` command as follows:

```rust
docker run --rm -it -v /some/local/dir:/home/user/data --entrypoint datool offchainlabs/nitro-node:v3.5.1-8f247fd keygen --dir /home/user/data/keys --ecdsa
```

#### Step 2: Change the DAS configuration and restart the server[​](#step-2-change-the-das-configuration-and-restart-the-server "Direct link to Step 2: Change the DAS configuration and restart the server")

Add the following configuration parameter to `daserver`:

```rust
--data-availability.extra-signature-checking-public-key /some/local/dir/keys/ecdsa.pub
```

OR

```rust
--data-availability.extra-signature-checking-public-key "0x<contents of ecdsa.pub>"
```

And then restart it.

#### Step 3: Store data signed with the ECDSA private key[​](#step-3-store-data-signed-with-the-ecdsa-private-key "Direct link to Step 3: Store data signed with the ECDSA private key")

Now you can use the `datool` utility to send store requests signed with the ECDSA private key:

```rust
datool client rpc store  --url http://localhost:9876 --message "Hello world" --signing-key /some/local/dir/keys/ecdsa
```

OR

```rust
datool client rpc store  --url http://localhost:9876 --message "Hello world" --signing-key "0x<contents of ecdsa>"
```

You can also use the `docker run` command:

```rust
docker run --rm -it -v /some/local/dir:/home/user/data --network="host" --entrypoint datool offchainlabs/nitro-node:v3.5.1-8f247fd client rpc store --url http://localhost:9876 --message "Hello world" --signing-key /home/user/data/keys/ecdsa
```

The above command will output the `Hex Encoded Data Hash` which can then be used to retrieve the data in the next step.

#### Step 4: Retrieve the stored data[​](#step-4-retrieve-the-stored-data "Direct link to Step 4: Retrieve the stored data")

Use again the `datool` to retrieve the stored data. Notice that to perform this step you must have the REST interface enabled in the DAS:

```rust
datool client rest getbyhash --url http://localhost:9877 --data-hash 0xDataHash
```

You can also use the `docker run` command:

```rust
docker run --rm -it --network="host" --entrypoint datool offchainlabs/nitro-node:v3.5.1-8f247fd client rest getbyhash --url http://localhost:9877 --data-hash 0xDataHash
```

If we set `0xDataHash` to `0x052cca0e379137c975c966bcc69ac8237ac38dc1fcf21ac9a6524c87a2aab423` (from the previous step), then the result should be: `Message: Hello world`

The retention period defaults to 24 hours, but can be configured when calling `datool client rpc store` with the parameter `--das-retention-period` and the number of milliseconds for the retention period.

### Test 3: REST health check[​](#test-3-rest-health-check "Direct link to Test 3: REST health check")

The REST interface has a health check on the path `/health` which will return a status `200` if the underlying storage is working, otherwise `503`.

Example:

```rust
curl -I <YOUR REST ENDPOINT>/health
```

### Test 4: Retrieve data from a batch poster transaction[​](#test-4-retrieve-data-from-a-batch-poster-transaction "Direct link to Test 4: Retrieve data from a batch poster transaction")

You can also do a test to retrieve the transaction data posted by a batch poster transaction. The transaction will contain both keyset and data hash information in its `data` field in method `addSequencerL2BatchFromOrigin(uint256 sequenceNumber, bytes data,uint256 afterDelayedMessagesRead, address gasRefunder,uint256 prevMessageCount,uint256 newMessageCount)`.

After you decode a batch poster transaction and get its `data` within the function data, you can continue to decode the `data` as follows:

The first part (1 byte) is the `header flag`, which is used to specify which type of batch it is. Here we need to check if it has bit `0x80` (For example, `0x88` and `0x80` are both valid, but `0x55` is wrong).

The second part (32 bytes) is the keyset hash. You can learn more about what keyset is [here](/how-arbitrum-works/anytrust-protocol#keysets).

The third part (32 bytes) is the data hash, and this is what we need to retrieve data. When you get this hash, you can retrieve data directly by following what we demonstrate in Step 4.

Running a mirror DAS[​](#running-a-mirror-das "Direct link to Running a mirror DAS")
------------------------------------------------------------------------------------

To avoid exposing the REST interface of your main DAS to the public in order to prevent spamming attacks (as explained in [Security considerations](#security-considerations)), you can choose to run a mirror DAS to complement your setup. The mirror DAS will handle all public REST requests, while reading information from the main DAS via its (now private) REST interface.

In general, mirror DA servers serve two main purposes:

1.  Prevent the main DAS from having to serve requests for data, allowing it to focus only on storing the data received.
2.  Provide resiliency to the network in the case of a DAS going down.

Find information about how to setup a mirror DAS in [How to deploy a mirror DAS](/run-arbitrum-node/data-availability-committees/deploy-mirror-das).

Security considerations[​](#security-considerations "Direct link to Security considerations")
---------------------------------------------------------------------------------------------

Keep in mind the following information when running the DAS.

A DAS should strive not to miss any batch of information sent by the sequencer. Although it can use a REST aggregator to fetch missing information from other DA servers, it should aim to synchronize all received information directly. To facilitate this, avoid placing any load balancing layer before the DAS, enabling it to handle all incoming traffic.

Taking that into account, there's a risk of Denial of Service attacks on those servers if the endpoint for the RPC interface is publicly known. To mitigate this risk, ensure the RPC endpoint's URL is not easily discoverable. It should be known only to the sequencer. Share this information with the chain owner through a private channel to maintain security.

Finally, as explained in the previous section, if you're also running a mirror DAS, there's no need to publicly expose the REST interface of your main DAS. Your mirrors can synchronize over your private network using the REST interface from your main DAS and other public mirrors.

External signer support[​](#external-signer-support "Direct link to External signer support")
---------------------------------------------------------------------------------------------

By default the batch poster uses the same ECDSA key to sign `das_store` requests as it uses to sign the batch transactions sent to the sequencer inbox contract. Many installations use an external signer for securing the batch poster's key. While using an external signer is suported for signing batch transactions, it is not currently supported for signing the requests sent to the DA Committee. Currently, if you want to use an external signer for the batch transactions together with AnyTrust, you must generate a separate key for signing the requests sent to the DA Committee. If a wallet file is used the account must be named "l1-batch-poster".

The batch poster would need to have the configuration for the external signer

```rust
--node.batch-poster.data-poster.external-signer...
```

and the configuration for the key which is only used for signing DA Committee requests.

```rust
--node.batch-poster.parent-chain-wallet...
```

The Committee servers would need to additionally specify the public key to accept signed messages from.

```rust
--data-availability.extra-signature-checking-public-key
```

Other considerations[​](#other-considerations "Direct link to Other considerations")
------------------------------------------------------------------------------------

*   When using [nginx](https://www.nginx.com/) in the networking stack, a DAS might fail receiving batches that are over a certain size. If this happens, the DAS won't be able to sign any more certificates and the batch poster will receive an error `413 Request Entity Too Large`. To prevent this behavior, the parameter `client_max_body_size` from nginx configuration should be configured with a higher value than the default 1M. It's recommended to set it to at least 50M.

What to do next?[​](#what-to-do-next "Direct link to What to do next?")
-----------------------------------------------------------------------

Once the DAS is deployed and tested, you'll have to communicate the following information to the chain owner, so they can update the chain parameters and configure the sequencer:

*   Public key
*   The https URL for the RPC endpoint which includes some random string (e.g. das.your-chain.io/rpc/randomstring123), communicated through a secure channel
*   The https URL for the REST endpoint (e.g. das.your-chain.io/rest)

Optional parameters[​](#optional-parameters "Direct link to Optional parameters")
---------------------------------------------------------------------------------

Besides the parameters described in this guide, there are some more options that can be useful when running the DAS. For a comprehensive list of configuration parameters, you can run `daserver --help`.

Parameter

Description

\--conf.dump

Prints out the current configuration

\--conf.file

Absolute path to the configuration file inside the volume to use instead of specifying all parameters in the command

Metrics[​](#metrics "Direct link to Metrics")
---------------------------------------------

The DAS comes with the option of producing Prometheus metrics. This option can be activated by using the following parameters:

Parameter

Description

\--metrics

Enables the metrics server

\--metrics-server.addr

Metrics server address (default "127.0.0.1")

\--metrics-server.port

Metrics server port (default 6070)

\--metrics-server.update-interval

Metrics server update interval (default 3s)

When metrics are enabled, several useful metrics are available at the configured port, at path `debug/metrics` or `debug/metrics/prometheus`.

### RPC metrics[​](#rpc-metrics "Direct link to RPC metrics")

Metric

Description

arb\_das\_rpc\_store\_requests

Count of RPC Store calls

arb\_das\_rpc\_store\_success

Successful RPC Store calls

arb\_das\_rpc\_store\_failure

Failed RPC Store calls

arb\_das\_rpc\_store\_bytes

Bytes retrieved with RPC Store calls

arb\_das\_rpc\_store\_duration (p50, p75, p95, p99, p999, p9999)

Duration of RPC Store calls (ns)

### REST metrics[​](#rest-metrics "Direct link to REST metrics")

Metric

Description

arb\_das\_rest\_getbyhash\_requests

Count of REST GetByHash calls

arb\_das\_rest\_getbyhash\_success

Successful REST GetByHash calls

arb\_das\_rest\_getbyhash\_failure

Failed REST GetByHash calls

arb\_das\_rest\_getbyhash\_bytes

Bytes retrieved with REST GetByHash calls

arb\_das\_rest\_getbyhash\_duration (p50, p75, p95, p99, p999, p9999)

Duration of REST GetByHash calls (ns)

---

# How to deploy a mirror Data Availability Server (DAS) | Arbitrum Docs

## How to deploy a mirror Data Availability Server (DAS)

Running a regular DAS vs running a mirror DAS

The main use-case for running a mirror DAS is to complement your setup as a Data Availability Committee (DAC) member. That means that you should run your main DAS first, and then configure the mirror DAS. Refer to _[How to deploy a DAS](/run-arbitrum-node/data-availability-committees/deploy-das)_ if needed.

 chains rely on an external Data Availability Committee (DAC) to store data and provide it on-demand instead of using its  as the Data Availability (DA) layer. The members of the DAC run a Data Availability Server (DAS) to handle these operations.

In this how-to, you'll learn how to configure a mirror DAS that serves `GET` requests for stored batches of information through a REST HTTP interface. For a refresher on DACs, refer to the _[Introduction](/run-arbitrum-node/data-availability-committees/get-started)_.

This how-to assumes that you're familiar with:

*   How a regular DAS works and what configuration options are available. Refer to _[How to deploy a DAS](/run-arbitrum-node/data-availability-committees/deploy-das)_ for a refresher.
*   [Kubernetes](https://kubernetes.io/). The examples in this guide use Kubernetes to containerize your DAS.

What is a mirror DAS?[​](#what-is-a-mirror-das "Direct link to What is a mirror DAS?")
--------------------------------------------------------------------------------------

To avoid exposing the REST interface of your main DAS to the public in order to prevent spamming attacks (as explained in [How to deploy a DAS](/run-arbitrum-node/data-availability-committees/deploy-das#security-considerations)), you can choose to run a mirror DAS to complement your setup. The mirror DAS will handle all public REST requests, while reading information from the main DAS via its (now private) REST interface.

In general, mirror DA servers serve two main purposes:

1.  Prevent the main DAS from having to serve requests for data, allowing it to focus only on storing the data received.
2.  Provide resiliency to the network in the case of a DAS going down.

Configuration options[​](#configuration-options "Direct link to Configuration options")
---------------------------------------------------------------------------------------

A mirror DAS will use the same tool and, thus, the same configuration options as your main DAS. You can find an explanation of those options in [How to deploy a DAS](/run-arbitrum-node/data-availability-committees/deploy-das#configuration-options).

How to deploy a mirror DAS[​](#how-to-deploy-a-mirror-das "Direct link to How to deploy a mirror DAS")
------------------------------------------------------------------------------------------------------

### Step 0: Prerequisites[​](#step-0-prerequisites "Direct link to Step 0: Prerequisites")

Gather the following information:

*   The latest Nitro docker image: `offchainlabs/nitro-node:v3.5.1-8f247fd`
*   An RPC endpoint for the . It is recommended to use a [third-party provider RPC](/build-decentralized-apps/reference/node-providers#third-party-rpc-providers) or [run your own node](/node-running/how-tos/running-an-orbit-node) to prevent being rate limited.
*   The SequencerInbox contract address in the parent chain.
*   URL of the list of REST endpoints of other DA servers to configure the REST aggregator.

### Step 1: Set up a persistent volume[​](#step-1-set-up-a-persistent-volume "Direct link to Step 1: Set up a persistent volume")

First, we'll set up a volume to store the DAS database. In k8s, we can use a configuration like this:

```rust
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: das-mirror
spec:
  accessModes:
    - ReadWriteOnce
  resources:
  requests:
    storage: 200Gi
  storageClassName: gp2
```

### Step 2: Deploy the mirror DAS[​](#step-2-deploy-the-mirror-das "Direct link to Step 2: Deploy the mirror DAS")

To run the mirror DAS, we'll use the `daserver` tool and we'll configure the following parameters:

Parameter

Description

\--data-availability.parent-chain-node-url

RPC endpoint of a parent chain node

\--data-availability.sequencer-inbox-address

Address of the SequencerInbox in the parent chain

\--enable-rest

Enables the REST server listening on --rest-addr and --rest-port

\--rest-addr

REST server listening interface (default "localhost")

\--rest-port

(Optional) REST server listening port (default 9877)

\--log-level

Log level: 1 - ERROR, 2 - WARN, 3 - INFO, 4 - DEBUG, 5 - TRACE (default 3)

\--data-availability.rest-aggregator.enable

Enables retrieval of sequencer batch data from a list of remote REST endpoints

\--data-availability.rest-aggregator.online-url-list

A URL to a list of URLs of REST DAS endpoints that is checked at startup. This option is additive with the urls option

\--data-availability.rest-aggregator.urls

List of URLs including 'http://' or 'https://' prefixes and port numbers to REST DAS endpoints. This option is additive with the online-url-list option

\--data-availability.rest-aggregator.sync-to-storage.check-already-exists

When using a REST aggregator, checks if the data already exists in this DAS's storage. Must be disabled for fast sync with an IPFS backend (default true)

\--data-availability.rest-aggregator.sync-to-storage.eager

When using a REST aggregator, eagerly syncs batch data to this DAS's storage from the REST endpoints, using the parent chain as the index of batch data hashes; otherwise only syncs lazily

\--data-availability.rest-aggregator.sync-to-storage.eager-lower-bound-block

When using a REST aggregator that's eagerly syncing, starts indexing forward from this block from the parent chain. Only used if there is no sync state.

\--data-availability.rest-aggregator.sync-to-storage.retention-period

When using a REST aggregator, period to retain the synced data (defaults to forever)

\--data-availability.rest-aggregator.sync-to-storage.state-dir

When using a REST aggregator, directory to store the sync state in, i.e. the block number currently synced up to, so that it doesn't sync from scratch each time

To enable caching, you can use the following parameters:

Parameter

Description

\--data-availability.local-cache.enable

Enables local in-memory caching of sequencer batch data

\--data-availability.local-cache.capacity

Maximum number of entries (up to 64KB each) to store in the cache. (default 20000)

Finally, for the storage backends you wish to configure, use the following parameters. Toggle between the different options to see all available parameters.

Local Badger database deprecated

The local badger DB storage option (set with `local-db-storage`) has been deprecated and should be replaced with the local files storage option (set with `local-file-storage`).

A migration tool has been included in Nitro to migrate all data from the local badger db to local files. You can activate it by using the parameter `--data-availability.migrate-local-db-to-file-storage`.

*   AWS S3 bucket
*   Local files
*   (Experimental) Google Cloud Storage
*   (Deprecated) Local Badger database

Parameter

Description

\--data-availability.s3-storage.enable

Enables storage/retrieval of sequencer batch data from an AWS S3 bucket

\--data-availability.s3-storage.access-key

S3 access key

\--data-availability.s3-storage.bucket

S3 bucket

\--data-availability.s3-storage.region

S3 region

\--data-availability.s3-storage.secret-key

S3 secret key

\--data-availability.s3-storage.object-prefix

Prefix to add to S3 objects

\--data-availability.s3-storage.discard-after-timeout

Whether to discard data after its expiry timeout (setting it to false, activates the “archive” mode)

Create the local directory before launching your DAS

Make sure you create the directory specified in `local-file-storage.data-dir` before launching your DAS to avoid potential permission issues with Docker or Kubernetes.

Parameter

Description

\--data-availability.local-file-storage.enable

Enables storage/retrieval of sequencer batch data from a directory of files, one per batch

\--data-availability.local-file-storage.data-dir

Absolute path of the directory inside the volume in which to store the data (it must exist)

\--data-availability.local-file-storage.enable-expiry

Enables expiry of batches

\--data-availability.local-file-storage.max-retention

Store requests with expiry times farther in the future than max-retention will be rejected (default: 504h0m0s)

Parameter

Description

\--data-availability.google-cloud-storage.enable

Enables storage/retrieval of sequencer batch data from a Google Cloud Storage bucket

\--data-availability.google-cloud-storage.access-token

Google Cloud Storage access token

\--data-availability.google-cloud-storage.bucket

Google Cloud Storage bucket

\--data-availability.google-cloud-storage.object-prefix

Prefix to add to Google Cloud Storage objects

\--data-availability.google-cloud-storage.enable-expiry

Enable expiry of batches (setting it to false, activates the "archive" mode)

\--data-availability.google-cloud-storage.max-retention

Store requests with expiry times farther in the future than max-retention will be rejected

Parameter

Description

\--data-availability.local-db-storage.enable

Enables storage/retrieval of sequencer batch data from a database on the local filesystem

\--data-availability.local-db-storage.data-dir

Absolute path of the directory inside the volume in which to store the database (it must exist)

\--data-availability.local-db-storage.discard-after-timeout

Whether to discard data after its expiry timeout (setting it to false, activates the “archive” mode)

\--data-availability.migrate-local-db-to-file-storage

Migrate all data on startup from local-db-storage to local-file-storage, then mark local-db-storage as unusable

Here's an example `daserver` command for a mirror DAS that:

*   Enables local cache
*   Enables AWS S3 bucket storage that doesn't discard data after expiring ([archive](#archive-da-servers))
*   Enables local file storage that, by default, doesn't discard data after expiring ([archive](#archive-da-servers))
*   Uses a local main DAS as part of the REST aggregator

```rust
daserver
    --data-availability.parent-chain-node-url "<YOUR PARENT CHAIN RPC ENDPOINT>"
    --data-availability.sequencer-inbox-address "<ADDRESS OF SEQUENCERINBOX ON PARENT CHAIN>"
    --enable-rest
    --rest-addr '0.0.0.0'
    --log-level 3
    --data-availability.local-cache.enable
    --data-availability.rest-aggregator.enable
    --data-availability.rest-aggregator.urls "http://your-main-das.svc.cluster.local:9877"
    --data-availability.rest-aggregator.online-url-list "<URL TO LIST OF REST ENDPOINTS>"
    --data-availability.rest-aggregator.sync-to-storage.eager
    --data-availability.rest-aggregator.sync-to-storage.eager-lower-bound-block "BLOCK NUMBER"
    --data-availability.rest-aggregator.sync-to-storage.state-dir /home/user/data/syncState
    --data-availability.s3-storage.enable
    --data-availability.s3-storage.access-key "<YOUR ACCESS KEY>"
    --data-availability.s3-storage.bucket "<YOUR BUCKET>"
    --data-availability.s3-storage.region "<YOUR REGION>"
    --data-availability.s3-storage.secret-key "<YOUR SECRET KEY>"
    --data-availability.s3-storage.object-prefix "<YOUR OBJECT KEY PREFIX>/"
    --data-availability.s3-storage.discard-after-timeout false
    --data-availability.local-file-storage.enable
    --data-availability.local-file-storage.data-dir /home/user/data/das-data
```

And here's an example of how to use a k8s deployment to run that command:

```rust
apiVersion: apps/v1
kind: Deployment
metadata:
    name: das-mirror
spec:
    replicas: 1
    selector:
    matchLabels:
        app: das-mirror
    strategy:
    rollingUpdate:
        maxSurge: 0
        maxUnavailable: 50%
    type: RollingUpdate
    template:
    metadata:
        labels:
        app: das-mirror
    spec:
        containers:
        - command:
        - bash
        - -c
        - |
            mkdir -p /home/user/data/badgerdb
            mkdir -p /home/user/data/syncState
            /usr/local/bin/daserver --data-availability.parent-chain-node-url "<YOUR PARENT CHAIN RPC ENDPOINT>" --data-availability.sequencer-inbox-address "<ADDRESS OF SEQUENCERINBOX ON PARENT CHAIN>" --enable-rest --rest-addr '0.0.0.0' --log-level 3 --data-availability.local-cache.enable --data-availability.rest-aggregator.enable --data-availability.rest-aggregator.urls "http://your-main-das.svc.cluster.local:9877" --data-availability.rest-aggregator.online-url-list "<URL TO LIST OF REST ENDPOINTS>" --data-availability.rest-aggregator.sync-to-storage.eager  --data-availability.rest-aggregator.sync-to-storage.eager-lower-bound-block "BLOCK NUMBER" --data-availability.rest-aggregator.sync-to-storage.state-dir /home/user/data/syncState --data-availability.s3-storage.enable --data-availability.s3-storage.access-key "<YOUR ACCESS KEY>" --data-availability.s3-storage.bucket "<YOUR BUCKET>" --data-availability.s3-storage.region "<YOUR REGION>" --data-availability.s3-storage.secret-key "<YOUR SECRET KEY>" --data-availability.s3-storage.object-prefix "<YOUR OBJECT KEY PREFIX>/" --data-availability.local-file-storage.enable --data-availability.local-file-storage.data-dir /home/user/data/das-data
        image: offchainlabs/nitro-node:v3.5.1-8f247fd
        imagePullPolicy: Always
        resources:
            limits:
            cpu: "4"
            memory: 10Gi
            requests:
            cpu: "4"
            memory: 10Gi
        ports:
        - containerPort: 9877
            hostPort: 9877
            protocol: TCP
        volumeMounts:
        - mountPath: /home/user/data/
            name: data
        readinessProbe:
            failureThreshold: 3
            httpGet:
            path: /health/
            port: 9877
            scheme: HTTP
            initialDelaySeconds: 5
            periodSeconds: 5
            successThreshold: 1
            timeoutSeconds: 1
        volumes:
        - name: data
        persistentVolumeClaim:
            claimName: das-mirror
```

Archive DA servers[​](#archive-da-servers "Direct link to Archive DA servers")
------------------------------------------------------------------------------

Archive DA servers are servers that don't discard any data after expiring. Each DAC should have at the very least one archive DAS to ensure all historical data is available.

To activate the "archive mode" in your DAS, set the parameter `discard-after-timeout` to `false` in your storage method. For example:

```rust
--data-availability.s3-storage.discard-after-timeout=false
```

Note that `local-file-storage` doesn't discard data after expiring by default, but expiration can be enabled with `enable-expiry`.

Archive servers should make use of the `--data-availability.rest-aggregator.sync-to-storage` options described above to pull in any data that they don't have.

Helm charts[​](#helm-charts "Direct link to Helm charts")
---------------------------------------------------------

A helm chart is available at [ArtifactHUB](https://artifacthub.io/packages/helm/offchainlabshelm/das). It supports running a mirror DAS by providing the parameters for your server. Find more information in the [OCL community Helm charts repository](https://github.com/OffchainLabs/community-helm-charts/tree/main/charts/das).

Testing the DAS[​](#testing-the-das "Direct link to Testing the DAS")
---------------------------------------------------------------------

Once the DAS is running, we can test if everything is working correctly using the following methods.

### Test 1: REST health check[​](#test-1-rest-health-check "Direct link to Test 1: REST health check")

The REST interface enabled in the mirror DAS has a health check on the path `/health` which will return `200` if the underlying storage is working, otherwise `503`.

Example:

```rust
curl -I <YOUR REST ENDPOINT>/health
```

Security considerations[​](#security-considerations "Direct link to Security considerations")
---------------------------------------------------------------------------------------------

Keep in mind the following information when running the mirror DAS.

For a mirror DAS, using a load balancer is recommended to manage incoming traffic effectively. Additionally, as the REST interface is cacheable, consider deploying a Content Delivery Network (CDN) or caching proxy in front of your REST endpoint. The URL for the REST interface will be publicly known; ensure that it is sufficiently distinct from the RPC endpoint to prevent the latter from being easily discovered.

What to do next?[​](#what-to-do-next "Direct link to What to do next?")
-----------------------------------------------------------------------

Once the DAS is deployed and tested, you'll have to communicate the following information to the chain owner, so they can update the chain parameters and configure the sequencer:

*   The https URL for the REST endpoint (e.g. das.your-chain.io/rest)

Optional parameters[​](#optional-parameters "Direct link to Optional parameters")
---------------------------------------------------------------------------------

Besides the parameters described in this guide, there are some more options that can be useful when running the DAS. For a comprehensive list of configuration parameters, you can run `daserver --help`.

Parameter

Description

\--conf.dump

Prints out the current configuration

\--conf.file

Absolute path to the configuration file inside the volume to use instead of specifying all parameters in the command

Metrics[​](#metrics "Direct link to Metrics")
---------------------------------------------

The DAS comes with the option of producing Prometheus metrics. This option can be activated by using the following parameters:

Parameter

Description

\--metrics

Enables the metrics server

\--metrics-server.addr

Metrics server address (default "127.0.0.1")

\--metrics-server.port

Metrics server port (default 6070)

\--metrics-server.update-interval

Metrics server update interval (default 3s)

When metrics are enabled, several useful metrics are available at the configured port, at path `debug/metrics` or `debug/metrics/prometheus`.

### RPC metrics[​](#rpc-metrics "Direct link to RPC metrics")

Metric

Description

arb\_das\_rpc\_store\_requests

Count of RPC Store calls

arb\_das\_rpc\_store\_success

Successful RPC Store calls

arb\_das\_rpc\_store\_failure

Failed RPC Store calls

arb\_das\_rpc\_store\_bytes

Bytes retrieved with RPC Store calls

arb\_das\_rpc\_store\_duration (p50, p75, p95, p99, p999, p9999)

Duration of RPC Store calls (ns)

### REST metrics[​](#rest-metrics "Direct link to REST metrics")

Metric

Description

arb\_das\_rest\_getbyhash\_requests

Count of REST GetByHash calls

arb\_das\_rest\_getbyhash\_success

Successful REST GetByHash calls

arb\_das\_rest\_getbyhash\_failure

Failed REST GetByHash calls

arb\_das\_rest\_getbyhash\_bytes

Bytes retrieved with REST GetByHash calls

arb\_das\_rest\_getbyhash\_duration (p50, p75, p95, p99, p999, p9999)

Duration of REST GetByHash calls (ns)

---

# How to configure a Data Availability Committee: Introduction | Arbitrum Docs

## How to configure a Data Availability Committee: Introduction

 chains rely on an external Data Availability Committee (DAC) to store data and provide it on-demand instead of using its  as the Data Availability (DA) layer. The members of the DAC run a Data Availability Server (DAS) to handle these operations.

This section offers information and a series of how-to guides to help you along the process of setting up a Data Availability Committee. These guides target two audiences: Committee members who wish to deploy a Data Availability Server, and chain owners who wish to configure their chain with the information of the Committee.

Before following the guides in this section, you should be familiar with how the AnyTrust protocol works and the role of the DAC in the protocol. Refer to _[Inside AnyTrust](/how-arbitrum-works/anytrust-protocol)_ to learn more.

If you are a DAC member[​](#if-you-are-a-dac-member "Direct link to If you are a DAC member")
---------------------------------------------------------------------------------------------

Committee members will need to run a DAS. To do that, they will first need to generate a pair of keys and deploy a DAS. They may also choose to deploy an additional mirror DAS. Find more information in [How to deploy a DAS](/run-arbitrum-node/data-availability-committees/deploy-das) and [How to deploy a mirror DAS](/run-arbitrum-node/data-availability-committees/deploy-mirror-das).

Here's a basic checklist of actions to complete for DAC members:

*   [Deploy a DAS](/run-arbitrum-node/data-availability-committees/deploy-das). Send the following information to the chain owner:
    *   Public BLS key
    *   The https URL for the RPC endpoint which includes some random string (e.g. das.your-chain.io/rpc/randomstring123), communicated through a secure channel
    *   The https URL for the REST endpoint (e.g. das.your-chain.io/rest)
*   [Deploy a mirror DAS](/run-arbitrum-node/data-availability-committees/deploy-mirror-das) if you want to complement your setup with a mirror DAS. Send the following information to the chain owner:
    *   The https URL for the REST endpoint (e.g. das.your-chain.io/rest)

If you are a chain owner[​](#if-you-are-a-chain-owner "Direct link to If you are a chain owner")
------------------------------------------------------------------------------------------------

Chain owners will need to gather the information from the committee members to craft the necessary data to update their chain and the batch poster (more information in [How to configure the DAC in your chain](/run-arbitrum-node/data-availability-committees/configure-dac)). They might also want to test each DAS individually, by following the testing guides available in [How to deploy a DAS](/run-arbitrum-node/data-availability-committees/deploy-das#testing-the-das) and [How to deploy a mirror DAS](/run-arbitrum-node/data-availability-committees/deploy-mirror-das#testing-the-das).

Here's a basic checklist of actions to complete for chain owners:

*   Gather the following information from every member of the committee:
    *   Public BLS Key
    *   URL of the RPC endpoint
    *   URL(s) of the REST endpoint(s)
*   Ensure that at least one DAS is running as an [archive DAS](/run-arbitrum-node/data-availability-committees/deploy-das#archive-da-servers)
*   [Generate the keyset and keyset hash](/run-arbitrum-node/data-availability-committees/configure-dac#step-1-generate-the-keyset-and-keyset-hash-with-all-the-information-from-the-servers) with all the information from the servers
*   [Update the SequencerInbox contract](/run-arbitrum-node/data-availability-committees/configure-dac#step-2-update-the-sequencerinbox-contract)
*   [Craft the new configuration for the batch poster](/run-arbitrum-node/data-availability-committees/configure-dac#step-3-craft-the-new-configuration-for-the-batch-poster)
*   [Craft the new configuration for your chain's nodes](/run-arbitrum-node/data-availability-committees/configure-dac#step-4-craft-the-new-configuration-for-your-chains-nodes)

Ask for help[​](#ask-for-help "Direct link to Ask for help")
------------------------------------------------------------

Configuring a DAC might be a complex process. If you need help setting it up, don't hesitate to ask us on [Discord](https://discord.gg/arbitrum).

---

# How to use Timeboost | Arbitrum Docs

## How to use Timeboost

Timeboost is a new transaction ordering policy for Arbitrum chains. With Timeboost, anyone can bid for the right to access an express lane on the **Sequencer** faster transaction inclusion.

In this how-to, you'll learn how to bid for the right to use the express lane and submit transactions through the express lane. To learn more about Timeboost and the key terms used on this page, refer to the [gentle introduction](/how-arbitrum-works/timeboost/gentle-introduction).

This how-to assumes that you're familiar with the following:

*   [How Timeboost works](/how-arbitrum-works/timeboost/gentle-introduction)
*   [viem](https://viem.sh/), since the snippets of code present in the how-to use this library

Note about transferring express lane rights

Please note that in the initial release of Timeboost, transferring of express lane control via the either the `setTransferor` or the `transferExpressLaneController` will not be supported by the Arbitrum Nitro node software in the initial launch and may be implemented at a future date via a regular node upgrade. Calls made to these two functions on the auction contract will be successful, but actual transfer of the rights will not be recognized by the node software (including the sequencer).

A round's express lane controller, at their choice, can still send transactions signed by others on a per-transaction basis, as explained later in this guide.

How to submit bids for the right to be the express lane controller[​](#how-to-submit-bids-for-the-right-to-be-the-express-lane-controller "Direct link to How to submit bids for the right to be the express lane controller")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

To use the express lane for faster transaction inclusion, you must win an auction for the right to be the express lane controller for a specific round.

info

Remember that, by default, each round lasts 60 seconds, and the auction for a specific round closes 15 seconds before the round starts. These default values can be configured on a chain using the `roundDurationSeconds` and `auctionClosingSeconds` parameters.

Auctions are facilitated by an auction contract, and bids get submitted to an autonomous auctioneer that interact with the contract. Let's look at the process of submitting bids and finding out the winner of an auction.

### Prerequisites: Gather the required information[​](#prerequisites-gather-the-required-information "Direct link to Prerequisites: Gather the required information")

Before we begin, make sure you have:

*   Address of the auction contract
*   Endpoint of the autonomous auctioneer

The following table shows this information for the Arbitrum DAO-owned chains:

Network

Auction contract

Autonomous auctioneer endpoint

Arbitrum Sepolia

[0x991DbEDf388CB5925318f06362D4fCa7b040527D](https://sepolia.arbiscan.io/address/0x991DbEDf388CB5925318f06362D4fCa7b040527D)

[https://sepolia-bv.arbitrum.io/](https://sepolia-bv.arbitrum.io/)

Arbitrum One

Pending on-chain governance vote

Pending on-chain governance vote

Arbitrum Nova

Pending on-chain governance vote

Pending on-chain governance vote

### Step 1: Deposit funds into the auction contract[​](#step-1-deposit-funds-into-the-auction-contract "Direct link to Step 1: Deposit funds into the auction contract")

Before bidding on an auction, we need to deposit funds in the auction contract. These funds are deposited in the form of the ERC-20 token used to bid, also known as the `bidding token`. We will be able to bid for an amount that is equal to or less than the tokens we have deposited in the auction contract.

To see the amount of tokens we have deposited in the auction contract, we can call the function `balanceOf` in the auction contract:

```rust
const depositedBalance = await publicClient.readContract({
  address: auctionContractAddress,
  abi: auctionContractAbi,
  functionName: 'balanceOf',
  args: [userAddress],
});
console.log(`Current balance of ${userAddress} in auction contract: ${depositedBalance}`);
```

If we want to deposit more funds to the auction contract, we first need to know what the bidding token is. To obtain the address of the bidding token, we can call the function `biddingToken` in the auction contract:

```rust
const biddingTokenContractAddress = await publicClient.readContract({
  address: auctionContractAddress,
  abi: auctionContractAbi,
  functionName: 'biddingToken',
});
console.log(`biddingToken: ${biddingTokenContractAddress}`);
```

Bidding token in Arbitrum chains

On Arbitrum One and Arbitrum Nova, the default bidding token is WETH.

Once we know what the bidding token is, we can deposit funds to the auction contract by calling the function `deposit` of the contract after having it approved as spender of the amount we want to deposit:

```rust
// Approving spending tokens
const approveHash = await walletClient.writeContract({
  account,
  address: biddingTokenContractAddress,
  abi: parseAbi(['function approve(address,uint256)']),
  functionName: 'approve',
  args: [auctionContract, amountToDeposit],
});
console.log(`Approve transaction sent: ${approveHash}`);

// Making the deposit
const depositHash = await walletClient.writeContract({
  account,
  address: auctionContractAddress,
  abi: auctionContractAbi,
  functionName: 'deposit',
  args: [amountToDeposit],
});
console.log(`Deposit transaction sent: ${depositHash}`);
```

### Step 2: submit bids[​](#step-2-submit-bids "Direct link to Step 2: submit bids")

Once we have deposited funds into the auction contract, we can submit bids for the current auction round.

We can obtain the current round by calling the function `currentRound` in the auction contract:

```rust
const currentRound = await publicClient.readContract({
  address: auctionContractAddress,
  abi: auctionContractAbi,
  functionName: 'currentRound',
});
console.log(`Current round: ${currentRound}`);
```

The above shows the current round that's running. At the same time, the auction for the next round might be open. For example, if the `currentRound` is 10, the auction for round 11 is happening right now. To check whether or not that auction is open, we can call the function `isAuctionRoundClosed` of the auction contract:

```rust
let currentAuctionRoundIsClosed = await publicClient.readContract({
  address: auctionContractAddress,
  abi: auctionContractAbi,
  functionName: 'isAuctionRoundClosed',
});
```

Remember that, by default, auctions for a given round open 60 seconds before that round starts and close 15 seconds before the round starts, so there might be no auctions opened at certain times.

Once we know what is the current round we can bid for (`currentRound + 1`) and we have verified that the auction is still open (`!currentAuctionRoundIsClosed`), we can submit a bid.

Bids are submitted to the autonomous auctioneer endpoint. We need to send a `auctioneer_submitBid` request with the following information:

*   chain id
*   address of the express lane controller candidate (for example, our address if we want to be the express lane controller)
*   address of the auction contract
*   round we are bidding for (in our example, `currentRound + 1`)
*   amount in wei of the deposit ERC-20 token to bid
*   signature (explained below)

Minimum reserve price

The amount to bid must be above the minimum reserve price at the moment you are bidding. This parameter is configurable per chain. You can obtain the minimum reserve price by calling the method `minReservePrice()(uint256)` in the auction contract.

Let's see an example of a call to this RPC method:

```rust
const currentAuctionRound = currentRound + 1;
const hexChainId: `0x${string}` = `0x${Number(publicClient.chain.id).toString(16)}`;

const res = await fetch(<AUTONOMOUS_AUCTIONEER_ENDPOINT>, {
  method: 'POST',
  headers: { 'content-type': 'application/json' },
  body: JSON.stringify({
    jsonrpc: '2.0',
    id: 'submit-bid',
    method: 'auctioneer_submitBid',
    params: [
      {
        chainId: hexChainId,
        expressLaneController: userAddress,
        auctionContractAddress: auctionContractAddress,
        round: `0x${currentAuctionRound.toString(16)}`,
        amount: `0x${Number(amountToBid).toString(16)}`,
        signature: signature,
      },
    ],
  }),
});
```

The signature that needs to be sent is an [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature over the following typed structure data:

*   Domain: `Bid(uint64 round,address expressLaneController,uint256 amount)`
*   `round`: auction round number
*   `expressLaneController`: address of the express lane controller candidate
*   `amount`: amount to bid

Here's an example to produce that signature with viem:

```rust
const currentAuctionRound = currentRound + 1;

const signatureData = hashTypedData({
  domain: {
    name: 'ExpressLaneAuction',
    version: '1',
    chainId: Number(publicClient.chain.id),
    verifyingContract: auctionContractAddress,
  },
  types: {
    Bid: [
      { name: 'round', type: 'uint64' },
      { name: 'expressLaneController', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
  },
  primaryType: 'Bid',
  message: {
    round: currentAuctionRound,
    expressLaneController: userAddress,
    amount: amountToBid,
  },
});
const signature = await account.sign({
  hash: signatureData,
});
```

info

You can also call the function `getBidHash` in the auction contract to obtain the `signatureData`, specifying the `round`, `userAddress` and `amountToBid`.

When sending the request, the autonomous auctioneer will return an empty result with an HTTP status `200` if received correctly. If the result returned contains an error message, it means that something went wrong. Following are some of the error messages that can help us understand what's happening:

Error

Description

`MALFORMED_DATA`

wrong input data, failed to deserialize, missing certain fields, etc.

`NOT_DEPOSITOR`

the address is not an active depositor in the auction contract

`WRONG_CHAIN_ID`

wrong chain id for the target chain

`WRONG_SIGNATURE`

signature failed to verify

`BAD_ROUND_NUMBER`

incorrect round, such as one from the past

`RESERVE_PRICE_NOT_MET`

bid amount does not meet the minimum required reserve price on-chain

`INSUFFICIENT_BALANCE`

the bid amount specified in the request is higher than the deposit balance of the depositor in the contract

### Step 3: find out the winner of the auction[​](#step-3-find-out-the-winner-of-the-auction "Direct link to Step 3: find out the winner of the auction")

After the auction closes and before the round starts, the autonomous auctioneer will call the auction contract with the two highest bids received so the contract can declare the winner and subtract the second-highest bid from the winner's deposited funds. After this, the contract will emit an event with the new express lane controller address.

We can use this event to determine whether or not we've won the auction. The event signature is:

```rust
event SetExpressLaneController(
    uint64 round,
    address indexed previousExpressLaneController,
    address indexed newExpressLaneController,
    address indexed transferor,
    uint64 startTimestamp,
    uint64 endTimestamp
);
```

Here's an example to get the log from the auction contract to determine the new express lane controller:

```rust
const fromBlock = <any recent block, for example during the auction>
const logs = await publicClient.getLogs({
  address: auctionContractAddress,
  event: auctionContractAbi.filter((abiEntry) => abiEntry.name === 'SetExpressLaneController')[0],
  fromBlock,
});

const newExpressLaneController = logs[0].args.newExpressLaneController;
console.log(`New express lane controller: ${newExpressLaneController}`);
```

If you won the auction, congratulations! You are the express lane controller for the next round, which, by default, will start 15 seconds after the auction closes. The following section explains how we can submit a transaction to the express lane.

How to submit transactions to the express lane[​](#how-to-submit-transactions-to-the-express-lane "Direct link to How to submit transactions to the express lane")
------------------------------------------------------------------------------------------------------------------------------------------------------------------

The sequencer immediately sequences transactions sent to the express lane, while regular transactions are delayed 200ms by default. However, only the express lane controller can send transactions to the express lane. The previous section explained how to participate in the auction as the express lane controller for a given round.

The express lane is handled by the sequencer, so transactions are sent to the sequencer endpoint. We need to send a `timeboost_sendExpressLaneTransaction` request with the following information:

*   chain id
*   current round (following the example above, `currentRound`)
*   address of the auction contract
*   sequence number: a per-round nonce of express lane submissions, which is reset to 0 at the beginning of each round
*   RLP encoded transaction payload
*   conditional options for Arbitrum transactions ([more information](https://github.com/OffchainLabs/go-ethereum/blob/48de2030c7a6fa8689bc0a0212ebca2a0c73e3ad/arbitrum_types/txoptions.go#L71))
*   signature (explained below)

Timeboost-ing third party transactions

Notice that while the express lane controller must sign the `timeboost_sendExpressLaneTransaction` request, the actual transaction to be executed can be signed by any party. In other words, the express lane controller can receive transactions signed by other parties and sign them to apply the time advantage offered by the express lane to those transactions.

Support for `eth_sendRawTransactionConditional`

Timeboost doesn't currently support the `eth_sendRawTransactionConditional` method.

Let's see an example of a call to this RPC method:

```rust
const hexChainId: `0x${string}` = `0x${Number(publicClient.chain.id).toString(16)}`;

const transaction = await walletClient.prepareTransactionRequest(...);
const serializedTransaction = await walletClient.signTransaction(transaction);

const res = await fetch(<SEQUENCER_ENDPOINT>, {
  method: 'POST',
  headers: { 'content-type': 'application/json' },
  body: JSON.stringify({
    jsonrpc: '2.0',
    id: 'express-lane-tx',
    method: 'timeboost_sendExpressLaneTransaction',
    params: [
      {
        chainId: hexChainId,
        round: `0x${currentRound.toString(16)}`,
        auctionContractAddress: auctionContractAddress,
        sequence: `0x${sequenceNumber.toString(16)}`,
        transaction: serializedTransaction,
        options: {},
        signature: signature,
      },
    ],
  }),
});
```

The signature that needs to be sent is an Ethereum signature over the bytes encoding of the following information:

*   Hash of `keccak256("TIMEBOOST_BID")`
*   Chain id in hexadecimal, padded to 32 bytes
*   Auction contract address
*   Round number in hexadecimal, padded to 8 bytes
*   Sequence number in hexadecimal, padded to 8 bytes
*   Serialized transaction

Here's an example to produce that signature:

```rust
const hexChainId: `0x${string}` = `0x${Number(publicClient.chain.id).toString(16)}`;

const transaction = await walletClient.prepareTransactionRequest(...);
const serializedTransaction = await walletClient.signTransaction(transaction);

const signatureData = concat([
  keccak256(toHex('TIMEBOOST_BID')),
  pad(hexChainId),
  auctionContract,
  toHex(numberToBytes(currentRound, { size: 8 })),
  toHex(numberToBytes(sequenceNumber, { size: 8 })),
  serializedTransaction,
]);
const signature = await account.signMessage({
  message: { raw: signatureData },
});
```

When sending the request, the sequencer will return an empty result with an HTTP status `200` if it received it correctly. If the result returned contains an error message, something went wrong. Following are some of the error messages that can help us understand what's happening:

Error

Description

`MALFORMED_DATA`

wrong input data, failed to deserialize, missing certain fields, etc.

`WRONG_CHAIN_ID`

wrong chain id for the target chain

`WRONG_SIGNATURE`

signature failed to verify

`BAD_ROUND_NUMBER`

incorrect round, such as one from the past

`NOT_EXPRESS_LANE_CONTROLLER`

the sender is not the express lane controller

`NO_ONCHAIN_CONTROLLER`

there is no defined, on-chain express lane controller for the round

What happens if you're not the express lane controller?

If you are not the express lane controller and you try to submit a transaction to the express lane, the sequencer will respond with the error `NOT_EXPRESS_LANE_CONTROLLER` or `NO_ONCHAIN_CONTROLLER`.

How to withdraw funds deposited in the auction contract[​](#how-to-withdraw-funds-deposited-in-the-auction-contract "Direct link to How to withdraw funds deposited in the auction contract")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Funds are deposited in the auction contract to have the right to bid in auctions. Withdrawing funds is possible through two steps: initiate withdrawal, wait for two rounds, and finalize withdrawal.

To initiate a withdrawal, we can call the function `initiateWithdrawal` in the auction contract:

```rust
const initWithdrawalTransaction = await walletClient.writeContract({
  account,
  address: auctionContractAddress,
  abi: auctionContractAbi,
  functionName: 'initiateWithdrawal',
});
console.log(`Initiate withdrawal transaction sent: ${initWithdrawalTransaction}`);
```

This transaction will initiate a withdrawal of all funds deposited by the sender account. When executing it, the contract will emit a `WithdrawalInitiated` event, with the following structure:

```rust
event WithdrawalInitiated(
    address indexed account,
    uint256 withdrawalAmount,
    uint256 roundWithdrawable
);
```

In this event, `account` refers to the address whose funds are being withdrawn, `withdrawalAmount` refers to the amount being withdrawn from the contract, and `roundWithdrawable` refers to the round at which the withdrawal can be finalized.

After two rounds have passed, we can call the method `finalizeWithdrawal` in the auction contract to finalize the withdrawal:

```rust
const finalizeWithdrawalTransaction = await walletClient.writeContract({
  account,
  address: auctionContractAddress,
  abi: auctionContractAbi,
  functionName: 'finalizeWithdrawal',
});
console.log(`Finalize withdrawal transaction sent: ${finalizeWithdrawalTransaction}`);
```

How to identify timeboosted transactions[​](#how-to-identify-timeboosted-transactions "Direct link to How to identify timeboosted transactions")
------------------------------------------------------------------------------------------------------------------------------------------------

Transactions sent to the express lane by the express lane controller and that have been executed (regardless of them being successful or having reverted) can be identified by looking at their receipts or the message broadcasted by the sequencer feed.

Transaction receipts include now a new field `timeboosted`, which will be `true` for timeboosted transactions, and `false` for regular non-timeboosted transactions. For example:

```rust
blockHash               0x56325449149b362d4ace3267681c3c90823f1e5c26ccc4df4386be023f563eb6
blockNumber             105169374
contractAddress
cumulativeGasUsed       58213
effectiveGasPrice       100000000
from                    0x193cA786e7C7CC67B6227391d739E41C43AF285f
gasUsed                 58213
logs                    []
logsBloom               0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
root
status                  1 (success)
transactionHash         0x62ea458ad2bb408fab57d1a31aa282fe3324b2711e0d73f4777db6e34bc1bef5
transactionIndex        1
type                    2
blobGasPrice
blobGasUsed
to                      0x0000000000000000000000000000000000000001
gasUsedForL1            "0x85a5"
l1BlockNumber           "0x6e8b49"
timeboosted             true
```

In the sequencer feed, the `BroadcastFeedMessage` struct now contains a `blockMetadata` field that represents whether a particular transaction in the block was timeboosted or not. The field blockMetadata is an array of bytes and it starts with a byte representing the version (`0`), followed by `ceil(N/8)` number of bytes where `N` is the number of transactions in the block. If a particular transaction was timeboosted, the bit representing its position in the block will be set to `1`, while the rest will be set to `0`. For example, if the `blockMetadata` of a particular message, viewed as bits is `00000000 01100000`, then the 2nd and 3rd transactions in that block were timeboosted.

---

# L1 Ethereum beacon chain RPC providers | Arbitrum Docs

## L1 Ethereum beacon chain RPC providers

Note

This reference document provides an overview of Ethereum beacon chain RPC providers for Arbitrum validators to use for accessing blob data following Ethereum's Dencun upgrade in March 2024. The list curated here is **not comprehensive and in no way does Offchain Labs endorse or benefit from your use of any of these providers.**

Following [Ethereum's Dencun upgrade in March 2024](https://eips.ethereum.org/EIPS/eip-7569), child blockchains like Arbitrum will be able to roll up and post batches of transaction data on Ethereum in the form of a new transaction format called a Blob. This Blob data will be part of the beacon chain and is fully downloadable by all consensus nodes. This means that data stored in blobs are inaccessible by the EVM, unlike calldata.

### What does this mean for node operators?[​](#what-does-this-mean-for-node-operators "Direct link to What does this mean for node operators?")

To run a node for a child Arbitrum chain (i.e. Arbitrum One, Arbitrum Nova, and L3 Orbit chains), your node will need access to blob data to sync up to the latest state of your Arbitrum child chain. Blob data on Ethereum is stored on the beacon chain and is inaccessible to the EVM, hence why dedicated RPC endpoints for the beacon chain will be required after the Dencun upgrade. You can find more details on node requirements in the [Run a full node guide](/run-arbitrum-node/run-full-node).

Furthermore, new node operators joining a network or node operators who come online following an extended period of offline time will require access to _historical_ blob data to sync up to the latest state of their Arbitrum chain.

Offchain Labs has plans to reduce a Nitro validator's reliance on historical blob data and will share updates on this effort in the future.

### List of Ethereum beacon chain RPC providers[​](#list-of-ethereum-beacon-chain-rpc-providers "Direct link to List of Ethereum beacon chain RPC providers")

Provider

Mainnet Beacon chain APIs?

Mainnet Historical blob data?

Holesky Beacon chain APIs?

Sepolia Beacon chain APIs?

[Ankr](https://www.ankr.com/docs/rpc-service/chains/chains-api/eth-beacon/)

✅

✅

[Chainbase](https://chainbase.com/)

✅

[Chainstack](https://docs.chainstack.com/reference/beacon-chain)

✅

✅

✅

✅

[Conduit](https://conduit.xyz/)\*

✅

✅

[BlastAPI](https://blastapi.io/public-api/ethereum)

✅

[Nirvana Labs](https://nirvanalabs.io)

✅

✅

[NodeReal](https://nodereal.io/)

✅

[QuickNode](https://www.quicknode.com/docs/ethereum)

✅

✅

✅

✅

[dRPC](https://drpc.org/chainlist/eth-beacon-chain)

✅

✅

✅

✅

Please reach out to these teams individually if you need assistance with setting up your validator with any of the above providers.

**\*Case-by-case basis, please contact them directly for help**

---

# How to run an archive node | Arbitrum Docs

## How to run an archive node

An Arbitrum **archive node** is a full node that maintains an archive of historical chain states. This how-to walks you through the process of configuring an archive node on your local machine so that you can query both pre-Nitro and post-Nitro state data.

caution

**Most users won't need to configure an archive node**. This node type is great for a small number of use cases - for example if you need to process historical data.

### Before we begin[​](#before-we-begin "Direct link to Before we begin")

Before the Nitro upgrade, Arbitrum One ran on the Classic stack for about one year (before block height 22207817). Although the Nitro chain uses the latest snapshot of the Classic chain's state as its genesis state, **the Nitro stack can't serve archive requests for pre-Nitro blocks**.

Running an Arbitrum One **full node** in **archive mode** lets you access both pre-Nitro and post-Nitro blocks, but it requires you to run **both Classic and Nitro nodes** together. You may not need to do this, depending on your use case:

Use case

Required node type(s)

Docs

Access the **Arbitrum network** without running your own node

Fully managed by third-parties, exposed via RPC endpoints

[RPC endpoints and providers](/build-decentralized-apps/reference/node-providers)

Run an **archive node** for **Arbitrum Sepolia (testnet)** or **Arbitrum Nova**

Full node (Nitro)

[How to run a full node (Nitro)](/run-arbitrum-node/run-full-node)

Send **post-Nitro** archive requests

Full node (Nitro)

[How to run a full node (Nitro)](/run-arbitrum-node/run-full-node)

Send **pre-Nitro** archive requests

Full node (Classic)

[How to run a full node (Classic, pre-Nitro)](/run-arbitrum-node/more-types/run-classic-node)

Send **post-Nitro** _and_ **pre-Nitro** archive requests

Full node (Nitro) _and_ full node (Classic)

That's what this how-to is for; you're in the right place.

### System requirements[​](#system-requirements "Direct link to System requirements")

caution

As of May 2024, archive node snapshots for Arbitrum One, Arbitrum Nova, and Arbitrum Sepolia are no longer being updated on [https://snapshot-explorer.arbitrum.io/](https://snapshot-explorer.arbitrum.io/) due to accelerated database and state growth. Teams who use these publicly available archive snapshots will need to wait longer than usual for their nodes to sync up.

The Offchain Labs team is actively exploring and working on solutions to address this and will provide an update as soon as possible. In the meantime, the Offchain Labs team continues to recommend that teams periodically create their own snapshots by stopping one of their archive nodes and backing up their database.

caution

The minimum storage requirements will change as the Nitro chains grow (growing rates are specified below). We recommend exceeding the minimum requirements as much as you can to minimize risk and maintenance overhead.

1.  **RAM:** 16GB+ for Nitro and 32GB+ for Classic
2.  **CPU:** 4+ core CPU
3.  **Storage (last updated on April 2024):**
    *   Arbitrum One: 9.7TB SSD, currently growing at a rate of about 850GB per month
    *   Arbitrum Nova: 4.3TB SSD, currently growing at a rate of about 1.8TB GB per month
4.  **Docker images:** We'll specify these in the below commands; you don't need to download them manually.
    *   Latest Docker image for **Arbitrum One Nitro**: `offchainlabs/nitro-node:v3.5.1-8f247fd`
    *   Latest Docker image for **Arbitrum One Classic**: `offchainlabs/arb-node:v1.4.5-e97c1a4`
5.  **Database snapshots:**
    *   Nitro database snapshot
        *   Use the parameter `--init.url=` on the first startup to initialize the Nitro database (you can find a list of snapshots [here](https://snapshot-explorer.arbitrum.io/)). Example: `--init.url="[https://snapshot.arbitrum.foundation/arb1/nitro-archive.tar](https://snapshot.arbitrum.foundation/arb1/nitro-archive.tar)"`
    *   Arbitrum One Classic database snapshot
        *   Download the latest Arbitrum One Classic database snapshot at [https://snapshot.arbitrum.foundation/arb1/classic-archive.tar](https://snapshot.arbitrum.foundation/arb1/classic-archive.tar) and place it in the mounted point directory
        *   Note that other chains don't have Classic blocks and thus don't require an initial genesis database.
    *   Snapshot Explorer
        *   You can find more snapshots on our [snapshot explorer](https://snapshot-explorer.arbitrum.io/)

### Review and configure ports[​](#review-and-configure-ports "Direct link to Review and configure ports")

*   RPC: `8547`
*   Sequencer Feed: `9642`
*   WebSocket: `8548`

### Review and configure parameters[​](#review-and-configure-parameters "Direct link to Review and configure parameters")

Arbitrum Nitro

Arbitrum Classic

Description

`--parent-chain.connection.url=<Layer 1 Ethereum RPC URL>`

`--l1.url=<Layer 1 Ethereum RPC URL>`

Provide an standard L1 node RPC endpoint that you run yourself or from a third-party node provider (see [RPC endpoints and providers](/build-decentralized-apps/reference/node-providers))

`--chain.id=<L2 chain ID>`

`--l2.chain-id=<L2 Chain ID>`

See [RPC endpoints and providers](/build-decentralized-apps/reference/node-providers) for a list of Arbitrum chains and the respective L2 chain IDs

`--execution.caching.archive`

`--node.caching.archive`

Required for running an **Arbitrum One Nitro** archival node and retains past block state

\-

`--node.cache.allow-slow-lookup`

Required for running an **Arbitrum One Classic** archival node. When this option is present, it will load old blocks from disk if not in memory cache.

\-

`--core.checkpoint-gas-frequency=156250000`

Required for running an **Arbitrum One Classic** archival node.

### Run the Docker image(s)[​](#run-the-docker-images "Direct link to Run the Docker image(s)")

When running a Docker image, an external volume should be mounted to persist the database across restarts. The mount point should be `/home/user/.arbitrum/mainnet`.

To run both Arbitrum Nitro and/or Arbitrum Classic in archive mode, follow one or more of the below examples:

*   **Arbitrum One Nitro archive node**:
    
    ```rust
    docker run --rm -it -v /some/local/dir/arbitrum:/home/user/.arbitrum -p 0.0.0.0:8547:8547 -p 0.0.0.0:8548:8548 offchainlabs/nitro-node:v3.5.1-8f247fd --parent-chain.connection.url https://l1-node:8545 --chain.id=42161 --http.api=net,web3,eth --http.corsdomain=* --http.addr=0.0.0.0 --http.vhosts=* --execution.caching.archive
    ```
    
*   **Arbitrum One Classic archive node**:
    
    ```rust
    docker run --rm -it -v /some/local/dir/arbitrum-mainnet/:/home/user/.arbitrum/mainnet -p 0.0.0.0:8547:8547 -p 0.0.0.0:8548:8548 offchainlabs/arb-node:v1.4.5-e97c1a4 --l1.url=https://l1-node:8545/ --node.chain-id=42161 --l2.disable-upstream --node.cache.allow-slow-lookup --core.checkpoint-gas-frequency=156250000 --core.lazy-load-core-machine
    ```
    
*   **Arbitrum One Nitro archive node with forwarding classic execution support**:
    
    ```rust
    docker run --rm -it -v /some/local/dir/arbitrum:/home/user/.arbitrum -p 0.0.0.0:8547:8547 -p 0.0.0.0:8548:8548 offchainlabs/nitro-node:v3.5.1-8f247fd --parent-chain.connection.url https://l1-node:8545 --chain.id=42161 --execution.rpc.classic-redirect=<classic node RPC> --http.api=net,web3,eth --http.corsdomain=* --http.addr=0.0.0.0 --http.vhosts=* --execution.caching.archive
    ```
    

Note that the above commands both map to port `8547` on their hosts. To run both on the same host, you should edit those mapping to different ports and specify your Classic node RPC URL as `<classic node RPC>` in your Nitro start command. To verify the connection health of your node(s), see [Docker network between containers - Docker Networking Example](https://www.middlewareinventory.com/blog/docker-network-example/).

#### A note on permissions[​](#a-note-on-permissions "Direct link to A note on permissions")

The Docker image is configured to run as non-root `UID 1000`. If you're running in Linux and you're getting permission errors when trying to run the Docker image, run this command to allow all users to update the persistent folders, replacing `arbitrum-mainnet` as needed:

```rust
mkdir /some/local/dir/arbitrum-mainnet
chmod -fR 777 /some/local/dir/arbitrum-mainnet
```

### Optional parameters[​](#optional-parameters "Direct link to Optional parameters")

Both Nitro and Classic have multiple other parameters that can be used to configure your node. For a full comprehensive list of the available parameters, use the flag `--help`.

### Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")

If you run into any issues, visit the [node-running troubleshooting guide](/run-arbitrum-node/troubleshooting).

---

# How to run a Classic node | Arbitrum Docs

## How to run a Classic node

### Do you need to run a Classic node?[​](#do-you-need-to-run-a-classic-node "Direct link to Do you need to run a Classic node?")

Arbitrum One has been upgraded to Nitro, the latest Arbitrum tech stack. "Arbitrum Classic" is our term for the old, pre-Nitro tech stack. The Nitro node databases have the raw data of all blocks, including pre-Nitro blocks. However, Nitro nodes cannot execute anything on pre-Nitro blocks. You need an Arbitrum Classic archive node to execute data on pre-Nitro blocks.

When querying archive blocks, the following commands can only be handled by Arbitrum Classic nodes:

*   `eth_call`
*   `eth_estimateGas`
*   `eth_getBalance`
*   `eth_getCode`
*   `eth_getTransactionCount`
*   `eth_getStorageAt`

🔉 Note that Arbitrum Nova and Arbitrum Sepolia started as a Nitro chain, so they don't have classic blocks.

### Required artifacts[​](#required-artifacts "Direct link to Required artifacts")

*   Latest Docker Image: `offchainlabs/arb-node:v1.4.5-e97c1a4`
*   Latest classic snapshot for Arbitrum One: [https://snapshot.arbitrum.foundation/arb1/classic-archive.tar](https://snapshot.arbitrum.foundation/arb1/classic-archive.tar)

### Required parameters[​](#required-parameters "Direct link to Required parameters")

*   `--l1.url=<Layer 1 Ethereum RPC URL>`
    *   Must provide standard Ethereum node RPC endpoint.
*   `--node.chain-id=<L2 Chain ID>`
    *   Must use `42161` for Arbitrum One

### Important ports[​](#important-ports "Direct link to Important ports")

*   RPC: `8547`
*   WebSocket: `8548`

### Putting it all together[​](#putting-it-all-together "Direct link to Putting it all together")

*   When running docker image, an external volume should be mounted to persist the database across restarts. The mount point should be `/home/user/.arbitrum/mainnet`.
*   Here is an example of how to run a classic archive node for Arbitrum One (only needed for archive requests on pre-Nitro blocks, so you'll probably want to enable the archive mode in your nitro node as well):

```rust
docker run --rm -it  -v /some/local/dir/arbitrum-mainnet/:/home/user/.arbitrum/mainnet -p 0.0.0.0:8547:8547 -p 0.0.0.0:8548:8548 offchainlabs/arb-node:v1.4.5-e97c1a4 --l1.url=https://l1-node:8545 --node.chain-id=42161 --l2.disable-upstream
```

### Note on permissions[​](#note-on-permissions "Direct link to Note on permissions")

*   The Docker image is configured to run as non-root UID 1000. This means if you are running in Linux and you are getting permission errors when trying to run the docker image, run this command to allow all users to update the persistent folders.

```rust
mkdir /some/local/dir/arbitrum-mainnet
chmod -fR 777 /some/local/dir/arbitrum-mainnet
```

### Optional parameters[​](#optional-parameters "Direct link to Optional parameters")

We show here a list of the parameters that are most commonly used when running a Classic node. You can also use the flag `--help` for a full comprehensive list of the available parameters.

*   `--core.cache.timed-expire`
    *   Defaults to `20m`, or 20 minutes. Age of oldest blocks to hold in cache so that disk lookups are not required
*   `--node.rpc.max-call-gas`
    *   Maximum amount of gas that a node will use in call, default is `5000000`
*   `--core.checkpoint-gas-frequency`
    *   Defaults to `1000000000`. Amount of gas between saving checkpoints to disk. When making archive queries node has to load closest previous checkpoint and then execute up to the requested block. The farther apart the checkpoints, the longer potential execution required. However, saving checkpoints more often slows down the node in general.
*   `--node.cache.allow-slow-lookup`
    *   When this option is present, will load old blocks from disk if not in memory cache
    *   If archive support is desired, recommend using `--node.cache.allow-slow-lookup --core.checkpoint-gas-frequency=156250000`
*   `--node.rpc.tracing.enable`
    *   Note that you also need to have a database populated with an archive node if you want to trace previous transactions
    *   This option enables the ability to call a tracing api which is inspired by the parity tracing API with some differences
        *   Example: `curl http://arbnode -X POST -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"arbtrace_call","params":[{"to": "0x6b175474e89094c44da98b954eedeac495271d0f","data": "0x70a082310000000000000000000000006E0d01A76C3Cf4288372a29124A26D4353EE51BE"},["trace"], "latest"],"id":67}'`
    *   The `trace_*` methods are renamed to `arbtrace_*`, except `trace_rawTransaction` is not supported
    *   Only `trace` type is supported. `vmTrace` and `stateDiff` types are not supported
    *   The self-destruct opcode is not included in the trace. To get the list of self-destructed contracts, you can provide the `deletedContracts` parameter to the method

### Feed relay[​](#feed-relay "Direct link to Feed relay")

*   Arbitrum classic does not communicate with Nitro sequencer, so the classic relay is no longer used.

---

# How to run a validator | Arbitrum Docs

## How to run a validator

Validators are nodes that choose to participate in the rollup protocol to advance the state of the chain securely. Since the activation of , chains can now choose to make validation permissionless. You can learn more in the [BoLD introduction](/how-arbitrum-works/bold/gentle-introduction).

This page describes the different strategies a validator may follow and provides instructions on how to run a validator for an Arbitrum chain.

This how-to assumes that you're familiar with the following:

*   How to run a full node (see instructions [here](/run-arbitrum-node/run-full-node) for DAO-governed chains, and [here](/node-running/how-tos/running-an-orbit-node) for Orbit chains)
*   [How the Rollup protocol works](/how-arbitrum-works/optimistic-rollup)
*   [How BoLD works](/bold/concepts/bold-technical-deep-dive#how-bold-uses-ethereum), if you're running a validator for a chain that has BoLD activated

Validation strategies[​](#validation-strategies "Direct link to Validation strategies")
---------------------------------------------------------------------------------------

Validators can be configured to follow a specific validation strategy. Here we describe what strategies are available in Nitro:

Strategy

Description

Gas usage

**`Defensive`**

This validator will follow the chain and if it's local state disagrees with an on-chain assertion, this validator will post a stake and create a challenge to defend the chain

Only acts if a bad assertion is found

**`StakeLatest`**

This validator will initially stake on the latest correct assertion found, and then move the stake whenever new correct assertions are created. It will also challenge any bad assertions that it finds (this strategy is only available in pre-BoLD chains)

Gas used every time a new assertion is created

**`ResolveNodes`**

This validator will stay staked on the latest assertion found, resolve any unconfirmed assertions, and it will challenge any bad assertions that it finds

Gas used every time a new assertion is created and to resolve unconfirmed assertions

**`MakeNodes`**

This validator continuously creates new assertions, resolves any unconfirmed assertions, and challenges bad assertions found. Note that if there is more than one `MakeNodes` validator running, they might all try to create a new assertion simultaneously. In that case, only one will be successful, while the others will have their transactions reverted

Gas used to create new assertions, move the stake to the latest one, and resolve unconfirmed assertions

### The watchtower strategy[​](#the-watchtower-strategy "Direct link to The watchtower strategy")

One more validation strategy is available for all types of nodes: `watchtower`. This strategy is enabled by default in all nodes (full and archive), and it doesn't require a wallet, as it never takes any action on-chain.

A node in `watchtower` mode will immediately log an error if an on-chain assertion deviates from the locally computed chain state.

```rust
found incorrect assertion in watchtower mode
```

To verify that the watchtower mode is enabled, this line should appear in the logs:

```rust
INFO [09-28|18:43:49.367] running as validator                     txSender=nil actingAsWallet=nil whitelisted=false strategy=Watchtower
```

Additionally, the following logs indicate whether all components are working correctly:

*   The log line `validation succeeded` shows that the node is validating chain blocks successfully
*   The log line `found correct assertion` shows that the node is finding assertions on the parent chain successfully

Watchtower mode adds a small amount of execution and memory overhead to your node. You can deactivate this mode using the parameter `--node.staker.enable=false`.

How to run a validator node[​](#how-to-run-a-validator-node "Direct link to How to run a validator node")
---------------------------------------------------------------------------------------------------------

This section explains how to configure your node to act as a validator.

### Step 0: prerequisites[​](#step-0-prerequisites "Direct link to Step 0: prerequisites")

A validator node is a regular full node with validation enabled, so you'll have to know how to configure a full node. You can find instructions [here](/run-arbitrum-node/run-full-node) for DAO-governed chains, and [here](/node-running/how-tos/running-an-orbit-node) for Orbit chains.

Additionally, you'll need a wallet with enough funds to perform actions on-chain and enough tokens to stake. Keep in mind that:

*   The token used to perform actions on-chain is the native token of the parent chain (usually `ETH`)
*   For chains with BoLD activated, the token used to stake depends on the chain configuration. For Arbitrum One and Arbitrum Nova, the staking token is `WETH`
*   For chains that don't have BoLD activated, the token used to stake is the native token of the parent chain (usually `ETH`)

### Step 1: configure and run your validator[​](#step-1-configure-and-run-your-validator "Direct link to Step 1: configure and run your validator")

On top of the configuration of a regular full node, you'll need to configure the following parameters for it to act as a validator:

Parameter

Value

Description

`--node.staker.enable`

`true`

Enables validation

`--node.staker.strategy`

`Watchtower`, `Defensive`, `StakeLatest`, `ResolveNodes`, `MakeNodes`

Strategy that your node will use (only needed if BoLD is not enabled)

`--node.staker.parent-chain-wallet.private-key`

0xPrivateKey

Private key of the wallet used to perform the operations on-chain. Use either `private-key` or `password` (below)

`--node.staker.parent-chain-wallet.password`

Password

Password of a wallet generated with nitro (see instructions [here](#use-nitro-to-create-a-wallet-for-your-validator)). Use either `private-key` (above) or `password`

`--node.bold.enable`

true

Enables validation with BoLD (not needed if BoLD is not activated)

`--node.bold.strategy`

`Watchtower`, `Defensive`, `ResolveNodes`, `MakeNodes`

Strategy that your node will use (not needed if BoLD is not activated)

Here's an example of how to run a defensive validator for Arbitrum One:

```rust
docker run --rm -it  -v /some/local/dir/arbitrum:/home/user/.arbitrum offchainlabs/nitro-node:v3.5.1-8f247fd --parent-chain.connection.url=https://l1-mainnet-node:8545 --chain.id=42161 --node.staker.enable --node.staker.strategy=Defensive --node.staker.parent-chain-wallet.password="SOME SECURE PASSWORD" --node.bold.enable --node.bold.strategy=Defensive
```

### Step 2: verify that your node is running as a validator[​](#step-2-verify-that-your-node-is-running-as-a-validator "Direct link to Step 2: verify that your node is running as a validator")

To verify that your node is acting as a validator, you can look for the following log line:

```rust
INFO [09-28|18:43:49.367] running as validator                     txSender=0x... actingAsWallet=0x... whitelisted=true strategy=Defensive
```

Note that `strategy` should be the configured strategy. `txSender` and `actingAsWallet` should both be present and not `nil`.

Furthermore, the following logs will indicate that all components are working as intended:

*   The log line `validation succeeded` shows that the node is validating chain blocks successfully
*   The log line `found correct assertion` shows that the node is finding assertions on the parent chain successfully

Run a validator for an Orbit chain[​](#run-a-validator-for-an-orbit-chain "Direct link to Run a validator for an Orbit chain")
------------------------------------------------------------------------------------------------------------------------------

Validation for Orbit chains works the same way as for DAO-governed Arbitrum chains. However, as specified in [How to run a node](/node-running/how-tos/running-an-orbit-node#2-child-chain-parameters), you need to include the information of the chain when configuring your node by using `--chain.info-json`.

```rust
--chain.info-json=<Orbit chain's info>
```

Additionally, keep in mind that some chains might not have BoLD activated yet, so BoLD-specific parameters will not be needed.

Advanced features[​](#advanced-features "Direct link to Advanced features")
---------------------------------------------------------------------------

### Use Nitro to create a wallet for your validator[​](#use-nitro-to-create-a-wallet-for-your-validator "Direct link to Use Nitro to create a wallet for your validator")

Clear passwords in the command line

This section shows how to manage a validator wallet using a password. Like any command that requires passing a password or private key, you should take extra precautions to secure your credentials. Failure to protect your password may compromise your validator wallet.

Nitro includes a tool to create a validator wallet for a specific chain automatically. You can access it by using the option `--node.staker.parent-chain-wallet.only-create-key` and setting a password for the wallet with `--node.staker.parent-chain-wallet.password`.

Here is an example of how to create a validator wallet for Arbitrum One and exit:

```rust
docker run --rm -it  -v /some/local/dir/arbitrum:/home/user/.arbitrum offchainlabs/nitro-node:v3.5.1-8f247fd --parent-chain.connection.url=https://l1-mainnet-node:8545 --chain.id=42161 --node.staker.enable --node.staker.parent-chain-wallet.only-create-key --node.staker.parent-chain-wallet.password="SOME SECURE PASSWORD"
```

The wallet file will be created under the mounted directory inside the `<chain-name>/wallet/` directory (for example, `arb1/wallet/` for Arbitrum One, or `nova/wallet/` for Arbitrum Nova). Be sure to backup the wallet file, as it will be the only way to withdraw the stake when desired.

Once the wallet is created, you can instruct your validator to use it by adding the option `--node.staker.parent-chain-wallet.password="SOME SECURE PASSWORD"` when running your node.

Use environment variables

If you prefer not to include your password in the command line, you can use environment variables or a secure secrets management solution to supply the password at runtime.

### How to add new validators to the allowlist (Orbit chains)[​](#how-to-add-new-validators-to-the-allowlist-orbit-chains "Direct link to How to add new validators to the allowlist (Orbit chains)")

On permissioned validation setups, the set of validators that can act on a given chain is limited to the ones added to the allowlist of validators in the Rollup contract.

Follow these instructions to add a new validator address to the allowlist. Remember that you need to be able to perform admin actions to the chain to complete this operation.

1.  Find your `upgradeExecutor` contract address
2.  Call the `executeCall` method of the `upgradeExecutor` contract:
    *   set the `target` address to your Rollup contract's address
    *   set the `targetCalldata` to `0xa3ffb772{Your new allowlist validator address}` (`0xa3ffb772` is the signature of `setValidator(address[],bool[])`). For example, if you want to add the address `0x1234567890123456789012345678901234567890`, your `targetCalldata` should be `0xa3ffb7721234567890123456789012345678901234567890`.
3.  Call your Rollup contract's `isValidator(address)` and check the result

After performing this operation, the new validator will be able to run a validator node to participate in the chain.

---

# How to build Nitro locally (Debian, Ubuntu, MacOS) | Arbitrum Docs

## How to build Nitro locally (Debian, Ubuntu, MacOS)

Arbitrum Nitro is the software that powers all Arbitrum chains. This how-to shows how you can build a Docker image, or binaries, directly from Nitro's source code. If you want to run a node for one of the Arbitrum chains, however, it is recommended that you use the docker image available on DockerHub, as explained in [How to run a full node](/run-arbitrum-node/run-full-node).

This how-to assumes that you're running one of the following operating systems:

*   [Debian 11.7 (arm64)](https://cdimage.debian.org/cdimage/archive/11.7.0/arm64/iso-cd/debian-11.7.0-arm64-netinst.iso)
*   [Ubuntu 22.04 (amd64)](https://releases.ubuntu.com/22.04.2/ubuntu-22.04.2-desktop-amd64.iso)
*   [MacOS Sonoma 14.3](https://developer.apple.com/documentation/macos-release-notes/macos-14_3-release-notes).

Build a Docker image[​](#build-a-docker-image "Direct link to Build a Docker image")
------------------------------------------------------------------------------------

### Step 1. Configure [Docker](https://docs.docker.com/engine/install)[​](#step-1-configure-docker "Direct link to step-1-configure-docker")

#### For [Debian](https://docs.docker.com/engine/install/debian)/[Ubuntu](https://docs.docker.com/engine/install/ubuntu)[​](#for-debianubuntu "Direct link to for-debianubuntu")

```rust
for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl gnupg
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg

# Add the repository to Apt sources:
echo \
  "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
  "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
sudo service docker start
```

(Note that if you are running Ubuntu 22.04, you might get an `Unable to locate package docker-buildx-plugin` error. Try `sudo apt install docker-buildx` instead.)

#### For [MacOS](https://docs.docker.com/desktop/install/mac-install/)[​](#for-macos "Direct link to for-macos")

Depending on whether your Mac has an Intel processor or Apple silicon, download the corresponding disk image from [Docker](https://docs.docker.com/desktop/install/mac-install/), and move it into your Applications folder.

#### \[Optional\] Run docker from a different user[​](#optional-run-docker-from-a-different-user "Direct link to [Optional] Run docker from a different user")

After installing docker, you might want to be able to run it with your current user instead of root. You can run the following commands to do so.

```rust
sudo groupadd docker
sudo usermod -aG docker $USER
newgrp docker
```

For troubleshooting, check Docker's section in [their documentation](https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user)

### Step 2. Download the Nitro source code[​](#step-2-download-the-nitro-source-code "Direct link to Step 2. Download the Nitro source code")

```rust
git clone --branch v3.5.1 https://github.com/OffchainLabs/nitro.git
cd nitro
git submodule update --init --recursive --force
```

### Step 3. Build the Nitro node Docker image[​](#step-3-build-the-nitro-node-docker-image "Direct link to Step 3. Build the Nitro node Docker image")

```rust
docker build . --tag nitro-node
```

That command will build a Docker image called `nitro-node` from the local source.

Build Nitro's binaries natively[​](#build-nitros-binaries-natively "Direct link to Build Nitro's binaries natively")
--------------------------------------------------------------------------------------------------------------------

If you want to build the node binaries natively, execute steps 1-3 of the [Build a Docker image](#build-a-docker-image) section and continue with the steps described here. Notice that even though we are building the binaries outside of Docker, it is still used to help build some WebAssembly components.

### Step 4. Configure prerequisites[​](#step-4-configure-prerequisites "Direct link to Step 4. Configure prerequisites")

#### For Debian/Ubuntu[​](#for-debianubuntu-1 "Direct link to For Debian/Ubuntu")

```rust
apt install git curl build-essential cmake npm golang clang make gotestsum wabt lld-13 python3
npm install --global yarn
ln -s /usr/bin/wasm-ld-13 /usr/local/bin/wasm-ld
```

#### For MacOS[​](#for-macos-1 "Direct link to For MacOS")

Install [Homebrew](https://brew.sh/) package manager and add it to your `PATH` environment variable:

```rust
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
echo "export PATH=/opt/homebrew/bin:$PATH" >> ~/.zprofile && source ~/.zprofile
```

(replace `~/.zprofile` with `~/.bash_profile` if you use bash instead of zsh).

Install essentials:

```rust
brew install git curl make cmake npm go golangci-lint wabt llvm lld libusb gotestsum
npm install --global yarn
sudo mkdir -p /usr/local/bin
echo "export PATH=/opt/homebrew/opt/llvm/bin:$PATH" >> ~/.zprofile && source ~/.zprofile
```

### Step 5. Configure node [18](https://github.com/nvm-sh/nvm)[​](#step-5-configure-node-18 "Direct link to step-5-configure-node-18")

#### For Debian/Ubuntu[​](#for-debianubuntu-2 "Direct link to For Debian/Ubuntu")

```rust
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
source "$HOME/.bashrc"
nvm install 18
nvm use 18
```

#### For MacOS[​](#for-macos-2 "Direct link to For MacOS")

```rust
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
nvm install 18
nvm use 18
```

### Step 6. Configure [Rust](https://www.rust-lang.org/tools/install)[​](#step-6-configure-rust "Direct link to step-6-configure-rust")

```rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source "$HOME/.cargo/env"
rustup install 1.84.1
rustup default 1.84.1
rustup install nightly-2025-02-14
rustup target add wasm32-unknown-unknown --toolchain 1.84.1
rustup target add wasm32-wasi --toolchain 1.84.1
rustup target add wasm32-unknown-unknown --toolchain nightly-2025-02-14
rustup target add wasm32-wasi --toolchain nightly-2025-02-14
rustup component add rust-src --toolchain nightly-2025-02-14
cargo install cbindgen
```

### Step 7. Install Bison [3.8.2](https://savannah.gnu.org/projects/bison/)[​](#step-7-install-bison-382 "Direct link to step-7-install-bison-382")

#### For Debian/Ubuntu[​](#for-debianubuntu-3 "Direct link to For Debian/Ubuntu")

```rust
sudo apt-get install bison
```

#### For MacOS[​](#for-macos-3 "Direct link to For MacOS")

```rust
brew install bison
```

### Step 8. Configure Go [1.23](https://github.com/moovweb/gvm)[​](#step-8-configure-go-123 "Direct link to step-8-configure-go-123")

#### Install and configure Go[​](#install-and-configure-go "Direct link to Install and configure Go")

```rust
bash < <(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)
source "$HOME/.gvm/scripts/gvm"
gvm install go1.23
gvm use go1.23 --default
curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.54.2
```

If you use zsh, replace `bash` with `zsh`.

#### Install foundry[​](#install-foundry "Direct link to Install foundry")

```rust
curl -L https://foundry.paradigm.xyz | bash
foundryup
```

### Step 9. Check dependencies[​](#step-9-check-dependencies "Direct link to Step 9. Check dependencies")

```rust
./scripts/check-build.sh
```

If this script shows any errors, fix them before proceeding to the next step.

### Step 10. Start build[​](#step-10-start-build "Direct link to Step 10. Start build")

```rust
make
```

### Step 11. Produce binaries[​](#step-11-produce-binaries "Direct link to Step 11. Produce binaries")

```rust
make build
```

#### Warnings on MacOS[​](#warnings-on-macos "Direct link to Warnings on MacOS")

In MacOS with Apple Silicon, warnings like the following might appear but they will not hinder the compilation process.

```rust
ld: warning: object file was built for newer 'macOS' version (14.4) than being linked (14.0)
```

To silence these warnings, export the following environment variables before building Nitro.

```rust
export MACOSX_DEPLOYMENT_TARGET=$(sw_vers -productVersion)
export CGO_LDFLAGS=-Wl,-no_warn_duplicate_libraries
```

### Step 12. Run your node[​](#step-12-run-your-node "Direct link to Step 12. Run your node")

To run your node using the generated binaries, use the following command from the `nitro` folder, with your desired parameters

```rust
./target/bin/nitro <node parameters>
```

#### WASM module root error (v2.3.4 or later)[​](#wasm-module-root-error-v234-or-later "Direct link to WASM module root error (v2.3.4 or later)")

Since v2.3.4, the State Transition Function (STF) contains code that is not yet activated on the current mainnet and testnet chains. Because of that, you might receive the following error when connecting your built node to those chains:

```rust
ERROR[05-21|21:59:17.415] unable to find validator machine directory for the on-chain WASM module root err="stat {WASM_MODULE_ROOT}: no such file or directory"
```

Try add flag:

```rust
--validation.wasm.allowed-wasm-module-roots={WASM_MODULE_ROOT}
```

---

# How to migrate state and history from a classic (pre-Nitro) node to a Nitro node | Arbitrum Docs

## How to migrate state and history from a classic (pre-Nitro) node to a Nitro node

When running a Nitro node for the first time on a chain that produced [classic blocks](/build-decentralized-apps/public-chains#classic-deprecated) in the past (like Arbitrum One), you need to initialize its database to, at least, the state of the chain after executing the last classic block. The common, and recommended, way of doing that is to provide a database snapshot using the `--init.url` option (as mentioned in [How to run a full node (Nitro)](/run-arbitrum-node/run-full-node)). In this how-to we show you an alternative way for doing that, migrating the state and history of the chain from a fully synced classic node.

Is this How-to for you?

As mentioned, the recommended way of initializing a Nitro node is by using a pre-initialized database snapshot with the `--init.url` option. This guide is for those that are interested in re-creating the full state of the chain from the genesis block using their own classic node.

Keep in mind that this process only applies to Arbitrum One. Other Arbitrum chains didn't produce classic blocks in the past, they started as Nitro chains.

Prerequisites[​](#prerequisites "Direct link to Prerequisites")
---------------------------------------------------------------

To successfully migrate the state and history of the chain from a classic (pre-Nitro) node to a Nitro node, you'll need:

*   A fully synced classic node: you can find instructions on how to run a classic node in [this page](/run-arbitrum-node/more-types/run-classic-node).
*   A clean, uninitialized Nitro node: you can find instructions on how to set up a Nitro node in [this page](/run-arbitrum-node/run-full-node).

Step 1: Enable export options in your classic node[​](#step-1-enable-export-options-in-your-classic-node "Direct link to Step 1: Enable export options in your classic node")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Launch your classic node with the option `--node.rpc.nitroexport.enable=true`. All exported data will be written to directory "nitroexport" under the classic instance directory (e.g. `${HOME}/.arbitrum/mainnet/nitroexport`). Make sure the classic node has read the entire rollup state.

Caution

Enabling the export options is only recommended for nodes with no public/external interfaces.

Exported file contents are not deterministic

Exporting the state of your own classic node should produce the same state as using files supplied by the Arbitrum Foundation (i.e. the same genesis blockhash). However, multiple exports of the same state will not necessarily create identical intermediate files. For example, state export is done in parallel, so the order of entries in the file is not deterministic.

Step 2: Export information from your classic node[​](#step-2-export-information-from-your-classic-node "Direct link to Step 2: Export information from your classic node")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Block & transaction history[​](#block--transaction-history "Direct link to Block & transaction history")

These are block headers, transactions and receipts executed in the classic node. Nitro node uses the history to be able to answer simple requests, like `eth_getTransactionReceipt`, from the classic history. The last block in the chain is the only one that affects the genesis block: timestamp is copied from the last block, and parentHash is taken from the last block's blockHash.

*   Call the RPC method `arb_exportHistory` with parameter `"latest"` to initiate history export. It will return immediately.
*   Calling `arb_exportHistoryStatus` will return the latest block exported, or an error if the export failed.
*   Data will be stored in the directory `nitroexport/nitro/l2chaindata/ancient`.

### Rollup state[​](#rollup-state "Direct link to Rollup state")

The rollup state is exported as a series of JSON files. State read from these JSON files will be added to Nitro's genesis block.

*   Call the RPC method `arb_exportState` with parameter `"latest"` to initiate state export. Unless disconnected, this will only return after the state export is done.
*   Data will be stored in the directory `nitroexport/state/<block_number>/`.

### Outbox messages (optional)[​](#outbox-messages-optional "Direct link to Outbox messages (optional)")

This data does not impact consensus and is optional. It allows a Nitro node to provide the information required when executing a withdrawal made on the classic rollup.

*   Call the RPC method `arb_exportOutbox` with parameter `"0xffffffffffffffff"` to initiate outbox export. It will return immediately.
*   Calling `arb_exportOutboxStatus` will return the latest outbox batch exported, or an error if the export failed.
*   Data will be stored in the directory `nitroexport/nitro/classic-msg`.

Step 3: Initialize your Nitro node importing the exported data[​](#step-3-initialize-your-nitro-node-importing-the-exported-data "Direct link to Step 3: Initialize your Nitro node importing the exported data")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

*   Place the `l2chaindata` and `classic-msg` (if exported) directories in Nitro's instance directory (e.g. `${HOME}/.arbitrum/arb1-nitro/`).
*   Launch the Nitro node with the argument `--init.import-file=/path/to/state/index.json`

Caution

This state import operation requires more resources than a regular run of a Nitro node.

### Other useful Nitro options[​](#other-useful-nitro-options "Direct link to Other useful Nitro options")

Flag

Description

`--init.accounts-per-sync`

Allows the node to make partial database writes to hard-disk during initialization, allowing memory to be freed. This should be used if memory load is very high. A reasonable initial value to try would be 100000. Systems with constrained memory might require a lower value.

`--init.then-quit`

Causes the node to quit after initialization is done.

`--init.force`

For an already-initialized node, forces the node to recalculate Nitro's genesis block. If the genesis blockhash doesn't match what's in the database, the node will panic.

See also[​](#see-also "Direct link to See also")
------------------------------------------------

*   [How to run a full node (Nitro)](/run-arbitrum-node/run-full-node)
*   [How to run a full node (Classic, pre-Nitro)](/run-arbitrum-node/more-types/run-classic-node)

---

# Nitro database snapshots | Arbitrum Docs

## Nitro database snapshots

Nitro stores the chain state and data in a database in the local filesystem. When starting Nitro for the first time, it will initialize an empty database by default and start processing transactions from Genesis. It takes a long time for the node to sync from Genesis, so starting from a database snapshot is advisable instead. Moreover, for the Arb1 chain, you must start from a snapshot because Nitro cannot process transactions from the Classic Arbitrum node.

Supply the snapshot URL to Nitro[​](#supply-the-snapshot-url-to-nitro "Direct link to Supply the snapshot URL to Nitro")
------------------------------------------------------------------------------------------------------------------------

There are multiple ways to supply Nitro with the database snapshot. The most straightforward way is to provide the configuration, so Nitro downloads the snapshot by itself. It is also possible to download the database manually and supply it to Nitro.

Downloading the latest snapshot[​](#downloading-the-latest-snapshot "Direct link to Downloading the latest snapshot")
---------------------------------------------------------------------------------------------------------------------

Nitro has a CLI configuration for downloading the latest snapshot from a remote server. Set the flag `--init.latest` to either `archive`, `pruned`, or `genesis`, and Nitro will download the preferred snapshot. You may also change the `--init.latest-base` flag to set the base URL when searching for the latest snapshot.

### How it works[​](#how-it-works "Direct link to How it works")

When searching for the latest snapshot, Nitro uses the chain name provided in `--chain.name`. Make sure to set it correctly; otherwise, Nitro might be unable to find the snapshot. Nitro will look for a remote file in `<latest-base>/<chain-name>/latest-<kind>.txt`, where `<kind>` is the option supplied to `--init.latest`. This file should contain either the path or the full URL to the snapshot; if it only contains the path, Nitro will use the `<latest-base>` as the base URL.

After finding the latest snapshot URL, Nitro will download the archive and temporarily store it in the directory specified in `--init.download-path`. Nitro looks for a SHA256 checksum on the remote server and verifies the checksum of the snapshot after finishing the download. (It is possible to disable this feature by setting `--init.validate-checksum` to false.)

The snapshot can be a single archive file or a series of parts. Nitro first tries to download the snapshot as a single archive. In this case, Nitro will look for a checksum file in `<archive-url>.sha256`. If the remote server returns not found (404 status code), Nitro will proceed to download the snapshot in parts. When downloading in parts, Nitro will look for a manifest file in `<archive-url>.manifest.txt` containing each part's name and checksum. In this case, Nitro will download each part in the manifest file and concatenate them into a single archive.

Finally, Nitro decompresses and extracts the snapshot archive, placing it in the database directory. Nitro will delete the archive after extracting it, so if you need to set up multiple nodes with the same snapshot, consider downloading it manually, as explained below.

* * *

Downloading the snapshot from a URL[​](#downloading-the-snapshot-from-a-url "Direct link to Downloading the snapshot from a URL")
---------------------------------------------------------------------------------------------------------------------------------

Instead of letting Nitro search for the latest snapshot, you can provide a specific URL to download by setting the flag `--init.url` with the snapshot URL. If the URL points to a remote server, it should start with the `https://` protocol definition. Given the URL, Nitro will download the snapshot as described in the "Downloading the Latest Snapshot" section.

Nitro also supports importing files from the local file system. In this case, you should provide the file path to `--init.url` starting with the prefix `file://` followed by the file path. Beware that when running Nitro inside a Docker container, you must mount a volume containing the provided snapshot using the docker flag `-v` (see [Docker documentation](https://docs.docker.com/reference/cli/docker/container/run/#volume)). Otherwise, the Nitro container running inside Docker won’t be able to find the snapshot in your local filesystem.

* * *

Downloading the snapshot manually[​](#downloading-the-snapshot-manually "Direct link to Downloading the snapshot manually")
---------------------------------------------------------------------------------------------------------------------------

It is possible to download the snapshot manually and supply the archive instead of having Nitro download it.

The first step is downloading the snapshot. The command below illustrates how to do that on the command line using wget. The `-c` flag tells the wget to continue the download from where it left off, which is helpful because snapshots can be huge files, and the download can fail mid-way. The `-P` flag tells wget to place the snapshot on the temporary dir.

```rust
wget -c -P /tmp "$SNAPSHOT_URL"
```

After downloading the snapshot, make sure to verify whether the checksum matches the one provided by the remote server. To fetch the checksum, you may run the command below.

```rust
wget -q -O - "$SNAPSHOT_URL".sha256
```

Once you know the expected snapshot checksum, run the command below to compute the checksum of the downloaded snapshot. Then, compare both and see if they are the same. If they are not the same, consider redownloading the snapshot. You must provide a valid snapshot to Nitro; otherwise, it won’t work properly.

```rust
sha256sum $PATH_TO_SNAPSHOT
```

Finally, you can provide a path to the downloaded snapshot archive to Nitro using the `--init.url` flag, as described in the "Download the Snapshot from a URL" section.

### Downloading snapshot parts[​](#downloading-snapshot-parts "Direct link to Downloading snapshot parts")

If the snapshot is divided into parts, you should first download the manifest file in `<snapshot-url>.manifest.txt`. This manifest contains the names and checksums of each part. For instance, the snippet below shows how the manifest file should look. You may use the commands described previously to download each part of the snapshot and verify their checksums.

```rust
a938e029605b81e03cd4b9a916c52d96d74c985ac264e2f298b90495c619af74  archive.tar.part0
9e095ce82e70fa62bb6e7b4421e7f2c04b2cd9e21d2bc62cbbaaeb877408357b  archive.tar.part1
e92172d6eaf770a76c7477e6768f742fc51555a5050de606bd0f837e59c7a61d  archive.tar.part2
d1b6fb9aeeb23903cdbb2a7cca8e6909bff4ee8e51c8a5acac2a142b3e3a5437  archive.tar.part3
f37e4552453202f2044e58b307bab7e466205bd280426abbc84f8646c6430cfa  archive.tar.part4
972c5f513faca6ac4fadd22c70bea97707c6d38e9a646432bc311f0ca10497ed  archive.tar.part5
```

After downloading all the parts and verifying their checksums, you may use the command below to join them into a single archive.

```rust
cat archive.tar.part* > archive.tar
```

* * *

Extracting the snapshot manually[​](#extracting-the-snapshot-manually "Direct link to Extracting the snapshot manually")
------------------------------------------------------------------------------------------------------------------------

It is also possible to extract the snapshot archive and place the files manually. First, you need to download the snapshot archive as described in "Manually Downloading the Snapshot". Then, create the directory where Nitro will look for its database. By default, Nitro stores the database on `$HOME/.arbitrum/$CHAIN/nitro`. Move the archive to this directory and extract it. The commands below exemplify this process for the Arbitrum Sepolia chain.

```rust
export CHAIN=sepolia-rollup
export ARCHIVE_PATH=/tmp/archive.tar.gz
mkdir -p $HOME/.arbitrum/$CHAIN/nitro
cd $HOME/.arbitrum/$CHAIN/nitro
tar zxfv $ARCHIVE_PATH
```

You should see the following subdirectories in this directory after extracting the archive.

```rust
arbitrumdata
l2chaindata
nodes
```

* * *

Creating a snapshot[​](#creating-a-snapshot "Direct link to Creating a snapshot")
---------------------------------------------------------------------------------

To generate a snapshot for the Nitro database, you first need to stop the process gracefully. You must not generate the snapshot while Nitro runs because the database might be in an intermediary state. Nitro should print logs like the ones described below when stopping.

```rust
^CINFO [08-22|18:10:55.015] shutting down because of sigint
INFO [08-22|18:10:55.016] delayed sequencer: context done          err="context canceled"
INFO [08-22|18:10:55.016] rpc response                             method=eth_getBlockByNumber logId=123 err="context canceled" result=null attempt=0 args="[\"0x405661\", false]"
INFO [08-22|18:10:55.293] Writing cached state to disk             block=39988 hash=8bebf3..939ab2 root=4f7a22..00c334
INFO [08-22|18:10:55.297] Persisted trie from memory database      nodes=643 size=156.31KiB time=3.673459ms gcnodes=329 gcsize=102.61KiB gctime="248.708µs" livenodes=2448 livesize=806.00KiB
INFO [08-22|18:10:55.297] Writing cached state to disk             block=39987 hash=ddcd60..fe0fc3 root=d6973e..7b9265
INFO [08-22|18:10:55.298] Persisted trie from memory database      nodes=34  size=11.19KiB  time="283.875µs" gcnodes=0   gcsize=0.00B     gctime=0s          livenodes=2414 livesize=794.81KiB
INFO [08-22|18:10:55.298] Writing cached state to disk             block=39861 hash=2a9dd3..f00ff0 root=139d5a..d6bf21
INFO [08-22|18:10:55.298] Persisted trie from memory database      nodes=73  size=24.88KiB  time="502.916µs" gcnodes=0   gcsize=0.00B     gctime=0s          livenodes=2341 livesize=769.93KiB
INFO [08-22|18:10:55.299] Writing cached state to disk             block=39861 hash=2a9dd3..f00ff0 root=139d5a..d6bf21
INFO [08-22|18:10:55.299] Persisted trie from memory database      nodes=0   size=0.00B     time="1.417µs"   gcnodes=0   gcsize=0.00B     gctime=0s          livenodes=2341 livesize=769.93KiB
INFO [08-22|18:10:55.299] Writing snapshot state to disk           root=bd18ce..3b0763
INFO [08-22|18:10:55.299] Persisted trie from memory database      nodes=0   size=0.00B     time="1.125µs"   gcnodes=0   gcsize=0.00B     gctime=0s          livenodes=2341 livesize=769.93KiB
INFO [08-22|18:10:55.304] Blockchain stopped
```

After nitro stops, go to the database directory and generate an archive file for the directories `arbitrumdata`, `l2chaindata`, and `nodes`. By default, the database directory for nitro is `$HOME/.arbitrum/$CHAIN/nitro`. The commands below exemplify how to generate the snapshot for Nitro.

```rust
export CHAIN=sepolia-rollup
export ARCHIVE_PATH=/tmp/archive.tar.gz
cd $HOME/.arbitrum/$CHAIN/nitro
tar zcfv $ARCHIVE_PATH arbitrumdata l2chaindata nodes
```

This command purposely omits the `wasm` directory from the snapshot archive. The `wasm` contains native-code executables, so it might be a security concern for users downloading the snapshot. If the user downloading the snapshot trusts you, or if you are storing it for your own use, you may include the `wasm` directory in it.

### Optional: divide it into parts[​](#optional-divide-it-into-parts "Direct link to Optional: divide it into parts")

It is possible to divide the snapshot into smaller parts to facilitate its download. This is particularly useful for archive snapshots of heavily used chains, such as arb1. These kinds of snapshots can reach terabytes, so dividing them into smaller parts is helpful. The snippet below illustrates how to divide the snapshot into parts using the split command. The `-b` argument tells the split to divide the snapshot into 100 GB parts. The `-d` argument tells split to enumerate the parts using a numeric suffix instead of an alphabetic one.

```rust
split -b 100g -d archive.tar.gz archive.tar.gz.part
```

After dividing it into parts, you should generate the manifest file containing the parts' names and checksums. Nitro will use these files to know how many parts there are and to validate their checksum. The command below exemplifies how to do that.

---

# Arbitrum nodes overview | Arbitrum Docs

## Arbitrum nodes overview

In order to be able to _interact with_ or _build applications on_ any of the Arbitrum chains, you need access to the corresponding Arbitrum node. Options are:

*   You can use third party node providers (see the list [here](/build-decentralized-apps/reference/node-providers)) to get RPC access to fully-managed nodes
*   You can run your own Arbitrum node, especially if you want to always know the state of the Arbitrum chain

Here, you can find resources that help you run different types of Arbitrum nodes:

*   Step-by-step instructions for running different Arbitrum nodes, including [full Nitro node](/run-arbitrum-node/run-full-node), [full Classic node](/run-arbitrum-node/more-types/run-classic-node), [local full chain simulation](/run-arbitrum-node/run-local-full-chain-simulation), [Nitro dev node](/run-arbitrum-node/run-nitro-dev-node), [feed relay](/run-arbitrum-node/sequencer/run-feed-relay), and [validator](/run-arbitrum-node/more-types/run-validator-node)
*   Step-by-step instructions for how to [read the sequencer feed](/run-arbitrum-node/sequencer/read-sequencer-feed), [build the Nitro locally](/run-arbitrum-node/nitro/build-nitro-locally) and [run the sequencer coordinator manager UI tool](/run-arbitrum-node/sequencer/run-sequencer-coordination-manager)
*   Step-by-step instructions for [how to configure a Data Availability Committee](/run-arbitrum-node/data-availability-committees/get-started)
*   [Troubleshooting page](/run-arbitrum-node/troubleshooting)
*   [Frequently asked questions](/node-running/faq)

---

# Quickstart: Run a node | Arbitrum Docs

## Quickstart: Run a node

info

There is no protocol level incentive to run an Arbitum full node. If you’re interested in accessing an Arbitrum chain, but you don’t want to set up your own node, see our [RPC endpoints and providers](/build-decentralized-apps/reference/node-providers) to get RPC access to fully-managed nodes hosted by a third party provider.

API security disclaimer

When exposing API endpoints to the Internet or any untrusted/hostile network, the following risks may arise:

*   Increased risk of crashes due to OOM: Exposing endpoints raises the risk of Out-of-Memory (OOM) crashes.
*   Increased risk of not keeping up with chain progression: Resource starvation (IO or CPU) may occur, leading to an inability to keep up with chain progression.

We strongly advise against exposing API endpoints publicly. Users considering such exposure should exercise caution and implement the right measures to enhance resilience.

When it comes to interacting with the Arbitrum network, users have the option to run either a full node or an archive node. There are distinct advantages to running an Arbitrum full node. In this quickstart, we will explore the reasons why a user may prefer to run a full node instead of an archive node. By understanding the benefits and trade-offs of each type of node, users can make an informed decision based on their specific requirements and objectives.

### Considerations for running an Arbitrum full node[​](#considerations-for-running-an-arbitrum-full-node "Direct link to Considerations for running an Arbitrum full node")

*   Transaction validation and security: Running a full node allows users to independently validate transactions and verify the state of the Arbitrum blockchain. Users can have full confidence in the authenticity and integrity of the transactions they interact with.
*   Reduced trust requirements: By running a full node, users can interact with the Arbitrum network without relying on third-party services or infrastructure. This reduces the need to trust external entities and mitigates the risk of potential centralized failures or vulnerabilities.
*   Lower resource requirements: Compared to archive nodes, full nodes generally require fewer resources such as storage and computational power. This makes them more accessible to users with limited hardware capabilities or those operating on resource-constrained environments.

For detailed instructions on how to run an Arbitrum full node, see [here](/run-arbitrum-node/run-full-node).

### Considerations for running an Arbitrum archive node[​](#considerations-for-running-an-arbitrum-archive-node "Direct link to Considerations for running an Arbitrum archive node")

While full nodes offer numerous advantages, there are situations where running an archive node may be more appropriate. Archive nodes store the complete history of the Arbitrum network, making them suitable for users who require extensive historical data access or advanced analytical purposes. However, it's important to note that archive nodes are more resource-intensive, requiring significant storage capacity and computational power.

For detailed instructions on how to run an Arbitrum archive node, see [here](/run-arbitrum-node/more-types/run-archive-node).

### Considerations for running an Arbitrum classic node[​](#considerations-for-running-an-arbitrum-classic-node "Direct link to Considerations for running an Arbitrum classic node")

The significance of running an Arbitrum classic node is mainly applicable to individuals with specific needs for an archive node and access to classic-related commands. More details can be found [here](/run-arbitrum-node/more-types/run-archive-node).

For detailed instructions on how to run an Arbitrum classic node, see [here](/run-arbitrum-node/more-types/run-classic-node).

### Considerations for running a feed relay[​](#considerations-for-running-a-feed-relay "Direct link to Considerations for running a feed relay")

If you are running a single node, there is no requirement to set up a feed relay. However, if you have multiple nodes, it is highly recommended to have a single feed relay per datacenter. This setup offers several advantages such as reducing ingress fees and enhancing stability within the network.

In the near future, feed endpoints will mandate compression using a custom dictionary. Therefore, if you plan to connect to a feed using anything other than a standard node, it is strongly advised to run a local feed relay. This will ensure that you have access to an uncompressed feed by default, maintaining optimal performance and compatibility.

For detailed instructions on how to run a feed relay, see [here](/run-arbitrum-node/sequencer/run-feed-relay).

---

# How to run a full node (Nitro) | Arbitrum Docs

## How to run a full node (Nitro)

info

There is no protocol-level incentive to run an Arbitum full node. If you’re interested in accessing an Arbitrum chain but don’t want to set up your own node, see our [Node Providers](/build-decentralized-apps/reference/node-providers) to get RPC access to fully managed nodes hosted by a third-party provider.

### Minimum hardware configuration[​](#minimum-hardware-configuration "Direct link to Minimum hardware configuration")

Minimum hardware configuration required to set up a Nitro full node (not archival):

*   **RAM**: 16 GB
*   **CPU**: 4 core CPU
    *   Single core performance is important. If the node is falling behind and a single core is 100% busy, it is recommended to update to a faster processor
*   **Storage (last updated on April 2024)**:
    *   Arbitrum One: 560GB for a pruned node, growing at ~200GB per month (NVMe SSD drives are recommended)
    *   Arbitrum Nova: 400GB for a pruned node, growing at ~1.6TB per month (NVMe SSD drives are recommended)

info

These minimum requirements for RAM and CPU are recommended for nodes that process a small amount of RPC requests. For nodes that require processing multiple simultaneous requests, both RAM and number of CPU cores will need to be scaled with the amount of traffic being served.

info

The minimum storage requirements will change over time as the Nitro chain grows. Using more than the minimum requirements to run a robust full node is recommended.

### Prerequisites[​](#prerequisites "Direct link to Prerequisites")

caution

Even though there are alpha and beta versions of the , only release versions should be used when running your node. Running alpha or beta versions is not supported and might lead to unexpected behaviors.

*   Latest Docker Image: `offchainlabs/nitro-node:v3.5.1-8f247fd`
*   Database snapshot (required for Arbitrum One, optional for other chains)
    *   Use the parameter `--init.latest <snapshot type>`, accepted values: "archive" | "pruned" | "genesis".
    *   When running more than one node, it's easier to manually download the different parts of the snapshot, join them into a single archive, and host it locally for your nodes. You can then use `--init.url="file:///path/to/snapshot/in/container/snapshot-file.tar"` to use it. (For how to manually download the snapshot parts, please see [Downloading the snapshot manually](/run-arbitrum-node/nitro/nitro-database-snapshots#downloading-the-snapshot-manually))
    *   This parameter is **required** when initializing an Arbitrum One node because the chain has _classic_ blocks. For the other chains, this parameter is optional.
    *   This parameter is ignored if the database already exists.
    *   Find more info in [Nitro database snapshots](/run-arbitrum-node/nitro/nitro-database-snapshots)
    *   You can find more snapshots on our [snapshot explorer](https://snapshot-explorer.arbitrum.io/)

### Required parameters[​](#required-parameters "Direct link to Required parameters")

*   L1 RPC URL
    *   Use the parameter `--parent-chain.connection.url=<Layer 1 Ethereum RPC URL>` for execution layer.
    *   If the chain is running [ArbOS 20](/run-arbitrum-node/arbos-releases/arbos20), additionally use the parameter `--parent-chain.blob-client.beacon-url=<Layer 1 Ethereum Beacon RPC URL>` for consensus layer. You can find a list of beacon chain RPC providers [here](/run-arbitrum-node/l1-ethereum-beacon-chain-rpc-providers).
        *   It must provide a standard layer 1 node RPC endpoint that you run yourself or from a node provider.
        *   Note: historical blob data is required for chains running [ArbOS 20](/run-arbitrum-node/arbos-releases/arbos20) to properly sync up if they are new or have been offline for more than 18 days. This means the consensus layer RPC endpoint you use may also need to provide historical blob data. Please see [Special notes on ArbOS 20: Atlas support for EIP-4844](/run-arbitrum-node/arbos-releases/arbos20#special-notes-on-arbos-20-atlas-support-for-eip-4844) for more details.
    *   Note: this parameter was called `--l1.url` in versions prior to `v2.1.0`
    *   Note: 8545 is usually the default port for the execution layer. For the Beacon endpoint port, you should connect to the correct port set on your parent chain's consensus client.
*   L2 chain ID or name
    *   Use the parameter `--chain.id=<L2 chain ID>` to set the child chain (L2) chain from its chain id. See [RPC endpoints and providers](/build-decentralized-apps/reference/node-providers) for a list of Arbitrum chains and their respective child chain chain IDs.
    *   Alternatively, you can use the parameter `--chain.name=<L2 chain name>` to set the child chain from its name (options are: `arb1`, `nova` and `sepolia-rollup`)
    *   Note: this parameter was called --l2.chain-id and only accepted chain IDs in versions before `v2.1.0`
*   For Arbitrum One or Arbitrum Nova chains (or any chains that have BoLD enabled), we recommend setting `--node.bold.enable=true` to ensure your node monitors for L1 assertions and alerts properly when an invalid assertion is observed on-chain. Setting this flag is not required as your node will continue to operate properly, validate the Arbitrum One/Nova chain, and serve RPC requests as usual, regardless of this flag.

### Important ports[​](#important-ports "Direct link to Important ports")

*   RPC: `8547`
*   Sequencer Feed: `9642`
*   WebSocket: `8548`
    *   WS port `8548` needs extra args to be opened. Please use these flags:
        *   \--ws.port=8548
        *   \--ws.addr=0.0.0.0
        *   \--ws.origins=\*

### Putting it all together[​](#putting-it-all-together "Direct link to Putting it all together")

*   When running the Docker image, an external volume should be mounted to persist the database across restarts. The mount point inside the docker image should be `/home/user/.arbitrum`
    
*   Here is an example of how to run nitro-node:
    
    *   Note that it is important that `/some/local/dir/arbitrum` already exists; otherwise, the directory might be created with `root` as owner, and the docker container won't be able to write to it
    
    ```rust
    docker run --rm -it  -v /some/local/dir/arbitrum:/home/user/.arbitrum -p 0.0.0.0:8547:8547 -p 0.0.0.0:8548:8548 offchainlabs/nitro-node:v3.5.1-8f247fd --parent-chain.connection.url https://l1-node:8545 --chain.id=<L2ChainId> --http.api=net,web3,eth --http.corsdomain=* --http.addr=0.0.0.0 --http.vhosts=*
    ```
    
    *   Note that if you are running an L1 node on localhost, you may need to add `--network host` right after `docker run` to use docker host-based networking
        
    *   When shutting down the Docker image, it is important to allow a graceful shutdown to save the current state to disk. Here is an example of how to do a graceful shutdown of all docker images currently running
        
    
    ```rust
    docker stop --time=300 $(docker ps -aq)
    ```
    

### Note on permissions[​](#note-on-permissions "Direct link to Note on permissions")

*   The Docker image is configured to run as non-root UID 1000. This means if you are running in Linux or OSX and you are getting permission errors when trying to run the docker image, run this command to allow all users to update the persistent folders
    
    ```rust
    mkdir /data/arbitrum
    chmod -fR 777 /data/arbitrum
    ```
    

### Watchtower mode[​](#watchtower-mode "Direct link to Watchtower mode")

*   By default, the full node will run in Watchtower mode. This means that the node watches the on-chain assertions, and if it disagrees with them, it will log an error containing the string `found incorrect assertion in watchtower mode`. For a BoLD-enabled chain like Arbitrum One or Arbitrum Nova, the `--node.bold.enable=true` flag must be set to ensure your node can monitor for on-chain assertions properly.
*   Watchtower mode adds a small amount of execution and memory overhead. You can deactivate this mode using the parameter `--node.staker.enable=false`.

### Pruning[​](#pruning "Direct link to Pruning")

*   Pruning a full node refers to removing older, unnecessary data from the local copy of the blockchain that the node maintains to save disk space and slightly improve the node's efficiency. Pruning will remove all states from blocks older than the latest 128.
*   You can activate pruning by using the parameter `--init.prune` and using "full" or "validator" as the value (depending on the type of node you are running). Remember that this process will happen upon starting the node and will not serve RPC requests while pruning.

### Optional parameters[​](#optional-parameters "Direct link to Optional parameters")

Below, we listed the most commonly used parameters when running a node. You can also use the flag `--help` for a comprehensive list of the available parameters.

Flag

Description

`--execution.rpc.classic-redirect=<RPC>`

Redirects archive requests for pre-nitro blocks to this RPC of an Arbitrum Classic node with archive database. Only for Arbitrum One.

`--http.api`

Offered APIs over the HTTP-RPC interface. Default: `net,web3,eth,arb`. Add `debug` for tracing.

`--http.corsdomain`

Accepts cross origin requests from these comma-separated domains (browser enforced).

`--http.vhosts`

Accepts requests from these comma-separated virtual hostnames (server enforced). Default: `localhost`. Accepts `*`.

`--http.addr`

Address to bind RPC to. May require `0.0.0.0` for Docker networking.

`--execution.caching.archive`

Retains past block state. For archive nodes.

`--node.feed.input.url=<feed address>`

Default: `wss://<chainName>.arbitrum.io/feed`. ⚠️ One feed relay per datacenter is advised. See [feed relay guide](/run-arbitrum-node/sequencer/run-feed-relay).

`--execution.forwarding-target=<RPC>`

Defaults to the L2 Sequencer RPC based on provided L1 and L2 chain IDs.

`--execution.rpc.evm-timeout`

Default: `5s`. Timeout for `eth_call`. (0 == no timeout).

`--execution.rpc.gas-cap`

Default: `50000000`. Gas cap for `eth_call`/`estimateGas`. (0 = no cap).

`--execution.rpc.tx-fee-cap`

Default: `1`. Transaction fee cap (in ether) for RPC APIs. (0 = no cap).

`--ipc.path`

Filename for IPC socket/pipe within datadir. 🔉 Not supported on macOS. Note the path is within the Docker container.

`--init.prune`

Prunes database before starting the node. Can be "full" or "validator".

`--init.url="<snapshot file>"`

(Non-Orbit Nitro nodes only) URL to download the genesis database from. Required only for the first startup of an Arbitrum One node. Reference to [snapshots](https://snapshot.arbitrum.foundation/index.html) and [archive node guide](/run-arbitrum-node/more-types/run-archive-node).

`--init.download-path="/path/to/dir"`

(Non-Orbit Nitro nodes only) Temporarily saves the downloaded database snapshot. Defaults to `/tmp/`. Used with `--init.url`.

`--node.batch-poster.post-4844-blobs`

Boolean. Default: `false`. Used to enable or disable the posting of transaction data using Blobs to L1 Ethereum. If using calldata is more expensive and if the parent chain supports EIP4844 blobs, the batch poster will use blobs when this flag is set to `true`. Can be `true` or `false`.

`--node.batch-poster.ignore-blob-price`

Boolean. Default: `false`. If the parent chain supports EIP4844 blobs and `ignore-blob-price` is set to `true`, the batch poster will use EIP4844 blobs even if using calldata is cheaper. Can be `true` or `false`.

`--init.latest`

string. if set, searches for the latest snapshot of the given kind (accepted values: "archive" , "pruned" , "genesis")

`--init.latest-base`

string. Default: "[https://snapshot.arbitrum.foundation/](https://snapshot.arbitrum.foundation/)". Base url used when searching for the latest. (If you are running orbit chains you might need to check with orbit chain team to get the url)

`--init.then-quit`

Allows any `--init.*` parameters to complete, and then the node will automatically quit. It doesn't initiate pruning by itself but works in conjunction with other `--init.*` parameters, making it easier to script tasks like database backups after initialization processes finish.

---

# How to run a local full chain simulation | Arbitrum Docs

## How to run a local full chain simulation

Overview[​](#overview "Direct link to Overview")
------------------------------------------------

A local full-chain simulation allows you to deploy and test smart contracts in a fully controlled environment. This how-to walks you through the process of setting up and running a complete development environment on your local machine, including a Nitro node, a dev-mode Geth parent chain, and multiple instances with different roles.

Note that the node is now Stylus-enabled by default, and the setup instructions remain the same as for running a Stylus dev node.

Step 1. Install prerequisites[​](#step-1-install-prerequisites "Direct link to Step 1. Install prerequisites")
--------------------------------------------------------------------------------------------------------------

You'll need [docker](https://docs.docker.com/get-docker/) and [docker compose](https://docs.docker.com/compose/) to run your node. Follow the instructions in their site to install them.

Step 2. Clone the [nitro-testnode](https://github.com/OffchainLabs/nitro-testnode) repo[​](#step-2-clone-the-nitro-testnode-repo "Direct link to step-2-clone-the-nitro-testnode-repo")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

You'll need the `release` branch.

```rust
  `git clone -b release --recurse-submodules https://github.com/OffchainLabs/nitro-testnode.git && cd nitro-testnode`
```

Step 3. Run your node[​](#step-3-run-your-node "Direct link to Step 3. Run your node")
--------------------------------------------------------------------------------------

```rust
./test-node.bash --init
```

Step 4. Successive runs[​](#step-4-successive-runs "Direct link to Step 4. Successive runs")
--------------------------------------------------------------------------------------------

To relaunch the node after the first installation, run the following command.

```rust
./test-node.bash
```

Clear local data

Note that running with the --init flag will clear all chain data and redeploy!

Rollup contract addresses and chain configuration[​](#rollup-contract-addresses-and-chain-configuration "Direct link to Rollup contract addresses and chain configuration")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

You can obtain the rollup chain configuration by running the following command. The chain configuration also includes the addresses of the core contracts.

```rust
docker exec nitro-testnode-sequencer-1 cat /config/l2_chain_info.json
```

You can find other available configuration files by running:

```rust
docker exec nitro-testnode-sequencer-1 ls /config
```

Token bridge[​](#token-bridge "Direct link to Token bridge")
------------------------------------------------------------

An parent-child chain token bridge can be deployed by using the parameter `--tokenbridge`. The list of contracts can be found by running:

```rust
docker compose run --entrypoint sh tokenbridge -c "cat l1l2_network.json"
```

Running an L3 chain[​](#running-an-l3-chain "Direct link to Running an L3 chain")
---------------------------------------------------------------------------------

An L3 chain can be deployed on top of the child chain (L2), by using the parameter `--l3node`. Its chain configuration can be found by running:

```rust
docker exec nitro-testnode-sequencer-1 cat /config/l3_chain_info.json
```

When deploying an L3 chain, the following parameters are also available:

`--l3-fee-token`: Uses a custom gas token for the L3 (symbol $APP), deployed on L2 at address `0x9b7c0fcc305ca36412f87fd6bd08c194909a7d4e` `--l3-token-bridge`: Deploys an L2-L3 token bridge. The list of contracts can be found by running `docker compose run --entrypoint sh tokenbridge -c "cat l2l3_network.json"`.

Additional arguments[​](#additional-arguments "Direct link to Additional arguments")
------------------------------------------------------------------------------------

You can find a list of additional arguments to use with `test-node.bash` by using `--help`.

```rust
./test-node.bash --help
```

Helper scripts[​](#helper-scripts "Direct link to Helper scripts")
------------------------------------------------------------------

The repository includes a set of helper scripts for basic actions like funding accounts or bridging funds. You can see a list of the available scripts by running:

```rust
./test-node.bash script --help
```

If you want to see information of a particular script, you can add the name of the script to the help command.

```rust
./test-node.bash script send-l1 --help
```

Here's an example of how to run the script that funds an address on L2. Replace `0x11223344556677889900` with the address you want to fund.

```rust
./test-node.bash script send-l2 --to address_0x11223344556677889900 --ethamount 5
```

Blockscout[​](#blockscout "Direct link to Blockscout")
------------------------------------------------------

Nitro comes with a local [Blockscout](https://www.blockscout.com/) block explorer. To access it, add the param `--blockscout` when running your node.

```rust
./test-node.bash --blockscout
```

The block explorer will be available at `http://localhost:4000`

Default endpoints and addresses[​](#default-endpoints-and-addresses "Direct link to Default endpoints and addresses")
---------------------------------------------------------------------------------------------------------------------

Node RPC endpoints are available at:

Node

Chain id

RPC endpoint

L1 geth devnet

1337

`http://localhost:8545`

L2 nitro devnet

412346

`http://localhost:8547` and `ws://localhost:8548`

L3 nitro (if enabled)

333333

`http://localhost:3347`

Some important addresses:

Role

Public address

Private key

Sequencer

`0xe2148eE53c0755215Df69b2616E552154EdC584f`

`0xcb5790da63720727af975f42c79f69918580209889225fa7128c92402a6d3a65`

Validator

`0x6A568afe0f82d34759347bb36F14A6bB171d2CBe`

`0x182fecf15bdf909556a0f617a63e05ab22f1493d25a9f1e27c228266c772a890`

L2 rollup owner

`0x5E1497dD1f08C87b2d8FE23e9AAB6c1De833D927`

`0xdc04c5399f82306ec4b4d654a342f40e2e0620fe39950d967e1e574b32d4dd36`

L3 rollup owner (if enabled)

`0x863c904166E801527125D8672442D736194A3362`

`0xecdf21cb41c65afb51f91df408b7656e2c8739a5877f2814add0afd780cc210e`

L3 sequencer (if enabled)

`0x3E6134aAD4C4d422FF2A4391Dc315c4DDf98D1a5`

`0x90f899754eb42949567d3576224bf533a20857bf0a60318507b75fcb3edc6f5f`

Dev account (prefunded with ETH in all networks)

`0x3f1Eae7D46d88F08fc2F8ed27FCb2AB183EB2d0E`

`0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659`

You can fund other addresses by using the scripts `send-l1` and `send-l2` as explained [here](#helper-scripts).

Private keys publicly known

Do not use any of these addresses in a production environment.

Optional parameters[​](#optional-parameters "Direct link to Optional parameters")
---------------------------------------------------------------------------------

Here, We show a list of the parameters that might be useful when running a local devnode. You can also use the flag `./test-node.bash --help` to get them.

Flag

Description

`--init`

Removes all the data, rebuilds, and deploys a new rollup

proof-of-stake chain (using Prysm for consensus)

heavy computation

up the L3 chain to use a custom fee token. Only valid if `--l3node` flag is provided

`--l3-fee-token-decimals`

Number of decimals to use for a custom fee token. Only valid if

`--l3-fee-token` flag is provided

valid if `--l3node` flag is provided

`--redundantsequencers`

Redundant sequencers \[0-3\]

running them

configuration: one node as a sequencer/batch-poster/staker (default unless using `--dev`)

`--tokenbridge`

Deploy an L1-L2 token bridge

launching the token bridge

`--no-simple`

Runs a full configuration with separate sequencer/batch-poster/validator/relayer

---

# How to run a local Nitro dev node | Arbitrum Docs

## How to run a local Nitro dev node

Overview[​](#overview "Direct link to Overview")
------------------------------------------------

This page provides step-by-step instructions for setting up and running a local Nitro node in `--dev` mode. This mode is ideal for developers who want to quickly test contracts using a single node, as it offers a simpler and faster setup compared to more complex environments.

While some teams use `nitro-testnode` for testing cross-layer messaging, which involves launching both Geth as parent chain and Nitro as child chain, this setup can be more complex and time-consuming. If your primary goal is to test contracts on a local node without needing cross-layer interactions, Nitro's `--dev` mode offers a lightweight and efficient alternative.

However, if you need more advanced functionality—such as cross-layer messaging, working with both the parent and child chains, or testing interactions between different layers—`nitro-testnode` is the preferred option. The testnode setup allows you to simulate a full parent-child chain environment, which is critical for those scenarios. See here for instructions.

Note that Nitro `--dev` mode is ideal for Stylus contract testing, as it is much lighter and faster to set up than the full nitro-testnode environment.

Prerequisites[​](#prerequisites "Direct link to Prerequisites")
---------------------------------------------------------------

Before beginning, ensure the following is installed and running on your machine:

*   Docker: Required to run the Nitro dev node in a container. Install Docker by following [the official installation guide](https://docs.docker.com/get-started/get-docker/) for your operating system.
*   cast: A command-line tool from Foundry for interacting with Ethereum smart contracts. You can install it via Foundry by following [the installation instructions](https://book.getfoundry.sh/getting-started/installation).
*   jq: A lightweight JSON parsing tool used to extract contract addresses from the script output. Install jq by following [the official installation guide](https://jqlang.github.io/jq/download/) for your operating system.

Clone the [nitro-devnode](https://github.com/OffchainLabs/nitro-devnode) repository[​](#clone-the-nitro-devnode-repository "Direct link to clone-the-nitro-devnode-repository")
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Use the following command to clone the repository:

```rust
git clone https://github.com/OffchainLabs/nitro-devnode.git
cd nitro-devnode
```

Run the dev node script:[​](#run-the-dev-node-script "Direct link to Run the dev node script:")
-----------------------------------------------------------------------------------------------

Run the script to start the Nitro dev node, deploy the Stylus `Cache Manager` contract, and register it as a WASM cache manager using the default development account:

```rust
./run-dev-node.sh
```

The script will:

*   Start the Nitro dev node in the background using Docker.
*   Deploy the Stylus `Cache Manager` contract on the local Nitro network.
*   Register the `Cache Manager` contract as a WASM cache manager.

Development account (used by default)[​](#development-account-used-by-default "Direct link to Development account (used by default)")
-------------------------------------------------------------------------------------------------------------------------------------

In `--dev` mode, the script uses a pre-funded development account by default. This account is pre-funded with ETH in all networks and is used to deploy contracts, interact with the chain, and assume chain ownership.

*   Address: 0x3f1Eae7D46d88F08fc2F8ed27FCb2AB183EB2d0E
*   Private key: 0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659

You don’t need to set up a private key manually unless you prefer using your own key.

Chain ownership in `--dev` mode[​](#chain-ownership-in---dev-mode "Direct link to chain-ownership-in---dev-mode")
-----------------------------------------------------------------------------------------------------------------

In Nitro `--dev` mode, the default chain owner is set to `0x0000000000000000000000000000000000000000`. However, you can use the `ArbDebug` precompile to set the chain owner. This precompile includes the `becomeChainOwner()` function, which can be called to assume ownership of the chain.

Chain ownership is important because it allows the owner to perform certain critical functions within the Arbitrum environment, such as:

*   Adding or removing other chain owners
*   Setting the parent and child chain base fees directly
*   Adjusting the gas pricing inertia and backlog tolerance
*   Modifying the computational speed limit and transaction gas limits
*   Managing network and infrastructure fee accounts

The script automatically sets the chain owner to the pre-funded dev account before registering the `Cache Manager` contract. Here’s how the `becomeChainOwner()` function is called within the script:

```rust
cast send 0x00000000000000000000000000000000000000FF "becomeChainOwner()" --private-key 0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659 --rpc-url http://127.0.0.1:8547
```

This step ensures that the dev account has ownership of the chain, which is necessary to register the `Cache Manager` as a WASM cache manager.

At the end of the process, you'll have the Nitro `dev` mode running with the necessary components deployed. This environment is ready for testing and interacting with your contracts, including those written in Stylus, using the deployed `Cache Manager` to support enhanced functionality for Stylus-based smart contracts.

---

# How to read the sequencer feed | Arbitrum Docs

## How to read the sequencer feed

[Running an Arbitrum relay locally as a feed relay](/run-arbitrum-node/sequencer/run-feed-relay) lets you subscribe to an uncompressed  for real-time data as the sequencer accepts and orders transactions off-chain.

When connected to websocket port `9642` of the local relay, you'll receive a data feed that looks something like this:

```rust
{
  "version": 1,
  "messages": [
    {
      "sequenceNumber": 25757171,
      "message": {
        "message": {
          "header": {
            "kind": 3,
            "sender": "0xa4b000000000000000000073657175656e636572",
            "blockNumber": 16238523,
            "timestamp": 1671691403,
            "requestId": null,
            "baseFeeL1": null
          },
          "l2Msg": "BAL40oKksUiElQL5AISg7rsAgxb6o5SZbYNoIF2DTixsqDpD2xII9GJLG4C4ZAhh6N0AAAAAAAAAAAAAAAC7EQiq1R1VYgL3/oXgvD921hYRyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArAAaAkebuEnSAUvrWVBGTxA7W+ZMNn5uyLlbOH7Nrs0bYOv6AOxQPqAo2UB0Z7vqlugjn+BUl0drDcWejBfDiPEC6jQA=="
        },
        "delayedMessagesRead": 354560
      },
      "signature": null
    }
  ]
}
```

Breaking this feed down a bit: the top-level data structure is defined by the [`BroadcastMessage struct`](https://github.com/OffchainLabs/nitro/blob/9b1e622102fa2bebfd7dffd327be19f8881f1467/broadcaster/broadcaster.go#L42):

```rust
type BroadcastMessage struct {
	Version int `json:"version"`
	// Note: the "Messages" object naming is slightly ambiguous: since there are different types of messages
	Messages                       []*BroadcastFeedMessage         `json:"messages,omitempty"`
	ConfirmedSequenceNumberMessage *ConfirmedSequenceNumberMessage `json:"confirmedSequenceNumberMessage,omitempty"`
}
```

The `messages` field is the [`BroadcastFeedMessage struct`](https://github.com/OffchainLabs/nitro/blob/9b1e622102fa2bebfd7dffd327be19f8881f1467/broadcaster/broadcaster.go#L49):

```rust
type BroadcastFeedMessage struct {
	SequenceNumber arbutil.MessageIndex         `json:"sequenceNumber"`
	Message        arbstate.MessageWithMetadata `json:"message"`
	Signature      []byte                       `json:"signature"`
	BlockMetadata  arbostypes.BlockMetadata     `json:"blockMetadata"`
}
```

Each `message` conforms to [`arbstate.MessageWithMetadata`](https://github.com/OffchainLabs/nitro/blob/a05f768d774f60468a58a6a94fcc1be18e4d8fae/arbstate/inbox.go#L42):

```rust
type MessageWithMetadata struct {
	Message             *arbos.L1IncomingMessage `json:"message"`
	DelayedMessagesRead uint64                   `json:"delayedMessagesRead"`
}
```

Finally, we get the transaction's information in the `message` subfield as an [`L1IncomingMessage`](https://github.com/OffchainLabs/nitro/blob/9b1e622102fa2bebfd7dffd327be19f8881f1467/arbos/incomingmessage.go#L61):

```rust
type L1IncomingMessage struct {
	Header *L1IncomingMessageHeader `json:"header"`
	L2msg  []byte                   `json:"l2Msg"`
	// Only used for `L1MessageType_BatchPostingReport`
	BatchGasCost *uint64 `json:"batchGasCost,omitempty" rlp:"optional"`
}
```

You can use the [`ParseL2Transactions`](https://github.com/OffchainLabs/nitro/blob/9b1e622102fa2bebfd7dffd327be19f8881f1467/arbos/incomingmessage.go#L227) function to decode the message.

Using the feed relay, you can also retrieve the `L2 block number` of a message:

*   On , this can be done by adding the Arbitrum One genesis block number (22207817) to the sequence number of the feed message.
*   Note that in the case of , the Nitro genesis number is `0`, so it doesn't need to be included when adding to the feed message's sequence number.

info

Note that the `messages[0].message.message.header.blockNumber` is `L1 block number` instead of `L2 block number`

---

# How to run a feed relay | Arbitrum Docs

## How to run a feed relay

caution

If running a single node, there is no need to run a feed relay. When running more that one node, it is strongly suggested to run a single feed relay per datacenter, which will reduce ingress fees and improve stability.

caution

Feed endpoints will soon require compression with a custom dictionary, so if connecting to feed with anything other than a standard node, it is strongly suggested to run a local feed relay which will provide an uncompressed feed by default.

The feed relay is in the same docker image as the Nitro node.

*   Here is an example of how to run the feed relay for Arbitrum One:
    
    ```rust
    docker run --rm -it  -p 0.0.0.0:9642:9642 --entrypoint relay offchainlabs/nitro-node:v3.5.1-8f247fd --node.feed.output.addr=0.0.0.0 --node.feed.input.url=wss://arb1.arbitrum.io/feed --chain.id=42161
    ```
    
*   Here is an example of how to run nitro-node for Arbitrum One with custom relay:
    
    ```rust
    docker run --rm -it  -v /some/local/dir/arbitrum:/home/user/.arbitrum -p 0.0.0.0:8547:8547 -p 0.0.0.0:8548:8548 offchainlabs/nitro-node:v3.5.1-8f247fd --parent-chain.connection.url=https://l1-mainnet-node:8545 --chain.id=42161 --http.api=net,web3,eth --http.corsdomain=* --http.addr=0.0.0.0 --http.vhosts=* --node.feed.input.url=ws://local-relay-address:9642
    ```
    

Note that Arbitrum classic does not communicate with Nitro sequencer, so classic relay is no longer used.

Helm charts (Kubernetes)[​](#helm-charts-kubernetes "Direct link to Helm charts (Kubernetes)")
----------------------------------------------------------------------------------------------

If you are using [Kubernetes](https://kubernetes.io/) to run your feed relay, a helm chart is available at [ArtifactHUB](https://artifacthub.io/packages/helm/offchainlabshelm/relay). It supports running a Nitro relay by providing the feed input URL. Find more information in the [OCL community Helm charts repository](https://github.com/OffchainLabs/community-helm-charts/tree/main/charts/relay).

---

# How to run a Sequencer Coordinator Manager (SQM) | Arbitrum Docs

## How to run a Sequencer Coordinator Manager (SQM)

The Sequencer Coordinator Manager (SQM) is a command-line tool that allows you to manage the priority list of sequencers, update their positions, add new sequencers to the list, and refresh the lists from the Redis server. The tool offers keyboard-only support. Any changes you make are stored locally until you choose to save and push them to the Redis server.

*   Here is an example of how to start the Sequencer Coordinator Manager and connect to a local Redis server:
    
    ```rust
    git clone --branch v3.5.1 https://github.com/OffchainLabs/nitro.git
    cd nitro
    make target/bin/seq-coordinator-manager
    ./target/bin/seq-coordinator-manager redis://127.0.0.1:6379
    ```
    

If mouse support is enabled, you can use your mouse to explore the tool. Otherwise, use your keyboard to explore the UI. The `enter` key selects options; `c` switches focus between lists. When you bring up any form, you can navigate within the form's options using the `Tab` key and use the up/down arrow keys to select options from the dropdown menu.

![Sequencer coordinator manager](/img/run-node-seq-coordinator-manager.png)

note

One of the sequencers is marked with a `chosen` indicator. This visual cue helps you identify the current chosen sequencer.

You can click/enter on any sequencer element in the priority list to bring up a form for updating its position. Within this form, you have the options to make changes via a dropdown menu and then either click `Update` to see the change locally, `Cancel` to cancel the operation, or `Remove` to remove the sequencer from the priority list.

When a sequencer is removed, it is automatically added to the `--Not in priority list but online--` list if it is online. Please remember that all changes made using this method are local and need to be saved to the Redis server by pressing `s` from the keyboard shortcuts to make them permanent.

![Change priority](/img/run-node-change-priority.png)

After selecting a sequencer from the non-priority list, you are given the option to add the selected sequencer to the priority list at any position of your choice. You can specify the position via a dropdown menu that lists all possible positions. Clicking `Update` will then display the updated priority list with the newly added sequencer in the chosen position.

![Add to priority](/img/run-node-add-to-priority.png)

You can also add a new sequencer to the priority list by pressing `a` from the keyboard shortcuts. This action will bring up a form to enter the sequencer details. After adding the sequencer URL, you can click `Add` to see the changes or `Cancel` to abort the operation.

![Add new Sequencer](/img/run-node-add-new-seq.png)

To exit the tool, press `q` from the keyboard shortcuts.

---

# Troubleshooting: Run a node | Arbitrum Docs

## Troubleshooting: Run a node

The guidance displayed on this page will change based on your selected configuration:

*   Operating system:
*   Linux, MacOS, Arm64
*   Windows

*   Network:
*   Arbitrum One (Nitro)
*   Arbitrum One (Classic)
*   Arbitrum Nova
*   Arbitrum Sepolia
*   Localhost

*   Node type:
*   Full node
*   Archive node
*   Validator node

Thank you!

At the end of this troubleshooting guide, you'll find a "Generate troubleshooting report" button. Clicking this button will generate a report that includes your selected configuration. You can include this report when asking for help.

**Using this page to generate a troubleshooting report is helpful** because it gathers the information that we need in order to resolve your issue.

### Step 1: Try the troubleshooting checklist[​](#step-1-try-the-troubleshooting-checklist "Direct link to Step 1: Try the troubleshooting checklist")

If you're running into unexpected outputs or errors, the following checklist may help you independently resolve your issue.

1\. Select an Operating system, Network, and Node type above

The guidance displayed on this page will change based on your selected configuration.

2\. Review the docs

*   Node type:
*   Full node
*   Archive node
*   Validator node

*   Network:
*   Arbitrum One (Nitro)
*   Arbitrum One (Classic)
*   Arbitrum Nova
*   Arbitrum Sepolia
*   Localhost

The [How to run a full node (Nitro)](/run-arbitrum-node/run-full-node) may address your issue.

[](/run-arbitrum-node/more-types/run-classic-node)

[How to run a full node (Classic, pre-Nitro)](/run-arbitrum-node/more-types/run-classic-node)

may address your issue.

The [How to run a full node (Nitro)](/run-arbitrum-node/run-full-node) may address your issue.

The [How to run a full node (Nitro)](/run-arbitrum-node/run-full-node) may address your issue.

The [How to run a local dev node](/run-arbitrum-node/run-local-dev-node) may address your issue.

[](/run-arbitrum-node/more-types/run-archive-node)

[How to run an archive node](/run-arbitrum-node/more-types/run-archive-node)

may address your issue.

[How to run a validator](/run-arbitrum-node/more-types/run-validator-node) may address your issue.

3\. Review the FAQ

Answers to frequently asked questions can be found in [Frequently asked questions: Run a node](/node-running/faq).

### Step 2: Look for your scenario[​](#step-2-look-for-your-scenario "Direct link to Step 2: Look for your scenario")

Common troubleshooting scenarios and solutions are detailed below.

You can check logs by different log types: info, warn, and error.

*   Logs type:
*   Info
*   Warn
*   Error

Scenario

Solution

You see `Unindex transactions`.

This is expected behavior. You'll see this when your node removes old `txlookup` indices. This is emitted from the base Geth node, so you'd see the same output from a mainnet Geth node.

You see `Head state missing, repairing`.

This is usually because your node shuts down ungracefully. In most cases, it will recover in a few minutes, but if it not, you may have to re-sync your node. Remember to shut down your node gracefully with the following command: `docker stop —time=300 $(docker ps -aq)`.

Your local machine is running out of memory

Nitro (and Geth) can consume a lot of memory depending on the request load. It's possible that your machine may run out of memory when receiving tons of requests.

Your Arbitrum node can’t connect to your parent chain node on `localhost:8545`

This is often because of a Docker port configuration issue. See [https://stackoverflow.com/questions/43884981/unable-to-connect-localhost-in-docker](https://stackoverflow.com/questions/43884981/unable-to-connect-localhost-in-docker).

You specified your snapshot file path via the `--init.url` parameter, but the snapshot file isn't found.

This is usually because the snapshot file isn't mounted to your Docker container. Mount it and change the file path to your Docker container’s mount point.

You get `403` errors from the feed URL.

This often happens when Cloudflare attempts to block botnets and other malicious actors but accidentally blocks node runners.

You see `latest assertion not yet in our node`

This usually because your node hasn’t synced to the latest state, it’s a normal behavior.

You see `"Post "xxx_url": context deadline exceeded"`

Please check your parent chain endpoint because there is something going wrong on that endpoint; you can check it.

You see `Resuming state snapshot generation`

This is a normal behavior while the node is catching up to the tip of the chain; once a node has been fully synced, "Resuming state snapshot generation" shouldn't be logged unless it falls behind again.

Scenario

Solution

You see

``   `error reading inbox` err="sequencer batches out of order; after batch A got batch B”   ``

This is because you get two discontinuous batches; this might be because of your parent chain endpoint issues. You can change to another endpoint and set nitro `--init.reorg-to-batch A`

You see

``   `error reading inbox` err="failed to get previous message for pos `x`: leveldb: not found”   ``

This is because your node db crashed and lost some messages. You can try to set `--init.reorg-to-message-batch x-1`

You see `` `Failed to load snapshot` err="head doesn't match snapshot: have a, want b” ``

This is usually because an ungraceful shutdown caused a corrupted database; try restarting the node without a prune flag, and after your node goes back to normal, then graceful shut it down and restart to prune it.

You see

``   failed to get blobs: expected at least six blobs for slot `[slot_number]` but only got 0   ``

This often happens when you connect to a beacon chain endpoint while the blob you are querying is expired. To resolve this error, connect to a beacon endpoint that supports historical blob data (see

[

List of Ethereum beacon chain RPC providers

](/run-arbitrum-node/l1-ethereum-beacon-chain-rpc-providers#list-of-ethereum-beacon-chain-rpc-providers)

).

You see `P2P server will be useless, neither dialing nor listening`

Arbitrum Nitro doesn’t need P2P mode, so you can ignore this log.

Scenario

Solution

You see `no contract code at given address`

Your parent chain node might not sync to the latest state, please wait after it finishes syncing.

You see

``   `staker: error checking latest staked` err="latest assertion of x: globalstate not in chain: count a hash b expected c, sendroot d expected f"   ``

Once it catches up, the node will check the state against the latest confirmed assertion staked onchain; if it doesn’t match, it will log this error. Usually, this is because of db corruption, so you might need to re-sync the blockchain; using a snapshot might help: [https://snapshot-explorer.arbitrum.io/](https://snapshot-explorer.arbitrum.io/)

You see

`   disabling L1 bound as batch posting message is close to the maximum delay blockNumber   `

or `batch is within reorg resistance margin from layer 1 minimum block or timestamp bounds`

It indicates that there has been an issue with batch posting on the network. This could occur if your batch poster didn't post a batch for an extended period. Common reasons include the node being shut down inadvertently or the batch poster running out of funds, leading to no new blocks being produced or posted by the batch poster.  
To resolve this, If re-org doesn’t matter, you can just start the batch poster with `--node.batch-poster.reorg-resistance-margin=0` and `node.batch-poster.l1-block-bound` to ignore, If it does, you'd want to modify the time bounds on the sequencer inbox to allow the sequencer to post a batch containing the transactions with the old timestamp

You see

`   on-chain WASM module root did not match with any of the allowed WASM module roots   `

Usually, because you are running on an old node version, try to upgrade your node. Also, you modify your node’s code; please refer to the continue set.

You see `error acting as staker`

In most cases, this error is caused by your parent chain endpoint's rate limit or other issues, you can check your parent chain endpoint. If the error still persists, please ask in our discord node-running [channel](https://discord.gg/arbitrum).

### Step 3: Generate a troubleshooting report[​](#step-3-generate-a-troubleshooting-report "Direct link to Step 3: Generate a troubleshooting report")

1.  Complete the above troubleshooting checklist.
2.  Fill in the below form.
3.  Click `Generate troubleshooting report`.
4.  Copy and paste the **generated report text** when asking for support on [Discord](https://discord.gg/ZpZuw7p) or any other support channel.

  

Node startup command (make sure to remove any sensitive information like, i.e., private keys)

Unexpected output

**Tip:** Paste the ~100 lines of output **before and including** the unexpected output you're asking about. You can use the following command to get the logs:

`docker logs --tail 100 YOUR_CONTAINER_ID`

Complete the checklist above before generating...

---

# Introduction | Arbitrum Docs

## Introduction

The Arbitrum SDK is a powerful TypeScript library that streamlines interactions with Arbitrum networks. It offers robust tools for bridging tokens and passing messages between networks through an intuitive interface to the underlying smart contracts.

**Key Features**

*   Token Bridging: Effortlessly bridge tokens between Ethereum and Arbitrum.
*   Message Passing: Seamlessly pass messages across networks.
*   Contracts Interface: Leverage a strongly-typed interface for interacting with smart contracts.

Below is an overview of the Arbitrum SDK functionality. See the [tutorials](https://github.com/OffchainLabs/arbitrum-tutorials) for more examples.

Getting Started[​](#getting-started "Direct link to Getting Started")
---------------------------------------------------------------------

Install dependencies

*   npm
*   yarn
*   pnpm

```rust
npm install @arbitrum/sdk
```

```rust
yarn add @arbitrum/sdk
```

```rust
pnpm install @arbitrum/sdk
```

Using the Arbitrum SDK[​](#using-the-arbitrum-sdk "Direct link to Using the Arbitrum SDK")
------------------------------------------------------------------------------------------

### Bridging assets[​](#bridging-assets "Direct link to Bridging assets")

Arbitrum SDK can be used to bridge assets to or from an Arbitrum Network. The following asset bridgers are currently available:

*   [`EthBridger`](/sdk/reference/assetBridger/ethBridger)
*   [`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger)

All asset bridgers have the following methods which accept different parameters depending on the asset bridger type:

*   [`deposit`](/sdk/reference/assetBridger/#deposit) - moves assets from the Parent to the Child chain
*   [`withdraw`](/sdk/reference/assetBridger/#withdraw) - moves assets from the Child to the Parent chain

#### Example ETH Deposit to Arbitrum One[​](#example-eth-deposit-to-arbitrum-one "Direct link to Example ETH Deposit to Arbitrum One")

```rust
import { getArbitrumNetwork, EthBridger } from '@arbitrum/sdk'

// get the `@arbitrum/sdk` ArbitrumNetwork object using the chain id of the Arbitrum One chain
const childNetwork = await getArbitrumNetwork(42161)
const ethBridger = new EthBridger(childNetwork)

const ethDepositTxResponse = await ethBridger.deposit({
  amount: utils.parseEther('23'),
  parentSigner, // an ethers v5 signer connected to mainnet ethereum
  childProvider, // an ethers v5 provider connected to Arbitrum One
})

const ethDepositTxReceipt = await ethDepositTxResponse.wait()
```

[Learn more in the Eth Deposit tutorial](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/eth-deposit)

#### Example ETH Withdrawal from Arbitrum One[​](#example-eth-withdrawal-from-arbitrum-one "Direct link to Example ETH Withdrawal from Arbitrum One")

```rust
import { getArbitrumNetwork, EthBridger } from '@arbitrum/sdk'

// get the `@arbitrum/sdk` ArbitrumNetwork object using the chain id of the Arbitrum One chain
const childNetwork = await getArbitrumNetwork(42161)
const ethBridger = new EthBridger(childNetwork)

const withdrawTx = await ethBridger.withdraw({
  amount: utils.parseEther('23'),
  childSigner, // an ethers v5 signer connected to Arbitrum One
  destinationAddress: childWallet.address,
})
const withdrawRec = await withdrawTx.wait()
```

[Learn more in the Eth Withdraw tutorial](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/eth-withdraw)

### Networks[​](#networks "Direct link to Networks")

Arbitrum SDK comes pre-configured for Mainnet and Sepolia, and their Arbitrum counterparts. Any other networks that are not pre-configured **must** be registered before being used.

#### Configuring Network[​](#configuring-network "Direct link to Configuring Network")

To interact with a custom [`ArbitrumNetwork`](/sdk/reference/dataEntities/networks), you can register it using the [`registerCustomArbitrumNetwork`](/sdk/reference/dataEntities/networks#registerCustomArbitrumNetwork) function.

```rust
import { registerCustomArbitrumNetwork } from '@arbitrum/sdk'

registerCustomArbitrumNetwork({
  chainID: 123456,
  name: 'Custom Arbitrum Network',
})
```

### Cross chain messages[​](#cross-chain-messages "Direct link to Cross chain messages")

When assets are moved by the Parent and Child cross chain messages are sent. The lifecycles of these messages are encapsulated in the classes [`ParentToChildMessage`](/sdk/reference/message/ParentToChildMessage) and [`ChildToParentMessage`](/sdk/reference/message/ParentToChildMessage). These objects are commonly created from the receipts of transactions that send cross chain messages. A cross chain message will eventually result in a transaction being executed on the destination chain, and these message classes provide the ability to wait for that finalizing transaction to occur.

#### Redeem a Parent-to-Child Message[​](#redeem-a-parent-to-child-message "Direct link to Redeem a Parent-to-Child Message")

```rust
import {
  ParentTransactionReceipt,
  ParentToChildMessageStatus,
} from '@arbitrum/sdk'

const parentTxnReceipt = new ParentTransactionReceipt(
  txnReceipt // ethers-js TransactionReceipt of an ethereum tx that triggered a Parent-to-Child message (say depositing a token via a bridge)
)

const parentToChildMessage = (
  await parentTxnReceipt.getParentToChildMessages(
    childSigner // connected ethers-js Wallet
  )
)[0]

const res = await parentToChildMessage.waitForStatus()

if (res.status === ParentToChildMessageStatus.Child) {
  // Message wasn't auto-redeemed; redeem it now:
  const response = await parentToChildMessage.redeem()
  const receipt = await response.wait()
} else if (res.status === ParentToChildMessageStatus.REDEEMED) {
  // Message successfully redeemed
}
```

[Learn more in the Redeem Failed Retryable Tickets tutorial](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/redeem-failed-retryable)

### Inbox Tools[​](#inbox-tools "Direct link to Inbox Tools")

As part of normal operation, the Arbitrum sequencer will send messages into the rollup chain. However, if the sequencer is unavailable and not posting batches, the inbox tools can be used to force the inclusion of transactions into the Arbitrum network.

Here's how you can use the inbox tools to withdraw ether from Arbitrum One without waiting for the sequencer:

```rust
const childNetwork = await getArbitrumNetwork(await childWallet.getChainId())

const inboxSdk = new InboxTools(parentWallet, childNetwork)
const arbSys = ArbSys__factory.connect(ARB_SYS_ADDRESS, childProvider)
const arbSysIface = arbSys.interface
const childCalldata = arbSysIface.encodeFunctionData('withdrawEth', [
  parentWallet.address,
])

const txChildRequest = {
  data: childCalldata,
  to: ARB_SYS_ADDRESS,
  value: 1,
}

const childSignedTx = await inboxSdk.signChildTx(txChildRequest, childWallet)
const childTxhash = ethers.utils.parseTransaction(childSignedTx).hash
const resultsParent = await inboxSdk.sendChildSignedTx(childSignedTx)

const inboxRec = await resultsParent.wait()
```

[Learn more in the Delayed Inbox tutorial](https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/delayedInbox-l2msg).

### Utils[​](#utils "Direct link to Utils")

*   [`EventFetcher`](/sdk/reference/utils/eventFetcher) - A utility to provide typing for the fetching of events
*   [`MultiCaller`](/sdk/reference/utils/multicall#multicaller) - A utility for executing multiple calls as part of a single RPC request. This can be useful for reducing round trips.
*   [`constants`](/sdk/reference/dataEntities/constants) - A list of useful Arbitrum related constants

Development[​](#development "Direct link to Development")
---------------------------------------------------------

### Run Integration tests[​](#run-integration-tests "Direct link to Run Integration tests")

1.  Copy the `.env-sample` file to `.env` and update the values with your own.
2.  First, make sure you have a [Nitro test node](https://github.com/Offchainlabs/nitro-testnode) running. Follow the instructions [here](https://docs.arbitrum.io/node-running/how-tos/local-dev-node).
3.  After the node has started up (that could take up to 20-30 mins), run `yarn gen:network`.
4.  Once done, finally run `yarn test:integration` to run the integration tests.

Defaults to `Arbitrum Sepolia`, for custom network use `--network` flag.

`Arbitrum Sepolia` expects env var `ARB_KEY` to be prefunded with at least 0.02 ETH, and env var `INFURA_KEY` to be set. (see `integration_test/config.ts`)

---

# Migrating from v3 to v4 | Arbitrum Docs

## Migrating from v3 to v4

Introduction[​](#introduction "Direct link to Introduction")
------------------------------------------------------------

`@arbitrum/sdk` v4 introduces significant changes to improve support Orbit chains from Offchain Labs. This guide outlines the breaking changes to know before migrating your existing v3 code to v4.

Major Changes Overview[​](#major-changes-overview "Direct link to Major Changes Overview")
------------------------------------------------------------------------------------------

1.  Terminology change from L1/L2 to parent/child
2.  Network types and functions updated
3.  Updates to `AssetBridger` and `Erc20Bridger` classes
4.  Changes to Message classes

Detailed Changes[​](#detailed-changes "Direct link to Detailed Changes")
------------------------------------------------------------------------

### 1\. Terminology change from L1/L2 to parent/child[​](#1-terminology-change-from-l1l2-to-parentchild "Direct link to 1. Terminology change from L1/L2 to parent/child")

Most instances of "L1" and "L2" have been replaced with "parent" and "child" respectively. This change reflects the more general parent-child relationship between chains in the Arbitrum ecosystem.

*   In most circumstances, when referring to a parent-child relationship between chains, the terms "parent" and "child" are used.
*   Though, when referring explicitly to "L1", "L2", or "L3", those specific terms are still used.

### 2\. Network types and functions updated[​](#2-network-types-and-functions-updated "Direct link to 2. Network types and functions updated")

*   The `L1Network` is no longer required to be registered before bridging.
*   Only Arbitrum networks need to be registered.
*   Arbitrum networks are defined as Arbitrum One, Arbitrum testnets, and any Orbit chain.
*   If you need a full list of Arbitrum networks, you can use the new [`getArbitrumNetworks`](/sdk/reference/dataEntities/networks#getArbitrumNetworks) function.
*   To list all of the children of a network, use the new [`getChildrenForNetwork`](/sdk/reference/dataEntities/networks#getChildrenForNetwork) function.

v3 Name

v4 Name

`L2Network`

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

`getL2Network`

[`getArbitrumNetwork`](/sdk/reference/dataEntities/networks#getArbitrumNetwork)

`l2Networks`

[`getArbitrumNetworks`](/sdk/reference/dataEntities/networks#getArbitrumNetworks)

`addCustomNetwork`

[`registerCustomArbitrumNetwork`](/sdk/reference/dataEntities/networks#registerCustomArbitrumNetwork)

`Network`

_removed_

`L1Network`

_removed_

`getL1Network`

_removed_

`getParentForNetwork`

_removed_

#### `ArbitrumNetwork` type[​](#arbitrumnetwork-type "Direct link to arbitrumnetwork-type")

`Network` type has been replaced with the [`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork) type and some properties have been removed or renamed.

v3 Name

v4 Name

`chainID`

`chainId`

`partnerChainID`

`parentChainId`

`explorerUrl`

_removed_

`isArbitrum`

_removed_

`partnerChainIDs`

_removed_

`nitroGenesisBlock`

_removed_

`nitroGenesisL1Block`

_removed_

`depositTimeout`

_removed_

`blockTime`

_removed_

#### `TokenBridge` type[​](#tokenbridge-type "Direct link to tokenbridge-type")

The `TokenBridge` type within the[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork) object has been updated.

v3 Name

v4 Name

`l1CustomGateway`

`parentCustomGateway`

`l1ERC20Gateway`

`parentErc20Gateway`

`l1GatewayRouter`

`parentGatewayRouter`

`l1MultiCall`

`parentMultiCall`

`l1ProxyAdmin`

`parentProxyAdmin`

`l1Weth`

`parentWeth`

`l1WethGateway`

`parentWethGateway`

`l2CustomGateway`

`childCustomGateway`

`l2ERC20Gateway`

`childErc20Gateway`

`l2GatewayRouter`

`childGatewayRouter`

`l2Multicall`

`childMultiCall`

`l2ProxyAdmin`

`childProxyAdmin`

`l2Weth`

`childWeth`

`l2WethGateway`

`childWethGateway`

### 3\. Updates to `AssetBridger` and `Erc20Bridger` classes[​](#3-updates-to-assetbridger-and-erc20bridger-classes "Direct link to 3-updates-to-assetbridger-and-erc20bridger-classes")

#### [`AssetBridger`](/sdk/reference/assetBridger/) Class Methods[​](#assetbridger--class-methods "Direct link to assetbridger--class-methods")

The [`AssetBridger`](/sdk/reference/assetBridger/) class methods and properties have been renamed to reflect the new parent-child terminology.

v3 Name

v4 Name

`l2Network`

`childNetwork`

`checkL1Network`

`checkParentNetwork`

`checkL2Network`

`checkChildNetwork`

#### [`AssetBridger`](/sdk/reference/assetBridger/) Class Method Parameters[​](#assetbridger--class-method-parameters "Direct link to assetbridger--class-method-parameters")

The objects passed to the class methods of classes that inherit from [`AssetBridger`](/sdk/reference/assetBridger/) ([`EthBridger`](/sdk/reference/assetBridger/ethBridger) and [`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger)) have been renamed.

v3 Name

v4 Name

`erc20L1Address`

`erc20ParentAddress`

`l1Provider`

`parentProvider`

`l2Provider`

`childProvider`

`l1Signer`

`parentSigner`

`l2Signer`

`childSigner`

#### [`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger) Class Methods[​](#erc20bridger-class-methods "Direct link to erc20bridger-class-methods")

v3 Name

v4 Name

`getL1GatewayAddress`

`getParentGatewayAddress`

`getL2GatewayAddress`

`getChildGatewayAddress`

`getL2WithdrawalEvents`

`getWithdrawalEvents`

`getL1TokenContract`

`getParentTokenContract`

`getL1ERC20Address`

`getParentErc20Address`

`getL2TokenContract`

`getChildTokenContract`

`getL2ERC20Address`

`getChildErc20Address`

`l1TokenIsDisabled`

`isDepositDisabled`

`l1Provider`

`parentProvider`

`getL1GatewaySetEvents`

`getParentGatewaySetEvents`

`getL2GatewaySetEvents`

`getChildGatewaySetEvents`

#### [`Erc20L1L3Bridger`](/sdk/reference/assetBridger/l1l3Bridger) Class Methods[​](#erc20l1l3bridger-class-methods "Direct link to erc20l1l3bridger-class-methods")

v3 Name

v4 Name

`getL2ERC20Address`

`getL2Erc20Address`

`getL3ERC20Address`

`getL3Erc20Address`

### 4\. Changes to Message classes[​](#4-changes-to-message-classes "Direct link to 4. Changes to Message classes")

Message classes have been renamed and their methods updated:

v3 Name

v4 Name

`L1TransactionReceipt`

`ParentTransactionReceipt`

`L1ContractTransaction`

`ParentContractTransaction`

`L1ToL2Message`

`ParentToChildMessage`

`L1ToL2MessageWriter`

`ParentToChildMessageWriter`

`L1ToL2MessageReader`

`ParentToChildMessageReader`

`L1ToL2MessageReaderClassic`

`ParentToChildMessageReaderClassic`

`L1ToL2MessageStatus`

`ParentToChildMessageStatus`

`L1ToL2MessageGasEstimator`

`ParentToChildMessageGasEstimator`

`L2TransactionReceipt`

`ChildTransactionReceipt`

`L2ContractTransaction`

`ChildContractTransaction`

`L2ToL1Message`

`ChildToParentMessage`

`L2ToL1MessageWriter`

`ChildToParentMessageWriter`

`L2ToL1MessageReader`

`ChildToParentMessageReader`

`L2ToL1MessageStatus`

`ChildToParentMessageStatus`

`EthDepositStatus`

`EthDepositMessageStatus`

`EthDepositMessageWaitResult`

`EthDepositMessageWaitForStatusResult`

`L1ToL2MessageWaitResult`

`ParentToChildMessageWaitForStatusResult`

#### `ChildToParentMessageClassic`[​](#childtoparentmessageclassic "Direct link to childtoparentmessageclassic")

v3 Name

v4 Name

`getL2ToL1Events`

`getChildToParentEvents`

#### `ChildToParentChainMessageNitro`[​](#childtoparentchainmessagenitro "Direct link to childtoparentchainmessagenitro")

v3 Name

v4 Name

`getL2ToL1Events`

`getChildToParentEvents`

#### `ChildTransactionReceipt`[​](#childtransactionreceipt "Direct link to childtransactionreceipt")

v3 Name

v4 Name

`getL2ToL1Events`

`getChildToParentEvents`

`getL2ToL1Messages`

`getChildToParentMessages`

#### `ParentToChildMessage`[​](#parenttochildmessage "Direct link to parenttochildmessage")

v3 Name

v4 Name

`EthDepositStatus`

`EthDepositMessageStatus`

#### `ParentToChildMessageStatus`[​](#parenttochildmessagestatus "Direct link to parenttochildmessagestatus")

v3 Name

v4 Name

`FUNDS_DEPOSITED_ON_L2`

`FUNDS_DEPOSITED_ON_CHILD`

#### `ParentTransactionReceipt`[​](#parenttransactionreceipt "Direct link to parenttransactionreceipt")

v3 Name

v4 Name

`getL1ToL2MessagesClassic`

`getParentToChildMessagesClassic`

`getL1ToL2Messages`

`getParentToChildMessages`

#### `ParentEthDepositTransactionReceipt`[​](#parentethdeposittransactionreceipt "Direct link to parentethdeposittransactionreceipt")

v3 Name

v4 Name

`waitForL2`

`waitForChildTransactionReceipt`

#### `ParentContractCallTransactionReceipt`[​](#parentcontractcalltransactionreceipt "Direct link to parentcontractcalltransactionreceipt")

v3 Name

v4 Name

`waitForL2`

`waitForChildTransactionReceipt`

---

# index | Arbitrum Docs

## index

Modules[​](#modules "Direct link to Modules")
---------------------------------------------

*   [assetBridger/assetBridger](/sdk/reference/assetBridger/)
*   [assetBridger/erc20Bridger](/sdk/reference/assetBridger/erc20Bridger)
*   [assetBridger/ethBridger](/sdk/reference/assetBridger/ethBridger)
*   [assetBridger/l1l3Bridger](/sdk/reference/assetBridger/l1l3Bridger)
*   [dataEntities/address](/sdk/reference/dataEntities/address)
*   [dataEntities/constants](/sdk/reference/dataEntities/constants)
*   [dataEntities/errors](/sdk/reference/dataEntities/errors)
*   [dataEntities/event](/sdk/reference/dataEntities/event)
*   [dataEntities/message](/sdk/reference/dataEntities/message)
*   [dataEntities/networks](/sdk/reference/dataEntities/networks)
*   [dataEntities/retryableData](/sdk/reference/dataEntities/retryableData)
*   [dataEntities/rpc](/sdk/reference/dataEntities/rpc)
*   [dataEntities/signerOrProvider](/sdk/reference/dataEntities/signerOrProvider)
*   [dataEntities/transactionRequest](/sdk/reference/dataEntities/transactionRequest)
*   [inbox/inbox](/sdk/reference/inbox/)
*   [message/ChildToParentMessage](/sdk/reference/message/ChildToParentMessage)
*   [message/ChildToParentMessageClassic](/sdk/reference/message/ChildToParentMessageClassic)
*   [message/ChildToParentMessageNitro](/sdk/reference/message/ChildToParentMessageNitro)
*   [message/ChildTransaction](/sdk/reference/message/ChildTransaction)
*   [message/ParentToChildMessage](/sdk/reference/message/ParentToChildMessage)
*   [message/ParentToChildMessageCreator](/sdk/reference/message/ParentToChildMessageCreator)
*   [message/ParentToChildMessageGasEstimator](/sdk/reference/message/ParentToChildMessageGasEstimator)
*   [message/ParentTransaction](/sdk/reference/message/ParentTransaction)
*   [utils/arbProvider](/sdk/reference/utils/arbProvider)
*   [utils/byte\_serialize\_params](/sdk/reference/utils/byte_serialize_params)
*   [utils/eventFetcher](/sdk/reference/utils/eventFetcher)
*   [utils/lib](/sdk/reference/utils/lib)
*   [utils/multicall](/sdk/reference/utils/multicall)
*   [utils/types](/sdk/reference/utils/types)

---

# assetBridger | Arbitrum Docs

## assetBridger

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### `abstract` AssetBridger<DepositParams, WithdrawParams>[​](#abstract-assetbridgerdepositparams-withdrawparams "Direct link to abstract-assetbridgerdepositparams-withdrawparams")

Base for bridging assets from parent-to-child and back

#### Extended by[​](#extended-by "Direct link to Extended by")

*   [`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger)
*   [`EthBridger`](/sdk/reference/assetBridger/ethBridger#ethbridger)

#### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`DepositParams`

`WithdrawParams`

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Description

`nativeToken?`

`readonly`

`string`

In case of a chain that uses ETH as its native/gas token, this is either `undefined` or the zero address  
  
In case of a chain that uses an ERC-20 token from the parent network as its native/gas token, this is the address of said token on the parent network

#### Accessors[​](#accessors "Direct link to Accessors")

##### nativeTokenIsEth[​](#nativetokeniseth "Direct link to nativeTokenIsEth")

```rust
get protected nativeTokenIsEth(): boolean
```

Whether the chain uses ETH as its native/gas token

###### Returns[​](#returns "Direct link to Returns")

`boolean`

###### Source[​](#source "Direct link to Source")

[assetBridger/assetBridger.ts:72](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L72)

#### Methods[​](#methods "Direct link to Methods")

##### checkChildNetwork()[​](#checkchildnetwork "Direct link to checkChildNetwork()")

```rust
protected checkChildNetwork(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the child network, throws if not

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-1 "Direct link to Returns")

`Promise`<`void`\>

###### Source[​](#source-1 "Direct link to Source")

[assetBridger/assetBridger.ts:61](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L61)

##### checkParentNetwork()[​](#checkparentnetwork "Direct link to checkParentNetwork()")

```rust
protected checkParentNetwork(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the parent network, throws if not

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`void`\>

###### Source[​](#source-2 "Direct link to Source")

[assetBridger/assetBridger.ts:50](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L50)

##### deposit()[​](#deposit "Direct link to deposit()")

```rust
abstract deposit(params: DepositParams): Promise<ParentContractTransaction<ParentTransactionReceipt>>
```

Transfer assets from parent-to-child

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`params`

`DepositParams`

###### Returns[​](#returns-3 "Direct link to Returns")

`Promise`<`ParentContractTransaction`<`ParentTransactionReceipt`\>>

###### Source[​](#source-3 "Direct link to Source")

[assetBridger/assetBridger.ts:80](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L80)

##### withdraw()[​](#withdraw "Direct link to withdraw()")

```rust
abstract withdraw(params: WithdrawParams): Promise<ChildContractTransaction>
```

Transfer assets from child-to-parent

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

Description

`params`

`WithdrawParams`

###### Returns[​](#returns-4 "Direct link to Returns")

`Promise`<`ChildContractTransaction`\>

###### Source[​](#source-4 "Direct link to Source")

[assetBridger/assetBridger.ts:88](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L88)

---

# erc20Bridger | Arbitrum Docs

## erc20Bridger

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### AdminErc20Bridger[​](#adminerc20bridger "Direct link to AdminErc20Bridger")

Admin functionality for the token bridge

#### Extends[​](#extends "Direct link to Extends")

*   [`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger)

#### Constructors[​](#constructors "Direct link to Constructors")

##### new AdminErc20Bridger()[​](#new-adminerc20bridger "Direct link to new AdminErc20Bridger()")

```rust
new AdminErc20Bridger(childNetwork: ArbitrumNetwork): AdminErc20Bridger
```

Bridger for moving ERC20 tokens back and forth between parent-to-child

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

`childNetwork`

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

###### Returns[​](#returns "Direct link to Returns")

[`AdminErc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#adminerc20bridger)

###### Inherited from[​](#inherited-from "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`constructor`](/sdk/reference/assetBridger/erc20Bridger#constructors-1)

###### Source[​](#source "Direct link to Source")

[assetBridger/erc20Bridger.ts:205](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L205)

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Description

Inherited from

`nativeToken?`

`readonly`

`string`

In case of a chain that uses ETH as its native/gas token, this is either `undefined` or the zero address  
  
In case of a chain that uses an ERC-20 token from the parent network as its native/gas token, this is the address of said token on the parent network

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger).`nativeToken`

#### Accessors[​](#accessors "Direct link to Accessors")

##### nativeTokenIsEth[​](#nativetokeniseth "Direct link to nativeTokenIsEth")

```rust
get protected nativeTokenIsEth(): boolean
```

Whether the chain uses ETH as its native/gas token

###### Returns[​](#returns-1 "Direct link to Returns")

`boolean`

###### Source[​](#source-1 "Direct link to Source")

[assetBridger/assetBridger.ts:72](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L72)

#### Methods[​](#methods "Direct link to Methods")

##### approveGasToken()[​](#approvegastoken "Direct link to approveGasToken()")

```rust
approveGasToken(params: ApproveParamsOrTxRequest): Promise<ContractTransaction>
```

Approves the custom gas token to be spent by the relevant gateway on the parent network

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ApproveParamsOrTxRequest`

###### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`ContractTransaction`\>

###### Inherited from[​](#inherited-from-1 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`approveGasToken`](/sdk/reference/assetBridger/erc20Bridger#approvegastoken-1)

###### Source[​](#source-2 "Direct link to Source")

[assetBridger/erc20Bridger.ts:276](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L276)

##### approveToken()[​](#approvetoken "Direct link to approveToken()")

```rust
approveToken(params: ApproveParamsOrTxRequest): Promise<ContractTransaction>
```

Approve tokens for deposit to the bridge. The tokens will be approved for the relevant gateway.

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ApproveParamsOrTxRequest`

###### Returns[​](#returns-3 "Direct link to Returns")

`Promise`<`ContractTransaction`\>

###### Inherited from[​](#inherited-from-2 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`approveToken`](/sdk/reference/assetBridger/erc20Bridger#approvetoken-1)

###### Source[​](#source-3 "Direct link to Source")

[assetBridger/erc20Bridger.ts:339](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L339)

##### checkChildNetwork()[​](#checkchildnetwork "Direct link to checkChildNetwork()")

```rust
protected checkChildNetwork(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the child network, throws if not

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-4 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from-3 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`checkChildNetwork`](/sdk/reference/assetBridger/erc20Bridger#checkchildnetwork-1)

###### Source[​](#source-4 "Direct link to Source")

[assetBridger/assetBridger.ts:61](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L61)

##### checkParentNetwork()[​](#checkparentnetwork "Direct link to checkParentNetwork()")

```rust
protected checkParentNetwork(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the parent network, throws if not

###### Parameters[​](#parameters-4 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-5 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from-4 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`checkParentNetwork`](/sdk/reference/assetBridger/erc20Bridger#checkparentnetwork-1)

###### Source[​](#source-5 "Direct link to Source")

[assetBridger/assetBridger.ts:50](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L50)

##### deposit()[​](#deposit "Direct link to deposit()")

```rust
deposit(params: Erc20DepositParams | ParentToChildTxReqAndSignerProvider): Promise<ParentContractCallTransaction>
```

Execute a token deposit from parent to child network

###### Parameters[​](#parameters-5 "Direct link to Parameters")

Parameter

Type

Description

`params`

`Erc20DepositParams` | `ParentToChildTxReqAndSignerProvider`

###### Returns[​](#returns-6 "Direct link to Returns")

`Promise`<`ParentContractCallTransaction`\>

###### Inherited from[​](#inherited-from-5 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`deposit`](/sdk/reference/assetBridger/erc20Bridger#deposit-1)

###### Source[​](#source-6 "Direct link to Source")

[assetBridger/erc20Bridger.ts:769](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L769)

##### getApproveGasTokenRequest()[​](#getapprovegastokenrequest "Direct link to getApproveGasTokenRequest()")

```rust
getApproveGasTokenRequest(params: ProviderTokenApproveParams): Promise<Required<Pick<TransactionRequest, "data" | "value" | "to">>>
```

Creates a transaction request for approving the custom gas token to be spent by the relevant gateway on the parent network

###### Parameters[​](#parameters-6 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ProviderTokenApproveParams`

###### Returns[​](#returns-7 "Direct link to Returns")

`Promise`<`Required`<`Pick`<`TransactionRequest`, `"data"` | `"value"` | `"to"`\>>>

###### Inherited from[​](#inherited-from-6 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getApproveGasTokenRequest`](/sdk/reference/assetBridger/erc20Bridger#getapprovegastokenrequest-1)

###### Source[​](#source-7 "Direct link to Source")

[assetBridger/erc20Bridger.ts:260](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L260)

##### getApproveTokenRequest()[​](#getapprovetokenrequest "Direct link to getApproveTokenRequest()")

```rust
getApproveTokenRequest(params: ProviderTokenApproveParams): Promise<Required<Pick<TransactionRequest, "data" | "value" | "to">>>
```

Get a tx request to approve tokens for deposit to the bridge. The tokens will be approved for the relevant gateway.

###### Parameters[​](#parameters-7 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ProviderTokenApproveParams`

###### Returns[​](#returns-8 "Direct link to Returns")

`Promise`<`Required`<`Pick`<`TransactionRequest`, `"data"` | `"value"` | `"to"`\>>>

###### Inherited from[​](#inherited-from-7 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getApproveTokenRequest`](/sdk/reference/assetBridger/erc20Bridger#getapprovetokenrequest-1)

###### Source[​](#source-8 "Direct link to Source")

[assetBridger/erc20Bridger.ts:306](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L306)

##### getChildErc20Address()[​](#getchilderc20address "Direct link to getChildErc20Address()")

```rust
getChildErc20Address(erc20ParentAddress: string, parentProvider: Provider): Promise<string>
```

Get the corresponding child network token address for the provided parent network token

###### Parameters[​](#parameters-8 "Direct link to Parameters")

Parameter

Type

Description

`erc20ParentAddress`

`string`

`parentProvider`

`Provider`

###### Returns[​](#returns-9 "Direct link to Returns")

`Promise`<`string`\>

###### Inherited from[​](#inherited-from-8 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getChildErc20Address`](/sdk/reference/assetBridger/erc20Bridger#getchilderc20address-1)

###### Source[​](#source-9 "Direct link to Source")

[assetBridger/erc20Bridger.ts:491](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L491)

##### getChildGatewayAddress()[​](#getchildgatewayaddress "Direct link to getChildGatewayAddress()")

```rust
getChildGatewayAddress(erc20ParentAddress: string, childProvider: Provider): Promise<string>
```

Get the address of the child gateway for this token

###### Parameters[​](#parameters-9 "Direct link to Parameters")

Parameter

Type

Description

`erc20ParentAddress`

`string`

`childProvider`

`Provider`

###### Returns[​](#returns-10 "Direct link to Returns")

`Promise`<`string`\>

###### Inherited from[​](#inherited-from-9 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getChildGatewayAddress`](/sdk/reference/assetBridger/erc20Bridger#getchildgatewayaddress-1)

###### Source[​](#source-10 "Direct link to Source")

[assetBridger/erc20Bridger.ts:244](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L244)

##### getChildGatewaySetEvents()[​](#getchildgatewaysetevents "Direct link to getChildGatewaySetEvents()")

```rust
getChildGatewaySetEvents(
   childProvider: Provider, 
   filter: object, 
customNetworkChildGatewayRouter?: string): Promise<object[]>
```

Get all the gateway set events on the child gateway router

###### Parameters[​](#parameters-10 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

The provider for the child network

`filter`

`object`

An object containing fromBlock and toBlock to filter events

`filter.fromBlock`

`BlockTag`

\-

`filter.toBlock`?

`BlockTag`

\-

`customNetworkChildGatewayRouter`?

`string`

Optional address of the custom network child gateway router

###### Returns[​](#returns-11 "Direct link to Returns")

`Promise`<`object`\[\]>

An array of GatewaySetEvent event arguments

###### Throws[​](#throws "Direct link to Throws")

If the network is custom and customNetworkChildGatewayRouter is not provided

###### Source[​](#source-11 "Direct link to Source")

[assetBridger/erc20Bridger.ts:1233](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L1233)

##### getChildTokenContract()[​](#getchildtokencontract "Direct link to getChildTokenContract()")

```rust
getChildTokenContract(childProvider: Provider, childTokenAddr: string): L2GatewayToken
```

Get the child network token contract at the provided address Note: This function just returns a typed ethers object for the provided address, it doesn't check the underlying form of the contract bytecode to see if it's an erc20, and doesn't ensure the validity of any of the underlying functions on that contract.

###### Parameters[​](#parameters-11 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`childTokenAddr`

`string`

###### Returns[​](#returns-12 "Direct link to Returns")

`L2GatewayToken`

###### Inherited from[​](#inherited-from-10 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getChildTokenContract`](/sdk/reference/assetBridger/erc20Bridger#getchildtokencontract-1)

###### Source[​](#source-12 "Direct link to Source")

[assetBridger/erc20Bridger.ts:462](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L462)

##### getDepositRequest()[​](#getdepositrequest "Direct link to getDepositRequest()")

```rust
getDepositRequest(params: DepositRequest): Promise<ParentToChildTransactionRequest>
```

Get the arguments for calling the deposit function

###### Parameters[​](#parameters-12 "Direct link to Parameters")

Parameter

Type

Description

`params`

`DepositRequest`

###### Returns[​](#returns-13 "Direct link to Returns")

`Promise` <[`ParentToChildTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#parenttochildtransactionrequest)\>

###### Inherited from[​](#inherited-from-11 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getDepositRequest`](/sdk/reference/assetBridger/erc20Bridger#getdepositrequest-1)

###### Source[​](#source-13 "Direct link to Source")

[assetBridger/erc20Bridger.ts:655](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L655)

##### getParentErc20Address()[​](#getparenterc20address "Direct link to getParentErc20Address()")

```rust
getParentErc20Address(erc20ChildChainAddress: string, childProvider: Provider): Promise<string>
```

Get the corresponding parent network address for the provided child network token Validates the returned address against the child network router to ensure it is correctly mapped to the provided erc20ChildChainAddress

###### Parameters[​](#parameters-13 "Direct link to Parameters")

Parameter

Type

Description

`erc20ChildChainAddress`

`string`

`childProvider`

`Provider`

###### Returns[​](#returns-14 "Direct link to Returns")

`Promise`<`string`\>

###### Inherited from[​](#inherited-from-12 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getParentErc20Address`](/sdk/reference/assetBridger/erc20Bridger#getparenterc20address-1)

###### Source[​](#source-14 "Direct link to Source")

[assetBridger/erc20Bridger.ts:514](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L514)

##### getParentGatewayAddress()[​](#getparentgatewayaddress "Direct link to getParentGatewayAddress()")

```rust
getParentGatewayAddress(erc20ParentAddress: string, parentProvider: Provider): Promise<string>
```

Get the address of the parent gateway for this token

###### Parameters[​](#parameters-14 "Direct link to Parameters")

Parameter

Type

Description

`erc20ParentAddress`

`string`

`parentProvider`

`Provider`

###### Returns[​](#returns-15 "Direct link to Returns")

`Promise`<`string`\>

###### Inherited from[​](#inherited-from-13 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getParentGatewayAddress`](/sdk/reference/assetBridger/erc20Bridger#getparentgatewayaddress-1)

###### Source[​](#source-15 "Direct link to Source")

[assetBridger/erc20Bridger.ts:226](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L226)

##### getParentGatewaySetEvents()[​](#getparentgatewaysetevents "Direct link to getParentGatewaySetEvents()")

```rust
getParentGatewaySetEvents(parentProvider: Provider, filter: object): Promise<object[]>
```

Get all the gateway set events on the Parent gateway router

###### Parameters[​](#parameters-15 "Direct link to Parameters")

Parameter

Type

Description

`parentProvider`

`Provider`

The provider for the parent network

`filter`

`object`

An object containing fromBlock and toBlock to filter events

`filter.fromBlock`

`BlockTag`

\-

`filter.toBlock`

`BlockTag`

\-

###### Returns[​](#returns-16 "Direct link to Returns")

`Promise`<`object`\[\]>

An array of GatewaySetEvent event arguments

###### Source[​](#source-16 "Direct link to Source")

[assetBridger/erc20Bridger.ts:1207](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L1207)

##### getParentTokenContract()[​](#getparenttokencontract "Direct link to getParentTokenContract()")

```rust
getParentTokenContract(parentProvider: Provider, parentTokenAddr: string): ERC20
```

Get the parent token contract at the provided address Note: This function just returns a typed ethers object for the provided address, it doesnt check the underlying form of the contract bytecode to see if it's an erc20, and doesn't ensure the validity of any of the underlying functions on that contract.

###### Parameters[​](#parameters-16 "Direct link to Parameters")

Parameter

Type

Description

`parentProvider`

`Provider`

`parentTokenAddr`

`string`

###### Returns[​](#returns-17 "Direct link to Returns")

`ERC20`

###### Inherited from[​](#inherited-from-14 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getParentTokenContract`](/sdk/reference/assetBridger/erc20Bridger#getparenttokencontract-1)

###### Source[​](#source-17 "Direct link to Source")

[assetBridger/erc20Bridger.ts:478](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L478)

##### getWithdrawalEvents()[​](#getwithdrawalevents "Direct link to getWithdrawalEvents()")

```rust
getWithdrawalEvents(
   childProvider: Provider, 
   gatewayAddress: string, 
   filter: object, 
   parentTokenAddress?: string, 
   fromAddress?: string, 
toAddress?: string): Promise<object & object[]>
```

Get the child network events created by a withdrawal

###### Parameters[​](#parameters-17 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`gatewayAddress`

`string`

`filter`

`object`

`filter.fromBlock`

`BlockTag`

\-

`filter.toBlock`?

`BlockTag`

\-

`parentTokenAddress`?

`string`

`fromAddress`?

`string`

`toAddress`?

`string`

\-

###### Returns[​](#returns-18 "Direct link to Returns")

`Promise`<`object` & `object`\[\]>

###### Inherited from[​](#inherited-from-15 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getWithdrawalEvents`](/sdk/reference/assetBridger/erc20Bridger#getwithdrawalevents-1)

###### Source[​](#source-18 "Direct link to Source")

[assetBridger/erc20Bridger.ts:367](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L367)

##### getWithdrawalRequest()[​](#getwithdrawalrequest "Direct link to getWithdrawalRequest()")

```rust
getWithdrawalRequest(params: Erc20WithdrawParams): Promise<ChildToParentTransactionRequest>
```

Get the arguments for calling the token withdrawal function

###### Parameters[​](#parameters-18 "Direct link to Parameters")

Parameter

Type

Description

`params`

`Erc20WithdrawParams`

###### Returns[​](#returns-19 "Direct link to Returns")

`Promise` <[`ChildToParentTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#childtoparenttransactionrequest)\>

###### Inherited from[​](#inherited-from-16 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`getWithdrawalRequest`](/sdk/reference/assetBridger/erc20Bridger#getwithdrawalrequest-1)

###### Source[​](#source-19 "Direct link to Source")

[assetBridger/erc20Bridger.ts:826](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L826)

##### isDepositDisabled()[​](#isdepositdisabled "Direct link to isDepositDisabled()")

```rust
isDepositDisabled(parentTokenAddress: string, parentProvider: Provider): Promise<boolean>
```

Whether the token has been disabled on the router

###### Parameters[​](#parameters-19 "Direct link to Parameters")

Parameter

Type

Description

`parentTokenAddress`

`string`

`parentProvider`

`Provider`

###### Returns[​](#returns-20 "Direct link to Returns")

`Promise`<`boolean`\>

###### Inherited from[​](#inherited-from-17 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`isDepositDisabled`](/sdk/reference/assetBridger/erc20Bridger#isdepositdisabled-1)

###### Source[​](#source-20 "Direct link to Source")

[assetBridger/erc20Bridger.ts:560](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L560)

##### isRegistered()[​](#isregistered "Direct link to isRegistered()")

```rust
isRegistered(params: object): Promise<boolean>
```

Checks if the token has been properly registered on both gateways. Mostly useful for tokens that use a custom gateway.

###### Parameters[​](#parameters-20 "Direct link to Parameters")

Parameter

Type

Description

`params`

`object`

`params.childProvider`

`Provider`

`params.erc20ParentAddress`

`string`

`params.parentProvider`

`Provider`

###### Returns[​](#returns-21 "Direct link to Returns")

`Promise`<`boolean`\>

###### Inherited from[​](#inherited-from-18 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`isRegistered`](/sdk/reference/assetBridger/erc20Bridger#isregistered-1)

###### Source[​](#source-21 "Direct link to Source")

[assetBridger/erc20Bridger.ts:924](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L924)

##### registerCustomToken()[​](#registercustomtoken "Direct link to registerCustomToken()")

```rust
registerCustomToken(
   parentTokenAddress: string, 
   childTokenAddress: string, 
   parentSigner: Signer, 
childProvider: Provider): Promise<ParentContractTransaction<ParentTransactionReceipt>>
```

Register a custom token on the Arbitrum bridge See [https://developer.offchainlabs.com/docs/bridging\_assets#the-arbitrum-generic-custom-gateway](https://developer.offchainlabs.com/docs/bridging_assets#the-arbitrum-generic-custom-gateway) for more details

###### Parameters[​](#parameters-21 "Direct link to Parameters")

Parameter

Type

Description

`parentTokenAddress`

`string`

Address of the already deployed parent token. Must inherit from [https://developer.offchainlabs.com/docs/sol\_contract\_docs/md\_docs/arb-bridge-peripherals/tokenbridge/ethereum/icustomtoken](https://developer.offchainlabs.com/docs/sol_contract_docs/md_docs/arb-bridge-peripherals/tokenbridge/ethereum/icustomtoken).

`childTokenAddress`

`string`

Address of the already deployed child token. Must inherit from [https://developer.offchainlabs.com/docs/sol\_contract\_docs/md\_docs/arb-bridge-peripherals/tokenbridge/arbitrum/iarbtoken](https://developer.offchainlabs.com/docs/sol_contract_docs/md_docs/arb-bridge-peripherals/tokenbridge/arbitrum/iarbtoken).

`parentSigner`

`Signer`

The signer with the rights to call `registerTokenOnL2` on the parent token

`childProvider`

`Provider`

Arbitrum rpc provider

###### Returns[​](#returns-22 "Direct link to Returns")

`Promise`<`ParentContractTransaction`<`ParentTransactionReceipt`\>>

###### Source[​](#source-22 "Direct link to Source")

[assetBridger/erc20Bridger.ts:1035](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L1035)

##### setGateways()[​](#setgateways "Direct link to setGateways()")

```rust
setGateways(
   parentSigner: Signer, 
   childProvider: Provider, 
   tokenGateways: TokenAndGateway[], 
options?: GasOverrides): Promise<ParentContractCallTransaction>
```

Register the provided token addresses against the provided gateways

###### Parameters[​](#parameters-22 "Direct link to Parameters")

Parameter

Type

Description

`parentSigner`

`Signer`

`childProvider`

`Provider`

`tokenGateways`

`TokenAndGateway`\[\]

`options`?

`GasOverrides`

\-

###### Returns[​](#returns-23 "Direct link to Returns")

`Promise`<`ParentContractCallTransaction`\>

###### Source[​](#source-23 "Direct link to Source")

[assetBridger/erc20Bridger.ts:1266](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L1266)

##### withdraw()[​](#withdraw "Direct link to withdraw()")

```rust
withdraw(params: ChildToParentTxReqAndSigner | OmitTyped<Erc20WithdrawParams, "from"> & object): Promise<ChildContractTransaction>
```

Withdraw tokens from child to parent network

###### Parameters[​](#parameters-23 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ChildToParentTxReqAndSigner` | [`OmitTyped`](/sdk/reference/utils/types#omittypedtk)<`Erc20WithdrawParams`, `"from"`\> & `object`

###### Returns[​](#returns-24 "Direct link to Returns")

`Promise`<`ChildContractTransaction`\>

###### Inherited from[​](#inherited-from-19 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`withdraw`](/sdk/reference/assetBridger/erc20Bridger#withdraw-1)

###### Source[​](#source-24 "Direct link to Source")

[assetBridger/erc20Bridger.ts:889](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L889)

##### fromProvider()[​](#fromprovider "Direct link to fromProvider()")

```rust
static fromProvider(childProvider: Provider): Promise<Erc20Bridger>
```

Instantiates a new Erc20Bridger from a child provider

###### Parameters[​](#parameters-24 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-25 "Direct link to Returns")

`Promise` <[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger)\>

###### Inherited from[​](#inherited-from-20 "Direct link to Inherited from")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger) . [`fromProvider`](/sdk/reference/assetBridger/erc20Bridger#fromprovider-1)

###### Source[​](#source-25 "Direct link to Source")

[assetBridger/erc20Bridger.ts:216](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L216)

* * *

### Erc20Bridger[​](#erc20bridger "Direct link to Erc20Bridger")

Bridger for moving ERC20 tokens back and forth between parent-to-child

#### Extends[​](#extends-1 "Direct link to Extends")

*   [`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams)<`Erc20DepositParams` | `ParentToChildTxReqAndSignerProvider`, [`OmitTyped`](/sdk/reference/utils/types#omittypedtk)<`Erc20WithdrawParams`, `"from"`\> | [`ChildToParentTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#childtoparenttransactionrequest)\>

#### Extended by[​](#extended-by "Direct link to Extended by")

*   [`AdminErc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#adminerc20bridger)

#### Constructors[​](#constructors-1 "Direct link to Constructors")

##### new Erc20Bridger()[​](#new-erc20bridger "Direct link to new Erc20Bridger()")

```rust
new Erc20Bridger(childNetwork: ArbitrumNetwork): Erc20Bridger
```

Bridger for moving ERC20 tokens back and forth between parent-to-child

###### Parameters[​](#parameters-25 "Direct link to Parameters")

Parameter

Type

`childNetwork`

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

###### Returns[​](#returns-26 "Direct link to Returns")

[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger)

###### Overrides[​](#overrides "Direct link to Overrides")

AssetBridger< Erc20DepositParams | ParentToChildTxReqAndSignerProvider, OmitTyped<Erc20WithdrawParams, 'from'> | ChildToParentTransactionRequest >.constructor

###### Source[​](#source-26 "Direct link to Source")

[assetBridger/erc20Bridger.ts:205](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L205)

#### Properties[​](#properties-1 "Direct link to Properties")

Property

Modifier

Type

Description

Inherited from

`nativeToken?`

`readonly`

`string`

In case of a chain that uses ETH as its native/gas token, this is either `undefined` or the zero address  
  
In case of a chain that uses an ERC-20 token from the parent network as its native/gas token, this is the address of said token on the parent network

[`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams).`nativeToken`

#### Accessors[​](#accessors-1 "Direct link to Accessors")

##### nativeTokenIsEth[​](#nativetokeniseth-1 "Direct link to nativeTokenIsEth")

```rust
get protected nativeTokenIsEth(): boolean
```

Whether the chain uses ETH as its native/gas token

###### Returns[​](#returns-27 "Direct link to Returns")

`boolean`

###### Source[​](#source-27 "Direct link to Source")

[assetBridger/assetBridger.ts:72](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L72)

#### Methods[​](#methods-1 "Direct link to Methods")

##### approveGasToken()[​](#approvegastoken-1 "Direct link to approveGasToken()")

```rust
approveGasToken(params: ApproveParamsOrTxRequest): Promise<ContractTransaction>
```

Approves the custom gas token to be spent by the relevant gateway on the parent network

###### Parameters[​](#parameters-26 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ApproveParamsOrTxRequest`

###### Returns[​](#returns-28 "Direct link to Returns")

`Promise`<`ContractTransaction`\>

###### Source[​](#source-28 "Direct link to Source")

[assetBridger/erc20Bridger.ts:276](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L276)

##### approveToken()[​](#approvetoken-1 "Direct link to approveToken()")

```rust
approveToken(params: ApproveParamsOrTxRequest): Promise<ContractTransaction>
```

Approve tokens for deposit to the bridge. The tokens will be approved for the relevant gateway.

###### Parameters[​](#parameters-27 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ApproveParamsOrTxRequest`

###### Returns[​](#returns-29 "Direct link to Returns")

`Promise`<`ContractTransaction`\>

###### Source[​](#source-29 "Direct link to Source")

[assetBridger/erc20Bridger.ts:339](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L339)

##### checkChildNetwork()[​](#checkchildnetwork-1 "Direct link to checkChildNetwork()")

```rust
protected checkChildNetwork(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the child network, throws if not

###### Parameters[​](#parameters-28 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-30 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from-21 "Direct link to Inherited from")

[`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams) . [`checkChildNetwork`](/sdk/reference/assetBridger/#checkchildnetwork)

###### Source[​](#source-30 "Direct link to Source")

[assetBridger/assetBridger.ts:61](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L61)

##### checkParentNetwork()[​](#checkparentnetwork-1 "Direct link to checkParentNetwork()")

```rust
protected checkParentNetwork(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the parent network, throws if not

###### Parameters[​](#parameters-29 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-31 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from-22 "Direct link to Inherited from")

[`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams) . [`checkParentNetwork`](/sdk/reference/assetBridger/#checkparentnetwork)

###### Source[​](#source-31 "Direct link to Source")

[assetBridger/assetBridger.ts:50](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L50)

##### deposit()[​](#deposit-1 "Direct link to deposit()")

```rust
deposit(params: Erc20DepositParams | ParentToChildTxReqAndSignerProvider): Promise<ParentContractCallTransaction>
```

Execute a token deposit from parent to child network

###### Parameters[​](#parameters-30 "Direct link to Parameters")

Parameter

Type

Description

`params`

`Erc20DepositParams` | `ParentToChildTxReqAndSignerProvider`

###### Returns[​](#returns-32 "Direct link to Returns")

`Promise`<`ParentContractCallTransaction`\>

###### Overrides[​](#overrides-1 "Direct link to Overrides")

[`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams) . [`deposit`](/sdk/reference/assetBridger/#deposit)

###### Source[​](#source-32 "Direct link to Source")

[assetBridger/erc20Bridger.ts:769](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L769)

##### getApproveGasTokenRequest()[​](#getapprovegastokenrequest-1 "Direct link to getApproveGasTokenRequest()")

```rust
getApproveGasTokenRequest(params: ProviderTokenApproveParams): Promise<Required<Pick<TransactionRequest, "data" | "value" | "to">>>
```

Creates a transaction request for approving the custom gas token to be spent by the relevant gateway on the parent network

###### Parameters[​](#parameters-31 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ProviderTokenApproveParams`

###### Returns[​](#returns-33 "Direct link to Returns")

`Promise`<`Required`<`Pick`<`TransactionRequest`, `"data"` | `"value"` | `"to"`\>>>

###### Source[​](#source-33 "Direct link to Source")

[assetBridger/erc20Bridger.ts:260](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L260)

##### getApproveTokenRequest()[​](#getapprovetokenrequest-1 "Direct link to getApproveTokenRequest()")

```rust
getApproveTokenRequest(params: ProviderTokenApproveParams): Promise<Required<Pick<TransactionRequest, "data" | "value" | "to">>>
```

Get a tx request to approve tokens for deposit to the bridge. The tokens will be approved for the relevant gateway.

###### Parameters[​](#parameters-32 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ProviderTokenApproveParams`

###### Returns[​](#returns-34 "Direct link to Returns")

`Promise`<`Required`<`Pick`<`TransactionRequest`, `"data"` | `"value"` | `"to"`\>>>

###### Source[​](#source-34 "Direct link to Source")

[assetBridger/erc20Bridger.ts:306](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L306)

##### getChildErc20Address()[​](#getchilderc20address-1 "Direct link to getChildErc20Address()")

```rust
getChildErc20Address(erc20ParentAddress: string, parentProvider: Provider): Promise<string>
```

Get the corresponding child network token address for the provided parent network token

###### Parameters[​](#parameters-33 "Direct link to Parameters")

Parameter

Type

Description

`erc20ParentAddress`

`string`

`parentProvider`

`Provider`

###### Returns[​](#returns-35 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-35 "Direct link to Source")

[assetBridger/erc20Bridger.ts:491](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L491)

##### getChildGatewayAddress()[​](#getchildgatewayaddress-1 "Direct link to getChildGatewayAddress()")

```rust
getChildGatewayAddress(erc20ParentAddress: string, childProvider: Provider): Promise<string>
```

Get the address of the child gateway for this token

###### Parameters[​](#parameters-34 "Direct link to Parameters")

Parameter

Type

Description

`erc20ParentAddress`

`string`

`childProvider`

`Provider`

###### Returns[​](#returns-36 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-36 "Direct link to Source")

[assetBridger/erc20Bridger.ts:244](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L244)

##### getChildTokenContract()[​](#getchildtokencontract-1 "Direct link to getChildTokenContract()")

```rust
getChildTokenContract(childProvider: Provider, childTokenAddr: string): L2GatewayToken
```

Get the child network token contract at the provided address Note: This function just returns a typed ethers object for the provided address, it doesn't check the underlying form of the contract bytecode to see if it's an erc20, and doesn't ensure the validity of any of the underlying functions on that contract.

###### Parameters[​](#parameters-35 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`childTokenAddr`

`string`

###### Returns[​](#returns-37 "Direct link to Returns")

`L2GatewayToken`

###### Source[​](#source-37 "Direct link to Source")

[assetBridger/erc20Bridger.ts:462](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L462)

##### getDepositRequest()[​](#getdepositrequest-1 "Direct link to getDepositRequest()")

```rust
getDepositRequest(params: DepositRequest): Promise<ParentToChildTransactionRequest>
```

Get the arguments for calling the deposit function

###### Parameters[​](#parameters-36 "Direct link to Parameters")

Parameter

Type

Description

`params`

`DepositRequest`

###### Returns[​](#returns-38 "Direct link to Returns")

`Promise` <[`ParentToChildTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#parenttochildtransactionrequest)\>

###### Source[​](#source-38 "Direct link to Source")

[assetBridger/erc20Bridger.ts:655](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L655)

##### getDepositRequestCallValue()[​](#getdepositrequestcallvalue "Direct link to getDepositRequestCallValue()")

```rust
private getDepositRequestCallValue(depositParams: OmitTyped<ParentToChildMessageGasParams, "deposit">): BigNumber | BigNumber
```

Get the call value for the deposit transaction request

###### Parameters[​](#parameters-37 "Direct link to Parameters")

Parameter

Type

Description

`depositParams`

[`OmitTyped`](/sdk/reference/utils/types#omittypedtk)<`ParentToChildMessageGasParams`, `"deposit"`\>

###### Returns[​](#returns-39 "Direct link to Returns")

`BigNumber` | `BigNumber`

###### Source[​](#source-39 "Direct link to Source")

[assetBridger/erc20Bridger.ts:593](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L593)

##### getDepositRequestOutboundTransferInnerData()[​](#getdepositrequestoutboundtransferinnerdata "Direct link to getDepositRequestOutboundTransferInnerData()")

```rust
private getDepositRequestOutboundTransferInnerData(depositParams: OmitTyped<ParentToChildMessageGasParams, "deposit">, decimals: number): string
```

Get the `data` param for call to `outboundTransfer`

###### Parameters[​](#parameters-38 "Direct link to Parameters")

Parameter

Type

Description

`depositParams`

[`OmitTyped`](/sdk/reference/utils/types#omittypedtk)<`ParentToChildMessageGasParams`, `"deposit"`\>

`decimals`

`number`

\-

###### Returns[​](#returns-40 "Direct link to Returns")

`string`

###### Source[​](#source-40 "Direct link to Source")

[assetBridger/erc20Bridger.ts:616](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L616)

##### getParentErc20Address()[​](#getparenterc20address-1 "Direct link to getParentErc20Address()")

```rust
getParentErc20Address(erc20ChildChainAddress: string, childProvider: Provider): Promise<string>
```

Get the corresponding parent network address for the provided child network token Validates the returned address against the child network router to ensure it is correctly mapped to the provided erc20ChildChainAddress

###### Parameters[​](#parameters-39 "Direct link to Parameters")

Parameter

Type

Description

`erc20ChildChainAddress`

`string`

`childProvider`

`Provider`

###### Returns[​](#returns-41 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-41 "Direct link to Source")

[assetBridger/erc20Bridger.ts:514](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L514)

##### getParentGatewayAddress()[​](#getparentgatewayaddress-1 "Direct link to getParentGatewayAddress()")

```rust
getParentGatewayAddress(erc20ParentAddress: string, parentProvider: Provider): Promise<string>
```

Get the address of the parent gateway for this token

###### Parameters[​](#parameters-40 "Direct link to Parameters")

Parameter

Type

Description

`erc20ParentAddress`

`string`

`parentProvider`

`Provider`

###### Returns[​](#returns-42 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-42 "Direct link to Source")

[assetBridger/erc20Bridger.ts:226](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L226)

##### getParentTokenContract()[​](#getparenttokencontract-1 "Direct link to getParentTokenContract()")

```rust
getParentTokenContract(parentProvider: Provider, parentTokenAddr: string): ERC20
```

Get the parent token contract at the provided address Note: This function just returns a typed ethers object for the provided address, it doesnt check the underlying form of the contract bytecode to see if it's an erc20, and doesn't ensure the validity of any of the underlying functions on that contract.

###### Parameters[​](#parameters-41 "Direct link to Parameters")

Parameter

Type

Description

`parentProvider`

`Provider`

`parentTokenAddr`

`string`

###### Returns[​](#returns-43 "Direct link to Returns")

`ERC20`

###### Source[​](#source-43 "Direct link to Source")

[assetBridger/erc20Bridger.ts:478](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L478)

##### getWithdrawalEvents()[​](#getwithdrawalevents-1 "Direct link to getWithdrawalEvents()")

```rust
getWithdrawalEvents(
   childProvider: Provider, 
   gatewayAddress: string, 
   filter: object, 
   parentTokenAddress?: string, 
   fromAddress?: string, 
toAddress?: string): Promise<object & object[]>
```

Get the child network events created by a withdrawal

###### Parameters[​](#parameters-42 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`gatewayAddress`

`string`

`filter`

`object`

`filter.fromBlock`

`BlockTag`

\-

`filter.toBlock`?

`BlockTag`

\-

`parentTokenAddress`?

`string`

`fromAddress`?

`string`

`toAddress`?

`string`

\-

###### Returns[​](#returns-44 "Direct link to Returns")

`Promise`<`object` & `object`\[\]>

###### Source[​](#source-44 "Direct link to Source")

[assetBridger/erc20Bridger.ts:367](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L367)

##### getWithdrawalRequest()[​](#getwithdrawalrequest-1 "Direct link to getWithdrawalRequest()")

```rust
getWithdrawalRequest(params: Erc20WithdrawParams): Promise<ChildToParentTransactionRequest>
```

Get the arguments for calling the token withdrawal function

###### Parameters[​](#parameters-43 "Direct link to Parameters")

Parameter

Type

Description

`params`

`Erc20WithdrawParams`

###### Returns[​](#returns-45 "Direct link to Returns")

`Promise` <[`ChildToParentTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#childtoparenttransactionrequest)\>

###### Source[​](#source-45 "Direct link to Source")

[assetBridger/erc20Bridger.ts:826](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L826)

##### isDepositDisabled()[​](#isdepositdisabled-1 "Direct link to isDepositDisabled()")

```rust
isDepositDisabled(parentTokenAddress: string, parentProvider: Provider): Promise<boolean>
```

Whether the token has been disabled on the router

###### Parameters[​](#parameters-44 "Direct link to Parameters")

Parameter

Type

Description

`parentTokenAddress`

`string`

`parentProvider`

`Provider`

###### Returns[​](#returns-46 "Direct link to Returns")

`Promise`<`boolean`\>

###### Source[​](#source-46 "Direct link to Source")

[assetBridger/erc20Bridger.ts:560](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L560)

##### isRegistered()[​](#isregistered-1 "Direct link to isRegistered()")

```rust
isRegistered(params: object): Promise<boolean>
```

Checks if the token has been properly registered on both gateways. Mostly useful for tokens that use a custom gateway.

###### Parameters[​](#parameters-45 "Direct link to Parameters")

Parameter

Type

Description

`params`

`object`

`params.childProvider`

`Provider`

`params.erc20ParentAddress`

`string`

`params.parentProvider`

`Provider`

###### Returns[​](#returns-47 "Direct link to Returns")

`Promise`<`boolean`\>

###### Source[​](#source-47 "Direct link to Source")

[assetBridger/erc20Bridger.ts:924](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L924)

##### isWethGateway()[​](#iswethgateway "Direct link to isWethGateway()")

```rust
private isWethGateway(gatewayAddress: string, parentProvider: Provider): Promise<boolean>
```

Is this a known or unknown WETH gateway

###### Parameters[​](#parameters-46 "Direct link to Parameters")

Parameter

Type

Description

`gatewayAddress`

`string`

`parentProvider`

`Provider`

###### Returns[​](#returns-48 "Direct link to Returns")

`Promise`<`boolean`\>

###### Source[​](#source-48 "Direct link to Source")

[assetBridger/erc20Bridger.ts:436](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L436)

##### looksLikeWethGateway()[​](#lookslikewethgateway "Direct link to looksLikeWethGateway()")

```rust
private looksLikeWethGateway(potentialWethGatewayAddress: string, parentProvider: Provider): Promise<boolean>
```

Does the provided address look like a weth gateway

###### Parameters[​](#parameters-47 "Direct link to Parameters")

Parameter

Type

Description

`potentialWethGatewayAddress`

`string`

`parentProvider`

`Provider`

###### Returns[​](#returns-49 "Direct link to Returns")

`Promise`<`boolean`\>

###### Source[​](#source-49 "Direct link to Source")

[assetBridger/erc20Bridger.ts:406](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L406)

##### withdraw()[​](#withdraw-1 "Direct link to withdraw()")

```rust
withdraw(params: ChildToParentTxReqAndSigner | OmitTyped<Erc20WithdrawParams, "from"> & object): Promise<ChildContractTransaction>
```

Withdraw tokens from child to parent network

###### Parameters[​](#parameters-48 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ChildToParentTxReqAndSigner` | [`OmitTyped`](/sdk/reference/utils/types#omittypedtk)<`Erc20WithdrawParams`, `"from"`\> & `object`

###### Returns[​](#returns-50 "Direct link to Returns")

`Promise`<`ChildContractTransaction`\>

###### Overrides[​](#overrides-2 "Direct link to Overrides")

[`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams) . [`withdraw`](/sdk/reference/assetBridger/#withdraw)

###### Source[​](#source-50 "Direct link to Source")

[assetBridger/erc20Bridger.ts:889](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L889)

##### fromProvider()[​](#fromprovider-1 "Direct link to fromProvider()")

```rust
static fromProvider(childProvider: Provider): Promise<Erc20Bridger>
```

Instantiates a new Erc20Bridger from a child provider

###### Parameters[​](#parameters-49 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-51 "Direct link to Returns")

`Promise` <[`Erc20Bridger`](/sdk/reference/assetBridger/erc20Bridger#erc20bridger)\>

###### Source[​](#source-51 "Direct link to Source")

[assetBridger/erc20Bridger.ts:216](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/erc20Bridger.ts#L216)

---

# ethBridger | Arbitrum Docs

## ethBridger

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### EthBridger[​](#ethbridger "Direct link to EthBridger")

Bridger for moving either ETH or custom gas tokens back and forth between parent and child networks

#### Extends[​](#extends "Direct link to Extends")

*   [`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams)<`EthDepositParams` | `EthDepositToParams` | `ParentToChildTxReqAndSigner`, `EthWithdrawParams` | `ChildToParentTxReqAndSigner`\>

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Description

Inherited from

`nativeToken?`

`readonly`

`string`

In case of a chain that uses ETH as its native/gas token, this is either `undefined` or the zero address  
  
In case of a chain that uses an ERC-20 token from the parent network as its native/gas token, this is the address of said token on the parent network

[`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams).`nativeToken`

#### Accessors[​](#accessors "Direct link to Accessors")

##### nativeTokenIsEth[​](#nativetokeniseth "Direct link to nativeTokenIsEth")

```rust
get protected nativeTokenIsEth(): boolean
```

Whether the chain uses ETH as its native/gas token

###### Returns[​](#returns "Direct link to Returns")

`boolean`

###### Source[​](#source "Direct link to Source")

[assetBridger/assetBridger.ts:72](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L72)

#### Methods[​](#methods "Direct link to Methods")

##### approveGasToken()[​](#approvegastoken "Direct link to approveGasToken()")

```rust
approveGasToken(params: WithParentSigner<ApproveGasTokenParamsOrTxRequest>): Promise<TransactionResponse>
```

Approves the custom gas token to be spent by the Inbox on the parent network.

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`params`

`WithParentSigner`<`ApproveGasTokenParamsOrTxRequest`\>

###### Returns[​](#returns-1 "Direct link to Returns")

`Promise`<`TransactionResponse`\>

###### Source[​](#source-1 "Direct link to Source")

[assetBridger/ethBridger.ts:223](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L223)

##### checkChildNetwork()[​](#checkchildnetwork "Direct link to checkChildNetwork()")

```rust
protected checkChildNetwork(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the child network, throws if not

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from "Direct link to Inherited from")

[`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams) . [`checkChildNetwork`](/sdk/reference/assetBridger/#checkchildnetwork)

###### Source[​](#source-2 "Direct link to Source")

[assetBridger/assetBridger.ts:61](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L61)

##### checkParentNetwork()[​](#checkparentnetwork "Direct link to checkParentNetwork()")

```rust
protected checkParentNetwork(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the parent network, throws if not

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-3 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from-1 "Direct link to Inherited from")

[`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams) . [`checkParentNetwork`](/sdk/reference/assetBridger/#checkparentnetwork)

###### Source[​](#source-3 "Direct link to Source")

[assetBridger/assetBridger.ts:50](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/assetBridger.ts#L50)

##### deposit()[​](#deposit "Direct link to deposit()")

```rust
deposit(params: EthDepositParams | ParentToChildTxReqAndSigner): Promise<ParentEthDepositTransaction>
```

Deposit ETH from Parent onto Child network

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

Description

`params`

`EthDepositParams` | `ParentToChildTxReqAndSigner`

###### Returns[​](#returns-4 "Direct link to Returns")

`Promise`<`ParentEthDepositTransaction`\>

###### Overrides[​](#overrides "Direct link to Overrides")

[`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams) . [`deposit`](/sdk/reference/assetBridger/#deposit)

###### Source[​](#source-4 "Direct link to Source")

[assetBridger/ethBridger.ts:291](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L291)

##### depositTo()[​](#depositto "Direct link to depositTo()")

```rust
depositTo(params: EthDepositToParams | ParentToChildTransactionRequest & object & object): Promise<ParentContractCallTransaction>
```

Deposit ETH from parent network onto a different child network address

###### Parameters[​](#parameters-4 "Direct link to Parameters")

Parameter

Type

Description

`params`

`EthDepositToParams` | [`ParentToChildTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#parenttochildtransactionrequest) & `object` & `object`

###### Returns[​](#returns-5 "Direct link to Returns")

`Promise`<`ParentContractCallTransaction`\>

###### Source[​](#source-5 "Direct link to Source")

[assetBridger/ethBridger.ts:354](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L354)

##### getApproveGasTokenRequest()[​](#getapprovegastokenrequest "Direct link to getApproveGasTokenRequest()")

```rust
getApproveGasTokenRequest(params?: ApproveGasTokenParams): Required<Pick<TransactionRequest, "data" | "value" | "to">>
```

Creates a transaction request for approving the custom gas token to be spent by the inbox on the parent network

###### Parameters[​](#parameters-5 "Direct link to Parameters")

Parameter

Type

Description

`params`?

`ApproveGasTokenParams`

###### Returns[​](#returns-6 "Direct link to Returns")

`Required`<`Pick`<`TransactionRequest`, `"data"` | `"value"` | `"to"`\>>

###### Source[​](#source-6 "Direct link to Source")

[assetBridger/ethBridger.ts:195](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L195)

##### getDepositRequest()[​](#getdepositrequest "Direct link to getDepositRequest()")

```rust
getDepositRequest(params: EthDepositRequestParams): Promise<OmitTyped<ParentToChildTransactionRequest, "retryableData">>
```

Gets tx request for depositing ETH or custom gas token

###### Parameters[​](#parameters-6 "Direct link to Parameters")

Parameter

Type

Description

`params`

`EthDepositRequestParams`

###### Returns[​](#returns-7 "Direct link to Returns")

`Promise` <[`OmitTyped`](/sdk/reference/utils/types#omittypedtk) <[`ParentToChildTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#parenttochildtransactionrequest), `"retryableData"`\>>

###### Source[​](#source-7 "Direct link to Source")

[assetBridger/ethBridger.ts:272](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L272)

##### getDepositRequestData()[​](#getdepositrequestdata "Direct link to getDepositRequestData()")

```rust
private getDepositRequestData(params: EthDepositRequestParams): string
```

Gets transaction calldata for a tx request for depositing ETH or custom gas token

###### Parameters[​](#parameters-7 "Direct link to Parameters")

Parameter

Type

Description

`params`

`EthDepositRequestParams`

###### Returns[​](#returns-8 "Direct link to Returns")

`string`

###### Source[​](#source-8 "Direct link to Source")

[assetBridger/ethBridger.ts:245](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L245)

##### getDepositToRequest()[​](#getdeposittorequest "Direct link to getDepositToRequest()")

```rust
getDepositToRequest(params: EthDepositToRequestParams): Promise<ParentToChildTransactionRequest>
```

Get a transaction request for an ETH deposit to a different child network address using Retryables

###### Parameters[​](#parameters-8 "Direct link to Parameters")

Parameter

Type

Description

`params`

`EthDepositToRequestParams`

###### Returns[​](#returns-9 "Direct link to Returns")

`Promise` <[`ParentToChildTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#parenttochildtransactionrequest)\>

###### Source[​](#source-9 "Direct link to Source")

[assetBridger/ethBridger.ts:316](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L316)

##### getWithdrawalRequest()[​](#getwithdrawalrequest "Direct link to getWithdrawalRequest()")

```rust
getWithdrawalRequest(params: EthWithdrawParams): Promise<ChildToParentTransactionRequest>
```

Get a transaction request for an eth withdrawal

###### Parameters[​](#parameters-9 "Direct link to Parameters")

Parameter

Type

Description

`params`

`EthWithdrawParams`

###### Returns[​](#returns-10 "Direct link to Returns")

`Promise` <[`ChildToParentTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#childtoparenttransactionrequest)\>

###### Source[​](#source-10 "Direct link to Source")

[assetBridger/ethBridger.ts:387](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L387)

##### isApproveGasTokenParams()[​](#isapprovegastokenparams "Direct link to isApproveGasTokenParams()")

```rust
private isApproveGasTokenParams(params: ApproveGasTokenParamsOrTxRequest): params is WithParentSigner<ApproveGasTokenParams>
```

Asserts that the provided argument is of type `ApproveGasTokenParams` and not `ApproveGasTokenTxRequest`.

###### Parameters[​](#parameters-10 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ApproveGasTokenParamsOrTxRequest`

###### Returns[​](#returns-11 "Direct link to Returns")

`params is WithParentSigner<ApproveGasTokenParams>`

###### Source[​](#source-11 "Direct link to Source")

[assetBridger/ethBridger.ts:185](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L185)

##### withdraw()[​](#withdraw "Direct link to withdraw()")

```rust
withdraw(params: ChildToParentTxReqAndSigner | EthWithdrawParams & object): Promise<ChildContractTransaction>
```

Withdraw ETH from child network onto parent network

###### Parameters[​](#parameters-11 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ChildToParentTxReqAndSigner` | `EthWithdrawParams` & `object`

###### Returns[​](#returns-12 "Direct link to Returns")

`Promise`<`ChildContractTransaction`\>

###### Overrides[​](#overrides-1 "Direct link to Overrides")

[`AssetBridger`](/sdk/reference/assetBridger/#assetbridgerdepositparamswithdrawparams) . [`withdraw`](/sdk/reference/assetBridger/#withdraw)

###### Source[​](#source-12 "Direct link to Source")

[assetBridger/ethBridger.ts:423](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L423)

##### fromProvider()[​](#fromprovider "Direct link to fromProvider()")

```rust
static fromProvider(childProvider: Provider): Promise<EthBridger>
```

Instantiates a new EthBridger from a child network Provider

###### Parameters[​](#parameters-12 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-13 "Direct link to Returns")

`Promise` <[`EthBridger`](/sdk/reference/assetBridger/ethBridger#ethbridger)\>

###### Source[​](#source-13 "Direct link to Source")

[assetBridger/ethBridger.ts:177](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/ethBridger.ts#L177)

---

# l1l3Bridger | Arbitrum Docs

## l1l3Bridger

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### Erc20L1L3Bridger[​](#erc20l1l3bridger "Direct link to Erc20L1L3Bridger")

Bridger for moving ERC20 tokens from L1 to L3

#### Extends[​](#extends "Direct link to Extends")

*   `BaseL1L3Bridger`

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Default value

Description

`_l1FeeTokenAddress`

`protected`

`undefined` | `string`

`undefined`

If the L3 network uses a custom fee token, this is the address of that token on L1

`l2ForwarderFactoryDefaultGasLimit`

`readonly`

`BigNumber`

`...`

Default gas limit for L2ForwarderFactory.callForwarder of 1,000,000  
  
Measured Standard: 361746  
  
Measured OnlyGasToken: 220416  
  
Measured NonGasTokenToCustomGas: 373449

`l2GasTokenAddress`

`readonly`

`undefined` | `string`

`undefined`

If the L3 network uses a custom (non-eth) fee token, this is the address of that token on L2

`teleporter`

`readonly`

`Teleporter`

`undefined`

Addresses of teleporter contracts on L2

#### Methods[​](#methods "Direct link to Methods")

##### \_checkL1Network()[​](#_checkl1network "Direct link to _checkL1Network()")

```rust
protected _checkL1Network(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the l1Network, throws if not

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from "Direct link to Inherited from")

`BaseL1L3Bridger._checkL1Network`

###### Source[​](#source "Direct link to Source")

[assetBridger/l1l3Bridger.ts:306](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L306)

##### \_checkL2Network()[​](#_checkl2network "Direct link to _checkL2Network()")

```rust
protected _checkL2Network(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the l2Network, throws if not

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-1 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from-1 "Direct link to Inherited from")

`BaseL1L3Bridger._checkL2Network`

###### Source[​](#source-1 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:314](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L314)

##### \_checkL3Network()[​](#_checkl3network "Direct link to _checkL3Network()")

```rust
protected _checkL3Network(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the l3Network, throws if not

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from-2 "Direct link to Inherited from")

`BaseL1L3Bridger._checkL3Network`

###### Source[​](#source-2 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:322](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L322)

##### \_decodeCallForwarderCalldata()[​](#_decodecallforwardercalldata "Direct link to _decodeCallForwarderCalldata()")

```rust
protected _decodeCallForwarderCalldata(data: string): L2ForwarderParamsStruct
```

Given raw calldata for a callForwarder call, decode the parameters

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

`data`

`string`

###### Returns[​](#returns-3 "Direct link to Returns")

`L2ForwarderParamsStruct`

###### Source[​](#source-3 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1402](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1402)

##### \_decodeTeleportCalldata()[​](#_decodeteleportcalldata "Direct link to _decodeTeleportCalldata()")

```rust
protected _decodeTeleportCalldata(data: string): TeleportParamsStruct
```

Given raw calldata for a teleport tx, decode the teleport parameters

###### Parameters[​](#parameters-4 "Direct link to Parameters")

Parameter

Type

`data`

`string`

###### Returns[​](#returns-4 "Direct link to Returns")

`TeleportParamsStruct`

###### Source[​](#source-4 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1388](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1388)

##### \_fillPartialTeleportParams()[​](#_fillpartialteleportparams "Direct link to _fillPartialTeleportParams()")

```rust
protected _fillPartialTeleportParams(
   partialTeleportParams: OmitTyped<TeleportParamsStruct, "gasParams">, 
   retryableOverrides: Erc20L1L3DepositRequestRetryableOverrides, 
   l1Provider: Provider, 
   l2Provider: Provider, 
l3Provider: Provider): Promise<object>
```

Given TeleportParams without the gas parameters, return TeleportParams with gas parameters populated. Does not modify the input parameters.

###### Parameters[​](#parameters-5 "Direct link to Parameters")

Parameter

Type

`partialTeleportParams`

[`OmitTyped`](/sdk/reference/utils/types#omittypedtk)<`TeleportParamsStruct`, `"gasParams"`\>

`retryableOverrides`

`Erc20L1L3DepositRequestRetryableOverrides`

`l1Provider`

`Provider`

`l2Provider`

`Provider`

`l3Provider`

`Provider`

###### Returns[​](#returns-5 "Direct link to Returns")

`Promise`<`object`\>

Member

Type

`costs`

\[`BigNumber`, `BigNumber`, `number`, `RetryableGasCostsStructOutput`\] & `object`

`teleportParams`

`object`

`teleportParams.amount`

`BigNumberish`

`teleportParams.gasParams`

`RetryableGasParamsStruct`

`teleportParams.l1Token`

`string`

`teleportParams.l1l2Router`

`string`

`teleportParams.l2l3RouterOrInbox`

`string`

`teleportParams.l3FeeTokenL1Addr`

`string`

`teleportParams.to`

`string`

###### Source[​](#source-5 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1194](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1194)

##### \_getL1L2FeeTokenBridgeGasEstimates()[​](#_getl1l2feetokenbridgegasestimates "Direct link to _getL1L2FeeTokenBridgeGasEstimates()")

```rust
protected _getL1L2FeeTokenBridgeGasEstimates(params: object): Promise<RetryableGasValues>
```

Estimate the gasLimit and maxSubmissionFee for the L1 to L2 fee token bridge leg of a teleportation

###### Parameters[​](#parameters-6 "Direct link to Parameters")

Parameter

Type

`params`

`object`

`params.feeTokenAmount`

`BigNumber`

`params.l1GasPrice`

`BigNumber`

`params.l1Provider`

`Provider`

`params.l2ForwarderAddress`

`string`

`params.l2Provider`

`Provider`

`params.l3FeeTokenL1Addr`

`string`

###### Returns[​](#returns-6 "Direct link to Returns")

`Promise`<`RetryableGasValues`\>

###### Source[​](#source-6 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1056](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1056)

##### \_getL1L2TokenBridgeGasEstimates()[​](#_getl1l2tokenbridgegasestimates "Direct link to _getL1L2TokenBridgeGasEstimates()")

```rust
protected _getL1L2TokenBridgeGasEstimates(params: object): Promise<RetryableGasValues>
```

Estimate the gasLimit and maxSubmissionFee for the L1 to L2 token bridge leg of a teleportation

###### Parameters[​](#parameters-7 "Direct link to Parameters")

Parameter

Type

`params`

`object`

`params.amount`

`BigNumberish`

`params.l1GasPrice`

`BigNumber`

`params.l1Provider`

`Provider`

`params.l1Token`

`string`

`params.l2ForwarderAddress`

`string`

`params.l2Provider`

`Provider`

###### Returns[​](#returns-7 "Direct link to Returns")

`Promise`<`RetryableGasValues`\>

###### Source[​](#source-7 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1024](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1024)

##### \_getL2ForwarderFactoryGasEstimates()[​](#_getl2forwarderfactorygasestimates "Direct link to _getL2ForwarderFactoryGasEstimates()")

```rust
protected _getL2ForwarderFactoryGasEstimates(l1GasPrice: BigNumber, l1Provider: Provider): Promise<RetryableGasValues>
```

Estimate the gasLimit and maxSubmissionFee for L2ForwarderFactory.callForwarder leg of a teleportation. Gas limit is hardcoded to 1,000,000

###### Parameters[​](#parameters-8 "Direct link to Parameters")

Parameter

Type

`l1GasPrice`

`BigNumber`

`l1Provider`

`Provider`

###### Returns[​](#returns-8 "Direct link to Returns")

`Promise`<`RetryableGasValues`\>

###### Source[​](#source-8 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1095](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1095)

##### \_getL2L3BridgeGasEstimates()[​](#_getl2l3bridgegasestimates "Direct link to _getL2L3BridgeGasEstimates()")

```rust
protected _getL2L3BridgeGasEstimates(params: object): Promise<RetryableGasValues>
```

Estimate the gasLimit and maxSubmissionFee for the L2 -> L3 leg of a teleportation.

###### Parameters[​](#parameters-9 "Direct link to Parameters")

Parameter

Type

`params`

`object`

`params.l1Provider`

`Provider`

`params.l2ForwarderAddress`

`string`

`params.l2GasPrice`

`BigNumber`

`params.l2Provider`

`Provider`

`params.l3Provider`

`Provider`

`params.partialTeleportParams`

[`OmitTyped`](/sdk/reference/utils/types#omittypedtk)<`TeleportParamsStruct`, `"gasParams"`\>

###### Returns[​](#returns-9 "Direct link to Returns")

`Promise`<`RetryableGasValues`\>

###### Source[​](#source-9 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1117](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1117)

##### \_getTokenBridgeGasEstimates()[​](#_gettokenbridgegasestimates "Direct link to _getTokenBridgeGasEstimates()")

```rust
protected _getTokenBridgeGasEstimates(params: object): Promise<RetryableGasValues>
```

Estimate the gasLimit and maxSubmissionFee for a token bridge retryable

###### Parameters[​](#parameters-10 "Direct link to Parameters")

Parameter

Type

`params`

`object`

`params.amount`

`BigNumber`

`params.childProvider`

`Provider`

`params.from`

`string`

`params.isWeth`

`boolean`

`params.parentErc20Address`

`string`

`params.parentGasPrice`

`BigNumber`

`params.parentGatewayAddress`

`string`

`params.parentProvider`

`Provider`

`params.to`

`string`

###### Returns[​](#returns-10 "Direct link to Returns")

`Promise`<`RetryableGasValues`\>

###### Source[​](#source-10 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:976](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L976)

##### \_l2ForwarderFactoryCalldataSize()[​](#_l2forwarderfactorycalldatasize "Direct link to _l2ForwarderFactoryCalldataSize()")

```rust
protected _l2ForwarderFactoryCalldataSize(): number
```

###### Returns[​](#returns-11 "Direct link to Returns")

`number`

The size of the calldata for a call to L2ForwarderFactory.callForwarder

###### Source[​](#source-11 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1366](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1366)

##### approveGasToken()[​](#approvegastoken "Direct link to approveGasToken()")

```rust
approveGasToken(params: TxRequestParams | object): Promise<ContractTransaction>
```

Approve the L3's fee token for teleportation. The tokens will be approved for L1Teleporter. Will throw if the L3 network uses ETH for fees or the fee token doesn't exist on L1.

###### Parameters[​](#parameters-11 "Direct link to Parameters")

Parameter

Type

`params`

`TxRequestParams` | `object`

###### Returns[​](#returns-12 "Direct link to Returns")

`Promise`<`ContractTransaction`\>

###### Source[​](#source-12 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:701](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L701)

##### approveToken()[​](#approvetoken "Direct link to approveToken()")

```rust
approveToken(params: TxRequestParams | TokenApproveParams & object): Promise<ContractTransaction>
```

Approve tokens for teleportation. The tokens will be approved for L1Teleporter.

###### Parameters[​](#parameters-12 "Direct link to Parameters")

Parameter

Type

`params`

`TxRequestParams` | `TokenApproveParams` & `object`

###### Returns[​](#returns-13 "Direct link to Returns")

`Promise`<`ContractTransaction`\>

###### Source[​](#source-13 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:659](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L659)

##### deposit()[​](#deposit "Direct link to deposit()")

```rust
deposit(params: TxRequestParams | Erc20L1L3DepositRequestParams & object): Promise<ParentContractCallTransaction>
```

Execute a teleportation of some tokens from L1 to L3.

###### Parameters[​](#parameters-13 "Direct link to Parameters")

Parameter

Type

`params`

`TxRequestParams` | `Erc20L1L3DepositRequestParams` & `object`

###### Returns[​](#returns-14 "Direct link to Returns")

`Promise`<`ParentContractCallTransaction`\>

###### Source[​](#source-14 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:811](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L811)

##### getApproveGasTokenRequest()[​](#getapprovegastokenrequest "Direct link to getApproveGasTokenRequest()")

```rust
getApproveGasTokenRequest(params: object): Promise<Required<Pick<TransactionRequest, "data" | "value" | "to">>>
```

Get a tx request to approve the L3's fee token for teleportation. The tokens will be approved for L1Teleporter. Will throw if the L3 network uses ETH for fees or the fee token doesn't exist on L1.

###### Parameters[​](#parameters-14 "Direct link to Parameters")

Parameter

Type

`params`

`object`

`params.amount`?

`BigNumber`

`params.l1Provider`

`Provider`

`params.l2Provider`

`Provider`

###### Returns[​](#returns-15 "Direct link to Returns")

`Promise`<`Required`<`Pick`<`TransactionRequest`, `"data"` | `"value"` | `"to"`\>>>

###### Source[​](#source-15 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:682](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L682)

##### getApproveTokenRequest()[​](#getapprovetokenrequest "Direct link to getApproveTokenRequest()")

```rust
getApproveTokenRequest(params: TokenApproveParams): Promise<Required<Pick<TransactionRequest, "data" | "value" | "to">>>
```

Get a tx request to approve tokens for teleportation. The tokens will be approved for L1Teleporter.

###### Parameters[​](#parameters-15 "Direct link to Parameters")

Parameter

Type

`params`

`TokenApproveParams`

###### Returns[​](#returns-16 "Direct link to Returns")

`Promise`<`Required`<`Pick`<`TransactionRequest`, `"data"` | `"value"` | `"to"`\>>>

###### Source[​](#source-16 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:640](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L640)

##### getDepositParameters()[​](#getdepositparameters "Direct link to getDepositParameters()")

```rust
getDepositParameters(params: object & TxReference): Promise<object>
```

Given a teleportation tx, get the L1Teleporter parameters, L2Forwarder parameters, and L2Forwarder address

###### Parameters[​](#parameters-16 "Direct link to Parameters")

Parameter

Type

`params`

`object` & `TxReference`

###### Returns[​](#returns-17 "Direct link to Returns")

`Promise`<`object`\>

Member

Type

`l2ForwarderAddress`

`Promise`<`string`\>

`l2ForwarderParams`

`L2ForwarderParamsStruct`

`teleportParams`

`TeleportParamsStruct`

###### Source[​](#source-17 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:837](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L837)

##### getDepositRequest()[​](#getdepositrequest "Direct link to getDepositRequest()")

```rust
getDepositRequest(params: Erc20L1L3DepositRequestParams & object | object): Promise<DepositRequestResult>
```

Get a tx request for teleporting some tokens from L1 to L3. Also returns the amount of fee tokens required for teleportation.

###### Parameters[​](#parameters-17 "Direct link to Parameters")

Parameter

Type

`params`

`Erc20L1L3DepositRequestParams` & `object` | `object`

###### Returns[​](#returns-18 "Direct link to Returns")

`Promise`<`DepositRequestResult`\>

###### Source[​](#source-18 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:732](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L732)

##### getDepositStatus()[​](#getdepositstatus "Direct link to getDepositStatus()")

```rust
getDepositStatus(params: GetL1L3DepositStatusParams): Promise<Erc20L1L3DepositStatus>
```

Fetch the cross chain messages and their status

Can provide either the txHash, the tx, or the txReceipt

###### Parameters[​](#parameters-18 "Direct link to Parameters")

Parameter

Type

`params`

`GetL1L3DepositStatusParams`

###### Returns[​](#returns-19 "Direct link to Returns")

`Promise`<`Erc20L1L3DepositStatus`\>

###### Source[​](#source-19 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:878](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L878)

##### getGasTokenOnL1()[​](#getgastokenonl1 "Direct link to getGasTokenOnL1()")

```rust
getGasTokenOnL1(l1Provider: Provider, l2Provider: Provider): Promise<string>
```

If the L3 network uses a custom gas token, return the address of that token on L1. If the fee token is not available on L1, does not use 18 decimals on L1 and L2, or the L3 network uses ETH for fees, throw.

###### Parameters[​](#parameters-19 "Direct link to Parameters")

Parameter

Type

`l1Provider`

`Provider`

`l2Provider`

`Provider`

###### Returns[​](#returns-20 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-20 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:431](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L431)

##### getL1L2GatewayAddress()[​](#getl1l2gatewayaddress "Direct link to getL1L2GatewayAddress()")

```rust
getL1L2GatewayAddress(erc20L1Address: string, l1Provider: Provider): Promise<string>
```

Given an L1 token's address, get the address of the token's L1 <-> L2 gateway on L1

###### Parameters[​](#parameters-20 "Direct link to Parameters")

Parameter

Type

`erc20L1Address`

`string`

`l1Provider`

`Provider`

###### Returns[​](#returns-21 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-21 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:532](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L532)

##### getL1TokenContract()[​](#getl1tokencontract "Direct link to getL1TokenContract()")

```rust
getL1TokenContract(l1TokenAddr: string, l1Provider: Provider): IERC20
```

Get the L1 token contract at the provided address Note: This function just returns a typed ethers object for the provided address, it doesn't check the underlying form of the contract bytecode to see if it's an erc20, and doesn't ensure the validity of any of the underlying functions on that contract.

###### Parameters[​](#parameters-21 "Direct link to Parameters")

Parameter

Type

`l1TokenAddr`

`string`

`l1Provider`

`Provider`

###### Returns[​](#returns-22 "Direct link to Returns")

`IERC20`

###### Source[​](#source-22 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:560](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L560)

##### getL2Erc20Address()[​](#getl2erc20address "Direct link to getL2Erc20Address()")

```rust
getL2Erc20Address(erc20L1Address: string, l1Provider: Provider): Promise<string>
```

Get the corresponding L2 token address for the provided L1 token

###### Parameters[​](#parameters-22 "Direct link to Parameters")

Parameter

Type

`erc20L1Address`

`string`

`l1Provider`

`Provider`

###### Returns[​](#returns-23 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-23 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:508](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L508)

##### getL2L3GatewayAddress()[​](#getl2l3gatewayaddress "Direct link to getL2L3GatewayAddress()")

```rust
getL2L3GatewayAddress(
   erc20L1Address: string, 
   l1Provider: Provider, 
l2Provider: Provider): Promise<string>
```

Get the address of the L2 <-> L3 gateway on L2 given an L1 token address

###### Parameters[​](#parameters-23 "Direct link to Parameters")

Parameter

Type

`erc20L1Address`

`string`

`l1Provider`

`Provider`

`l2Provider`

`Provider`

###### Returns[​](#returns-24 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-24 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:545](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L545)

##### getL2TokenContract()[​](#getl2tokencontract "Direct link to getL2TokenContract()")

```rust
getL2TokenContract(l2TokenAddr: string, l2Provider: Provider): L2GatewayToken
```

Get the L2 token contract at the provided address Note: This function just returns a typed ethers object for the provided address, it doesn't check the underlying form of the contract bytecode to see if it's an erc20, and doesn't ensure the validity of any of the underlying functions on that contract.

###### Parameters[​](#parameters-24 "Direct link to Parameters")

Parameter

Type

`l2TokenAddr`

`string`

`l2Provider`

`Provider`

###### Returns[​](#returns-25 "Direct link to Returns")

`L2GatewayToken`

###### Source[​](#source-25 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:570](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L570)

##### getL3Erc20Address()[​](#getl3erc20address "Direct link to getL3Erc20Address()")

```rust
getL3Erc20Address(
   erc20L1Address: string, 
   l1Provider: Provider, 
l2Provider: Provider): Promise<string>
```

Get the corresponding L3 token address for the provided L1 token

###### Parameters[​](#parameters-25 "Direct link to Parameters")

Parameter

Type

`erc20L1Address`

`string`

`l1Provider`

`Provider`

`l2Provider`

`Provider`

###### Returns[​](#returns-26 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-26 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:518](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L518)

##### getL3TokenContract()[​](#getl3tokencontract "Direct link to getL3TokenContract()")

```rust
getL3TokenContract(l3TokenAddr: string, l3Provider: Provider): L2GatewayToken
```

Get the L3 token contract at the provided address Note: This function just returns a typed ethers object for the provided address, it doesn't check the underlying form of the contract bytecode to see if it's an erc20, and doesn't ensure the validity of any of the underlying functions on that contract.

###### Parameters[​](#parameters-26 "Direct link to Parameters")

Parameter

Type

`l3TokenAddr`

`string`

`l3Provider`

`Provider`

###### Returns[​](#returns-27 "Direct link to Returns")

`L2GatewayToken`

###### Source[​](#source-27 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:583](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L583)

##### l1TokenIsDisabled()[​](#l1tokenisdisabled "Direct link to l1TokenIsDisabled()")

```rust
l1TokenIsDisabled(l1TokenAddress: string, l1Provider: Provider): Promise<boolean>
```

Whether the L1 token has been disabled on the L1 <-> L2 router given an L1 token address

###### Parameters[​](#parameters-27 "Direct link to Parameters")

Parameter

Type

`l1TokenAddress`

`string`

`l1Provider`

`Provider`

###### Returns[​](#returns-28 "Direct link to Returns")

`Promise`<`boolean`\>

###### Source[​](#source-28 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:593](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L593)

##### l2ForwarderAddress()[​](#l2forwarderaddress "Direct link to l2ForwarderAddress()")

```rust
l2ForwarderAddress(
   owner: string, 
   routerOrInbox: string, 
   destinationAddress: string, 
l1OrL2Provider: Provider): Promise<string>
```

Given some L2Forwarder parameters, get the address of the L2Forwarder contract

###### Parameters[​](#parameters-28 "Direct link to Parameters")

Parameter

Type

`owner`

`string`

`routerOrInbox`

`string`

`destinationAddress`

`string`

`l1OrL2Provider`

`Provider`

###### Returns[​](#returns-29 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-29 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:613](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L613)

##### l2TokenIsDisabled()[​](#l2tokenisdisabled "Direct link to l2TokenIsDisabled()")

```rust
l2TokenIsDisabled(l2TokenAddress: string, l2Provider: Provider): Promise<boolean>
```

Whether the L2 token has been disabled on the L2 <-> L3 router given an L2 token address

###### Parameters[​](#parameters-29 "Direct link to Parameters")

Parameter

Type

`l2TokenAddress`

`string`

`l2Provider`

`Provider`

###### Returns[​](#returns-30 "Direct link to Returns")

`Promise`<`boolean`\>

###### Source[​](#source-30 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:603](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L603)

##### teleportationType()[​](#teleportationtype "Direct link to teleportationType()")

```rust
teleportationType(partialTeleportParams: Pick<TeleportParamsStruct, "l1Token" | "l3FeeTokenL1Addr">): TeleportationType
```

Get the type of teleportation from the l1Token and l3FeeTokenL1Addr teleport parameters

###### Parameters[​](#parameters-30 "Direct link to Parameters")

Parameter

Type

`partialTeleportParams`

`Pick`<`TeleportParamsStruct`, `"l1Token"` | `"l3FeeTokenL1Addr"`\>

###### Returns[​](#returns-31 "Direct link to Returns")

`TeleportationType`

###### Source[​](#source-31 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:953](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L953)

* * *

### EthL1L3Bridger[​](#ethl1l3bridger "Direct link to EthL1L3Bridger")

Bridge ETH from L1 to L3 using a double retryable ticket

#### Extends[​](#extends-1 "Direct link to Extends")

*   `BaseL1L3Bridger`

#### Methods[​](#methods-1 "Direct link to Methods")

##### \_checkL1Network()[​](#_checkl1network-1 "Direct link to _checkL1Network()")

```rust
protected _checkL1Network(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the l1Network, throws if not

###### Parameters[​](#parameters-31 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-32 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from-3 "Direct link to Inherited from")

`BaseL1L3Bridger._checkL1Network`

###### Source[​](#source-32 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:306](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L306)

##### \_checkL2Network()[​](#_checkl2network-1 "Direct link to _checkL2Network()")

```rust
protected _checkL2Network(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the l2Network, throws if not

###### Parameters[​](#parameters-32 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-33 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from-4 "Direct link to Inherited from")

`BaseL1L3Bridger._checkL2Network`

###### Source[​](#source-33 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:314](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L314)

##### \_checkL3Network()[​](#_checkl3network-1 "Direct link to _checkL3Network()")

```rust
protected _checkL3Network(sop: SignerOrProvider): Promise<void>
```

Check the signer/provider matches the l3Network, throws if not

###### Parameters[​](#parameters-33 "Direct link to Parameters")

Parameter

Type

Description

`sop`

`SignerOrProvider`

###### Returns[​](#returns-34 "Direct link to Returns")

`Promise`<`void`\>

###### Inherited from[​](#inherited-from-5 "Direct link to Inherited from")

`BaseL1L3Bridger._checkL3Network`

###### Source[​](#source-34 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:322](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L322)

##### deposit()[​](#deposit-1 "Direct link to deposit()")

```rust
deposit(params: TxRequestParams | EthL1L3DepositRequestParams & object): Promise<ParentContractCallTransaction>
```

Deposit ETH to L3 via a double retryable ticket

###### Parameters[​](#parameters-34 "Direct link to Parameters")

Parameter

Type

`params`

`TxRequestParams` | `EthL1L3DepositRequestParams` & `object`

###### Returns[​](#returns-35 "Direct link to Returns")

`Promise`<`ParentContractCallTransaction`\>

###### Source[​](#source-35 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1521](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1521)

##### getDepositParameters()[​](#getdepositparameters-1 "Direct link to getDepositParameters()")

```rust
getDepositParameters(params: object & TxReference): Promise<object>
```

Given an L1 transaction, get the retryable parameters for both l2 and l3 tickets

###### Parameters[​](#parameters-35 "Direct link to Parameters")

Parameter

Type

`params`

`object` & `TxReference`

###### Returns[​](#returns-36 "Direct link to Returns")

`Promise`<`object`\>

Member

Type

`l1l2TicketData`

[`RetryableMessageParams`](/sdk/reference/dataEntities/message#retryablemessageparams)

`l2l3TicketData`

[`RetryableMessageParams`](/sdk/reference/dataEntities/message#retryablemessageparams)

###### Source[​](#source-36 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1547](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1547)

##### getDepositRequest()[​](#getdepositrequest-1 "Direct link to getDepositRequest()")

```rust
getDepositRequest(params: EthL1L3DepositRequestParams & object | object): Promise<ParentToChildTransactionRequest>
```

Get a tx request to deposit ETH to L3 via a double retryable ticket

###### Parameters[​](#parameters-36 "Direct link to Parameters")

Parameter

Type

`params`

`EthL1L3DepositRequestParams` & `object` | `object`

###### Returns[​](#returns-37 "Direct link to Returns")

`Promise` <[`ParentToChildTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#parenttochildtransactionrequest)\>

###### Source[​](#source-37 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1463](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1463)

##### getDepositStatus()[​](#getdepositstatus-1 "Direct link to getDepositStatus()")

```rust
getDepositStatus(params: GetL1L3DepositStatusParams): Promise<EthL1L3DepositStatus>
```

Get the status of a deposit given an L1 tx receipt. Does not check if the tx is actually a deposit tx.

###### Parameters[​](#parameters-37 "Direct link to Parameters")

Parameter

Type

`params`

`GetL1L3DepositStatusParams`

###### Returns[​](#returns-38 "Direct link to Returns")

`Promise`<`EthL1L3DepositStatus`\>

Information regarding each step of the deposit and `EthL1L3DepositStatus.completed` which indicates whether the deposit has fully completed.

###### Source[​](#source-38 "Direct link to Source")

[assetBridger/l1l3Bridger.ts:1577](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/assetBridger/l1l3Bridger.ts#L1577)

---

# address | Arbitrum Docs

## address

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### Address[​](#address "Direct link to Address")

Ethereum/Arbitrum address class

#### Constructors[​](#constructors "Direct link to Constructors")

##### new Address()[​](#new-address "Direct link to new Address()")

```rust
new Address(value: string): Address
```

Ethereum/Arbitrum address class

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`value`

`string`

A valid Ethereum address. Doesn't need to be checksum cased.

###### Returns[​](#returns "Direct link to Returns")

[`Address`](/sdk/reference/dataEntities/address#address)

###### Source[​](#source "Direct link to Source")

[dataEntities/address.ts:18](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/address.ts#L18)

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Description

`value`

`readonly`

`string`

A valid Ethereum address. Doesn't need to be checksum cased.

#### Methods[​](#methods "Direct link to Methods")

##### applyAlias()[​](#applyalias "Direct link to applyAlias()")

```rust
applyAlias(): Address
```

Find the L2 alias of an L1 address

###### Returns[​](#returns-1 "Direct link to Returns")

[`Address`](/sdk/reference/dataEntities/address#address)

###### Source[​](#source-1 "Direct link to Source")

[dataEntities/address.ts:43](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/address.ts#L43)

##### undoAlias()[​](#undoalias "Direct link to undoAlias()")

```rust
undoAlias(): Address
```

Find the L1 alias of an L2 address

###### Returns[​](#returns-2 "Direct link to Returns")

[`Address`](/sdk/reference/dataEntities/address#address)

###### Source[​](#source-2 "Direct link to Source")

[dataEntities/address.ts:51](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/address.ts#L51)

---

# constants | Arbitrum Docs

## constants

Variables[​](#variables "Direct link to Variables")
---------------------------------------------------

### ADDRESS\_ALIAS\_OFFSET[​](#address_alias_offset "Direct link to ADDRESS_ALIAS_OFFSET")

```rust
const ADDRESS_ALIAS_OFFSET: "0x1111000000000000000000000000000000001111" = '0x1111000000000000000000000000000000001111';
```

The offset added to an L1 address to get the corresponding L2 address

#### Source[​](#source "Direct link to Source")

[dataEntities/constants.ts:41](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/constants.ts#L41)

* * *

### ARB1\_NITRO\_GENESIS\_L1\_BLOCK[​](#arb1_nitro_genesis_l1_block "Direct link to ARB1_NITRO_GENESIS_L1_BLOCK")

```rust
const ARB1_NITRO_GENESIS_L1_BLOCK: 15447158 = 15447158;
```

The L1 block at which Nitro was activated for Arbitrum One.

#### See[​](#see "Direct link to See")

[https://etherscan.io/block/15447158](https://etherscan.io/block/15447158)

#### Source[​](#source-1 "Direct link to Source")

[dataEntities/constants.ts:71](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/constants.ts#L71)

* * *

### ARB1\_NITRO\_GENESIS\_L2\_BLOCK[​](#arb1_nitro_genesis_l2_block "Direct link to ARB1_NITRO_GENESIS_L2_BLOCK")

```rust
const ARB1_NITRO_GENESIS_L2_BLOCK: 22207817 = 22207817;
```

The L2 block at which Nitro was activated for Arbitrum One.

#### See[​](#see-1 "Direct link to See")

[https://arbiscan.io/block/22207817](https://arbiscan.io/block/22207817)

#### Source[​](#source-2 "Direct link to Source")

[dataEntities/constants.ts:78](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/constants.ts#L78)

* * *

### CUSTOM\_TOKEN\_IS\_ENABLED[​](#custom_token_is_enabled "Direct link to CUSTOM_TOKEN_IS_ENABLED")

```rust
const CUSTOM_TOKEN_IS_ENABLED: 42161 = 42161;
```

If a custom token is enabled for arbitrum it will implement a function called isArbitrumEnabled which returns this value. Intger: 0xa4b1

#### Source[​](#source-3 "Direct link to Source")

[dataEntities/constants.ts:52](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/constants.ts#L52)

* * *

### DEFAULT\_DEPOSIT\_TIMEOUT[​](#default_deposit_timeout "Direct link to DEFAULT_DEPOSIT_TIMEOUT")

```rust
const DEFAULT_DEPOSIT_TIMEOUT: number;
```

How long to wait (in milliseconds) for a deposit to arrive before timing out a request.

Finalisation on mainnet can be up to 2 epochs = 64 blocks. We add 10 minutes for the system to create and redeem the ticket, plus some extra buffer of time.

Total timeout: 30 minutes.

#### Source[​](#source-4 "Direct link to Source")

[dataEntities/constants.ts:64](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/constants.ts#L64)

* * *

### DISABLED\_GATEWAY[​](#disabled_gateway "Direct link to DISABLED_GATEWAY")

```rust
const DISABLED_GATEWAY: "0x0000000000000000000000000000000000000001" = '0x0000000000000000000000000000000000000001';
```

Address of the gateway a token will be assigned to if it is disabled

#### Source[​](#source-5 "Direct link to Source")

[dataEntities/constants.ts:46](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/constants.ts#L46)

---

# errors | Arbitrum Docs

## errors

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### ArbSdkError[​](#arbsdkerror "Direct link to ArbSdkError")

Errors originating in Arbitrum SDK

#### Extends[​](#extends "Direct link to Extends")

*   `Error`

#### Extended by[​](#extended-by "Direct link to Extended by")

*   [`MissingProviderArbSdkError`](/sdk/reference/dataEntities/errors#missingproviderarbsdkerror)

* * *

### MissingProviderArbSdkError[​](#missingproviderarbsdkerror "Direct link to MissingProviderArbSdkError")

Thrown when a signer does not have a connected provider

#### Extends[​](#extends-1 "Direct link to Extends")

*   [`ArbSdkError`](/sdk/reference/dataEntities/errors#arbsdkerror)

---

# event | Arbitrum Docs

## event

Type Aliases[​](#type-aliases "Direct link to Type Aliases")
------------------------------------------------------------

### EventArgs<T>[​](#eventargst "Direct link to EventArgs<T>")

```rust
type EventArgs<T>: T extends TypedEvent<infer _, infer TObj> ? TObj : never;
```

The type of the event arguments. Gets the second generic arg

#### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T`

#### Source[​](#source "Direct link to Source")

[dataEntities/event.ts:10](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/event.ts#L10)

* * *

### EventFromFilter<TFilter>[​](#eventfromfiltertfilter "Direct link to EventFromFilter<TFilter>")

```rust
type EventFromFilter<TFilter>: TFilter extends TypedEventFilter<infer TEvent> ? TEvent : never;
```

The event type of a filter Gets the first generic arg

#### Type parameters[​](#type-parameters-1 "Direct link to Type parameters")

Type parameter

`TFilter`

#### Source[​](#source-1 "Direct link to Source")

[dataEntities/event.ts:18](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/event.ts#L18)

* * *

### TypeChainContractFactory<TContract>[​](#typechaincontractfactorytcontract "Direct link to TypeChainContractFactory<TContract>")

```rust
type TypeChainContractFactory<TContract>: object;
```

Typechain contract factories have additional properties

#### Type parameters[​](#type-parameters-2 "Direct link to Type parameters")

Type parameter

`TContract` _extends_ `Contract`

#### Type declaration[​](#type-declaration "Direct link to Type declaration")

Member

Type

`connect`

`TContract`

`createInterface`

`Interface`

#### Source[​](#source-2 "Direct link to Source")

[dataEntities/event.ts:41](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/event.ts#L41)

Functions[​](#functions "Direct link to Functions")
---------------------------------------------------

### parseTypedLog()[​](#parsetypedlog "Direct link to parseTypedLog()")

```rust
function parseTypedLog<TContract, TFilterName>(
   contractFactory: TypeChainContractFactory<TContract>, 
   log: Log, 
filterName: TFilterName): null | EventArgs<EventFromFilter<ReturnType<TContract["filters"][TFilterName]>>>
```

Parse a log that matches a given filter name.

#### Type parameters[​](#type-parameters-3 "Direct link to Type parameters")

Type parameter

`TContract` _extends_ `Contract`

`TFilterName` _extends_ `string`

#### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`contractFactory`

[`TypeChainContractFactory`](/sdk/reference/dataEntities/event#typechaincontractfactorytcontract)<`TContract`\>

`log`

`Log`

The log to parse

`filterName`

`TFilterName`

#### Returns[​](#returns "Direct link to Returns")

`null` | [`EventArgs`](/sdk/reference/dataEntities/event#eventargst) <[`EventFromFilter`](/sdk/reference/dataEntities/event#eventfromfiltertfilter)<`ReturnType`<`TContract`\[`"filters"`\]\[`TFilterName`\]>>>

Null if filter name topic does not match log topic

#### Source[​](#source-3 "Direct link to Source")

[dataEntities/event.ts:53](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/event.ts#L53)

* * *

### parseTypedLogs()[​](#parsetypedlogs "Direct link to parseTypedLogs()")

```rust
function parseTypedLogs<TContract, TFilterName>(
   contractFactory: TypeChainContractFactory<TContract>, 
   logs: Log[], 
   filterName: TFilterName): EventArgs<EventFromFilter<ReturnType<TContract["filters"][TFilterName]>>>[]
```

Parses an array of logs. Filters out any logs whose topic does not match provided the filter name topic.

#### Type parameters[​](#type-parameters-4 "Direct link to Type parameters")

Type parameter

`TContract` _extends_ `Contract`

`TFilterName` _extends_ `string`

#### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`contractFactory`

[`TypeChainContractFactory`](/sdk/reference/dataEntities/event#typechaincontractfactorytcontract)<`TContract`\>

`logs`

`Log`\[\]

The logs to parse

`filterName`

`TFilterName`

#### Returns[​](#returns-1 "Direct link to Returns")

[`EventArgs`](/sdk/reference/dataEntities/event#eventargst) <[`EventFromFilter`](/sdk/reference/dataEntities/event#eventfromfiltertfilter)<`ReturnType`<`TContract`\[`"filters"`\]\[`TFilterName`\]>>>\[\]

#### Source[​](#source-4 "Direct link to Source")

[dataEntities/event.ts:78](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/event.ts#L78)

---

# message | Arbitrum Docs

## message

Enumerations[​](#enumerations "Direct link to Enumerations")
------------------------------------------------------------

### InboxMessageKind[​](#inboxmessagekind "Direct link to InboxMessageKind")

The inbox message kind as defined in: [https://github.com/OffchainLabs/nitro/blob/c7f3429e2456bf5ca296a49cec3bb437420bc2bb/contracts/src/libraries/MessageTypes.sol](https://github.com/OffchainLabs/nitro/blob/c7f3429e2456bf5ca296a49cec3bb437420bc2bb/contracts/src/libraries/MessageTypes.sol)

#### Enumeration Members[​](#enumeration-members "Direct link to Enumeration Members")

Enumeration Member

Value

`L1MessageType_ethDeposit`

`12`

`L1MessageType_submitRetryableTx`

`9`

`L2MessageType_signedTx`

`4`

Interfaces[​](#interfaces "Direct link to Interfaces")
------------------------------------------------------

### RetryableMessageParams[​](#retryablemessageparams "Direct link to RetryableMessageParams")

The components of a submit retryable message. Can be parsed from the events emitted from the Inbox.

#### Properties[​](#properties "Direct link to Properties")

Property

Type

Description

`callValueRefundAddress`

`string`

Address to credit l2Callvalue on L2 if retryable txn times out or gets cancelled

`data`

`string`

Calldata for of the L2 message

`destAddress`

`string`

Destination address for L2 message

`excessFeeRefundAddress`

`string`

L2 address address to credit (gaslimit x gasprice - execution cost)

`gasLimit`

`BigNumber`

Max gas deducted from user's L2 balance to cover L2 execution

`l1Value`

`BigNumber`

Value sent at L1

`l2CallValue`

`BigNumber`

Call value in L2 message

`maxFeePerGas`

`BigNumber`

Gas price for L2 execution

`maxSubmissionFee`

`BigNumber`

Max gas deducted from L2 balance to cover base submission fee

---

# networks | Arbitrum Docs

## networks

Interfaces[​](#interfaces "Direct link to Interfaces")
------------------------------------------------------

### ArbitrumNetwork[​](#arbitrumnetwork "Direct link to ArbitrumNetwork")

Represents an Arbitrum chain, e.g. Arbitrum One, Arbitrum Sepolia, or an L3 chain.

#### Properties[​](#properties "Direct link to Properties")

Property

Type

Description

`chainId`

`number`

Id of the chain.

`confirmPeriodBlocks`

`number`

The time allowed for validators to dispute or challenge state assertions. Measured in L1 blocks.

`ethBridge`

`EthBridge`

The core contracts

`isBold?`

`boolean`

Has the network been upgraded to bold. True if yes, otherwise undefined  
This is a temporary property and will be removed in future if Bold is widely adopted and  
the legacy challenge protocol is deprecated

`isCustom`

`boolean`

Whether or not the chain was registered by the user.

`isTestnet`

`boolean`

Whether or not it is a testnet chain.

`name`

`string`

Name of the chain.

`nativeToken?`

`string`

In case of a chain that uses ETH as its native/gas token, this is either `undefined` or the zero address  
  
In case of a chain that uses an ERC-20 token from the parent chain as its native/gas token, this is the address of said token on the parent chain

`parentChainId`

`number`

Chain id of the parent chain, i.e. the chain on which this chain settles to.

`retryableLifetimeSeconds?`

`number`

Represents how long a retryable ticket lasts for before it expires (in seconds). Defaults to 7 days.

`teleporter?`

`Teleporter`

The teleporter contracts.

`tokenBridge?`

`TokenBridge`

The token bridge contracts.

* * *

### L2NetworkTokenBridge[​](#l2networktokenbridge "Direct link to l2networktokenbridge")

This type is only here for when you want to achieve backwards compatibility between SDK v3 and v4.

Please see TokenBridge for the latest type.

#### Deprecated[​](#deprecated "Direct link to Deprecated")

since v4

Type Aliases[​](#type-aliases "Direct link to Type Aliases")
------------------------------------------------------------

### L2Network[​](#l2network "Direct link to l2network")

```rust
type L2Network: Prettify<Omit<ArbitrumNetwork, "chainId" | "parentChainId" | "tokenBridge"> & object>;
```

This type is only here for when you want to achieve backwards compatibility between SDK v3 and v4.

Please see [ArbitrumNetwork](/sdk/reference/dataEntities/networks#arbitrumnetwork) for the latest type.

#### Deprecated[​](#deprecated-1 "Direct link to Deprecated")

since v4

#### Source[​](#source "Direct link to Source")

[dataEntities/networks.ts:94](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/networks.ts#L94)

Functions[​](#functions "Direct link to Functions")
---------------------------------------------------

### assertArbitrumNetworkHasTokenBridge()[​](#assertarbitrumnetworkhastokenbridge "Direct link to assertArbitrumNetworkHasTokenBridge()")

```rust
function assertArbitrumNetworkHasTokenBridge<T>(network: T): asserts network is T & Object
```

Asserts that the given object has a token bridge. This is useful because not all Arbitrum network operations require a token bridge.

#### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T` _extends_ [`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

#### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`network`

`T`

[ArbitrumNetwork](/sdk/reference/dataEntities/networks#arbitrumnetwork) object

#### Returns[​](#returns "Direct link to Returns")

`asserts network is T & Object`

#### Throws[​](#throws "Direct link to Throws")

ArbSdkError if the object does not have a token bridge

#### Source[​](#source-1 "Direct link to Source")

[dataEntities/networks.ts:554](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/networks.ts#L554)

* * *

### getArbitrumNetwork()[​](#getarbitrumnetwork "Direct link to getArbitrumNetwork()")

```rust
function getArbitrumNetwork(chainId: number): ArbitrumNetwork
```

Returns the Arbitrum chain associated with the given signer, provider or chain id.

#### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

`chainId`

`number`

#### Returns[​](#returns-1 "Direct link to Returns")

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

#### Note[​](#note "Direct link to Note")

Throws if the chain is not an Arbitrum chain.

#### Source[​](#source-2 "Direct link to Source")

[dataEntities/networks.ts:316](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/networks.ts#L316)

* * *

### getArbitrumNetworkInformationFromRollup()[​](#getarbitrumnetworkinformationfromrollup "Direct link to getArbitrumNetworkInformationFromRollup()")

```rust
function getArbitrumNetworkInformationFromRollup(rollupAddress: string, parentProvider: Provider): Promise<ArbitrumNetworkInformationFromRollup>
```

Returns all the information about an Arbitrum network that can be fetched from its Rollup contract.

#### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`rollupAddress`

`string`

Address of the Rollup contract on the parent chain

`parentProvider`

`Provider`

Provider for the parent chain

#### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`ArbitrumNetworkInformationFromRollup`\>

An ArbitrumNetworkInformationFromRollup object

#### Source[​](#source-3 "Direct link to Source")

[dataEntities/networks.ts:376](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/networks.ts#L376)

* * *

### getArbitrumNetworks()[​](#getarbitrumnetworks "Direct link to getArbitrumNetworks()")

```rust
function getArbitrumNetworks(): ArbitrumNetwork[]
```

Returns all Arbitrum networks registered in the SDK, both default and custom.

#### Returns[​](#returns-3 "Direct link to Returns")

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)\[\]

#### Source[​](#source-4 "Direct link to Source")

[dataEntities/networks.ts:359](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/networks.ts#L359)

* * *

### getChildrenForNetwork()[​](#getchildrenfornetwork "Direct link to getChildrenForNetwork()")

```rust
function getChildrenForNetwork(parentChainOrChainId: number | ArbitrumNetwork): ArbitrumNetwork[]
```

Returns a list of children chains for the given chain or chain id.

#### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

`parentChainOrChainId`

`number` | [`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

#### Returns[​](#returns-4 "Direct link to Returns")

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)\[\]

#### Source[​](#source-5 "Direct link to Source")

[dataEntities/networks.ts:298](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/networks.ts#L298)

* * *

### isParentNetwork()[​](#isparentnetwork "Direct link to isParentNetwork()")

```rust
function isParentNetwork(parentChainOrChainId: number | ArbitrumNetwork): boolean
```

Determines if a chain is a parent of _any_ other chain. Could be an L1 or an L2 chain.

#### Parameters[​](#parameters-4 "Direct link to Parameters")

Parameter

Type

`parentChainOrChainId`

`number` | [`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

#### Returns[​](#returns-5 "Direct link to Returns")

`boolean`

#### Source[​](#source-6 "Direct link to Source")

[dataEntities/networks.ts:283](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/networks.ts#L283)

* * *

### mapL2NetworkToArbitrumNetwork()[​](#mapl2networktoarbitrumnetwork "Direct link to mapL2NetworkToArbitrumNetwork()")

```rust
function mapL2NetworkToArbitrumNetwork(l2Network: object): ArbitrumNetwork
```

Maps the old [L2Network](/sdk/reference/dataEntities/networks#l2network) (from SDK v3) to [ArbitrumNetwork](/sdk/reference/dataEntities/networks#arbitrumnetwork) (from SDK v4).

#### Parameters[​](#parameters-5 "Direct link to Parameters")

Parameter

Type

Description

`l2Network`

`object`

\-

`l2Network.chainID`

`number`

\-

`l2Network.confirmPeriodBlocks`

`number`

The time allowed for validators to dispute or challenge state assertions. Measured in L1 blocks.

`l2Network.ethBridge`

`EthBridge`

The core contracts

`l2Network.isBold`?

`boolean`

Has the network been upgraded to bold. True if yes, otherwise undefined  
This is a temporary property and will be removed in future if Bold is widely adopted and  
the legacy challenge protocol is deprecated

`l2Network.isCustom`

`boolean`

Whether or not the chain was registered by the user.

`l2Network.isTestnet`

`boolean`

Whether or not it is a testnet chain.

`l2Network.name`

`string`

Name of the chain.

`l2Network.nativeToken`?

`string`

In case of a chain that uses ETH as its native/gas token, this is either `undefined` or the zero address  
  
In case of a chain that uses an ERC-20 token from the parent chain as its native/gas token, this is the address of said token on the parent chain

`l2Network.partnerChainID`

`number`

\-

`l2Network.retryableLifetimeSeconds`?

`number`

Represents how long a retryable ticket lasts for before it expires (in seconds). Defaults to 7 days.

`l2Network.teleporter`?

`Teleporter`

The teleporter contracts.

`l2Network.tokenBridge`

[`L2NetworkTokenBridge`](/sdk/reference/dataEntities/networks#l2networktokenbridge)

\-

#### Returns[​](#returns-6 "Direct link to Returns")

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

#### Source[​](#source-7 "Direct link to Source")

[dataEntities/networks.ts:534](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/networks.ts#L534)

* * *

### mapL2NetworkTokenBridgeToTokenBridge()[​](#mapl2networktokenbridgetotokenbridge "Direct link to mapL2NetworkTokenBridgeToTokenBridge()")

```rust
function mapL2NetworkTokenBridgeToTokenBridge(input: L2NetworkTokenBridge): TokenBridge
```

Maps the old L2Network.tokenBridge (from SDK v3) to [ArbitrumNetwork.tokenBridge](/sdk/reference/dataEntities/networks#arbitrumnetwork) (from SDK v4).

#### Parameters[​](#parameters-6 "Direct link to Parameters")

Parameter

Type

`input`

[`L2NetworkTokenBridge`](/sdk/reference/dataEntities/networks#l2networktokenbridge)

#### Returns[​](#returns-7 "Direct link to Returns")

`TokenBridge`

#### Source[​](#source-8 "Direct link to Source")

[dataEntities/networks.ts:510](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/networks.ts#L510)

* * *

### registerCustomArbitrumNetwork()[​](#registercustomarbitrumnetwork "Direct link to registerCustomArbitrumNetwork()")

```rust
function registerCustomArbitrumNetwork(network: ArbitrumNetwork, options?: object): ArbitrumNetwork
```

Registers a custom Arbitrum network.

#### Parameters[​](#parameters-7 "Direct link to Parameters")

Parameter

Type

Description

`network`

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

[ArbitrumNetwork](/sdk/reference/dataEntities/networks#arbitrumnetwork) to be registered

`options`?

`object`

Additional options

`options.throwIfAlreadyRegistered`?

`boolean`

Whether or not the function should throw if the network is already registered, defaults to `false`

#### Returns[​](#returns-8 "Direct link to Returns")

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

#### Source[​](#source-9 "Direct link to Source")

[dataEntities/networks.ts:415](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/networks.ts#L415)

---

# retryableData | Arbitrum Docs

## retryableData

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### RetryableDataTools[​](#retryabledatatools "Direct link to RetryableDataTools")

Tools for parsing retryable data from errors. When calling createRetryableTicket on Inbox.sol special values can be passed for gasLimit and maxFeePerGas. This causes the call to revert with the info needed to estimate the gas needed for a retryable ticket using L1ToL2GasPriceEstimator.

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Default value

Description

`ErrorTriggeringParams`

`static`

`object`

`...`

The parameters that should be passed to createRetryableTicket in order to induce  
a revert with retryable data

`ErrorTriggeringParams.gasLimit`

`public`

`BigNumber`

`...`

\-

`ErrorTriggeringParams.maxFeePerGas`

`public`

`BigNumber`

`...`

\-

#### Methods[​](#methods "Direct link to Methods")

##### tryParseError()[​](#tryparseerror "Direct link to tryParseError()")

```rust
static tryParseError(ethersJsErrorOrData: string | Error | object): null | RetryableData
```

Try to parse a retryable data struct from the supplied ethersjs error, or any explicitly supplied error data

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`ethersJsErrorOrData`

`string` | `Error` | `object`

###### Returns[​](#returns "Direct link to Returns")

`null` | `RetryableData`

###### Source[​](#source "Direct link to Source")

[dataEntities/retryableData.ts:114](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/retryableData.ts#L114)

---

# rpc | Arbitrum Docs

## rpc

Interfaces[​](#interfaces "Direct link to Interfaces")
------------------------------------------------------

### ArbTransactionReceipt[​](#arbtransactionreceipt "Direct link to ArbTransactionReceipt")

Eth transaction receipt with additional arbitrum specific fields

#### Extends[​](#extends "Direct link to Extends")

*   `TransactionReceipt`

#### Properties[​](#properties "Direct link to Properties")

Property

Type

Description

`gasUsedForL1`

`BigNumber`

Amount of gas spent on l1 computation in units of l2 gas

`l1BlockNumber`

`number`

The l1 block number that would be used for block.number calls  
that occur within this transaction.  
See [https://developer.offchainlabs.com/docs/time\_in\_arbitrum](https://developer.offchainlabs.com/docs/time_in_arbitrum)

---

# signerOrProvider | Arbitrum Docs

## signerOrProvider

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### SignerProviderUtils[​](#signerproviderutils "Direct link to SignerProviderUtils")

Utility functions for signer/provider union types

#### Methods[​](#methods "Direct link to Methods")

##### checkNetworkMatches()[​](#checknetworkmatches "Direct link to checkNetworkMatches()")

```rust
static checkNetworkMatches(signerOrProvider: SignerOrProvider, chainId: number): Promise<void>
```

Checks that the signer/provider that's provider matches the chain id Throws if not.

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`signerOrProvider`

`SignerOrProvider`

`chainId`

`number`

###### Returns[​](#returns "Direct link to Returns")

`Promise`<`void`\>

###### Source[​](#source "Direct link to Source")

[dataEntities/signerOrProvider.ts:56](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/signerOrProvider.ts#L56)

##### getProvider()[​](#getprovider "Direct link to getProvider()")

```rust
static getProvider(signerOrProvider: SignerOrProvider): undefined | Provider
```

If signerOrProvider is a provider then return itself. If signerOrProvider is a signer then return signer.provider

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`signerOrProvider`

`SignerOrProvider`

###### Returns[​](#returns-1 "Direct link to Returns")

`undefined` | `Provider`

###### Source[​](#source-1 "Direct link to Source")

[dataEntities/signerOrProvider.ts:24](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/signerOrProvider.ts#L24)

##### signerHasProvider()[​](#signerhasprovider "Direct link to signerHasProvider()")

```rust
static signerHasProvider(signer: Signer): signer is Signer & Object
```

Check if the signer has a connected provider

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`signer`

`Signer`

###### Returns[​](#returns-2 "Direct link to Returns")

`signer is Signer & Object`

###### Source[​](#source-2 "Direct link to Source")

[dataEntities/signerOrProvider.ts:44](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/signerOrProvider.ts#L44)

---

# transactionRequest | Arbitrum Docs

## transactionRequest

Interfaces[​](#interfaces "Direct link to Interfaces")
------------------------------------------------------

### ChildToParentTransactionRequest[​](#childtoparenttransactionrequest "Direct link to ChildToParentTransactionRequest")

A transaction request for a transaction that will trigger a child to parent message

#### Properties[​](#properties "Direct link to Properties")

Property

Type

Description

`estimateParentGasLimit`

(`l1Provider`: `Provider`) => `Promise`<`BigNumber`\>

Estimate the gas limit required to execute the withdrawal on the parent chain.  
Note that this is only a rough estimate as it may not be possible to know  
the exact size of the proof straight away, however the real value should be  
within a few thousand gas of this estimate.

* * *

### ParentToChildTransactionRequest[​](#parenttochildtransactionrequest "Direct link to ParentToChildTransactionRequest")

A transaction request for a transaction that will trigger some sort of execution on the child chain

#### Properties[​](#properties-1 "Direct link to Properties")

Property

Type

Description

`retryableData`

[`OmitTyped`](/sdk/reference/utils/types#omittypedtk)<`ParentToChildMessageNoGasParams`, `"excessFeeRefundAddress"` | `"callValueRefundAddress"`\> & `Partial`<`ParentToChildMessageNoGasParams`\> & `ParentToChildMessageGasParams`

Information about the retryable ticket, and it's subsequent execution, that  
will occur on the child chain

`txRequest`

`Required`<`Pick`<`TransactionRequest`, `"data"` | `"value"` | `"from"` | `"to"`\>>

Core fields needed to form the parent component of the transaction request

#### Methods[​](#methods "Direct link to Methods")

##### isValid()[​](#isvalid "Direct link to isValid()")

```rust
isValid(): Promise<boolean>
```

If this request were sent now, would it have enough margin to reliably succeed

###### Returns[​](#returns "Direct link to Returns")

`Promise`<`boolean`\>

###### Source[​](#source "Direct link to Source")

[dataEntities/transactionRequest.ts:28](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/transactionRequest.ts#L28)

Functions[​](#functions "Direct link to Functions")
---------------------------------------------------

### isChildToParentTransactionRequest()[​](#ischildtoparenttransactionrequest "Direct link to isChildToParentTransactionRequest()")

```rust
function isChildToParentTransactionRequest<T>(possibleRequest: ChildToParentTransactionRequest | IsNotTransactionRequest<T>): possibleRequest is ChildToParentTransactionRequest
```

Check if an object is of ChildToParentTransactionRequest type

#### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T`

#### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`possibleRequest`

[`ChildToParentTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#childtoparenttransactionrequest) | `IsNotTransactionRequest`<`T`\>

#### Returns[​](#returns-1 "Direct link to Returns")

`possibleRequest is ChildToParentTransactionRequest`

#### Source[​](#source-1 "Direct link to Source")

[dataEntities/transactionRequest.ts:70](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/transactionRequest.ts#L70)

* * *

### isParentToChildTransactionRequest()[​](#isparenttochildtransactionrequest "Direct link to isParentToChildTransactionRequest()")

```rust
function isParentToChildTransactionRequest<T>(possibleRequest: ParentToChildTransactionRequest | IsNotTransactionRequest<T>): possibleRequest is ParentToChildTransactionRequest
```

Check if an object is of ParentToChildTransactionRequest type

#### Type parameters[​](#type-parameters-1 "Direct link to Type parameters")

Type parameter

`T`

#### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`possibleRequest`

[`ParentToChildTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#parenttochildtransactionrequest) | `IsNotTransactionRequest`<`T`\>

#### Returns[​](#returns-2 "Direct link to Returns")

`possibleRequest is ParentToChildTransactionRequest`

#### Source[​](#source-2 "Direct link to Source")

[dataEntities/transactionRequest.ts:57](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/dataEntities/transactionRequest.ts#L57)

---

# inbox | Arbitrum Docs

## inbox

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### InboxTools[​](#inboxtools "Direct link to InboxTools")

Tools for interacting with the inbox and bridge contracts

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Description

`parentProvider`

`private`

`Provider`

Parent chain provider

#### Methods[​](#methods "Direct link to Methods")

##### estimateArbitrumGas()[​](#estimatearbitrumgas "Direct link to estimateArbitrumGas()")

```rust
private estimateArbitrumGas(childTransactionRequest: RequiredTransactionRequestType, childProvider: Provider): Promise<GasComponentsWithChildPart>
```

We should use nodeInterface to get the gas estimate is because we are making a delayed inbox message which doesn't need parent calldata gas fee part.

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

`childTransactionRequest`

`RequiredTransactionRequestType`

`childProvider`

`Provider`

###### Returns[​](#returns "Direct link to Returns")

`Promise`<`GasComponentsWithChildPart`\>

###### Source[​](#source "Direct link to Source")

[inbox/inbox.ts:156](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/inbox/inbox.ts#L156)

##### findFirstBlockBelow()[​](#findfirstblockbelow "Direct link to findFirstBlockBelow()")

```rust
private findFirstBlockBelow(blockNumber: number, blockTimestamp: number): Promise<Block>
```

Find the first (or close to first) block whose number is below the provided number, and whose timestamp is below the provided timestamp

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`blockNumber`

`number`

`blockTimestamp`

`number`

###### Returns[​](#returns-1 "Direct link to Returns")

`Promise`<`Block`\>

###### Source[​](#source-1 "Direct link to Source")

[inbox/inbox.ts:87](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/inbox/inbox.ts#L87)

##### forceInclude()[​](#forceinclude "Direct link to forceInclude()")

```rust
forceInclude<T>(messageDeliveredEvent?: T, overrides?: Overrides): Promise<T extends ForceInclusionParams ? ContractTransaction : null | ContractTransaction>
```

Force includes all eligible messages in the delayed inbox. The inbox contract doesn't allow a message to be force-included until after a delay period has been completed.

###### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T` _extends_ `undefined` | `ForceInclusionParams`

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`messageDeliveredEvent`?

`T`

Provide this to include all messages up to this one. Responsibility is on the caller to check the eligibility of this event.

`overrides`?

`Overrides`

\-

###### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`T` _extends_ `ForceInclusionParams` ? `ContractTransaction` : `null` | `ContractTransaction`\>

The force include transaction, or null if no eligible message were found for inclusion

###### Source[​](#source-2 "Direct link to Source")

[inbox/inbox.ts:356](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/inbox/inbox.ts#L356)

##### getEventsAndIncreaseRange()[​](#geteventsandincreaserange "Direct link to getEventsAndIncreaseRange()")

```rust
private getEventsAndIncreaseRange(
   bridge: Bridge, 
   searchRangeBlocks: number, 
   maxSearchRangeBlocks: number, 
rangeMultiplier: number): Promise<FetchedEvent<MessageDeliveredEvent>[]>
```

Look for force includable events in the search range blocks, if no events are found the search range is increased incrementally up to the max search range blocks.

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

Description

`bridge`

`Bridge`

`searchRangeBlocks`

`number`

`maxSearchRangeBlocks`

`number`

`rangeMultiplier`

`number`

\-

###### Returns[​](#returns-3 "Direct link to Returns")

`Promise`<`FetchedEvent`<`MessageDeliveredEvent`\>\[\]>

###### Source[​](#source-3 "Direct link to Source")

[inbox/inbox.ts:256](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/inbox/inbox.ts#L256)

##### getForceIncludableBlockRange()[​](#getforceincludableblockrange "Direct link to getForceIncludableBlockRange()")

```rust
private getForceIncludableBlockRange(blockNumberRangeSize: number): Promise<object>
```

Get a range of blocks within messages eligible for force inclusion emitted events

###### Parameters[​](#parameters-4 "Direct link to Parameters")

Parameter

Type

Description

`blockNumberRangeSize`

`number`

###### Returns[​](#returns-4 "Direct link to Returns")

`Promise`<`object`\>

Member

Type

Value

`endBlock`

`number`

firstEligibleBlock.number

`startBlock`

`number`

...

###### Source[​](#source-4 "Direct link to Source")

[inbox/inbox.ts:186](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/inbox/inbox.ts#L186)

##### getForceIncludableEvent()[​](#getforceincludableevent "Direct link to getForceIncludableEvent()")

```rust
getForceIncludableEvent(
   maxSearchRangeBlocks: number, 
   startSearchRangeBlocks: number, 
rangeMultiplier: number): Promise<null | ForceInclusionParams>
```

Find the event of the latest message that can be force include

###### Parameters[​](#parameters-5 "Direct link to Parameters")

Parameter

Type

Default value

Description

`maxSearchRangeBlocks`

`number`

`undefined`

The max range of blocks to search in.  
Defaults to 3 \* 6545 ( = ~3 days) prior to the first eligible block

`startSearchRangeBlocks`

`number`

`100`

The start range of block to search in.  
Moves incrementally up to the maxSearchRangeBlocks. Defaults to 100;

`rangeMultiplier`

`number`

`2`

The multiplier to use when increasing the block range  
Defaults to 2.

###### Returns[​](#returns-5 "Direct link to Returns")

`Promise`<`null` | `ForceInclusionParams`\>

Null if non can be found.

###### Source[​](#source-5 "Direct link to Source")

[inbox/inbox.ts:307](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/inbox/inbox.ts#L307)

##### sendChildSignedTx()[​](#sendchildsignedtx "Direct link to sendChildSignedTx()")

```rust
sendChildSignedTx(signedTx: string): Promise<null | ContractTransaction>
```

Send Child Chain signed tx using delayed inbox, which won't alias the sender's address It will be automatically included by the sequencer on Chain, if it isn't included within 24 hours, you can force include it

###### Parameters[​](#parameters-6 "Direct link to Parameters")

Parameter

Type

Description

`signedTx`

`string`

A signed transaction which can be sent directly to chain,  
you can call inboxTools.signChainMessage to get.

###### Returns[​](#returns-6 "Direct link to Returns")

`Promise`<`null` | `ContractTransaction`\>

The parent delayed inbox's transaction itself.

###### Source[​](#source-6 "Direct link to Source")

[inbox/inbox.ts:401](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/inbox/inbox.ts#L401)

##### signChildTx()[​](#signchildtx "Direct link to signChildTx()")

```rust
signChildTx(txRequest: RequiredTransactionRequestType, childSigner: Signer): Promise<string>
```

Sign a transaction with msg.to, msg.value and msg.data. You can use this as a helper to call inboxTools.sendChainSignedMessage above.

###### Parameters[​](#parameters-7 "Direct link to Parameters")

Parameter

Type

Description

`txRequest`

`RequiredTransactionRequestType`

A signed transaction which can be sent directly to chain,  
tx.to, tx.data, tx.value must be provided when not contract creation, if  
contractCreation is true, no need provide tx.to. tx.gasPrice and tx.nonce  
can be overrided. (You can also send contract creation transaction by set tx.to  
to zero address or null)

`childSigner`

`Signer`

ethers Signer type, used to sign Chain transaction

###### Returns[​](#returns-7 "Direct link to Returns")

`Promise`<`string`\>

The parent delayed inbox's transaction signed data.

###### Source[​](#source-7 "Direct link to Source")

[inbox/inbox.ts:429](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/inbox/inbox.ts#L429)

---

# ChildToParentMessage | Arbitrum Docs

## ChildToParentMessage

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### ChildToParentMessage[​](#childtoparentmessage "Direct link to ChildToParentMessage")

Base functionality for Child-to-Parent messages

#### Extended by[​](#extended-by "Direct link to Extended by")

*   [`ChildToParentMessageReader`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereader)

#### Methods[​](#methods "Direct link to Methods")

##### fromEvent()[​](#fromevent "Direct link to fromEvent()")

```rust
static fromEvent<T>(
   parentSignerOrProvider: T, 
   event: ChildToParentTransactionEvent, 
parentProvider?: Provider): ChildToParentMessageReaderOrWriter<T>
```

Instantiates a new `ChildToParentMessageWriter` or `ChildToParentMessageReader` object.

###### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`parentSignerOrProvider`

`T`

Signer or provider to be used for executing or reading the Child-to-Parent message.

`event`

`ChildToParentTransactionEvent`

The event containing the data of the Child-to-Parent message.

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `ParentSignerOrProvider` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns "Direct link to Returns")

[`ChildToParentMessageReaderOrWriter`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereaderorwritert)<`T`\>

###### Source[​](#source "Direct link to Source")

[message/ChildToParentMessage.ts:76](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L76)

##### getChildToParentEvents()[​](#getchildtoparentevents "Direct link to getChildToParentEvents()")

```rust
static getChildToParentEvents(
   childProvider: Provider, 
   filter: object, 
   position?: BigNumber, 
   destination?: string, 
   hash?: BigNumber, 
indexInBatch?: BigNumber): Promise<ChildToParentTransactionEvent & object[]>
```

Get event logs for ChildToParent transactions.

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`filter`

`object`

Block range filter

`filter.fromBlock`

`BlockTag`

\-

`filter.toBlock`?

`BlockTag`

\-

`position`?

`BigNumber`

The batchnumber indexed field was removed in nitro and a position indexed field was added.  
For pre-nitro events the value passed in here will be used to find events with the same batchnumber.  
For post nitro events it will be used to find events with the same position.

`destination`?

`string`

The parent destination of the ChildToParent message

`hash`?

`BigNumber`

The uniqueId indexed field was removed in nitro and a hash indexed field was added.  
For pre-nitro events the value passed in here will be used to find events with the same uniqueId.  
For post nitro events it will be used to find events with the same hash.

`indexInBatch`?

`BigNumber`

The index in the batch, only valid for pre-nitro events. This parameter is ignored post-nitro

###### Returns[​](#returns-1 "Direct link to Returns")

`Promise`<`ChildToParentTransactionEvent` & `object`\[\]>

Any classic and nitro events that match the provided filters.

###### Source[​](#source-1 "Direct link to Source")

[message/ChildToParentMessage.ts:109](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L109)

* * *

### ChildToParentMessageReader[​](#childtoparentmessagereader "Direct link to ChildToParentMessageReader")

Provides read-only access for Child-to-Parent messages

#### Extends[​](#extends "Direct link to Extends")

*   [`ChildToParentMessage`](/sdk/reference/message/ChildToParentMessage#childtoparentmessage)

#### Extended by[​](#extended-by-1 "Direct link to Extended by")

*   [`ChildToParentMessageWriter`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagewriter)

#### Methods[​](#methods-1 "Direct link to Methods")

##### getFirstExecutableBlock()[​](#getfirstexecutableblock "Direct link to getFirstExecutableBlock()")

```rust
getFirstExecutableBlock(childProvider: Provider): Promise<null | BigNumber>
```

Estimates the Parent block number in which this Child-to-Parent tx will be available for execution. If the message can or already has been executed, this returns null

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`null` | `BigNumber`\>

expected Parent block number where the Child-to-Parent message will be executable. Returns null if the message can or already has been executed

###### Source[​](#source-2 "Direct link to Source")

[message/ChildToParentMessage.ts:273](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L273)

##### status()[​](#status "Direct link to status()")

```rust
status(childProvider: Provider): Promise<ChildToParentMessageStatus>
```

Get the status of this message In order to check if the message has been executed proof info must be provided.

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

###### Returns[​](#returns-3 "Direct link to Returns")

`Promise`<`ChildToParentMessageStatus`\>

###### Source[​](#source-3 "Direct link to Source")

[message/ChildToParentMessage.ts:237](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L237)

##### waitUntilReadyToExecute()[​](#waituntilreadytoexecute "Direct link to waitUntilReadyToExecute()")

```rust
waitUntilReadyToExecute(childProvider: Provider, retryDelay: number): Promise<CONFIRMED | EXECUTED>
```

Waits until the outbox entry has been created, and will not return until it has been. WARNING: Outbox entries are only created when the corresponding node is confirmed. Which can take 1 week+, so waiting here could be a very long operation.

###### Parameters[​](#parameters-4 "Direct link to Parameters")

Parameter

Type

Default value

Description

`childProvider`

`Provider`

`undefined`

\-

`retryDelay`

`number`

`500`

###### Returns[​](#returns-4 "Direct link to Returns")

`Promise`<`CONFIRMED` | `EXECUTED`\>

outbox entry status (either executed or confirmed but not pending)

###### Source[​](#source-4 "Direct link to Source")

[message/ChildToParentMessage.ts:252](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L252)

##### fromEvent()[​](#fromevent-1 "Direct link to fromEvent()")

```rust
static fromEvent<T>(
   parentSignerOrProvider: T, 
   event: ChildToParentTransactionEvent, 
parentProvider?: Provider): ChildToParentMessageReaderOrWriter<T>
```

Instantiates a new `ChildToParentMessageWriter` or `ChildToParentMessageReader` object.

###### Type parameters[​](#type-parameters-1 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-5 "Direct link to Parameters")

Parameter

Type

Description

`parentSignerOrProvider`

`T`

Signer or provider to be used for executing or reading the Child-to-Parent message.

`event`

`ChildToParentTransactionEvent`

The event containing the data of the Child-to-Parent message.

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `ParentSignerOrProvider` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns-5 "Direct link to Returns")

[`ChildToParentMessageReaderOrWriter`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereaderorwritert)<`T`\>

###### Inherited from[​](#inherited-from "Direct link to Inherited from")

[`ChildToParentMessage`](/sdk/reference/message/ChildToParentMessage#childtoparentmessage) . [`fromEvent`](/sdk/reference/message/ChildToParentMessage#fromevent)

###### Source[​](#source-5 "Direct link to Source")

[message/ChildToParentMessage.ts:76](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L76)

##### getChildToParentEvents()[​](#getchildtoparentevents-1 "Direct link to getChildToParentEvents()")

```rust
static getChildToParentEvents(
   childProvider: Provider, 
   filter: object, 
   position?: BigNumber, 
   destination?: string, 
   hash?: BigNumber, 
indexInBatch?: BigNumber): Promise<ChildToParentTransactionEvent & object[]>
```

Get event logs for ChildToParent transactions.

###### Parameters[​](#parameters-6 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`filter`

`object`

Block range filter

`filter.fromBlock`

`BlockTag`

\-

`filter.toBlock`?

`BlockTag`

\-

`position`?

`BigNumber`

The batchnumber indexed field was removed in nitro and a position indexed field was added.  
For pre-nitro events the value passed in here will be used to find events with the same batchnumber.  
For post nitro events it will be used to find events with the same position.

`destination`?

`string`

The parent destination of the ChildToParent message

`hash`?

`BigNumber`

The uniqueId indexed field was removed in nitro and a hash indexed field was added.  
For pre-nitro events the value passed in here will be used to find events with the same uniqueId.  
For post nitro events it will be used to find events with the same hash.

`indexInBatch`?

`BigNumber`

The index in the batch, only valid for pre-nitro events. This parameter is ignored post-nitro

###### Returns[​](#returns-6 "Direct link to Returns")

`Promise`<`ChildToParentTransactionEvent` & `object`\[\]>

Any classic and nitro events that match the provided filters.

###### Inherited from[​](#inherited-from-1 "Direct link to Inherited from")

[`ChildToParentMessage`](/sdk/reference/message/ChildToParentMessage#childtoparentmessage) . [`getChildToParentEvents`](/sdk/reference/message/ChildToParentMessage#getchildtoparentevents)

###### Source[​](#source-6 "Direct link to Source")

[message/ChildToParentMessage.ts:109](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L109)

* * *

### ChildToParentMessageWriter[​](#childtoparentmessagewriter "Direct link to ChildToParentMessageWriter")

Provides read and write access for Child-to-Parent messages

#### Extends[​](#extends-1 "Direct link to Extends")

*   [`ChildToParentMessageReader`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereader)

#### Constructors[​](#constructors "Direct link to Constructors")

##### new ChildToParentMessageWriter()[​](#new-childtoparentmessagewriter "Direct link to new ChildToParentMessageWriter()")

```rust
new ChildToParentMessageWriter(
   parentSigner: Signer, 
   event: ChildToParentTransactionEvent, 
   parentProvider?: Provider): ChildToParentMessageWriter
```

Instantiates a new `ChildToParentMessageWriter` object.

###### Parameters[​](#parameters-7 "Direct link to Parameters")

Parameter

Type

Description

`parentSigner`

`Signer`

The signer to be used for executing the Child-to-Parent message.

`event`

`ChildToParentTransactionEvent`

The event containing the data of the Child-to-Parent message.

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `parentSigner` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns-7 "Direct link to Returns")

[`ChildToParentMessageWriter`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagewriter)

###### Overrides[​](#overrides "Direct link to Overrides")

`ChildToParentMessageReader.constructor`

###### Source[​](#source-7 "Direct link to Source")

[message/ChildToParentMessage.ts:296](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L296)

#### Methods[​](#methods-2 "Direct link to Methods")

##### execute()[​](#execute "Direct link to execute()")

```rust
execute(childProvider: Provider, overrides?: Overrides): Promise<ContractTransaction>
```

Executes the ChildToParentMessage on Parent chain. Will throw an error if the outbox entry has not been created, which happens when the corresponding assertion is confirmed.

###### Parameters[​](#parameters-8 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

`overrides`?

`Overrides`

###### Returns[​](#returns-8 "Direct link to Returns")

`Promise`<`ContractTransaction`\>

###### Source[​](#source-8 "Direct link to Source")

[message/ChildToParentMessage.ts:325](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L325)

##### getFirstExecutableBlock()[​](#getfirstexecutableblock-1 "Direct link to getFirstExecutableBlock()")

```rust
getFirstExecutableBlock(childProvider: Provider): Promise<null | BigNumber>
```

Estimates the Parent block number in which this Child-to-Parent tx will be available for execution. If the message can or already has been executed, this returns null

###### Parameters[​](#parameters-9 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-9 "Direct link to Returns")

`Promise`<`null` | `BigNumber`\>

expected Parent block number where the Child-to-Parent message will be executable. Returns null if the message can or already has been executed

###### Inherited from[​](#inherited-from-2 "Direct link to Inherited from")

[`ChildToParentMessageReader`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereader) . [`getFirstExecutableBlock`](/sdk/reference/message/ChildToParentMessage#getfirstexecutableblock)

###### Source[​](#source-9 "Direct link to Source")

[message/ChildToParentMessage.ts:273](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L273)

##### status()[​](#status-1 "Direct link to status()")

```rust
status(childProvider: Provider): Promise<ChildToParentMessageStatus>
```

Get the status of this message In order to check if the message has been executed proof info must be provided.

###### Parameters[​](#parameters-10 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

###### Returns[​](#returns-10 "Direct link to Returns")

`Promise`<`ChildToParentMessageStatus`\>

###### Inherited from[​](#inherited-from-3 "Direct link to Inherited from")

[`ChildToParentMessageReader`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereader) . [`status`](/sdk/reference/message/ChildToParentMessage#status)

###### Source[​](#source-10 "Direct link to Source")

[message/ChildToParentMessage.ts:237](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L237)

##### waitUntilReadyToExecute()[​](#waituntilreadytoexecute-1 "Direct link to waitUntilReadyToExecute()")

```rust
waitUntilReadyToExecute(childProvider: Provider, retryDelay: number): Promise<CONFIRMED | EXECUTED>
```

Waits until the outbox entry has been created, and will not return until it has been. WARNING: Outbox entries are only created when the corresponding node is confirmed. Which can take 1 week+, so waiting here could be a very long operation.

###### Parameters[​](#parameters-11 "Direct link to Parameters")

Parameter

Type

Default value

Description

`childProvider`

`Provider`

`undefined`

\-

`retryDelay`

`number`

`500`

###### Returns[​](#returns-11 "Direct link to Returns")

`Promise`<`CONFIRMED` | `EXECUTED`\>

outbox entry status (either executed or confirmed but not pending)

###### Inherited from[​](#inherited-from-4 "Direct link to Inherited from")

[`ChildToParentMessageReader`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereader) . [`waitUntilReadyToExecute`](/sdk/reference/message/ChildToParentMessage#waituntilreadytoexecute)

###### Source[​](#source-11 "Direct link to Source")

[message/ChildToParentMessage.ts:252](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L252)

##### fromEvent()[​](#fromevent-2 "Direct link to fromEvent()")

```rust
static fromEvent<T>(
   parentSignerOrProvider: T, 
   event: ChildToParentTransactionEvent, 
parentProvider?: Provider): ChildToParentMessageReaderOrWriter<T>
```

Instantiates a new `ChildToParentMessageWriter` or `ChildToParentMessageReader` object.

###### Type parameters[​](#type-parameters-2 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-12 "Direct link to Parameters")

Parameter

Type

Description

`parentSignerOrProvider`

`T`

Signer or provider to be used for executing or reading the Child-to-Parent message.

`event`

`ChildToParentTransactionEvent`

The event containing the data of the Child-to-Parent message.

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `ParentSignerOrProvider` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns-12 "Direct link to Returns")

[`ChildToParentMessageReaderOrWriter`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereaderorwritert)<`T`\>

###### Inherited from[​](#inherited-from-5 "Direct link to Inherited from")

[`ChildToParentMessageReader`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereader) . [`fromEvent`](/sdk/reference/message/ChildToParentMessage#fromevent-1)

###### Source[​](#source-12 "Direct link to Source")

[message/ChildToParentMessage.ts:76](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L76)

##### getChildToParentEvents()[​](#getchildtoparentevents-2 "Direct link to getChildToParentEvents()")

```rust
static getChildToParentEvents(
   childProvider: Provider, 
   filter: object, 
   position?: BigNumber, 
   destination?: string, 
   hash?: BigNumber, 
indexInBatch?: BigNumber): Promise<ChildToParentTransactionEvent & object[]>
```

Get event logs for ChildToParent transactions.

###### Parameters[​](#parameters-13 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`filter`

`object`

Block range filter

`filter.fromBlock`

`BlockTag`

\-

`filter.toBlock`?

`BlockTag`

\-

`position`?

`BigNumber`

The batchnumber indexed field was removed in nitro and a position indexed field was added.  
For pre-nitro events the value passed in here will be used to find events with the same batchnumber.  
For post nitro events it will be used to find events with the same position.

`destination`?

`string`

The parent destination of the ChildToParent message

`hash`?

`BigNumber`

The uniqueId indexed field was removed in nitro and a hash indexed field was added.  
For pre-nitro events the value passed in here will be used to find events with the same uniqueId.  
For post nitro events it will be used to find events with the same hash.

`indexInBatch`?

`BigNumber`

The index in the batch, only valid for pre-nitro events. This parameter is ignored post-nitro

###### Returns[​](#returns-13 "Direct link to Returns")

`Promise`<`ChildToParentTransactionEvent` & `object`\[\]>

Any classic and nitro events that match the provided filters.

###### Inherited from[​](#inherited-from-6 "Direct link to Inherited from")

[`ChildToParentMessageReader`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereader) . [`getChildToParentEvents`](/sdk/reference/message/ChildToParentMessage#getchildtoparentevents-1)

###### Source[​](#source-13 "Direct link to Source")

[message/ChildToParentMessage.ts:109](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L109)

Type Aliases[​](#type-aliases "Direct link to Type Aliases")
------------------------------------------------------------

### ChildToParentMessageReaderOrWriter<T>[​](#childtoparentmessagereaderorwritert "Direct link to ChildToParentMessageReaderOrWriter<T>")

```rust
type ChildToParentMessageReaderOrWriter<T>: T extends Provider ? ChildToParentMessageReader : ChildToParentMessageWriter;
```

Conditional type for Signer or Provider. If T is of type Provider then ChildToParentMessageReaderOrWriter<T> will be of type ChildToParentMessageReader. If T is of type Signer then ChildToParentMessageReaderOrWriter<T> will be of type ChildToParentMessageWriter.

#### Type parameters[​](#type-parameters-3 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

#### Source[​](#source-14 "Direct link to Source")

[message/ChildToParentMessage.ts:54](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessage.ts#L54)

---

# ChildToParentMessageClassic | Arbitrum Docs

## ChildToParentMessageClassic

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### ChildToParentMessageReaderClassic[​](#childtoparentmessagereaderclassic "Direct link to ChildToParentMessageReaderClassic")

Provides read-only access for classic Child-to-Parent-messages

#### Extends[​](#extends "Direct link to Extends")

*   `ChildToParentMessageClassic`

#### Extended by[​](#extended-by "Direct link to Extended by")

*   [`ChildToParentMessageWriterClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagewriterclassic)

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Default value

Description

Inherited from

`batchNumber`

`readonly`

`BigNumber`

`undefined`

The number of the batch this message is part of

`ChildToParentMessageClassic.batchNumber`

`indexInBatch`

`readonly`

`BigNumber`

`undefined`

The index of this message in the batch

`ChildToParentMessageClassic.indexInBatch`

`outboxAddress`

`protected`

`null` | `string`

`null`

Contains the classic outbox address, or set to zero address if this network  
did not have a classic outbox deployed

\-

#### Methods[​](#methods "Direct link to Methods")

##### getFirstExecutableBlock()[​](#getfirstexecutableblock "Direct link to getFirstExecutableBlock()")

```rust
getFirstExecutableBlock(childProvider: Provider): Promise<null | BigNumber>
```

Estimates the Parent Chain block number in which this Child-to-Parent tx will be available for execution

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns "Direct link to Returns")

`Promise`<`null` | `BigNumber`\>

Always returns null for classic chainToParentChain messages since they can be executed in any block now.

###### Source[​](#source "Direct link to Source")

[message/ChildToParentMessageClassic.ts:386](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L386)

##### getOutboxAddress()[​](#getoutboxaddress "Direct link to getOutboxAddress()")

```rust
protected getOutboxAddress(childProvider: Provider, batchNumber: number): Promise<string>
```

Classic had 2 outboxes, we need to find the correct one for the provided batch number

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`batchNumber`

`number`

###### Returns[​](#returns-1 "Direct link to Returns")

`Promise`<`string`\>

###### Source[​](#source-1 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:211](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L211)

##### hasExecuted()[​](#hasexecuted "Direct link to hasExecuted()")

```rust
hasExecuted(childProvider: Provider): Promise<boolean>
```

Check if given outbox message has already been executed

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

###### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`boolean`\>

###### Source[​](#source-2 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:301](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L301)

##### status()[​](#status "Direct link to status()")

```rust
status(childProvider: Provider): Promise<ChildToParentMessageStatus>
```

Get the status of this message In order to check if the message has been executed proof info must be provided.

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-3 "Direct link to Returns")

`Promise`<`ChildToParentMessageStatus`\>

###### Source[​](#source-3 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:339](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L339)

##### tryGetProof()[​](#trygetproof "Direct link to tryGetProof()")

```rust
tryGetProof(childProvider: Provider): Promise<null | MessageBatchProofInfo>
```

Get the execution proof for this message. Returns null if the batch does not exist yet.

###### Parameters[​](#parameters-4 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-4 "Direct link to Returns")

`Promise`<`null` | `MessageBatchProofInfo`\>

###### Source[​](#source-4 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:285](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L285)

##### waitUntilOutboxEntryCreated()[​](#waituntiloutboxentrycreated "Direct link to waitUntilOutboxEntryCreated()")

```rust
waitUntilOutboxEntryCreated(childProvider: Provider, retryDelay: number): Promise<CONFIRMED | EXECUTED>
```

Waits until the outbox entry has been created, and will not return until it has been. WARNING: Outbox entries are only created when the corresponding node is confirmed. Which can take 1 week+, so waiting here could be a very long operation.

###### Parameters[​](#parameters-5 "Direct link to Parameters")

Parameter

Type

Default value

Description

`childProvider`

`Provider`

`undefined`

\-

`retryDelay`

`number`

`500`

###### Returns[​](#returns-5 "Direct link to Returns")

`Promise`<`CONFIRMED` | `EXECUTED`\>

outbox entry status (either executed or confirmed but not pending)

###### Source[​](#source-5 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:364](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L364)

##### fromBatchNumber()[​](#frombatchnumber "Direct link to fromBatchNumber()")

```rust
static fromBatchNumber<T>(
   parentSignerOrProvider: T, 
   batchNumber: BigNumber, 
   indexInBatch: BigNumber, 
parentProvider?: Provider): ChildToParentMessageReaderOrWriterClassic<T>
```

Instantiates a new `ChildToParentMessageWriterClassic` or `ChildToParentMessageReaderClassic` object.

###### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-6 "Direct link to Parameters")

Parameter

Type

Description

`parentSignerOrProvider`

`T`

Signer or provider to be used for executing or reading the Child-to-Parent message.

`batchNumber`

`BigNumber`

The number of the batch containing the Child-to-Parent message.

`indexInBatch`

`BigNumber`

The index of the Child-to-Parent message within the batch.

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `parentSignerOrProvider` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns-6 "Direct link to Returns")

[`ChildToParentMessageReaderOrWriterClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderorwriterclassict)<`T`\>

###### Inherited from[​](#inherited-from "Direct link to Inherited from")

`ChildToParentMessageClassic.fromBatchNumber`

###### Source[​](#source-6 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:128](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L128)

* * *

### ChildToParentMessageWriterClassic[​](#childtoparentmessagewriterclassic "Direct link to ChildToParentMessageWriterClassic")

Provides read and write access for classic Child-to-Parent-messages

#### Extends[​](#extends-1 "Direct link to Extends")

*   [`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic)

#### Constructors[​](#constructors "Direct link to Constructors")

##### new ChildToParentMessageWriterClassic()[​](#new-childtoparentmessagewriterclassic "Direct link to new ChildToParentMessageWriterClassic()")

```rust
new ChildToParentMessageWriterClassic(
   parentSigner: Signer, 
   batchNumber: BigNumber, 
   indexInBatch: BigNumber, 
   parentProvider?: Provider): ChildToParentMessageWriterClassic
```

Instantiates a new `ChildToParentMessageWriterClassic` object.

###### Parameters[​](#parameters-7 "Direct link to Parameters")

Parameter

Type

Description

`parentSigner`

`Signer`

The signer to be used for executing the Child-to-Parent message.

`batchNumber`

`BigNumber`

The number of the batch containing the Child-to-Parent message.

`indexInBatch`

`BigNumber`

The index of the Child-to-Parent message within the batch.

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `parentSigner` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns-7 "Direct link to Returns")

[`ChildToParentMessageWriterClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagewriterclassic)

###### Overrides[​](#overrides "Direct link to Overrides")

`ChildToParentMessageReaderClassic.constructor`

###### Source[​](#source-7 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:406](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L406)

#### Properties[​](#properties-1 "Direct link to Properties")

Property

Modifier

Type

Default value

Description

Inherited from

`batchNumber`

`readonly`

`BigNumber`

`undefined`

The number of the batch this message is part of

[`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic).`batchNumber`

`indexInBatch`

`readonly`

`BigNumber`

`undefined`

The index of this message in the batch

[`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic).`indexInBatch`

`outboxAddress`

`protected`

`null` | `string`

`null`

Contains the classic outbox address, or set to zero address if this network  
did not have a classic outbox deployed

[`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic).`outboxAddress`

`parentSigner`

`private`

`Signer`

`undefined`

The signer to be used for executing the Child-to-Parent message.

\-

#### Methods[​](#methods-1 "Direct link to Methods")

##### execute()[​](#execute "Direct link to execute()")

```rust
execute(childProvider: Provider, overrides?: Overrides): Promise<ContractTransaction>
```

Executes the ChildToParentMessage on Parent Chain. Will throw an error if the outbox entry has not been created, which happens when the corresponding assertion is confirmed.

###### Parameters[​](#parameters-8 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

`overrides`?

`Overrides`

###### Returns[​](#returns-8 "Direct link to Returns")

`Promise`<`ContractTransaction`\>

###### Source[​](#source-8 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:421](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L421)

##### getFirstExecutableBlock()[​](#getfirstexecutableblock-1 "Direct link to getFirstExecutableBlock()")

```rust
getFirstExecutableBlock(childProvider: Provider): Promise<null | BigNumber>
```

Estimates the Parent Chain block number in which this Child-to-Parent tx will be available for execution

###### Parameters[​](#parameters-9 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-9 "Direct link to Returns")

`Promise`<`null` | `BigNumber`\>

Always returns null for classic chainToParentChain messages since they can be executed in any block now.

###### Inherited from[​](#inherited-from-1 "Direct link to Inherited from")

[`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic) . [`getFirstExecutableBlock`](/sdk/reference/message/ChildToParentMessageClassic#getfirstexecutableblock)

###### Source[​](#source-9 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:386](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L386)

##### getOutboxAddress()[​](#getoutboxaddress-1 "Direct link to getOutboxAddress()")

```rust
protected getOutboxAddress(childProvider: Provider, batchNumber: number): Promise<string>
```

Classic had 2 outboxes, we need to find the correct one for the provided batch number

###### Parameters[​](#parameters-10 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`batchNumber`

`number`

###### Returns[​](#returns-10 "Direct link to Returns")

`Promise`<`string`\>

###### Inherited from[​](#inherited-from-2 "Direct link to Inherited from")

[`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic) . [`getOutboxAddress`](/sdk/reference/message/ChildToParentMessageClassic#getoutboxaddress)

###### Source[​](#source-10 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:211](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L211)

##### hasExecuted()[​](#hasexecuted-1 "Direct link to hasExecuted()")

```rust
hasExecuted(childProvider: Provider): Promise<boolean>
```

Check if given outbox message has already been executed

###### Parameters[​](#parameters-11 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

###### Returns[​](#returns-11 "Direct link to Returns")

`Promise`<`boolean`\>

###### Inherited from[​](#inherited-from-3 "Direct link to Inherited from")

[`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic) . [`hasExecuted`](/sdk/reference/message/ChildToParentMessageClassic#hasexecuted)

###### Source[​](#source-11 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:301](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L301)

##### status()[​](#status-1 "Direct link to status()")

```rust
status(childProvider: Provider): Promise<ChildToParentMessageStatus>
```

Get the status of this message In order to check if the message has been executed proof info must be provided.

###### Parameters[​](#parameters-12 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-12 "Direct link to Returns")

`Promise`<`ChildToParentMessageStatus`\>

###### Inherited from[​](#inherited-from-4 "Direct link to Inherited from")

[`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic) . [`status`](/sdk/reference/message/ChildToParentMessageClassic#status)

###### Source[​](#source-12 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:339](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L339)

##### tryGetProof()[​](#trygetproof-1 "Direct link to tryGetProof()")

```rust
tryGetProof(childProvider: Provider): Promise<null | MessageBatchProofInfo>
```

Get the execution proof for this message. Returns null if the batch does not exist yet.

###### Parameters[​](#parameters-13 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-13 "Direct link to Returns")

`Promise`<`null` | `MessageBatchProofInfo`\>

###### Inherited from[​](#inherited-from-5 "Direct link to Inherited from")

[`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic) . [`tryGetProof`](/sdk/reference/message/ChildToParentMessageClassic#trygetproof)

###### Source[​](#source-13 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:285](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L285)

##### waitUntilOutboxEntryCreated()[​](#waituntiloutboxentrycreated-1 "Direct link to waitUntilOutboxEntryCreated()")

```rust
waitUntilOutboxEntryCreated(childProvider: Provider, retryDelay: number): Promise<CONFIRMED | EXECUTED>
```

Waits until the outbox entry has been created, and will not return until it has been. WARNING: Outbox entries are only created when the corresponding node is confirmed. Which can take 1 week+, so waiting here could be a very long operation.

###### Parameters[​](#parameters-14 "Direct link to Parameters")

Parameter

Type

Default value

Description

`childProvider`

`Provider`

`undefined`

\-

`retryDelay`

`number`

`500`

###### Returns[​](#returns-14 "Direct link to Returns")

`Promise`<`CONFIRMED` | `EXECUTED`\>

outbox entry status (either executed or confirmed but not pending)

###### Inherited from[​](#inherited-from-6 "Direct link to Inherited from")

[`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic) . [`waitUntilOutboxEntryCreated`](/sdk/reference/message/ChildToParentMessageClassic#waituntiloutboxentrycreated)

###### Source[​](#source-14 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:364](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L364)

##### fromBatchNumber()[​](#frombatchnumber-1 "Direct link to fromBatchNumber()")

```rust
static fromBatchNumber<T>(
   parentSignerOrProvider: T, 
   batchNumber: BigNumber, 
   indexInBatch: BigNumber, 
parentProvider?: Provider): ChildToParentMessageReaderOrWriterClassic<T>
```

Instantiates a new `ChildToParentMessageWriterClassic` or `ChildToParentMessageReaderClassic` object.

###### Type parameters[​](#type-parameters-1 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-15 "Direct link to Parameters")

Parameter

Type

Description

`parentSignerOrProvider`

`T`

Signer or provider to be used for executing or reading the Child-to-Parent message.

`batchNumber`

`BigNumber`

The number of the batch containing the Child-to-Parent message.

`indexInBatch`

`BigNumber`

The index of the Child-to-Parent message within the batch.

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `parentSignerOrProvider` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns-15 "Direct link to Returns")

[`ChildToParentMessageReaderOrWriterClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderorwriterclassict)<`T`\>

###### Inherited from[​](#inherited-from-7 "Direct link to Inherited from")

[`ChildToParentMessageReaderClassic`](/sdk/reference/message/ChildToParentMessageClassic#childtoparentmessagereaderclassic) . [`fromBatchNumber`](/sdk/reference/message/ChildToParentMessageClassic#frombatchnumber)

###### Source[​](#source-15 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:128](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L128)

Type Aliases[​](#type-aliases "Direct link to Type Aliases")
------------------------------------------------------------

### ChildToParentMessageReaderOrWriterClassic<T>[​](#childtoparentmessagereaderorwriterclassict "Direct link to ChildToParentMessageReaderOrWriterClassic<T>")

```rust
type ChildToParentMessageReaderOrWriterClassic<T>: T extends Provider ? ChildToParentMessageReaderClassic : ChildToParentMessageWriterClassic;
```

Conditional type for Signer or Provider. If T is of type Provider then ChildToParentMessageReaderOrWriter<T> will be of type ChildToParentMessageReader. If T is of type Signer then ChildToParentMessageReaderOrWriter<T> will be of type ChildToParentMessageWriter.

#### Type parameters[​](#type-parameters-2 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

#### Source[​](#source-16 "Direct link to Source")

[message/ChildToParentMessageClassic.ts:98](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageClassic.ts#L98)

---

# ChildToParentMessageNitro | Arbitrum Docs

## ChildToParentMessageNitro

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### ChildToParentMessageNitro[​](#childtoparentmessagenitro "Direct link to ChildToParentMessageNitro")

Base functionality for nitro Child->Parent messages

#### Extended by[​](#extended-by "Direct link to Extended by")

*   [`ChildToParentMessageReaderNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagereadernitro)

#### Methods[​](#methods "Direct link to Methods")

##### fromEvent()[​](#fromevent "Direct link to fromEvent()")

```rust
static fromEvent<T>(
   parentSignerOrProvider: T, 
   event: object, 
parentProvider?: Provider): ChildToParentMessageReaderOrWriterNitro<T>
```

Instantiates a new `ChildToParentMessageWriterNitro` or `ChildToParentMessageReaderNitro` object.

###### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`parentSignerOrProvider`

`T`

Signer or provider to be used for executing or reading the Child-to-Parent message.

`event`

`object`

The event containing the data of the Child-to-Parent message.

`event.arbBlockNum`

`BigNumber`

\-

`event.caller`?

`string`

\-

`event.callvalue`?

`BigNumber`

\-

`event.data`?

`string`

\-

`event.destination`?

`string`

\-

`event.ethBlockNum`?

`BigNumber`

\-

`event.hash`?

`BigNumber`

\-

`event.position`?

`BigNumber`

\-

`event.timestamp`?

`BigNumber`

\-

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `parentSignerOrProvider` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns "Direct link to Returns")

[`ChildToParentMessageReaderOrWriterNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagereaderorwriternitrot)<`T`\>

###### Source[​](#source "Direct link to Source")

[message/ChildToParentMessageNitro.ts:148](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L148)

* * *

### ChildToParentMessageReaderNitro[​](#childtoparentmessagereadernitro "Direct link to ChildToParentMessageReaderNitro")

Provides read-only access nitro for child-to-parent-messages

#### Extends[​](#extends "Direct link to Extends")

*   [`ChildToParentMessageNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagenitro)

#### Extended by[​](#extended-by-1 "Direct link to Extended by")

*   [`ChildToParentMessageWriterNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagewriternitro)

#### Methods[​](#methods-1 "Direct link to Methods")

##### getFirstExecutableBlock()[​](#getfirstexecutableblock "Direct link to getFirstExecutableBlock()")

```rust
getFirstExecutableBlock(childProvider: Provider): Promise<null | BigNumber>
```

Estimates the L1 block number in which this L2 to L1 tx will be available for execution. If the message can or already has been executed, this returns null

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-1 "Direct link to Returns")

`Promise`<`null` | `BigNumber`\>

expected parent chain block number where the child chain to parent chain message will be executable. Returns null if the message can be or already has been executed

###### Source[​](#source-1 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:596](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L596)

##### getRollupAndUpdateNetwork()[​](#getrollupandupdatenetwork "Direct link to getRollupAndUpdateNetwork()")

```rust
private getRollupAndUpdateNetwork(arbitrumNetwork: ArbitrumNetwork): Promise<RollupUserLogic | BoldRollupUserLogic>
```

If the local network is not currently bold, checks if the remote network is bold and if so updates the local network with a new rollup address

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`arbitrumNetwork`

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

###### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`RollupUserLogic` | `BoldRollupUserLogic`\>

The rollup contract, bold or legacy

###### Source[​](#source-2 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:567](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L567)

##### hasExecuted()[​](#hasexecuted "Direct link to hasExecuted()")

```rust
protected hasExecuted(childProvider: Provider): Promise<boolean>
```

Check if this message has already been executed in the Outbox

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

###### Returns[​](#returns-3 "Direct link to Returns")

`Promise`<`boolean`\>

###### Source[​](#source-3 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:225](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L225)

##### isBold()[​](#isbold "Direct link to isBold()")

```rust
private isBold(arbitrumNetwork: ArbitrumNetwork, parentProvider: Provider): Promise<undefined | string>
```

Check whether the provided network has a BoLD rollup

###### Parameters[​](#parameters-4 "Direct link to Parameters")

Parameter

Type

Description

`arbitrumNetwork`

[`ArbitrumNetwork`](/sdk/reference/dataEntities/networks#arbitrumnetwork)

`parentProvider`

`Provider`

###### Returns[​](#returns-4 "Direct link to Returns")

`Promise`<`undefined` | `string`\>

###### Source[​](#source-4 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:531](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L531)

##### status()[​](#status "Direct link to status()")

```rust
status(childProvider: Provider): Promise<ChildToParentMessageStatus>
```

Get the status of this message In order to check if the message has been executed proof info must be provided.

###### Parameters[​](#parameters-5 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

###### Returns[​](#returns-5 "Direct link to Returns")

`Promise`<`ChildToParentMessageStatus`\>

###### Source[​](#source-5 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:240](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L240)

##### waitUntilReadyToExecute()[​](#waituntilreadytoexecute "Direct link to waitUntilReadyToExecute()")

```rust
waitUntilReadyToExecute(childProvider: Provider, retryDelay: number): Promise<CONFIRMED | EXECUTED>
```

Waits until the outbox entry has been created, and will not return until it has been. WARNING: Outbox entries are only created when the corresponding node is confirmed. Which can take 1 week+, so waiting here could be a very long operation.

###### Parameters[​](#parameters-6 "Direct link to Parameters")

Parameter

Type

Default value

Description

`childProvider`

`Provider`

`undefined`

\-

`retryDelay`

`number`

`500`

###### Returns[​](#returns-6 "Direct link to Returns")

`Promise`<`CONFIRMED` | `EXECUTED`\>

outbox entry status (either executed or confirmed but not pending)

###### Source[​](#source-6 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:507](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L507)

##### fromEvent()[​](#fromevent-1 "Direct link to fromEvent()")

```rust
static fromEvent<T>(
   parentSignerOrProvider: T, 
   event: object, 
parentProvider?: Provider): ChildToParentMessageReaderOrWriterNitro<T>
```

Instantiates a new `ChildToParentMessageWriterNitro` or `ChildToParentMessageReaderNitro` object.

###### Type parameters[​](#type-parameters-1 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-7 "Direct link to Parameters")

Parameter

Type

Description

`parentSignerOrProvider`

`T`

Signer or provider to be used for executing or reading the Child-to-Parent message.

`event`

`object`

The event containing the data of the Child-to-Parent message.

`event.arbBlockNum`

`BigNumber`

\-

`event.caller`?

`string`

\-

`event.callvalue`?

`BigNumber`

\-

`event.data`?

`string`

\-

`event.destination`?

`string`

\-

`event.ethBlockNum`?

`BigNumber`

\-

`event.hash`?

`BigNumber`

\-

`event.position`?

`BigNumber`

\-

`event.timestamp`?

`BigNumber`

\-

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `parentSignerOrProvider` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns-7 "Direct link to Returns")

[`ChildToParentMessageReaderOrWriterNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagereaderorwriternitrot)<`T`\>

###### Inherited from[​](#inherited-from "Direct link to Inherited from")

[`ChildToParentMessageNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagenitro) . [`fromEvent`](/sdk/reference/message/ChildToParentMessageNitro#fromevent)

###### Source[​](#source-7 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:148](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L148)

* * *

### ChildToParentMessageWriterNitro[​](#childtoparentmessagewriternitro "Direct link to ChildToParentMessageWriterNitro")

Provides read and write access for nitro child-to-Parent-messages

#### Extends[​](#extends-1 "Direct link to Extends")

*   [`ChildToParentMessageReaderNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagereadernitro)

#### Constructors[​](#constructors "Direct link to Constructors")

##### new ChildToParentMessageWriterNitro()[​](#new-childtoparentmessagewriternitro "Direct link to new ChildToParentMessageWriterNitro()")

```rust
new ChildToParentMessageWriterNitro(
   parentSigner: Signer, 
   event: object, 
   parentProvider?: Provider): ChildToParentMessageWriterNitro
```

Instantiates a new `ChildToParentMessageWriterNitro` object.

###### Parameters[​](#parameters-8 "Direct link to Parameters")

Parameter

Type

Description

`parentSigner`

`Signer`

The signer to be used for executing the Child-to-Parent message.

`event`

`object`

The event containing the data of the Child-to-Parent message.

`event.arbBlockNum`

`BigNumber`

\-

`event.caller`?

`string`

\-

`event.callvalue`?

`BigNumber`

\-

`event.data`?

`string`

\-

`event.destination`?

`string`

\-

`event.ethBlockNum`?

`BigNumber`

\-

`event.hash`?

`BigNumber`

\-

`event.position`?

`BigNumber`

\-

`event.timestamp`?

`BigNumber`

\-

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `parentSigner` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns-8 "Direct link to Returns")

[`ChildToParentMessageWriterNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagewriternitro)

###### Overrides[​](#overrides "Direct link to Overrides")

`ChildToParentMessageReaderNitro.constructor`

###### Source[​](#source-8 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:724](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L724)

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Description

`parentSigner`

`private`

`Signer`

The signer to be used for executing the Child-to-Parent message.

#### Methods[​](#methods-2 "Direct link to Methods")

##### execute()[​](#execute "Direct link to execute()")

```rust
execute(childProvider: Provider, overrides?: Overrides): Promise<ContractTransaction>
```

Executes the ChildToParentMessage on Parent Chain. Will throw an error if the outbox entry has not been created, which happens when the corresponding assertion is confirmed.

###### Parameters[​](#parameters-9 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

`overrides`?

`Overrides`

###### Returns[​](#returns-9 "Direct link to Returns")

`Promise`<`ContractTransaction`\>

###### Source[​](#source-9 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:738](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L738)

##### getFirstExecutableBlock()[​](#getfirstexecutableblock-1 "Direct link to getFirstExecutableBlock()")

```rust
getFirstExecutableBlock(childProvider: Provider): Promise<null | BigNumber>
```

Estimates the L1 block number in which this L2 to L1 tx will be available for execution. If the message can or already has been executed, this returns null

###### Parameters[​](#parameters-10 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-10 "Direct link to Returns")

`Promise`<`null` | `BigNumber`\>

expected parent chain block number where the child chain to parent chain message will be executable. Returns null if the message can be or already has been executed

###### Inherited from[​](#inherited-from-1 "Direct link to Inherited from")

[`ChildToParentMessageReaderNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagereadernitro) . [`getFirstExecutableBlock`](/sdk/reference/message/ChildToParentMessageNitro#getfirstexecutableblock)

###### Source[​](#source-10 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:596](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L596)

##### hasExecuted()[​](#hasexecuted-1 "Direct link to hasExecuted()")

```rust
protected hasExecuted(childProvider: Provider): Promise<boolean>
```

Check if this message has already been executed in the Outbox

###### Parameters[​](#parameters-11 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

###### Returns[​](#returns-11 "Direct link to Returns")

`Promise`<`boolean`\>

###### Inherited from[​](#inherited-from-2 "Direct link to Inherited from")

[`ChildToParentMessageReaderNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagereadernitro) . [`hasExecuted`](/sdk/reference/message/ChildToParentMessageNitro#hasexecuted)

###### Source[​](#source-11 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:225](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L225)

##### status()[​](#status-1 "Direct link to status()")

```rust
status(childProvider: Provider): Promise<ChildToParentMessageStatus>
```

Get the status of this message In order to check if the message has been executed proof info must be provided.

###### Parameters[​](#parameters-12 "Direct link to Parameters")

Parameter

Type

`childProvider`

`Provider`

###### Returns[​](#returns-12 "Direct link to Returns")

`Promise`<`ChildToParentMessageStatus`\>

###### Inherited from[​](#inherited-from-3 "Direct link to Inherited from")

[`ChildToParentMessageReaderNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagereadernitro) . [`status`](/sdk/reference/message/ChildToParentMessageNitro#status)

###### Source[​](#source-12 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:240](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L240)

##### waitUntilReadyToExecute()[​](#waituntilreadytoexecute-1 "Direct link to waitUntilReadyToExecute()")

```rust
waitUntilReadyToExecute(childProvider: Provider, retryDelay: number): Promise<CONFIRMED | EXECUTED>
```

Waits until the outbox entry has been created, and will not return until it has been. WARNING: Outbox entries are only created when the corresponding node is confirmed. Which can take 1 week+, so waiting here could be a very long operation.

###### Parameters[​](#parameters-13 "Direct link to Parameters")

Parameter

Type

Default value

Description

`childProvider`

`Provider`

`undefined`

\-

`retryDelay`

`number`

`500`

###### Returns[​](#returns-13 "Direct link to Returns")

`Promise`<`CONFIRMED` | `EXECUTED`\>

outbox entry status (either executed or confirmed but not pending)

###### Inherited from[​](#inherited-from-4 "Direct link to Inherited from")

[`ChildToParentMessageReaderNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagereadernitro) . [`waitUntilReadyToExecute`](/sdk/reference/message/ChildToParentMessageNitro#waituntilreadytoexecute)

###### Source[​](#source-13 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:507](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L507)

##### fromEvent()[​](#fromevent-2 "Direct link to fromEvent()")

```rust
static fromEvent<T>(
   parentSignerOrProvider: T, 
   event: object, 
parentProvider?: Provider): ChildToParentMessageReaderOrWriterNitro<T>
```

Instantiates a new `ChildToParentMessageWriterNitro` or `ChildToParentMessageReaderNitro` object.

###### Type parameters[​](#type-parameters-2 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-14 "Direct link to Parameters")

Parameter

Type

Description

`parentSignerOrProvider`

`T`

Signer or provider to be used for executing or reading the Child-to-Parent message.

`event`

`object`

The event containing the data of the Child-to-Parent message.

`event.arbBlockNum`

`BigNumber`

\-

`event.caller`?

`string`

\-

`event.callvalue`?

`BigNumber`

\-

`event.data`?

`string`

\-

`event.destination`?

`string`

\-

`event.ethBlockNum`?

`BigNumber`

\-

`event.hash`?

`BigNumber`

\-

`event.position`?

`BigNumber`

\-

`event.timestamp`?

`BigNumber`

\-

`parentProvider`?

`Provider`

Optional. Used to override the Provider which is attached to `parentSignerOrProvider` in case you need more control. This will be a required parameter in a future major version update.

###### Returns[​](#returns-14 "Direct link to Returns")

[`ChildToParentMessageReaderOrWriterNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagereaderorwriternitrot)<`T`\>

###### Inherited from[​](#inherited-from-5 "Direct link to Inherited from")

[`ChildToParentMessageReaderNitro`](/sdk/reference/message/ChildToParentMessageNitro#childtoparentmessagereadernitro) . [`fromEvent`](/sdk/reference/message/ChildToParentMessageNitro#fromevent-1)

###### Source[​](#source-14 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:148](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L148)

Type Aliases[​](#type-aliases "Direct link to Type Aliases")
------------------------------------------------------------

### ChildToParentMessageReaderOrWriterNitro<T>[​](#childtoparentmessagereaderorwriternitrot "Direct link to ChildToParentMessageReaderOrWriterNitro<T>")

```rust
type ChildToParentMessageReaderOrWriterNitro<T>: T extends Provider ? ChildToParentMessageReaderNitro : ChildToParentMessageWriterNitro;
```

Conditional type for Signer or Provider. If T is of type Provider then ChildToParentMessageReaderOrWriter<T> will be of type ChildToParentMessageReader. If T is of type Signer then ChildToParentMessageReaderOrWriter<T> will be of type ChildToParentMessageWriter.

#### Type parameters[​](#type-parameters-3 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

#### Source[​](#source-15 "Direct link to Source")

[message/ChildToParentMessageNitro.ts:64](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildToParentMessageNitro.ts#L64)

---

# ChildTransaction | Arbitrum Docs

## ChildTransaction

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### ChildTransactionReceipt[​](#childtransactionreceipt "Direct link to ChildTransactionReceipt")

Extension of ethers-js TransactionReceipt, adding Arbitrum-specific functionality

#### Implements[​](#implements "Direct link to Implements")

*   `TransactionReceipt`

#### Methods[​](#methods "Direct link to Methods")

##### getBatchConfirmations()[​](#getbatchconfirmations "Direct link to getBatchConfirmations()")

```rust
getBatchConfirmations(childProvider: JsonRpcProvider): Promise<BigNumber>
```

Get number of parent chain confirmations that the batch including this tx has

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`JsonRpcProvider`

###### Returns[​](#returns "Direct link to Returns")

`Promise`<`BigNumber`\>

number of confirmations of batch including tx, or 0 if no batch included this tx

###### Source[​](#source "Direct link to Source")

[message/ChildTransaction.ts:138](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildTransaction.ts#L138)

##### getBatchNumber()[​](#getbatchnumber "Direct link to getBatchNumber()")

```rust
getBatchNumber(childProvider: JsonRpcProvider): Promise<BigNumber>
```

Get the number of the batch that included this tx (will throw if no such batch exists)

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`JsonRpcProvider`

###### Returns[​](#returns-1 "Direct link to Returns")

`Promise`<`BigNumber`\>

number of batch in which tx was included, or errors if no batch includes the current tx

###### Source[​](#source-1 "Direct link to Source")

[message/ChildTransaction.ts:151](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildTransaction.ts#L151)

##### getChildToParentEvents()[​](#getchildtoparentevents "Direct link to getChildToParentEvents()")

```rust
getChildToParentEvents(): ChildToParentTransactionEvent[]
```

Get ChildToParentTransactionEvent events created by this transaction

###### Returns[​](#returns-2 "Direct link to Returns")

`ChildToParentTransactionEvent`\[\]

###### Source[​](#source-2 "Direct link to Source")

[message/ChildTransaction.ts:97](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildTransaction.ts#L97)

##### getChildToParentMessages()[​](#getchildtoparentmessages "Direct link to getChildToParentMessages()")

```rust
getChildToParentMessages<T>(parentSignerOrProvider: T): Promise<ChildToParentMessageReaderOrWriter<T>[]>
```

Get any child-to-parent-messages created by this transaction

###### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`parentSignerOrProvider`

`T`

###### Returns[​](#returns-3 "Direct link to Returns")

`Promise` <[`ChildToParentMessageReaderOrWriter`](/sdk/reference/message/ChildToParentMessage#childtoparentmessagereaderorwritert)<`T`\>\[\]>

###### Source[​](#source-3 "Direct link to Source")

[message/ChildTransaction.ts:119](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildTransaction.ts#L119)

##### getRedeemScheduledEvents()[​](#getredeemscheduledevents "Direct link to getRedeemScheduledEvents()")

```rust
getRedeemScheduledEvents(): object[]
```

Get event data for any redeems that were scheduled in this transaction

###### Returns[​](#returns-4 "Direct link to Returns")

`object`\[\]

###### Source[​](#source-4 "Direct link to Source")

[message/ChildTransaction.ts:111](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildTransaction.ts#L111)

##### isDataAvailable()[​](#isdataavailable "Direct link to isDataAvailable()")

```rust
isDataAvailable(childProvider: JsonRpcProvider, confirmations: number): Promise<boolean>
```

Whether the data associated with this transaction has been made available on parent chain

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

Default value

Description

`childProvider`

`JsonRpcProvider`

`undefined`

`confirmations`

`number`

`10`

The number of confirmations on the batch before data is to be considered available

###### Returns[​](#returns-5 "Direct link to Returns")

`Promise`<`boolean`\>

###### Source[​](#source-5 "Direct link to Source")

[message/ChildTransaction.ts:173](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildTransaction.ts#L173)

##### monkeyPatchWait()[​](#monkeypatchwait "Direct link to monkeyPatchWait()")

```rust
static monkeyPatchWait(contractTransaction: ContractTransaction): ChildContractTransaction
```

Replaces the wait function with one that returns an L2TransactionReceipt

###### Parameters[​](#parameters-4 "Direct link to Parameters")

Parameter

Type

Description

`contractTransaction`

`ContractTransaction`

###### Returns[​](#returns-6 "Direct link to Returns")

`ChildContractTransaction`

###### Source[​](#source-6 "Direct link to Source")

[message/ChildTransaction.ts:187](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildTransaction.ts#L187)

##### toRedeemTransaction()[​](#toredeemtransaction "Direct link to toRedeemTransaction()")

```rust
static toRedeemTransaction(redeemTx: ChildContractTransaction, childProvider: Provider): RedeemTransaction
```

Adds a waitForRedeem function to a redeem transaction

###### Parameters[​](#parameters-5 "Direct link to Parameters")

Parameter

Type

Description

`redeemTx`

`ChildContractTransaction`

`childProvider`

`Provider`

###### Returns[​](#returns-7 "Direct link to Returns")

`RedeemTransaction`

###### Source[​](#source-7 "Direct link to Source")

[message/ChildTransaction.ts:208](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ChildTransaction.ts#L208)

---

# ParentToChildMessage | Arbitrum Docs

## ParentToChildMessage

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### EthDepositMessage[​](#ethdepositmessage "Direct link to EthDepositMessage")

A message for Eth deposits from Parent to Child

#### Constructors[​](#constructors "Direct link to Constructors")

##### new EthDepositMessage()[​](#new-ethdepositmessage "Direct link to new EthDepositMessage()")

```rust
new EthDepositMessage(
   childProvider: Provider, 
   childChainId: number, 
   messageNumber: BigNumber, 
   from: string, 
   to: string, 
   value: BigNumber): EthDepositMessage
```

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`childChainId`

`number`

`messageNumber`

`BigNumber`

`from`

`string`

\-

`to`

`string`

Recipient address of the ETH on Chain

`value`

`BigNumber`

###### Returns[​](#returns "Direct link to Returns")

[`EthDepositMessage`](/sdk/reference/message/ParentToChildMessage#ethdepositmessage)

###### Source[​](#source "Direct link to Source")

[message/ParentToChildMessage.ts:852](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentToChildMessage.ts#L852)

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Description

`childChainId`

`readonly`

`number`

\-

`childProvider`

`private`

`Provider`

\-

`messageNumber`

`readonly`

`BigNumber`

\-

`to`

`readonly`

`string`

Recipient address of the ETH on Chain

`value`

`readonly`

`BigNumber`

\-

#### Methods[​](#methods "Direct link to Methods")

##### fromEventComponents()[​](#fromeventcomponents "Direct link to fromEventComponents()")

```rust
static fromEventComponents(
   childProvider: Provider, 
   messageNumber: BigNumber, 
   senderAddr: string, 
inboxMessageEventData: string): Promise<EthDepositMessage>
```

Create an EthDepositMessage from data emitted in event when calling ethDeposit on Inbox.sol

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

`messageNumber`

`BigNumber`

The message number in the Inbox.InboxMessageDelivered event

`senderAddr`

`string`

The sender address from Bridge.MessageDelivered event

`inboxMessageEventData`

`string`

The data field from the Inbox.InboxMessageDelivered event

###### Returns[​](#returns-1 "Direct link to Returns")

`Promise` <[`EthDepositMessage`](/sdk/reference/message/ParentToChildMessage#ethdepositmessage)\>

###### Source[​](#source-1 "Direct link to Source")

[message/ParentToChildMessage.ts:823](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentToChildMessage.ts#L823)

##### parseEthDepositData()[​](#parseethdepositdata "Direct link to parseEthDepositData()")

```rust
static private parseEthDepositData(eventData: string): object
```

Parse the data field in event InboxMessageDelivered(uint256 indexed messageNum, bytes data);

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`eventData`

`string`

###### Returns[​](#returns-2 "Direct link to Returns")

`object`

destination and amount

Member

Type

`to`

`string`

`value`

`BigNumber`

###### Source[​](#source-2 "Direct link to Source")

[message/ParentToChildMessage.ts:802](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentToChildMessage.ts#L802)

Type Aliases[​](#type-aliases "Direct link to Type Aliases")
------------------------------------------------------------

### ParentToChildMessageReaderOrWriter<T>[​](#parenttochildmessagereaderorwritert "Direct link to ParentToChildMessageReaderOrWriter<T>")

```rust
type ParentToChildMessageReaderOrWriter<T>: T extends Provider ? ParentToChildMessageReader : ParentToChildMessageWriter;
```

Conditional type for Signer or Provider. If T is of type Provider then ParentToChildMessageReaderOrWriter<T> will be of type ParentToChildMessageReader. If T is of type Signer then ParentToChildMessageReaderOrWriter<T> will be of type ParentToChildMessageWriter.

#### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

#### Source[​](#source-3 "Direct link to Source")

[message/ParentToChildMessage.ts:98](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentToChildMessage.ts#L98)

* * *

### ParentToChildMessageWaitForStatusResult[​](#parenttochildmessagewaitforstatusresult "Direct link to ParentToChildMessageWaitForStatusResult")

```rust
type ParentToChildMessageWaitForStatusResult: object | object;
```

If the status is redeemed, childTxReceipt is populated. For all other statuses childTxReceipt is not populated

#### Source[​](#source-4 "Direct link to Source")

[message/ParentToChildMessage.ts:240](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentToChildMessage.ts#L240)

---

# ParentToChildMessageCreator | Arbitrum Docs

## ParentToChildMessageCreator

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### ParentToChildMessageCreator[​](#parenttochildmessagecreator "Direct link to ParentToChildMessageCreator")

Creates retryable tickets by directly calling the Inbox contract on Parent chain

#### Methods[​](#methods "Direct link to Methods")

##### createRetryableTicket()[​](#createretryableticket "Direct link to createRetryableTicket()")

```rust
createRetryableTicket(
   params: OmitTyped<ParentToChildMessageNoGasParams, "excessFeeRefundAddress" | "callValueRefundAddress"> & Partial<ParentToChildMessageNoGasParams> & object | ParentToChildTransactionRequest & object, 
   childProvider: Provider, 
options?: GasOverrides): Promise<ParentContractTransaction<ParentTransactionReceipt>>
```

Creates a retryable ticket by directly calling the Inbox contract on Parent chain

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

`params`

[`OmitTyped`](/sdk/reference/utils/types#omittypedtk)<`ParentToChildMessageNoGasParams`, `"excessFeeRefundAddress"` | `"callValueRefundAddress"`\> & `Partial`<`ParentToChildMessageNoGasParams`\> & `object` | [`ParentToChildTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#parenttochildtransactionrequest) & `object`

`childProvider`

`Provider`

`options`?

`GasOverrides`

###### Returns[​](#returns "Direct link to Returns")

`Promise`<`ParentContractTransaction`<`ParentTransactionReceipt`\>>

###### Source[​](#source "Direct link to Source")

[message/ParentToChildMessageCreator.ts:206](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentToChildMessageCreator.ts#L206)

##### getTicketCreationRequest()[​](#getticketcreationrequest "Direct link to getTicketCreationRequest()")

```rust
static getTicketCreationRequest(
   params: ParentToChildMessageParams, 
   parentProvider: Provider, 
   childProvider: Provider, 
options?: GasOverrides): Promise<ParentToChildTransactionRequest>
```

Generate a transaction request for creating a retryable ticket

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ParentToChildMessageParams`

`parentProvider`

`Provider`

`childProvider`

`Provider`

`options`?

`GasOverrides`

###### Returns[​](#returns-1 "Direct link to Returns")

`Promise` <[`ParentToChildTransactionRequest`](/sdk/reference/dataEntities/transactionRequest#parenttochildtransactionrequest)\>

###### Source[​](#source-1 "Direct link to Source")

[message/ParentToChildMessageCreator.ts:139](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentToChildMessageCreator.ts#L139)

##### getTicketCreationRequestCallData()[​](#getticketcreationrequestcalldata "Direct link to getTicketCreationRequestCallData()")

```rust
static protected getTicketCreationRequestCallData(
   params: ParentToChildMessageParams, 
   estimates: Pick<RetryableData, ParentToChildGasKeys>, 
   excessFeeRefundAddress: string, 
   callValueRefundAddress: string, 
   nativeTokenIsEth: boolean): string
```

Prepare calldata for a call to create a retryable ticket

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ParentToChildMessageParams`

`estimates`

`Pick`<`RetryableData`, `ParentToChildGasKeys`\>

`excessFeeRefundAddress`

`string`

`callValueRefundAddress`

`string`

`nativeTokenIsEth`

`boolean`

###### Returns[​](#returns-2 "Direct link to Returns")

`string`

###### Source[​](#source-2 "Direct link to Source")

[message/ParentToChildMessageCreator.ts:92](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentToChildMessageCreator.ts#L92)

##### getTicketEstimate()[​](#getticketestimate "Direct link to getTicketEstimate()")

```rust
static protected getTicketEstimate(
   params: ParentToChildMessageNoGasParams, 
   parentProvider: Provider, 
   childProvider: Provider, 
retryableGasOverrides?: GasOverrides): Promise<Pick<RetryableData, ParentToChildGasKeys>>
```

Gets a current estimate for the supplied params

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

Description

`params`

`ParentToChildMessageNoGasParams`

`parentProvider`

`Provider`

`childProvider`

`Provider`

`retryableGasOverrides`?

`GasOverrides`

###### Returns[​](#returns-3 "Direct link to Returns")

`Promise`<`Pick`<`RetryableData`, `ParentToChildGasKeys`\>>

###### Source[​](#source-3 "Direct link to Source")

[message/ParentToChildMessageCreator.ts:66](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentToChildMessageCreator.ts#L66)

---

# ParentToChildMessageGasEstimator | Arbitrum Docs

## ParentToChildMessageGasEstimator

Type Aliases[​](#type-aliases "Direct link to Type Aliases")
------------------------------------------------------------

### PercentIncrease[​](#percentincrease "Direct link to PercentIncrease")

```rust
type PercentIncrease: object;
```

An optional big number percentage increase

#### Type declaration[​](#type-declaration "Direct link to Type declaration")

Member

Type

Description

`base`

`BigNumber`

If provided, will override the estimated base

`percentIncrease`

`BigNumber`

How much to increase the base by. If not provided system defaults may be used.

#### Source[​](#source "Direct link to Source")

[message/ParentToChildMessageGasEstimator.ts:43](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentToChildMessageGasEstimator.ts#L43)

---

# ParentTransaction | Arbitrum Docs

## ParentTransaction

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### ParentContractCallTransactionReceipt[​](#parentcontractcalltransactionreceipt "Direct link to ParentContractCallTransactionReceipt")

A ParentTransactionReceipt with additional functionality that only exists if the transaction created a single call to a child chain contract - this includes token deposits.

#### Extends[​](#extends "Direct link to Extends")

*   `ParentTransactionReceipt`

#### Methods[​](#methods "Direct link to Methods")

##### getEthDeposits()[​](#getethdeposits "Direct link to getEthDeposits()")

```rust
getEthDeposits(childProvider: Provider): Promise<EthDepositMessage[]>
```

Get any eth deposit messages created by this transaction

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns "Direct link to Returns")

`Promise` <[`EthDepositMessage`](/sdk/reference/message/ParentToChildMessage#ethdepositmessage)\[\]>

###### Inherited from[​](#inherited-from "Direct link to Inherited from")

`ParentTransactionReceipt.getEthDeposits`

###### Source[​](#source "Direct link to Source")

[message/ParentTransaction.ts:191](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L191)

##### getInboxMessageDeliveredEvents()[​](#getinboxmessagedeliveredevents "Direct link to getInboxMessageDeliveredEvents()")

```rust
getInboxMessageDeliveredEvents(): object[]
```

Get any InboxMessageDelivered events that were emitted during this transaction

###### Returns[​](#returns-1 "Direct link to Returns")

`object`\[\]

###### Inherited from[​](#inherited-from-1 "Direct link to Inherited from")

`ParentTransactionReceipt.getInboxMessageDeliveredEvents`

###### Source[​](#source-1 "Direct link to Source")

[message/ParentTransaction.ts:134](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L134)

##### getMessageDeliveredEvents()[​](#getmessagedeliveredevents "Direct link to getMessageDeliveredEvents()")

```rust
getMessageDeliveredEvents(): object[]
```

Get any MessageDelivered events that were emitted during this transaction

###### Returns[​](#returns-2 "Direct link to Returns")

`object`\[\]

###### Inherited from[​](#inherited-from-2 "Direct link to Inherited from")

`ParentTransactionReceipt.getMessageDeliveredEvents`

###### Source[​](#source-2 "Direct link to Source")

[message/ParentTransaction.ts:126](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L126)

##### getMessageEvents()[​](#getmessageevents "Direct link to getMessageEvents()")

```rust
getMessageEvents(): object[]
```

Get combined data for any InboxMessageDelivered and MessageDelivered events emitted during this transaction

###### Returns[​](#returns-3 "Direct link to Returns")

`object`\[\]

###### Inherited from[​](#inherited-from-3 "Direct link to Inherited from")

`ParentTransactionReceipt.getMessageEvents`

###### Source[​](#source-3 "Direct link to Source")

[message/ParentTransaction.ts:147](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L147)

##### getParentToChildMessages()[​](#getparenttochildmessages "Direct link to getParentToChildMessages()")

```rust
getParentToChildMessages<T>(childSignerOrProvider: T): Promise<ParentToChildMessageReaderOrWriter<T>[]>
```

Get any parent-to-child messages created by this transaction

###### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`childSignerOrProvider`

`T`

###### Returns[​](#returns-4 "Direct link to Returns")

`Promise` <[`ParentToChildMessageReaderOrWriter`](/sdk/reference/message/ParentToChildMessage#parenttochildmessagereaderorwritert)<`T`\>\[\]>

###### Inherited from[​](#inherited-from-4 "Direct link to Inherited from")

`ParentTransactionReceipt.getParentToChildMessages`

###### Source[​](#source-4 "Direct link to Source")

[message/ParentTransaction.ts:248](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L248)

##### getParentToChildMessagesClassic()[​](#getparenttochildmessagesclassic "Direct link to getParentToChildMessagesClassic()")

```rust
getParentToChildMessagesClassic(childProvider: Provider): Promise<ParentToChildMessageReaderClassic[]>
```

Get classic parent-to-child messages created by this transaction

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-5 "Direct link to Returns")

`Promise`<`ParentToChildMessageReaderClassic`\[\]>

###### Inherited from[​](#inherited-from-5 "Direct link to Inherited from")

`ParentTransactionReceipt.getParentToChildMessagesClassic`

###### Source[​](#source-5 "Direct link to Source")

[message/ParentTransaction.ts:216](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L216)

##### getTokenDepositEvents()[​](#gettokendepositevents "Direct link to getTokenDepositEvents()")

```rust
getTokenDepositEvents(): object[]
```

Get any token deposit events created by this transaction

###### Returns[​](#returns-6 "Direct link to Returns")

`object`\[\]

###### Inherited from[​](#inherited-from-6 "Direct link to Inherited from")

`ParentTransactionReceipt.getTokenDepositEvents`

###### Source[​](#source-6 "Direct link to Source")

[message/ParentTransaction.ts:298](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L298)

##### isClassic()[​](#isclassic "Direct link to isClassic()")

```rust
isClassic<T>(childSignerOrProvider: T): Promise<boolean>
```

Check if is a classic transaction

###### Type parameters[​](#type-parameters-1 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-3 "Direct link to Parameters")

Parameter

Type

Description

`childSignerOrProvider`

`T`

###### Returns[​](#returns-7 "Direct link to Returns")

`Promise`<`boolean`\>

###### Inherited from[​](#inherited-from-7 "Direct link to Inherited from")

`ParentTransactionReceipt.isClassic`

###### Source[​](#source-7 "Direct link to Source")

[message/ParentTransaction.ts:106](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L106)

##### waitForChildTransactionReceipt()[​](#waitforchildtransactionreceipt "Direct link to waitForChildTransactionReceipt()")

```rust
waitForChildTransactionReceipt<T>(
   childSignerOrProvider: T, 
   confirmations?: number, 
timeout?: number): Promise<object & ParentToChildMessageWaitForStatusResult>
```

Wait for the transaction to arrive and be executed on the child chain

###### Type parameters[​](#type-parameters-2 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-4 "Direct link to Parameters")

Parameter

Type

Description

`childSignerOrProvider`

`T`

\-

`confirmations`?

`number`

Amount of confirmations the retryable ticket and the auto redeem receipt should have

`timeout`?

`number`

Amount of time to wait for the retryable ticket to be created  
Defaults to 15 minutes, as by this time all transactions are expected to be included on the child chain. Throws on timeout.

###### Returns[​](#returns-8 "Direct link to Returns")

`Promise`<`object` & [`ParentToChildMessageWaitForStatusResult`](/sdk/reference/message/ParentToChildMessage#parenttochildmessagewaitforstatusresult)\>

The wait result contains `complete`, a `status`, a ParentToChildMessage and optionally the `childTxReceipt`. If `complete` is true then this message is in the terminal state. For contract calls this is true only if the status is REDEEMED.

###### Source[​](#source-8 "Direct link to Source")

[message/ParentTransaction.ts:407](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L407)

##### monkeyPatchContractCallWait()[​](#monkeypatchcontractcallwait "Direct link to monkeyPatchContractCallWait()")

```rust
static monkeyPatchContractCallWait(contractTransaction: ContractTransaction): ParentContractCallTransaction
```

Replaces the wait function with one that returns a [ParentContractCallTransactionReceipt](/sdk/reference/message/ParentTransaction#parentcontractcalltransactionreceipt)

###### Parameters[​](#parameters-5 "Direct link to Parameters")

Parameter

Type

Description

`contractTransaction`

`ContractTransaction`

###### Returns[​](#returns-9 "Direct link to Returns")

`ParentContractCallTransaction`

###### Inherited from[​](#inherited-from-8 "Direct link to Inherited from")

`ParentTransactionReceipt.monkeyPatchContractCallWait`

###### Source[​](#source-9 "Direct link to Source")

[message/ParentTransaction.ts:343](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L343)

##### monkeyPatchEthDepositWait()[​](#monkeypatchethdepositwait "Direct link to monkeyPatchEthDepositWait()")

```rust
static monkeyPatchEthDepositWait(contractTransaction: ContractTransaction): ParentEthDepositTransaction
```

Replaces the wait function with one that returns a [ParentEthDepositTransactionReceipt](/sdk/reference/message/ParentTransaction#parentethdeposittransactionreceipt)

###### Parameters[​](#parameters-6 "Direct link to Parameters")

Parameter

Type

Description

`contractTransaction`

`ContractTransaction`

###### Returns[​](#returns-10 "Direct link to Returns")

`ParentEthDepositTransaction`

###### Inherited from[​](#inherited-from-9 "Direct link to Inherited from")

`ParentTransactionReceipt.monkeyPatchEthDepositWait`

###### Source[​](#source-10 "Direct link to Source")

[message/ParentTransaction.ts:327](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L327)

##### monkeyPatchWait()[​](#monkeypatchwait "Direct link to monkeyPatchWait()")

```rust
static monkeyPatchWait(contractTransaction: ContractTransaction): ParentContractTransaction<ParentTransactionReceipt>
```

Replaces the wait function with one that returns a ParentTransactionReceipt

###### Parameters[​](#parameters-7 "Direct link to Parameters")

Parameter

Type

Description

`contractTransaction`

`ContractTransaction`

###### Returns[​](#returns-11 "Direct link to Returns")

`ParentContractTransaction`<`ParentTransactionReceipt`\>

###### Inherited from[​](#inherited-from-10 "Direct link to Inherited from")

`ParentTransactionReceipt.monkeyPatchWait`

###### Source[​](#source-11 "Direct link to Source")

[message/ParentTransaction.ts:311](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L311)

* * *

### ParentEthDepositTransactionReceipt[​](#parentethdeposittransactionreceipt "Direct link to ParentEthDepositTransactionReceipt")

A ParentTransactionReceipt with additional functionality that only exists if the transaction created a single eth deposit.

#### Extends[​](#extends-1 "Direct link to Extends")

*   `ParentTransactionReceipt`

#### Methods[​](#methods-1 "Direct link to Methods")

##### getEthDeposits()[​](#getethdeposits-1 "Direct link to getEthDeposits()")

```rust
getEthDeposits(childProvider: Provider): Promise<EthDepositMessage[]>
```

Get any eth deposit messages created by this transaction

###### Parameters[​](#parameters-8 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-12 "Direct link to Returns")

`Promise` <[`EthDepositMessage`](/sdk/reference/message/ParentToChildMessage#ethdepositmessage)\[\]>

###### Inherited from[​](#inherited-from-11 "Direct link to Inherited from")

`ParentTransactionReceipt.getEthDeposits`

###### Source[​](#source-12 "Direct link to Source")

[message/ParentTransaction.ts:191](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L191)

##### getInboxMessageDeliveredEvents()[​](#getinboxmessagedeliveredevents-1 "Direct link to getInboxMessageDeliveredEvents()")

```rust
getInboxMessageDeliveredEvents(): object[]
```

Get any InboxMessageDelivered events that were emitted during this transaction

###### Returns[​](#returns-13 "Direct link to Returns")

`object`\[\]

###### Inherited from[​](#inherited-from-12 "Direct link to Inherited from")

`ParentTransactionReceipt.getInboxMessageDeliveredEvents`

###### Source[​](#source-13 "Direct link to Source")

[message/ParentTransaction.ts:134](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L134)

##### getMessageDeliveredEvents()[​](#getmessagedeliveredevents-1 "Direct link to getMessageDeliveredEvents()")

```rust
getMessageDeliveredEvents(): object[]
```

Get any MessageDelivered events that were emitted during this transaction

###### Returns[​](#returns-14 "Direct link to Returns")

`object`\[\]

###### Inherited from[​](#inherited-from-13 "Direct link to Inherited from")

`ParentTransactionReceipt.getMessageDeliveredEvents`

###### Source[​](#source-14 "Direct link to Source")

[message/ParentTransaction.ts:126](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L126)

##### getMessageEvents()[​](#getmessageevents-1 "Direct link to getMessageEvents()")

```rust
getMessageEvents(): object[]
```

Get combined data for any InboxMessageDelivered and MessageDelivered events emitted during this transaction

###### Returns[​](#returns-15 "Direct link to Returns")

`object`\[\]

###### Inherited from[​](#inherited-from-14 "Direct link to Inherited from")

`ParentTransactionReceipt.getMessageEvents`

###### Source[​](#source-15 "Direct link to Source")

[message/ParentTransaction.ts:147](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L147)

##### getParentToChildMessages()[​](#getparenttochildmessages-1 "Direct link to getParentToChildMessages()")

```rust
getParentToChildMessages<T>(childSignerOrProvider: T): Promise<ParentToChildMessageReaderOrWriter<T>[]>
```

Get any parent-to-child messages created by this transaction

###### Type parameters[​](#type-parameters-3 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-9 "Direct link to Parameters")

Parameter

Type

Description

`childSignerOrProvider`

`T`

###### Returns[​](#returns-16 "Direct link to Returns")

`Promise` <[`ParentToChildMessageReaderOrWriter`](/sdk/reference/message/ParentToChildMessage#parenttochildmessagereaderorwritert)<`T`\>\[\]>

###### Inherited from[​](#inherited-from-15 "Direct link to Inherited from")

`ParentTransactionReceipt.getParentToChildMessages`

###### Source[​](#source-16 "Direct link to Source")

[message/ParentTransaction.ts:248](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L248)

##### getParentToChildMessagesClassic()[​](#getparenttochildmessagesclassic-1 "Direct link to getParentToChildMessagesClassic()")

```rust
getParentToChildMessagesClassic(childProvider: Provider): Promise<ParentToChildMessageReaderClassic[]>
```

Get classic parent-to-child messages created by this transaction

###### Parameters[​](#parameters-10 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

###### Returns[​](#returns-17 "Direct link to Returns")

`Promise`<`ParentToChildMessageReaderClassic`\[\]>

###### Inherited from[​](#inherited-from-16 "Direct link to Inherited from")

`ParentTransactionReceipt.getParentToChildMessagesClassic`

###### Source[​](#source-17 "Direct link to Source")

[message/ParentTransaction.ts:216](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L216)

##### getTokenDepositEvents()[​](#gettokendepositevents-1 "Direct link to getTokenDepositEvents()")

```rust
getTokenDepositEvents(): object[]
```

Get any token deposit events created by this transaction

###### Returns[​](#returns-18 "Direct link to Returns")

`object`\[\]

###### Inherited from[​](#inherited-from-17 "Direct link to Inherited from")

`ParentTransactionReceipt.getTokenDepositEvents`

###### Source[​](#source-18 "Direct link to Source")

[message/ParentTransaction.ts:298](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L298)

##### isClassic()[​](#isclassic-1 "Direct link to isClassic()")

```rust
isClassic<T>(childSignerOrProvider: T): Promise<boolean>
```

Check if is a classic transaction

###### Type parameters[​](#type-parameters-4 "Direct link to Type parameters")

Type parameter

`T` _extends_ `SignerOrProvider`

###### Parameters[​](#parameters-11 "Direct link to Parameters")

Parameter

Type

Description

`childSignerOrProvider`

`T`

###### Returns[​](#returns-19 "Direct link to Returns")

`Promise`<`boolean`\>

###### Inherited from[​](#inherited-from-18 "Direct link to Inherited from")

`ParentTransactionReceipt.isClassic`

###### Source[​](#source-19 "Direct link to Source")

[message/ParentTransaction.ts:106](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L106)

##### waitForChildTransactionReceipt()[​](#waitforchildtransactionreceipt-1 "Direct link to waitForChildTransactionReceipt()")

```rust
waitForChildTransactionReceipt(
   childProvider: Provider, 
   confirmations?: number, 
timeout?: number): Promise<object & EthDepositMessageWaitForStatusResult>
```

Wait for the funds to arrive on the child chain

###### Parameters[​](#parameters-12 "Direct link to Parameters")

Parameter

Type

Description

`childProvider`

`Provider`

\-

`confirmations`?

`number`

Amount of confirmations the retryable ticket and the auto redeem receipt should have

`timeout`?

`number`

Amount of time to wait for the retryable ticket to be created  
Defaults to 15 minutes, as by this time all transactions are expected to be included on the child chain. Throws on timeout.

###### Returns[​](#returns-20 "Direct link to Returns")

`Promise`<`object` & `EthDepositMessageWaitForStatusResult`\>

The wait result contains `complete`, a `status`, the ParentToChildMessage and optionally the `childTxReceipt` If `complete` is true then this message is in the terminal state. For eth deposits complete this is when the status is FUNDS\_DEPOSITED, EXPIRED or REDEEMED.

###### Source[​](#source-20 "Direct link to Source")

[message/ParentTransaction.ts:369](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L369)

##### monkeyPatchContractCallWait()[​](#monkeypatchcontractcallwait-1 "Direct link to monkeyPatchContractCallWait()")

```rust
static monkeyPatchContractCallWait(contractTransaction: ContractTransaction): ParentContractCallTransaction
```

Replaces the wait function with one that returns a [ParentContractCallTransactionReceipt](/sdk/reference/message/ParentTransaction#parentcontractcalltransactionreceipt)

###### Parameters[​](#parameters-13 "Direct link to Parameters")

Parameter

Type

Description

`contractTransaction`

`ContractTransaction`

###### Returns[​](#returns-21 "Direct link to Returns")

`ParentContractCallTransaction`

###### Inherited from[​](#inherited-from-19 "Direct link to Inherited from")

`ParentTransactionReceipt.monkeyPatchContractCallWait`

###### Source[​](#source-21 "Direct link to Source")

[message/ParentTransaction.ts:343](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L343)

##### monkeyPatchEthDepositWait()[​](#monkeypatchethdepositwait-1 "Direct link to monkeyPatchEthDepositWait()")

```rust
static monkeyPatchEthDepositWait(contractTransaction: ContractTransaction): ParentEthDepositTransaction
```

Replaces the wait function with one that returns a [ParentEthDepositTransactionReceipt](/sdk/reference/message/ParentTransaction#parentethdeposittransactionreceipt)

###### Parameters[​](#parameters-14 "Direct link to Parameters")

Parameter

Type

Description

`contractTransaction`

`ContractTransaction`

###### Returns[​](#returns-22 "Direct link to Returns")

`ParentEthDepositTransaction`

###### Inherited from[​](#inherited-from-20 "Direct link to Inherited from")

`ParentTransactionReceipt.monkeyPatchEthDepositWait`

###### Source[​](#source-22 "Direct link to Source")

[message/ParentTransaction.ts:327](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L327)

##### monkeyPatchWait()[​](#monkeypatchwait-1 "Direct link to monkeyPatchWait()")

```rust
static monkeyPatchWait(contractTransaction: ContractTransaction): ParentContractTransaction<ParentTransactionReceipt>
```

Replaces the wait function with one that returns a ParentTransactionReceipt

###### Parameters[​](#parameters-15 "Direct link to Parameters")

Parameter

Type

Description

`contractTransaction`

`ContractTransaction`

###### Returns[​](#returns-23 "Direct link to Returns")

`ParentContractTransaction`<`ParentTransactionReceipt`\>

###### Inherited from[​](#inherited-from-21 "Direct link to Inherited from")

`ParentTransactionReceipt.monkeyPatchWait`

###### Source[​](#source-23 "Direct link to Source")

[message/ParentTransaction.ts:311](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/message/ParentTransaction.ts#L311)

---

# arbProvider | Arbitrum Docs

## arbProvider

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### ArbitrumProvider[​](#arbitrumprovider "Direct link to ArbitrumProvider")

Arbitrum specific formats

#### Extends[​](#extends "Direct link to Extends")

*   `Web3Provider`

#### Constructors[​](#constructors "Direct link to Constructors")

##### new ArbitrumProvider()[​](#new-arbitrumprovider "Direct link to new ArbitrumProvider()")

```rust
new ArbitrumProvider(provider: JsonRpcProvider, network?: Networkish): ArbitrumProvider
```

Arbitrum specific formats

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`provider`

`JsonRpcProvider`

Must be connected to an Arbitrum network

`network`?

`Networkish`

Must be an Arbitrum network

###### Returns[​](#returns "Direct link to Returns")

[`ArbitrumProvider`](/sdk/reference/utils/arbProvider#arbitrumprovider)

###### Overrides[​](#overrides "Direct link to Overrides")

`Web3Provider.constructor`

###### Source[​](#source "Direct link to Source")

[utils/arbProvider.ts:77](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/arbProvider.ts#L77)

---

# byte\_serialize\_params | Arbitrum Docs

## byte_serialize_params

Functions[​](#functions "Direct link to Functions")
---------------------------------------------------

### argSerializerConstructor()[​](#argserializerconstructor "Direct link to argSerializerConstructor()")

```rust
function argSerializerConstructor(arbProvider: Provider): (params: PrimativeOrPrimativeArray[]) => Promise<Uint8Array>
```

to use:

```rust
const mySerializeParamsFunction = argSerializerConstructor("rpcurl")
mySerializeParamsFunction(["4","5", "6"])
```

#### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

`arbProvider`

`Provider`

#### Returns[​](#returns "Direct link to Returns")

`Function`

##### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

`params`

`PrimativeOrPrimativeArray`\[\]

##### Returns[​](#returns-1 "Direct link to Returns")

`Promise`<`Uint8Array`\>

#### Source[​](#source "Direct link to Source")

[utils/byte\_serialize\_params.ts:102](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/byte_serialize_params.ts#L102)

* * *

### serializeParams()[​](#serializeparams "Direct link to serializeParams()")

```rust
function serializeParams(params: PrimativeOrPrimativeArray[], addressToIndex: (address: string) => Promise<number>): Promise<Uint8Array>
```

#### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`params`

`PrimativeOrPrimativeArray`\[\]

array of serializable types to

`addressToIndex`

(`address`: `string`) => `Promise`<`number`\>

optional getter of address index registered in table

#### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`Uint8Array`\>

#### Source[​](#source-1 "Direct link to Source")

[utils/byte\_serialize\_params.ts:138](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/byte_serialize_params.ts#L138)

---

# eventFetcher | Arbitrum Docs

## eventFetcher

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### EventFetcher[​](#eventfetcher "Direct link to EventFetcher")

Fetches and parses blockchain logs

#### Methods[​](#methods "Direct link to Methods")

##### getEvents()[​](#getevents "Direct link to getEvents()")

```rust
getEvents<TContract, TEventFilter>(
   contractFactory: TypeChainContractFactory<TContract>, 
   topicGenerator: (t: TContract) => TEventFilter, 
filter: object): Promise<FetchedEvent<TEventOf<TEventFilter>>[]>
```

Fetch logs and parse logs

###### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`TContract` _extends_ `Contract`

`TEventFilter` _extends_ `TypedEventFilter`<`TypedEvent`<`any`, `any`\>>

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`contractFactory`

[`TypeChainContractFactory`](/sdk/reference/dataEntities/event#typechaincontractfactorytcontract)<`TContract`\>

A contract factory for generating a contract of type TContract at the addr

`topicGenerator`

(`t`: `TContract`) => `TEventFilter`

Generator function for creating

`filter`

`object`

Block and address filter parameters

`filter.address`?

`string`

\-

`filter.fromBlock`

`BlockTag`

\-

`filter.toBlock`

`BlockTag`

\-

###### Returns[​](#returns "Direct link to Returns")

`Promise`<`FetchedEvent`<`TEventOf`<`TEventFilter`\>>\[\]>

###### Source[​](#source "Direct link to Source")

[utils/eventFetcher.ts:57](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/eventFetcher.ts#L57)

---

# lib | Arbitrum Docs

## lib

Functions[​](#functions "Direct link to Functions")
---------------------------------------------------

### getFirstBlockForL1Block()[​](#getfirstblockforl1block "Direct link to getFirstBlockForL1Block()")

```rust
function getFirstBlockForL1Block(__namedParameters: GetFirstBlockForL1BlockProps): Promise<number | undefined>
```

This function performs a binary search to find the first Arbitrum block that corresponds to a given L1 block number. The function returns a Promise that resolves to a number if a block is found, or undefined otherwise.

#### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

`__namedParameters`

`GetFirstBlockForL1BlockProps`

#### Returns[​](#returns "Direct link to Returns")

`Promise`<`number` | `undefined`\>

*   A Promise that resolves to a number if a block is found, or undefined otherwise.

#### Source[​](#source "Direct link to Source")

[utils/lib.ts:90](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/lib.ts#L90)

* * *

### getTransactionReceipt()[​](#gettransactionreceipt "Direct link to getTransactionReceipt()")

```rust
function getTransactionReceipt(
   provider: Provider, 
   txHash: string, 
   confirmations?: number, 
timeout?: number): Promise<null | TransactionReceipt>
```

Waits for a transaction receipt if confirmations or timeout is provided Otherwise tries to fetch straight away.

#### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`provider`

`Provider`

`txHash`

`string`

`confirmations`?

`number`

`timeout`?

`number`

#### Returns[​](#returns-1 "Direct link to Returns")

`Promise`<`null` | `TransactionReceipt`\>

#### Source[​](#source-1 "Direct link to Source")

[utils/lib.ts:33](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/lib.ts#L33)

---

# multicall | Arbitrum Docs

## multicall

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

### MultiCaller[​](#multicaller "Direct link to MultiCaller")

Util for executing multi calls against the MultiCallV2 contract

#### Properties[​](#properties "Direct link to Properties")

Property

Modifier

Type

Description

`address`

`readonly`

`string`

Address of multicall contract

#### Methods[​](#methods "Direct link to Methods")

##### getBlockNumberInput()[​](#getblocknumberinput "Direct link to getBlockNumberInput()")

```rust
getBlockNumberInput(): CallInput<BigNumber>
```

Get the call input for the current block number

###### Returns[​](#returns "Direct link to Returns")

[`CallInput`](/sdk/reference/utils/multicall#callinputt)<`BigNumber`\>

###### Source[​](#source "Direct link to Source")

[utils/multicall.ts:133](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/multicall.ts#L133)

##### getCurrentBlockTimestampInput()[​](#getcurrentblocktimestampinput "Direct link to getCurrentBlockTimestampInput()")

```rust
getCurrentBlockTimestampInput(): CallInput<BigNumber>
```

Get the call input for the current block timestamp

###### Returns[​](#returns-1 "Direct link to Returns")

[`CallInput`](/sdk/reference/utils/multicall#callinputt)<`BigNumber`\>

###### Source[​](#source-1 "Direct link to Source")

[utils/multicall.ts:149](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/multicall.ts#L149)

##### getTokenData()[​](#gettokendata "Direct link to getTokenData()")

```rust
getTokenData<T>(erc20Addresses: string[], options?: T): Promise<TokenInputOutput<T>[]>
```

Multicall for token properties. Will collect all the requested properies for each of the supplied token addresses.

###### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T` _extends_ `undefined` | `TokenMultiInput`

###### Parameters[​](#parameters "Direct link to Parameters")

Parameter

Type

Description

`erc20Addresses`

`string`\[\]

`options`?

`T`

Defaults to just 'name'

###### Returns[​](#returns-2 "Direct link to Returns")

`Promise`<`TokenInputOutput`<`T`\>\[\]>

###### Source[​](#source-2 "Direct link to Source")

[utils/multicall.ts:231](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/multicall.ts#L231)

##### multiCall()[​](#multicall "Direct link to multiCall()")

```rust
multiCall<T, TRequireSuccess>(params: T, requireSuccess?: TRequireSuccess): Promise<DecoderReturnType<T, TRequireSuccess>>
```

Executes a multicall for the given parameters Return values are order the same as the inputs. If a call failed undefined is returned instead of the value.

To get better type inference when the individual calls are of different types create your inputs as a tuple and pass the tuple in. The return type will be a tuple of the decoded return types. eg.

```rust
  const inputs: [
    CallInput<Awaited<ReturnType<ERC20['functions']['balanceOf']>>[0]>,
    CallInput<Awaited<ReturnType<ERC20['functions']['name']>>[0]>
  ] = [
    {
      targetAddr: token.address,
      encoder: () => token.interface.encodeFunctionData('balanceOf', ['']),
      decoder: (returnData: string) =>
        token.interface.decodeFunctionResult('balanceOf', returnData)[0],
    },
    {
      targetAddr: token.address,
      encoder: () => token.interface.encodeFunctionData('name'),
      decoder: (returnData: string) =>
        token.interface.decodeFunctionResult('name', returnData)[0],
    },
  ]

  const res = await multiCaller.call(inputs)
```

###### Type parameters[​](#type-parameters-1 "Direct link to Type parameters")

Type parameter

`T` _extends_ [`CallInput`](/sdk/reference/utils/multicall#callinputt)<`unknown`\>\[\]

`TRequireSuccess` _extends_ `boolean`

###### Parameters[​](#parameters-1 "Direct link to Parameters")

Parameter

Type

Description

`params`

`T`

`requireSuccess`?

`TRequireSuccess`

Fail the whole call if any internal call fails

###### Returns[​](#returns-3 "Direct link to Returns")

`Promise`<`DecoderReturnType`<`T`, `TRequireSuccess`\>>

###### Source[​](#source-3 "Direct link to Source")

[utils/multicall.ts:197](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/multicall.ts#L197)

##### fromProvider()[​](#fromprovider "Direct link to fromProvider()")

```rust
static fromProvider(provider: Provider): Promise<MultiCaller>
```

Finds the correct multicall address for the given provider and instantiates a multicaller

###### Parameters[​](#parameters-2 "Direct link to Parameters")

Parameter

Type

Description

`provider`

`Provider`

###### Returns[​](#returns-4 "Direct link to Returns")

`Promise` <[`MultiCaller`](/sdk/reference/utils/multicall#multicaller)\>

###### Source[​](#source-4 "Direct link to Source")

[utils/multicall.ts:125](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/multicall.ts#L125)

Type Aliases[​](#type-aliases "Direct link to Type Aliases")
------------------------------------------------------------

### CallInput<T>[​](#callinputt "Direct link to CallInput<T>")

```rust
type CallInput<T>: object;
```

Input to multicall aggregator

#### Type parameters[​](#type-parameters-2 "Direct link to Type parameters")

Type parameter

`T`

#### Type declaration[​](#type-declaration "Direct link to Type declaration")

Member

Type

Description

`decoder`

(`returnData`: `string`) => `T`

Function to decode the result of the call

`encoder`

() => `string`

Function to produce encoded call data

`targetAddr`

`string`

Address of the target contract to be called

#### Source[​](#source-5 "Direct link to Source")

[utils/multicall.ts:30](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/multicall.ts#L30)

---

# types | Arbitrum Docs

## types

Type Aliases[​](#type-aliases "Direct link to Type Aliases")
------------------------------------------------------------

### OmitTyped<T, K>[​](#omittypedt-k "Direct link to OmitTyped<T, K>")

```rust
type OmitTyped<T, K>: Omit<T, K>;
```

Omit doesnt enforce that the seconds generic is a keyof the first OmitTyped guards against the underlying type prop names being refactored, and not being updated in the usage of OmitTyped

#### Type parameters[​](#type-parameters "Direct link to Type parameters")

Type parameter

`T`

`K` _extends_ keyof `T`

#### Source[​](#source "Direct link to Source")

[utils/types.ts:6](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/types.ts#L6)

* * *

### PartialPick<T, K>[​](#partialpickt-k "Direct link to PartialPick<T, K>")

```rust
type PartialPick<T, K>: OmitTyped<T, K> & Partial<T>;
```

Make the specified properties optional

#### Type parameters[​](#type-parameters-1 "Direct link to Type parameters")

Type parameter

`T`

`K` _extends_ keyof `T`

#### Source[​](#source-1 "Direct link to Source")

[utils/types.ts:11](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/types.ts#L11)

* * *

### RequiredPick<T, K>[​](#requiredpickt-k "Direct link to RequiredPick<T, K>")

```rust
type RequiredPick<T, K>: Required<Pick<T, K>> & T;
```

Make the specified properties required

#### Type parameters[​](#type-parameters-2 "Direct link to Type parameters")

Type parameter

`T`

`K` _extends_ keyof `T`

#### Source[​](#source-2 "Direct link to Source")

[utils/types.ts:16](https://github.com/OffchainLabs/arbitrum-sdk/blob/b8d7b712331a78aa8e789c06496a2586170ad5d3/src/lib/utils/types.ts#L16)

---

# A gentle introduction to Arbitrum | Arbitrum Docs

## A gentle introduction to Arbitrum

#### Q: Hello! What’s Arbitrum?[​](#q-hello-whats-arbitrum "Direct link to Q: Hello! What’s Arbitrum?")

Hi!  is a technology suite designed to scale Ethereum. You can use Arbitrum chains to do all things you do on Ethereum — use Web3 apps, deploy smart contracts, etc., but your transactions will be cheaper and faster. Our flagship product — Arbitrum Rollup — is an Optimistic rollup protocol that inherits Ethereum-level security.

#### Q: What, what’s “Ethereum”? What's a “smart contract”? Where am I?[​](#q-what-whats-ethereum-whats-a-smart-contract-where-am-i "Direct link to Q: What, what’s “Ethereum”? What's a “smart contract”? Where am I?")

If you aren’t yet familiar with the Ethereum ecosystem, you can check out [ethereum.org](https://ethereum.org/en/learn/) for an intro. Come back whenever you're ready, no rush.

#### Q: You said Arbitrum exists to “scale” Ethereum; why does Ethereum need this help? Is there something wrong with Ethereum?[​](#q-you-said-arbitrum-exists-to-scale-ethereum-why-does-ethereum-need-this-help-is-there-something-wrong-with-ethereum "Direct link to Q: You said Arbitrum exists to “scale” Ethereum; why does Ethereum need this help? Is there something wrong with Ethereum?")

Ethereum is awesome; on its own, however, it’s also very limited. The Ethereum  only allows about 20-40 transactions per second (TPS) (that’s in total, for all Ethereum users); when the limit is reached, users are forced to compete against each other for their transactions to be included, which causes fees to go up.

#### Q: Why does Ethereum have such low TPS?[​](#q-why-does-ethereum-have-such-low-tps "Direct link to Q: Why does Ethereum have such low TPS?")

This was a deliberate decision in Ethereum’s design. Ethereum requires that its nodes (computers running the Ethereum software) have a way of coming to consensus on the current state of things; the way they do this is by processing every  in Ethereum’s history; i.e., if you’ve ever used Ethereum, every Ethereum full node has a copy of your transactions in its blockchain ledger.

One of the Ethereum community’s precepts, being an open, decentralized, peer to peer system, is that it should be reasonably accessible for anyone to run an Ethereum node and validate the chain for themselves; i.e., if it gets too expensive (in terms of hardware requirements / computational resources), this undercuts the fundamental goal of decentralization. The combination of these two factors — every node has to process every transaction, and we want it to be relatively feasible to run a node — means Ethereum transaction throughput has to be capped fairly low.

#### Q: And Arbitrum Rollup fixes this?[​](#q-and-arbitrum-rollup-fixes-this "Direct link to Q: And Arbitrum Rollup fixes this?")

Arbitrum rollup fixes this! The basic idea is this: an  runs as a sort of sub-module within Ethereum. Unlike regular, layer 1 ( “L1”) Ethereum transactions, we don’t require Ethereum nodes to process every Arbitrum transaction; rather, Ethereum adopts an [“innocent until proven guilty"](https://insights.deribit.com/market-research/making-sense-of-rollups-part-2-dispute-resolution-on-arbitrum-and-optimism/) attitude to Arbitrum. Layer 1 initially “optimistically assumes” activity on Arbitrum is following the proper rules. If a violation occurs (i.e., somebody claims “now I have all of your money”), this claim can be disputed back on L1; fraud will be proven, the invalid claim disregarded, and the malicious party will be financially penalized.

This ability to adjudicate and prove fraud on L1 is Arbitrum’s key, fundamental feature, and is how and why the system inherits Ethereum’s security.

#### Q: So we can use Ethereum to prove fraud on Arbitrum; cool! But if fraud is committed, can we be absolutely sure that we'll be able to prove it?[​](#q-so-we-can-use-ethereum-to-prove-fraud-on-arbitrum-cool-but-if-fraud-is-committed-can-we-be-absolutely-sure-that-well-be-able-to-prove-it "Direct link to Q: So we can use Ethereum to prove fraud on Arbitrum; cool! But if fraud is committed, can we be absolutely sure that we'll be able to prove it?")

Yes, indeed we can be. This is where the “rollup” part comes in. The data that gets fed into an Arbitrum Rollup chain (i.e., user’s transaction data) is posted directly on Ethereum. Thus, as long as Ethereum itself is running securely, anybody who’s interested has visibility into what’s going on in Arbitrum, and has the ability to detect and prove fraud.

#### Q: Who actually does this work (of checking for fraud, proving it, etc?)[​](#q-who-actually-does-this-work-of-checking-for-fraud-proving-it-etc "Direct link to Q: Who actually does this work (of checking for fraud, proving it, etc?)")

The parties who move the Arbitrum chain state forward on L1 — i.e., making claims about the chain’s state, disputing other’s claims, etc. — are called validators. In practice, we don’t expect the average Arbitrum user to be interested in running a validator, just like the average Ethereum user typically doesn’t run their own layer 1 staking node. The crucial property, however, is that anybody can; becoming an Arbitrum validator requires no special permission ([once the allowlist is lifted](https://docs.arbitrum.foundation/state-of-progressive-decentralization)), only that a user runs the [open source validator software](https://github.com/OffchainLabs/nitro) (and stakes Ether when/if they need to take action).

Additionally, as long as there’s even just one honest validator, the chain will remain secure; i.e., it only takes one non-malicious fraud-prover to catch any number of malicious trouble-makers. These properties together make the system “trustless”; users are not relying on any special designated party for their funds to be secure.

#### Q: And how exactly is “fraud” “proven”? Sounds complicated.[​](#q-and-how-exactly-is-fraud-proven-sounds-complicated "Direct link to Q: And how exactly is “fraud” “proven”? Sounds complicated.")

Oh, it’s not so bad. In essence, if two validators disagree, only one of them (at most) can be telling the truth. In a dispute, the two validators play an interactive, call-and-response game in which they narrow down their dispute to a single computational step (think of something small and simple, like multiplying two numbers). This one step gets executed on L1 and will necessarily prove that the honest party was telling the truth. For a more detailed rundown, see [here](/how-arbitrum-works/interactive-fraud-proofs).

#### Q: This dispute game obviously takes some time; does this impose any sort of delay on Arbitrum users' transactions?[​](#q-this-dispute-game-obviously-takes-some-time-does-this-impose-any-sort-of-delay-on-arbitrum-users-transactions "Direct link to Q: This dispute game obviously takes some time; does this impose any sort of delay on Arbitrum users' transactions?")

The only delay that's felt by a user is in "withdrawing" — moving their funds from Arbitrum back to Ethereum; if users are withdrawing directly from Arbitrum to Ethereum, they must typically wait 1 week before receiving their funds on L1. If users use a fast- application, however, they can bypass this delay period entirely (likely for a small fee). Anything else a user does — i.e., depositing funds from Ethereum onto Arbitrum, or using a  deployed on an Arbitrum chain — doesn't incur this delay period.

#### Q: Okay, so backing up: the “optimistic execution” part is how and why Arbitrum is able to offer low fees, yes?[​](#q-okay-so-backing-up-the-optimistic-execution-part-is-how-and-why-arbitrum-is-able-to-offer-low-fees-yes "Direct link to Q: Okay, so backing up: the “optimistic execution” part is how and why Arbitrum is able to offer low fees, yes?")

Primarily, yes, this is the heart of where the savings come from. However, there are a number of other means by which Arbitrum alleviates the burden on L1, all of which translate to lower transaction costs for end users. For one, Arbitrum transactions are submitted on the L1 in batches; typically, a single  (submitted in a single L1 transaction) will contain several hundred L2 transactions. Batching amortizes the overhead cost of interacting with the L1, and thus offers significant savings over posting individual transactions at a time. Furthermore, the transaction data is posted on L1 in compressed form (and only decompressed within the L2 environment), further minimizing the transaction’s L1 footprint.

#### Q: As far as the experience of using Arbitrum: when you said that it’s very similar to using Ethereum…[​](#q-as-far-as-the-experience-of-using-arbitrum-when-you-said-that-its-very-similar-to-using-ethereum "Direct link to Q: As far as the experience of using Arbitrum: when you said that it’s very similar to using Ethereum…")

We really meant it, yes. Different layer 2 protocols emphasize and optimize for different things; Arbitrum was created with Ethereum compatibility as a top priority. This means users can use Arbitrum with all their favorite Ethereum wallets; developers can build and deploy contracts with all their favorite Ethereum libraries and tooling; in fact, most of the time, the experience of using Arbitrum will feel identical to that of using Ethereum (with the important exception of it being much cheaper and faster).

Much development went into achieving this level of Ethereum compatibility. But at its core: the Arbitrum itself uses a fork of [Geth](/how-arbitrum-works/geth-at-the-core) — the most widely used Ethereum implementation — with modifications to transform it into a trustless layer 2. This means most of the code running in Arbitrum is identical to the code running in Ethereum. We call this cutting-edge approach Nitro (developers can see the codebase [here](https://github.com/OffchainLabs/nitro)).

#### Q: So builders can do all the stuff they do on Ethereum on Arbitrum, nice! But can they do _more_?[​](#q-so-builders-can-do-all-the-stuff-they-do-on-ethereum-on-arbitrum-nice-but-can-they-do-more "Direct link to q-so-builders-can-do-all-the-stuff-they-do-on-ethereum-on-arbitrum-nice-but-can-they-do-more")

They can; the latest version of the Arbitrum tech stack, called , keeps Nitro's Ethereum compatibility, while adding on powerful new features, namely the ability to write highly performant smart contracts in programming languages like Rust, C++, and more.  is currently on public testnet; you can read more about it [here](/stylus/gentle-introduction).

#### Q: So it sounds like Arbitrum Rollup is an ideal solution that solves any and all scaling problems…?[​](#q-so-it-sounds-like-arbitrum-rollup-is-an-ideal-solution-that-solves-any-and-all-scaling-problems "Direct link to Q: So it sounds like Arbitrum Rollup is an ideal solution that solves any and all scaling problems…?")

Arbitrum Rollup is very awesome and cool; its design is geared heavily toward avoidance of introducing any centralization or trust assumptions, and it is thus a clear, strict net-win for the Ethereum ecosystem. Decentralization, however, comes at a (literal) price, and not all applications and users necessarily want or need to pay that price. For dapp use-cases with different security considerations, different tools in the Arbitrum suite are appropriate; i.e., Arbitrum AnyTrust chains!

#### Q: What’s an AnyTrust chain?[​](#q-whats-an-anytrust-chain "Direct link to Q: What’s an AnyTrust chain?")

An  doesn’t have the same decentralization / trustlessness / permissionless security guarantees of a Rollup chain, and thus can offer lower fees. Rollup and AnyTrust are similar in many ways, though have one key difference: whereas in Rollup, all data is posted on L1 (which allows anyone to permissionless join as a validator), in AnyTrust, data is managed off-chain. In the case of a , an AnyTrust chain reverts back to “rollup mode”; the security assumption here is that at least 2 of the committee members are honest (i.e., they will provide the data when it’s necessary). Keeping the data off-chain in the happy/common case means the system can charge the user significantly lower fees. For applications that require high transaction throughput and don’t require the full decentralization that rollups provide, AnyTrust could be a sensible tradeoff.

#### Q: So there's more than one Arbitrum chain out there?[​](#q-so-theres-more-than-one-arbitrum-chain-out-there "Direct link to Q: So there's more than one Arbitrum chain out there?")

Yep! The fact that multiple chains can run in parallel is a crucial perk to off-chain scaling technology.

Here’s a snapshot of the chains running on Arbitrum:

*   On Ethereum mainnet:
    
    *   ["Arbitrum One"](https://portal.arbitrum.one/): an  operated by the [Arbitrum Foundation](https://arbitrum.foundation)
    *   ["Nova"](https://nova.arbitrum.io/): an  operated by the [Arbitrum Foundation](https://arbitrum.foundation)
*   On Arbitrum One and Nova:
    
    *   Various L3 (Orbit) chain
*   On other L2s:
    
    *   Various L2 (Orbit) chain

![700px-img](/assets/images/arbitrum-chains-diagram-b72489f575d8d56d39425a73c645072b.jpeg)

Developers can launch their own Arbitrum chains that run as an L2 chain on top of Ethereum. They can also run Arbitrum chains that run on top of an EVM L2 chain.

Checkout the [Arbitrum Portal](https://portal.arbitrum.io/orbit/ecosystem) for an extensive overview of the Orbit chains running on Arbitrum.

Users and developers can pick whatever suits their security / transaction cost needs.

#### Q: Who makes decisions about the future of Arbitrum One and Arbitrum Nova?[​](#q-who-makes-decisions-about-the-future-of-arbitrum-one-and-arbitrum-nova "Direct link to Q: Who makes decisions about the future of Arbitrum One and Arbitrum Nova?")

The  and Nova chains are owned by the Governance system; to learn more, see the [Arbitrum Governance docs](https://docs.arbitrum.foundation/).

---

# Get started with Arbitrum | Arbitrum Docs

## Get started with Arbitrum

 is a suite of Ethereum scaling solutions that make it easy to build and use decentralized applications. This document provides a high-level overview of the Arbitrum suite along with onboarding guidance tailored to specific audiences.

The Arbitrum suite[​](#the-arbitrum-suite "Direct link to The Arbitrum suite")
------------------------------------------------------------------------------

The Arbitrum suite includes the protocols, chains, services, and SDKs that power the Arbitrum ecosystem:

Component

Description

[Arbitrum Rollup](/how-arbitrum-works/optimistic-rollup)

A **protocol** for scaling Ethereum smart contracts.

[Arbitrum AnyTrust](/how-arbitrum-works/anytrust-protocol)

A **protocol** for scaling Ethereum smart contracts even further, with a mild trust assumption.

[Arbitrum Nitro](/how-arbitrum-works/a-gentle-introduction)

The node **software** that codifies the Rollup and AnyTrust protocols.

[Arbitrum nodes](/run-arbitrum-node/run-full-node)

**Machines** that run Nitro in order to service and/or interact with an Arbitrum chain.

[Arbitrum One](https://portal.arbitrum.io/?chains=arbitrum-one)

A public Rollup **chain**.

[Arbitrum Nova](https://portal.arbitrum.io/?chains=arbitrum-nova)

A public AnyTrust **chain**.

[Arbitrum bridge](https://bridge.arbitrum.io/)

Lets you move ETH and ERC-20 tokens between Ethereum, Arbitrum, and select Orbit chains.

[Arbitrum Orbit](https://orbit.arbitrum.io/)

Lets you run your own Rollup and AnyTrust chains.

[Arbitrum Stylus](/stylus/gentle-introduction)

Lets you write EVM-compatible smart contracts in Rust and any other language that compiles to Wasm.

Arbitrum for users[​](#arbitrum-for-users "Direct link to Arbitrum for users")
------------------------------------------------------------------------------

**Users** interact with Arbitrum either through the Arbitrum bridge or by using dApps that have been deployed to an Arbitrum chain.

Resource

Description

[Arbitrum bridge](https://bridge.arbitrum.io/)

Lets you move ETH and ERC-20 tokens between Ethereum, Arbitrum, and select Orbit chains.

[Arbitrum Portal](https://portal.arbitrum.io/)

A directory of dApps on Arbitrum.

[Quickstart (bridge)](/arbitrum-bridge/quickstart)

Provides step-by-step instructions for first-time bridge users.

Arbitrum for developers[​](#arbitrum-for-developers "Direct link to Arbitrum for developers")
---------------------------------------------------------------------------------------------

**Developers** build Arbitrum dApps by deploying smart contracts to an Arbitrum chain.

Resource

Description

[A gentle introduction to Arbitrum](/welcome/arbitrum-gentle-introduction)

A technical introduction to Arbitrum's suite of scaling solutions.

[Quickstart (Solidity)](/build-decentralized-apps/quickstart-solidity-remix)

Targeted at web2 developers who want to deploy their first Solidity smart contract to Arbitrum.

[Quickstart (Rust)](/stylus/quickstart)

Targeted at web3 developers who want to deploy their first Rust smart contract to Arbitrum using Stylus.

Arbitrum for node runners[​](#arbitrum-for-node-runners "Direct link to Arbitrum for node runners")
---------------------------------------------------------------------------------------------------

**Node runners** run the machines that support the Arbitrum ecosystem.

Resource

Description

[Run a full node](/run-arbitrum-node/run-full-node)

Targeted at node runners who want to access Arbitrum chains without having to connect to a third-party node.

[Configure a Data Availability Committee](/run-arbitrum-node/data-availability-committees/get-started)

Targeted at Data Availability Committee members and Orbit chain operators who want to run a Data Availability Server.

Arbitrum for chain operators[​](#arbitrum-for-chain-operators "Direct link to Arbitrum for chain operators")
------------------------------------------------------------------------------------------------------------

**Chain operators** use Arbitrum Orbit to run special-purpose Rollup and AnyTrust chains.

Resource

Description

[Orbit gentle introduction](/launch-orbit-chain/a-gentle-introduction)

Targeted at readers who want to understand Orbit's value proposition and use cases.

[Orbit quickstart](/launch-orbit-chain/orbit-quickstart)

Targeted at chain operators who want to deploy their first Arbitrum chain using Arbitrum Orbit.

How it works[​](#how-it-works "Direct link to How it works")
------------------------------------------------------------

Resource

Description

[Inside Nitro](/how-arbitrum-works/a-gentle-introduction)

A technical deep dive into Nitro's architecture.

[Inside AnyTrust](/how-arbitrum-works/anytrust-protocol)

A technical deep dive into the AnyTrust protocol.

[Arbitrum whitepaper](https://github.com/OffchainLabs/nitro/blob/master/docs/Nitro-whitepaper.pdf)

The original whitepaper that introduced Nitro.

[DAO docs](https://docs.arbitrum.foundation/gentle-intro-dao-governance)

Docs that support members of the Arbitrum DAO.