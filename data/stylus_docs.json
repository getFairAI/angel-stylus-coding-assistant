[
  {
    "text": "Stylus Rust SDK overview\n\nThis section provides an in-depth overview of the features provided by the Stylus Rust SDK . For information about deploying Rust smart contracts, see the cargo stylus CLI Tool . For a conceptual introduction to Stylus, see Stylus: A Gentle Introduction . To deploy your first Stylus smart contract using Rust, refer to the Quickstart .\n\nThe Stylus Rust SDK is built on top of Alloy , a collection of crates empowering the Rust Ethereum ecosystem. Because the SDK uses the same Rust primitives for Ethereum types , Stylus is compatible with existing Rust libraries.\n\nThe Stylus Rust SDK has been audited in August 2024 at commit #62bd831 by Open Zeppelin which can be viewed on our audits page .\n\nThis section contains a set of pages that describe a certain aspect of the Stylus Rust SDK, like how to work with variables , or what ways are there to send ether . Additionally, there's also a page that compiles a set of advanced features that the Stylus Rust SDK provides.\n\nFinally, there's also a Stylus by example portal available that provides most of the information included in this section, as well as many different example contracts.",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Overview"
    }
  },
  {
    "text": "Structure of a Rust Contract\n\nContracts in Rust are similar to contracts in Solidity. Each contract can contain declarations of State Variables, Functions, Function Modifiers, Events, Errors, Struct Types, and Enum Types. In addition, Rust contracts can import third-party packages from crates.io as dependencies and use them for advanced functionality.\n\nProject layout ​\n\nIn the most basic example, this is how a Rust contract will be organized. The simplest way to get going with a new project is to follow the Quickstart guide, or if you've already installed all dependencies, just run cargo stylus new <YOUR_PROJECT_NAME> from your terminal to begin a new project. Once installed, your project will include the following required files:\n\n- src - lib.rs - main.rs - Cargo.toml - rust-toolchain.toml\n\nsrc/lib.rs is the root module of your contract's code. Here, you can import utilities or methods from internal or external modules, define the data layout of your contract's state variables, and define your contract's public API. This module must define a root data struct with the #[entrypoint] macro and provide an impl block annotated with #[public] to define public or external methods. See First App for an example of this. These macros are used to maintain Solidity ABI compatibility to ensure that Rust contracts work with existing Solidity libraries and tooling.\n\nsrc/main.rs is typically auto-generated by cargo-stylus and does not usually need to be modified. Its purpose is to assist with the generation of JSON describing your contract's public interface, for use with automated tooling and frontend frameworks.\n\nCargo.toml is a standard file that Rust projects use to define a package's name, repository location, etc, as well as import dependencies and define feature and build flags. From here, you can define required dependencies such as the Stylus SDK itself or import third-party packages from crates.io . See First Steps with Cargo if you are new to Rust.\n\nrust-toolchain.toml is used by public blockchain explorers, like Arbiscan , to assist with source code verification. To ensure that source code can be compiled deterministically, we use this file to include relevant metadata like what version of Rust was used. It can also be used to pin the project to a specific Rust version that it's compatible with.\n\nYour contract may also include other dot files (such as .gitignore , .env , etc), markdown files for docs, or additional subfolders.\n\nState variables ​\n\nLike Solidity, Rust contracts are able to define state variables . These are variables which are stored on the chain's state trie , which is essentially the chain's database. They differ from standard Rust variables in that they must implement the Storage trait from the Stylus SDK. This trait is used to layout the data in the trie in a Solidity-compatible fashion. The Stylus SDK provides Storage types for all Solidity primitives out-of-the-box, such as StorageAddress , StorageU256 , etc. See storage module for more information.\n\nWhen working with state variables, you can either use Rust-style syntax or Solidity-style syntax to define your data schema. The #[storage] macro is used to define Rust-style state variables while sol_storage! macro is used for Solidity-style state variables. Both styles may have more than one struct but must annotate a single struct as the root struct with #[entrypoint] macro. Below are examples of each.\n\nRust-style Schema\n\nuse stylus_sdk :: { prelude :: * , storage :: { StorageU256 , StorageAddress } } ; #[storage] #[entrypoint] pub struct MyContract { owner : StorageAddress , version : StorageU256 , }\n\nSolidity-style Schema\n\nuse stylus_sdk :: { prelude :: * } ; sol_storage! { #[entrypoint] pub struct MyContract { address owner ; version : uint256 , } }\n\nTo read from state or write to it, getters and setters are used:\n\nlet new_count = self . count . get ( ) + U256 :: from ( 1 ) ; self . count . set ( new_count ) ;\n\nSee Storage Data Types for more examples of this.\n\nFunctions ​\n\nContract functions are defined by providing an impl block for your contract's #[entrypoint] struct and annotating that block with #[public] to make the functions part of the contract's public API. The first parameter of each function is &self , which references the struct annotated with #[entrypoint] , it's used for reading state variables. By default, methods are view-only and cannot mutate state. To make a function mutable and able to alter state, &mut self must be used. Internal methods can be defined on a separate impl block for the struct that is not annotated with #[public] . Internal methods can access state.\n\n// Defines the public, external methods for your contract // This impl block must be for the #[entrypoint] struct defined prior #[public] impl Counter { // By annotating first arg with &self, this indicates a view function pub fn get ( & self ) -> U256 { self . count . get ( ) } // By annotating with &mut self, this is a mutable public function pub fn set_count ( & mut self , count : U256 ) { self . count . set ( count ) ; } } // Internal methods (NOT part of public API) impl Counter { fn add ( a : U256 , b : U256 ) -> U256 { a + b } }\n\nModules ​\n\nModules are a way to organize code into logical units. While your contract must have a lib.rs which defines your entrypoint struct, you can also define utility functions, structs, enums, etc., in modules and import them to use in your contract's methods.\n\nFor example, with this file structure:\n\n- src - lib.rs - main.rs - utils - mod.rs - Cargo.toml - rust-toolchain.toml\n\nIn lib.rs :\n\n// import module mod utils ; // ..other code const score = utils :: check_score ( ) ;\n\nSee Defining modules in the Rust book for more info on modules and how to use them.\n\nImporting packages ​\n\nRust has a robust package manager for managing dependencies and importing third-party libraries to use in your smart contracts. These packages (called crates in Rust) are located at crates.io . To make use of a dependency in your code, you'll need to complete these steps:\n\nAdd the package name and version to your Cargo.toml :\n\n# Cargo.toml [ package ] # ...package info here [ dependencies ] rust_decimal = \"1.36.0\"\n\nImport the package into your contract:\n\n// lib.rs use rust_decimal_macros :: dec ;\n\nUse imported types in your contract:\n\n// create a fixed point Decimal value let price = dec! ( 72.00 ) ;\n\nNote, not all Rust crates are compatible with Stylus since they need to be compiled to WASM and used in a blockchain context, which is more limited than a desktop application. For instance, the rand crate is not usable, as there is no onchain randomness available to smart contracts. In addition, contracts cannot access functions that use networking or filesystem access features. There is also a need to be mindful of the size of the crates you import, since the default contract size limit is 24KB (compressed). Crates that do not use the standard library ( no_std crates) tend to work best. See Using public Rust crates for more important details on using public Rust crates as well as a curated list of crates that tend to work well for smart contract development.\n\nEvents ​\n\nEvents are used to publicly log values to the EVM. They can be useful for users to understand what occurred during a transaction while inspecting a transaction on a public explorer, like Arbiscan .\n\nsol! { event HighestBidIncreased ( address bidder , uint256 amount ) ; } #[public] impl AuctionContract { pub fn bid ( ) { // ... evm :: log ( HighestBidIncreased { bidder : Address :: from ( [ 0x11 ; 20 ] ) , amount : U256 :: from ( 42 ) , } ) ; } }\n\nErrors ​\n\nErrors allow you to define descriptive names for failure situations. These can be useful for debugging or providing users with helpful information for why a transaction may have failed.\n\nsol! { error NotEnoughFunds ( uint256 request , uint256 available ) ; } #[derive(SolidityError)] pub enum TokenErrors { NotEnoughFunds ( NotEnoughFunds ) , } #[public] impl Token { pub fn transfer ( & mut self , to : Address , amount : U256 ) -> Result < ( ) , TokenErrors > { const balance = self . balances . get ( msg :: sender ( ) ) ; if ( balance < amount ) { return Err ( TokenErrors :: NotEnoughFunds ( NotEnoughFunds { request : amount , available : balance , } ) ) ; } // .. other code here } }",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Structure of a Contract"
    }
  },
  {
    "text": "Hello World\n\nUsing the console! macro from the stylus_sdk allows you to print output to the terminal for debugging purposes. To view the output, you'll need to run a local Stylus dev node as described in the Arbitrum docs and set the debug feature flag as shown in line 7 of the Cargo.toml file below.\n\nThe console! macro works similar to the built-in println! macro that comes with Rust.\n\nExamples ​\n\nThis code has yet to be audited. Please use at your own risk.\n\n// Out: Stylus says: 'hello there!' console! ( \"hello there!\" ) ; // Out: Stylus says: 'format some arguments' console! ( \"format {} arguments\" , \"some\" ) ; let local_variable = \"Stylus\" ; // Out: Stylus says: 'Stylus is awesome!' console! ( \"{local_variable} is awesome!\" ) ; // Out: Stylus says: 'When will you try out Stylus?' console! ( \"When will you try out {}?\" , local_variable ) ;\n\nsrc/main.rs ​\n\n#![cfg_attr(not(feature = \"export-abi\" ), no_main)] extern crate alloc ; use stylus_sdk :: { console , prelude :: * , stylus_proc :: entrypoint , ArbResult } ; #[storage] #[entrypoint] pub struct Hello ; #[public] impl Hello { fn user_main ( _input : Vec < u8 > ) -> ArbResult { // Will print 'Stylus says: Hello Stylus!' on your local dev node // Be sure to add \"debug\" feature flag to your Cargo.toml file as // shown below. console! ( \"Hello Stylus!\" ) ; Ok ( Vec :: new ( ) ) } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus_hello_world\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = { version = \"0.6.0\" , features = [ \"debug\" ] } hex = \"0.4.3\" sha3 = \"0.10\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Hello World"
    }
  },
  {
    "text": "Primitive Data Types\n\nThe Stylus SDK makes use of the popular Alloy library (from the developers of ethers-rs and Foundry ) to represent various native Solidity types as Rust types and to seamlessly convert between them when needed. These are needed since there are a number of custom types (like address) and large integers that are not natively supported in Rust.\n\nIn this section, we'll focus on the following types:\n\nU256 I256 Address Boolean Bytes\n\nMore in-depth documentation about the available methods and types in the Alloy library can be found in their docs. It also helps to cross-reference with Solidity docs if you don't already have a solid understanding of those types.\n\nLearn More ​\n\nAlloy docs (v0.7.6) Address Signed Uint Stylus Rust SDK Bytes Solidity docs (v0.8.19)\n\nAddress Signed Uint\n\nBytes\n\nIntegers ​\n\nAlloy defines a set of convenient Rust types to represent the typically sized integers used in Solidity. The type U256 represents a 256-bit unsigned integer, meaning it cannot be negative. The range for a U256 number is 0 to 2^256 - 1.\n\nNegative numbers are allowed for I types, such as I256 . These represent signed integers.\n\nU256 maps to uint256 ... I256 maps to int256 U128 maps to uint128 ... I128 maps to int128 ... U8 maps to uint8 ... I8 maps to int8\n\nInteger Usage ​\n\nThis code has yet to be audited. Please use at your own risk.\n\n// Unsigned let eight_bit : U8 = U8 :: from ( 1 ) ; let two_fifty_six_bit : U256 = U256 :: from ( 0xff_u64 ) ; // Out: Stylus says: '8-bit: 1 | 256-bit: 255' console! ( \"8-bit: {} | 256-bit: {}\" , eight_bit , two_fifty_six_bit ) ; // Signed let eight_bit : I8 = I8 :: unchecked_from ( - 1 ) ; let two_fifty_six_bit : I256 = I256 :: unchecked_from ( 0xff_u64 ) ; // Out: Stylus says: '8-bit: -1 | 256-bit: 255' console! ( \"8-bit: {} | 256-bit: {}\" , eight_bit , two_fifty_six_bit ) ;\n\nExpanded Integer Usage ​\n\n// Use `try_from` if you're not sure it'll fit let a = I256 :: try_from ( 20003000 ) . unwrap ( ) ; // Or parse from a string let b = \"100\" . parse :: < I256 > ( ) . unwrap ( ) ; // With hex characters let c = \"-0x138f\" . parse :: < I256 > ( ) . unwrap ( ) ; // Underscores are ignored let d = \"1_000_000\" . parse :: < I256 > ( ) . unwrap ( ) ; // Math works great let e = a * b + c - d ; // Out: Stylus says: '20003000 * 100 + -5007 - 1000000 = 1999294993' console! ( \"{} * {} + {} - {} = {}\" , a , b , c , d , e ) ; // Useful constants let f = I256 :: MAX ; let g = I256 :: MIN ; let h = I256 :: ZERO ; let i = I256 :: MINUS_ONE ; // Stylus says: '5789...9967, -5789...9968, 0, -1' console! ( \"{f}, {g}, {h}, {i}\" ) ; // As hex: Stylus says: '0x7fff...ffff, 0x8000...0000, 0x0, 0xffff...ffff' console! ( \"{:#x}, {:#x}, {:#x}, {:#x}\" , f , g , h , i ) ;\n\nAddress ​\n\nEthereum addresses are 20 bytes in length, or 160 bits. Alloy provides a number of helper utilities for converting to addresses from strings, bytes, numbers, and addresses.\n\nAddress Usage ​\n\n// From a 20 byte slice, all 1s let addr1 = Address :: from ( [ 0x11 ; 20 ] ) ; // Out: Stylus says: '0x1111111111111111111111111111111111111111' console! ( \"{addr1}\" ) ; // Use the address! macro to parse a string as a checksummed address let addr2 = address! ( \"d8da6bf26964af9d7eed9e03e53415d37aa96045\" ) ; // Out: Stylus says: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045' console! ( \"{addr2}\" ) ; // Format compressed addresses for output // Out: Stylus says: '0xd8dA…6045' console! ( \"{addr2:#}\" ) ;\n\nBoolean ​\n\nUse native Rust primitives where it makes sense and where no equivalent Alloy primitive exists.\n\nBoolean Usage ​\n\nlet frightened : bool = true ; // Out: Stylus says: 'Boo! Did I scare you?' console! ( \"Boo! Did I scare you?\" ) ; let response = match frightened { true => \"Yes!\" . to_string ( ) , false => \"No!\" . to_string ( ) , } ; // Out: Stylus says: 'Yes!' console! ( \"{response}\" ) ;\n\nBytes ​\n\nThe Stylus SDK provides this wrapper type around Vec<u8> to represent a bytes value in Solidity.\n\nlet vec = vec! [ 108 , 27 , 56 , 87 ] ; let b = Bytes :: from ( vec ) ; // Out: Stylus says: '0x6c1b3857' console! ( String :: from_utf8_lossy ( b . as_slice ( ) ) ) ; let b = Bytes :: from ( b\"Hello!\" . to_vec ( ) ) ; // Out: Stylus says: 'Hello!' console! ( String :: from_utf8_lossy ( b . as_slice ( ) ) ) ;\n\nNote: Return the Bytes type on your Rust function if you want to return the ABI bytes memory type.\n\nBoilerplate ​\n\nsrc/lib.rs ​\n\n#![cfg_attr(not(any(feature = \"export-abi\" , test)), no_main)] extern crate alloc ; use alloc :: { string :: ToString , vec :: Vec } ; use stylus_sdk :: { alloy_primitives :: { address , Address , I256 , I8 , U256 , U8 } , console , prelude :: * , ArbResult } ; #[storage] #[entrypoint] pub struct Data { } #[public] impl Data { fn user_main ( _input : Vec < u8 > ) -> ArbResult { // Use native Rust primitives where they make sense // and where no equivalent Alloy primitive exists let frightened : bool = true ; // Out: Stylus says: 'Boo! Did I scare you?' console! ( \"Boo! Did I scare you?\" ) ; let _response = match frightened { true => \"Yes!\" . to_string ( ) , false => \"No!\" . to_string ( ) , } ; // Out: Stylus says: 'Yes!' console! ( \"{_response}\" ) ; // U256 stands for a 256-bit *unsigned* integer, meaning it cannot be // negative. The range for a U256 number is 0 to 2^256 - 1. Alloy provides // a set of unsigned integer types to represent the various sizes available // in the EVM. //    U256 maps to uint256 //    U128 maps to uint128 //    ... //    U8 maps to uint8 let _eight_bit : U8 = U8 :: from ( 1 ) ; let _two_fifty_six_bit : U256 = U256 :: from ( 0xff_u64 ) ; // Out: Stylus says: '8-bit: 1 | 256-bit: 255' console! ( \"8-bit: {} | 256-bit: {}\" , _eight_bit , _two_fifty_six_bit ) ; // Negative numbers are allowed for I types. These represent signed integers. //    I256 maps to int256 //    I128 maps to int128 //    ... //    I8 maps to int8 let _eight_bit : I8 = I8 :: unchecked_from ( - 1 ) ; let _two_fifty_six_bit : I256 = I256 :: unchecked_from ( 0xff_u64 ) ; // Out: Stylus says: '8-bit: -1 | 256-bit: 255' console! ( \"8-bit: {} | 256-bit: {}\" , _eight_bit , _two_fifty_six_bit ) ; // Additional usage of integers // Use `try_from` if you're not sure it'll fit let a = I256 :: try_from ( 20003000 ) . unwrap ( ) ; // Or parse from a string let b = \"100\" . parse :: < I256 > ( ) . unwrap ( ) ; // With hex characters let c = \"-0x138f\" . parse :: < I256 > ( ) . unwrap ( ) ; // Underscores are ignored let d = \"1_000_000\" . parse :: < I256 > ( ) . unwrap ( ) ; // Math works great let _e = a * b + c - d ; // Out: Stylus says: '20003000 * 100 + -5007 - 1000000 = 1999294993' console! ( \"{} * {} + {} - {} = {}\" , a , b , c , d , _e ) ; // Useful constants let _f = I256 :: MAX ; let _g = I256 :: MIN ; let _h = I256 :: ZERO ; let _i = I256 :: MINUS_ONE ; // Stylus says: '5789...9967, -5789...9968, 0, -1' console! ( \"{_f}, {_g}, {_h}, {_i}\" ) ; // As hex: Stylus says: '0x7fff...ffff, 0x8000...0000, 0x0, 0xffff...ffff' console! ( \"{:#x}, {:#x}, {:#x}, {:#x}\" , _f , _g , _h , _i ) ; // Ethereum addresses are 20 bytes in length, or 160 bits. Alloy provides a number of helper utilities for converting to addresses from strings, bytes, numbers, and addresses // From a 20 byte slice, all 1s let _addr1 = Address :: from ( [ 0x11 ; 20 ] ) ; // Out: Stylus says: '0x1111111111111111111111111111111111111111' console! ( \"{_addr1}\" ) ; // Use the address! macro to parse a string as a checksummed address let _addr2 = address! ( \"d8da6bf26964af9d7eed9e03e53415d37aa96045\" ) ; // Out: Stylus says: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045' console! ( \"{_addr2}\" ) ; // Format compressed addresses for output // Out: Stylus says: '0xd8dA…6045' console! ( \"{_addr2:#}\" ) ; Ok ( Vec :: new ( ) ) } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus_data_example\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Primitive Data Types"
    }
  },
  {
    "text": "Variables\n\nIn Solidity, there are 3 types of variables: local, state, and global. Local variables are not stored on the blockchain, while state variables are (and incur a much higher cost as a result). This is true of Arbitrum Stylus Rust smart contracts as well, although how they're defined is quite different.\n\nIn Rust, local variables are just ordinary variables you assign with let or let mut statements. Local variables are far cheaper than state variables, even on the EVM, however, Stylus local variables are more than 100x cheaper to allocate in memory than their Solidity equivalents.\n\nUnlike Solidity, Rust was not built inherently with the blockchain in mind. It is a general purpose programming language. We therefore define specific storage types to explicitly denote values intended to be stored permanently as part of the contract's state. State variables cost the same to store as their Solidity equivalents.\n\nGlobal variables in Solidity, such as msg.sender and block.timestamp , are available as function calls pulled in from the stylus_sdk with their Rust equivalents being msg::sender() and block::timestamp() , respectively. These variables provide information about the blockchain or the active transaction.\n\nLearn more ​\n\nRust Docs - Variables and Mutability Stylus SDK Rust Docs - Storage Stylus SDK Guide - Storage Solidity docs - state variables Solidity docs - global variables\n\nsrc/lib.rs ​\n\nThis code has yet to be audited. Please use at your own risk.\n\n// Only run this as a WASM if the export-abi feature is not set. #![cfg_attr(not(any(feature = \"export-abi\" , test)), no_main)] extern crate alloc ; use stylus_sdk :: alloy_primitives :: { U16 , U256 } ; use stylus_sdk :: prelude :: * ; use stylus_sdk :: storage :: { StorageAddress , StorageBool , StorageU256 } ; use stylus_sdk :: { block , console , msg } ; #[storage] #[entrypoint] pub struct Contract { initialized : StorageBool , owner : StorageAddress , max_supply : StorageU256 , } #[public] impl Contract { // State variables are initialized in an `init` function. pub fn init ( & mut self ) -> Result < ( ) , Vec < u8 >> { // We check if contract has been initialized before. // We return if so, we initialize if not. let initialized = self . initialized . get ( ) ; if initialized { return Ok ( ( ) ) ; } self . initialized . set ( true ) ; // We set the contract owner to the caller, // which we get from the global msg module self . owner . set ( msg :: sender ( ) ) ; self . max_supply . set ( U256 :: from ( 10_000 ) ) ; Ok ( ( ) ) } pub fn do_something ( ) -> Result < ( ) , Vec < u8 >> { // Local variables are not saved to the blockchain // 16-bit Rust integer let _i = 456_u16 ; // 16-bit int inferred from U16 Alloy primitive let _j = U16 :: from ( 123 ) ; // Here are some global variables let _timestamp = block :: timestamp ( ) ; let _amount = msg :: value ( ) ; console! ( \"Local variables: {_i}, {_j}\" ) ; console! ( \"Global variables: {_timestamp}, {_amount}\" ) ; Ok ( ( ) ) } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus_variable_example\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Variables"
    }
  },
  {
    "text": "Constants\n\nConstants are values that are bound to a name and cannot change. They are always immutable. In Rust, constants are declared with the const keyword. Unlike variables declared with the let keyword, constants must be annotated with their type.\n\nConstants are valid for the entire length of the transaction. They are essentially inlined wherever they are used, meaning that their value is copied directly into whatever context invokes them.\n\nSince their value is hardcoded, they can save on gas cost as their value does not need to be fetched from storage.\n\nLearn More ​\n\nRust docs - Constant items Solidity docs - Constant variables\n\nsrc/lib.rs ​\n\nThis code has yet to be audited. Please use at your own risk.\n\n// Only run this as a WASM if the export-abi feature is not set. #![cfg_attr(not(any(feature = \"export-abi\" , test)), no_main)] extern crate alloc ; use alloc :: vec ; use alloc :: vec :: Vec ; use stylus_sdk :: alloy_primitives :: Address ; use stylus_sdk :: prelude :: * ; use stylus_sdk :: storage :: StorageAddress ; const OWNER : & str = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\" ; #[storage] #[entrypoint] pub struct Contract { owner : StorageAddress , } #[public] impl Contract { pub fn init ( & mut self ) -> Result < ( ) , Vec < u8 >> { // Parse the const &str as a local Address variable let owner_address = Address :: parse_checksummed ( OWNER , None ) . expect ( \"Invalid address\" ) ; // Save the result as the owner self . owner . set ( owner_address ) ; Ok ( ( ) ) } pub fn owner ( & self ) -> Result < Address , Vec < u8 >> { let owner_address = self . owner . get ( ) ; Ok ( owner_address ) } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus_constants_example\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Constants"
    }
  },
  {
    "text": "Functions\n\nFunctions are a fundamental part of any programming language, including Stylus, enabling you to encapsulate logic into reusable components.\n\nThis guide covers the syntax and usage of functions, including internal and external functions, and how to return multiple values.\n\nLearn More ​\n\nRust docs - Functions Solidity docs - Functions\n\nOverview ​\n\nA function in Stylus consists of a name, a set of parameters, an optional return type, and a body.\n\nJust as with storage, Stylus methods are Solidity ABI equivalent. This means that contracts written in different programming languages are fully interoperable.\n\nFunctions are declared with the fn keyword. Parameters allow the function to accept inputs, and the return type specifies the output of the function. If no return type is specified, the function returns void .\n\nFollowing is an example of a function add that takes two uint256 values and returns their sum.\n\nThis code has yet to be audited. Please use at your own risk.\n\nfn add ( a : uint256 , b : uint256 ) -> uint256 { return a + b ; }\n\nFunction Parameters ​\n\nFunction parameters are the inputs to a function. They are specified as a list of IDENTIFIER: Type pairs, separated by commas.\n\nIn this example, the function add_numbers takes two u32 parameters, a and b and returns the sum of the two numbers.\n\nfn add_numbers ( a : u32 , b : u32 ) -> u32 { a + b }\n\nReturn Types ​\n\nReturn types in functions are an essential part of defining the behavior and expected outcomes of your smart contract methods.\n\nHere, we explain the syntax and usage of return types in Stylus with general examples.\n\nBasic Syntax ​\n\nA function with a return type in Stylus follows this basic structure. The return type is specified after the -> arrow.\nValues are returned using the return keyword or implicitly as the last expression of the function. In Rust and Stylus, the last expression in a function is implicitly returned, so the return keyword is often omitted.\n\npub fn function_name ( & self ) -> ReturnType { // Function body }\n\nExamples ​\n\nFunction returning a String: This get_greeting function returns a String . The return type is specified as String after the -> arrow.\n\npub fn get_greeting ( ) -> String { \"Hello, Stylus!\" . into ( ) }\n\nFunction returning an Integer: This get_number function returns an unsigned 32-bit integer ( u32 ).\n\npub fn get_number ( ) -> u32 { 42 }\n\nFunction returning a Result with Ok and Err variants: The perform_operation function returns a Result<u32, CustomError> .\nThe Result type is used for functions that can return either a success value ( Ok ) or an error ( Err ). In this case, it returns Ok(value) on success and an error variant of CustomError on failure.\n\npub enum CustomError { ErrorVariant , } pub fn perform_operation ( value : u32 ) -> Result < u32 , CustomError > { if value > 0 { Ok ( value ) } else { Err ( CustomError :: ErrorVariant ) } }\n\nPublic Functions ​\n\nPublic functions are those that can be called by other contracts.\n\nTo define a public function in a Stylus contract, you use the #[public] macro. This macro ensures that the function is accessible from outside the contract.\n\nPreviously, all public methods were required to return a Result type with Vec<u8> as the error type. This is now optional. Specifically, if a method is \"infallible\" (i.e., it cannot produce an error), it does not need to return a Result type. Here's what this means:\n\nInfallible methods: Methods that are guaranteed not to fail (no errors possible) do not need to use the Result type. They can return their result directly without wrapping it in Result . Optional error handling: The Result type with Vec<u8> as the error type is now optional for methods that cannot produce an error.\n\nInfallible methods: Methods that are guaranteed not to fail (no errors possible) do not need to use the Result type. They can return their result directly without wrapping it in Result .\n\nOptional error handling: The Result type with Vec<u8> as the error type is now optional for methods that cannot produce an error.\n\nIn the following example, owner is a public function that returns the contract owner's address. Since this function is infallible (i.e., it cannot produce an error), it does not need to return a Result type.\n\n#[external] impl Contract { // Define an external function to get the owner of the contract pub fn owner ( & self ) -> Address { self . owner . get ( ) } }\n\nInternal Functions ​\n\nInternal functions are those that can only be called within the contract itself. These functions are not exposed to external calls.\n\nTo define an internal function, you simply include it within your contract's implementation without the #[public] macro.\n\nThe choice between public and internal functions depends on the desired level of accessibility and interaction within and across contracts.\n\nIn the followinge example, set_owner is an internal function that sets a new owner for the contract. It is only callable within the contract itself.\n\nimpl Contract { // Define an internal function to set a new owner pub fn set_owner ( & mut self , new_owner : Address ) { self . owner . set ( new_owner ) ; } }\n\nTo mix public and internal functions within the same contract, you should use two separate impl blocks with the same contract name. Public functions are defined within an impl block annotated with the #[public] attribute, signifying that these functions are part of the contract's public interface and can be invoked from outside the contract.\nIn contrast, internal functions are placed within a separate impl block that does not have the #[public] attribute, making them internal to the contract and inaccessible to external entities.\n\nsrc/lib.rs ​\n\n// Only run this as a WASM if the export-abi feature is not set. #![cfg_attr(not(any(feature = \"export-abi\" , test)), no_main)] extern crate alloc ; use alloc :: vec ; use stylus_sdk :: alloy_primitives :: Address ; use stylus_sdk :: prelude :: * ; use stylus_sdk :: storage :: StorageAddress ; use stylus_sdk :: alloy_primitives :: U256 ; use stylus_sdk :: storage :: StorageU256 ; use stylus_sdk :: console ; #[storage] #[entrypoint] pub struct ExampleContract { owner : StorageAddress , data : StorageU256 , } #[public] impl ExampleContract { // External function to set the data pub fn set_data ( & mut self , value : U256 ) { self . data . set ( value ) ; } // External function to get the data pub fn get_data ( & self ) -> U256 { self . data . get ( ) } // External function to get the contract owner pub fn get_owner ( & self ) -> Address { self . owner . get ( ) } } impl ExampleContract { // Internal function to set a new owner pub fn set_owner ( & mut self , new_owner : Address ) { self . owner . set ( new_owner ) ; } // Internal function to log data pub fn log_data ( & self ) { let _data = self . data . get ( ) ; console! ( \"Current data is: {:?}\" , _data ) ; } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus-functions\" version = \"0.1.0\" edition = \"2021\" [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" sha3 = \"0.10.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] debug = [ \"stylus-sdk/debug\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Function"
    }
  },
  {
    "text": "Errors\n\nIn Rust Stylus contracts, error handling is a crucial aspect of writing robust and reliable smart contracts. Rust differentiates between recoverable and unrecoverable errors. Recoverable errors are represented using the Result type, which can either be Ok , indicating success, or Err , indicating failure. This allows developers to manage errors gracefully and maintain control over the flow of execution. Unrecoverable errors are handled with the panic! macro, which stops execution, unwinds the stack, and returns a dataless error.\n\nIn Stylus contracts, error types are often explicitly defined, providing clear and structured ways to handle different failure scenarios. This structured approach promotes better error management, ensuring that contracts are secure, maintainable, and behave predictably under various conditions. Similar to Solidity and EVM, errors in Stylus will undo all changes made to the state during a transaction by reverting the transaction. Thus, there are two main types of errors in Rust Stylus contracts:\n\nRecoverable Errors : The Stylus SDK provides features that make using recoverable errors in Rust Stylus contracts convenient. This type of error handling is strongly recommended for Stylus contracts. Unrecoverable Errors : These can be defined similarly to Rust code but are not recommended for smart contracts if recoverable errors can be used instead.\n\nLearn More ​\n\nSolidity docs: Expressions and Control Structures #[derive(SolidityError)] alloy_sol_types::SolError Error handling: Rust book\n\nRecoverable Errors ​\n\nRecoverable errors are represented using the Result type, which can either be Ok , indicating success, or Err , indicating failure. The Stylus SDK provides tools to define custom error types and manage recoverable errors effectively.\n\nHere's a simplified Rust Stylus contract demonstrating how to define and handle recoverable errors:\n\nThis code has yet to be audited. Please use at your own risk.\n\n#![cfg_attr(not(feature = \"export-abi\" ), no_main)] extern crate alloc ; use alloy_sol_types :: sol ; use stylus_sdk :: { abi :: Bytes , alloy_primitives :: { Address , U256 } , call :: RawCall , prelude :: * } ; #[storage] #[entrypoint] pub struct MultiCall ; // Declare events and Solidity error types sol! { error ArraySizeNotMatch ( ) ; error CallFailed ( uint256 call_index ) ; } #[derive(SolidityError)] pub enum MultiCallErrors { ArraySizeNotMatch ( ArraySizeNotMatch ) , CallFailed ( CallFailed ) , } #[public] impl MultiCall { pub fn multicall ( & self , addresses : Vec < Address > , data : Vec < Bytes > , ) -> Result < Vec < Bytes > , MultiCallErrors > { let addr_len = addresses . len ( ) ; let data_len = data . len ( ) ; let mut results : Vec < Bytes > = Vec :: new ( ) ; if addr_len != data_len { return Err ( MultiCallErrors :: ArraySizeNotMatch ( ArraySizeNotMatch { } ) ) ; } for i in 0 .. addr_len { let result : Result < Vec < u8 > , Vec < u8 >> = RawCall :: new ( ) . call ( addresses [ i ] , data [ i ] . to_vec ( ) . as_slice ( ) ) ; let data = match result { Ok ( data ) => data , Err ( _data ) => return Err ( MultiCallErrors :: CallFailed ( CallFailed { call_index : U256 :: from ( i ) } ) ) , } ; results . push ( data . into ( ) ) } Ok ( results ) } }\n\nUsing SolidityError Derive Macro : The #[derive(SolidityError)] attribute is used for the MultiCallErrors enum, automatically implementing the necessary traits for error handling. Defining Errors : Custom errors ArraySizeNotMatch and CallFailed is declared in MultiCallErrors enum. CallFailed error includes a call_index parameter to indicate which call failed. ArraySizeNotMatch Error Handling : The multicall function returns ArraySizeNotMatch if the size of addresses and data vectors are not equal. CallFailed Error Handling : The multicall function returns a CallFailed error with the index of the failed call if any call fails. Note that we're using match to check if the result of the call is an error or a return data. We'll describe match pattern in the further sections.\n\nUnrecoverable Errors ​\n\nHere are various ways to handle such errors in the multicall function, which calls multiple addresses and panics in different scenarios:\n\nUsing panic! ​\n\nDirectly panics if the call fails, including the index of the failed call.\n\nfor i in 0 .. addr_len { let result = RawCall :: new ( ) . call ( addresses [ i ] , data [ i ] . to_vec ( ) . as_slice ( ) ) ; let data = match result { Ok ( data ) => data , Err ( _data ) => panic! ( \"Call to address {:?} failed at index {}\" , addresses [ i ] , i ) , } ; results . push ( data . into ( ) ) ; }\n\nHandling Call Failure with panic! : The function panics if any call fails and the transaction will be reverted without any data.\n\nUsing unwrap ​\n\nUses unwrap to handle the result, panicking if the call fails.\n\nfor i in 0 .. addr_len { let result = RawCall :: new ( ) . call ( addresses [ i ] , data [ i ] . to_vec ( ) . as_slice ( ) ) . unwrap ( ) ; results . push ( result . into ( ) ) ; }\n\nHandling Call Failure with unwrap : The function uses unwrap to panic if any call fails, including the index of the failed call.\n\nUsing match ​\n\nUses a match statement to handle the result of call , panicking if the call fails.\n\nfor i in 0 .. addr_len { let result = RawCall :: new ( ) . call ( addresses [ i ] , data [ i ] . to_vec ( ) . as_slice ( ) ) ; let data = match result { Ok ( data ) => data , Err ( _data ) => return Err ( MultiCallErrors :: CallFailed ( CallFailed { call_index : U256 :: from ( i ) } ) ) , } ; results . push ( data . into ( ) ) ; }\n\nHandling Call Failure with match : The function uses a match statement to handle the result of call , returning error if any call fails.\n\nUsing the ? Operator ​\n\nUses the ? operator to propagate the error if the call fails, including the index of the failed call.\n\nfor i in 0 .. addr_len { let result = RawCall :: new ( ) . call ( addresses [ i ] , data [ i ] . to_vec ( ) . as_slice ( ) ) . map_err ( | _ | MultiCallErrors :: CallFailed ( CallFailed { call_index : U256 :: from ( i ) } ) ) ? ; results . push ( result . into ( ) ) ; }\n\nHandling Call Failure with ? Operator: The function uses the ? operator to propagate the error if any call fails, including the index of the failed call.\n\nEach method demonstrates a different way to handle unrecoverable errors in the multicall function of a Rust Stylus contract, providing a comprehensive approach to error management.\n\nNote that as mentioned above, it is strongly recommended to use custom error handling instead of unrecoverable error handling.\n\nBoilerplate ​\n\nsrc/lib.rs ​\n\nThe lib.rs code can be found at the top of the page in the recoverable error example section.\n\nCargo.toml ​\n\n[ package ] name = \"stylus-multicall-contract\" version = \"0.1.7\" edition = \"2021\" [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ [ bin ] ] name = \"stylus-multicall-contract\" path = \"src/main.rs\" [ lib ] crate-type = [ \"lib\" , \"cdylib\" ]",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Errors"
    }
  },
  {
    "text": "Events\n\nEvents allow for data to be logged publicly to the blockchain. Log entries provide the contract's address, a series of up to four topics, and some arbitrary length binary data. The Stylus Rust SDK provides a few ways to publish event logs described below.\n\nLearn More ​\n\nSolidity docs: Events stylus_sdk::evm::log alloy_sol_types::SolEvent\n\nLog ​\n\nUsing the evm::log function in the Stylus SDK is the preferred way to log events. It ensures that an event will be logged in a Solidity ABI-compatible format. The log function takes any type that implements Alloy SolEvent trait. It's not recommended to attempt to implement this trait on your own. Instead, make use of the provided sol! macro to declare your Events and their schema using Solidity-style syntax to declare the parameter types. Alloy will create ABI-compatible Rust types which you can instantiate and pass to the evm::log function.\n\nLog Usage ​\n\nThis code has yet to be audited. Please use at your own risk.\n\n// sol! macro event declaration // Up to 3 parameters can be indexed. // Indexed parameters helps you filter the logs efficiently sol! { event Log ( address indexed sender , string message ) ; event AnotherLog ( ) ; } #[storage] #[entrypoint] pub struct Events { } #[public] impl Events { fn user_main ( _input : Vec < u8 > ) -> ArbResult { // emits a 'Log' event, defined above in the sol! macro evm :: log ( Log { sender : Address :: from ( [ 0x11 ; 20 ] ) , message : \"Hello world!\" . to_string ( ) , } ) ; // no data, but 'AnotherLog' event will still emit to the chain evm :: log ( AnotherLog { } ) ; Ok ( vec! [ ] ) } }\n\nRaw Log ​\n\nThe evm::raw_log affordance offers the ability to send anonymous events that do not necessarily conform to the Solidity ABI. Instead, up to four raw 32-byte indexed topics are published along with any arbitrary bytes appended as data.\n\nNOTE : It's still possible to achieve Solidity ABI compatibility using this construct. To do so you'll have to manually compute the ABI signature for the event, following the equation set in the Solidity docs . The result of that should be assigned to TOPIC_0 , the first topic in the slice passed to raw_log .\n\nRaw Log Usage ​\n\n// set up local variables let user = Address :: from ( [ 0x22 ; 20 ] ) ; let balance = U256 :: from ( 10_000_000 ) ; // declare up to 4 topics // topics must be of type FixedBytes<32> let topics = & [ user . into_word ( ) ] ; // store non-indexed data in a byte Vec let mut data : Vec < u8 > = vec! [ ] ; // to_be_bytes means 'to big endian bytes' data . extend_from_slice ( balance . to_be_bytes :: < 32 > ( ) . to_vec ( ) . as_slice ( ) ) ; // unwrap() here 'consumes' the Result evm :: raw_log ( topics . as_slice ( ) , data . as_ref ( ) ) . unwrap ( ) ;\n\nResult ​\n\nCombining the above examples into the boiler plate provided below this section, deploying to a Stylus chain and then invoking the deployed contract will result in the following three events logged to the chain:\n\nlogs ​\n\n[ { \"address\": \"0x6cf4a18ac8efd6b0b99d3200c4fb9609dd60d4b3\", \"topics\": [ \"0x0738f4da267a110d810e6e89fc59e46be6de0c37b1d5cd559b267dc3688e74e0\", \"0x0000000000000000000000001111111111111111111111111111111111111111\" ], \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000c48656c6c6f20776f726c64210000000000000000000000000000000000000000\", \"blockHash\": \"0xfef880025dc87b5ab4695a0e1a6955dd7603166ecba79ce0f503a568b2ec8940\", \"blockNumber\": \"0x94\", \"transactionHash\": \"0xc7318dae2164eb441fb80f5b869f844e3e97ae83c24a4639d46ec4d915a30818\", \"transactionIndex\": \"0x1\", \"logIndex\": \"0x0\", \"removed\": false }, { \"address\": \"0x6cf4a18ac8efd6b0b99d3200c4fb9609dd60d4b3\", \"topics\": [\"0xfe1a3ad11e425db4b8e6af35d11c50118826a496df73006fc724cb27f2b99946\"], \"data\": \"0x\", \"blockHash\": \"0xfef880025dc87b5ab4695a0e1a6955dd7603166ecba79ce0f503a568b2ec8940\", \"blockNumber\": \"0x94\", \"transactionHash\": \"0xc7318dae2164eb441fb80f5b869f844e3e97ae83c24a4639d46ec4d915a30818\", \"transactionIndex\": \"0x1\", \"logIndex\": \"0x1\", \"removed\": false }, { \"address\": \"0x6cf4a18ac8efd6b0b99d3200c4fb9609dd60d4b3\", \"topics\": [\"0x0000000000000000000000002222222222222222222222222222222222222222\"], \"data\": \"0x0000000000000000000000000000000000000000000000000000000000989680\", \"blockHash\": \"0xfef880025dc87b5ab4695a0e1a6955dd7603166ecba79ce0f503a568b2ec8940\", \"blockNumber\": \"0x94\", \"transactionHash\": \"0xc7318dae2164eb441fb80f5b869f844e3e97ae83c24a4639d46ec4d915a30818\", \"transactionIndex\": \"0x1\", \"logIndex\": \"0x2\", \"removed\": false } ]\n\nBoilerplate ​\n\nsrc/lib.rs ​\n\n// Only run this as a WASM if the export-abi feature is not set. #![cfg_attr(not(any(feature = \"export-abi\" , test)), no_main)] extern crate alloc ; use alloc :: vec :: Vec ; use alloc :: { string :: ToString , vec } ; use stylus_sdk :: alloy_primitives :: U256 ; use stylus_sdk :: { alloy_primitives :: Address , alloy_sol_types :: sol , evm , prelude :: * , ArbResult } ; // sol! macro event declaration // Up to 3 parameters can be indexed. // Indexed parameters helps you filter the logs by the indexed parameter sol! { event Log ( address indexed sender , string message ) ; event AnotherLog ( ) ; } #[storage] #[entrypoint] pub struct Events { } #[public] impl Events { fn user_main ( _input : Vec < u8 > ) -> ArbResult { // emits a 'Log' event, defined above in the sol! macro evm :: log ( Log { sender : Address :: from ( [ 0x11 ; 20 ] ) , message : \"Hello world!\" . to_string ( ) , } ) ; // no data, but event will still log to the chain evm :: log ( AnotherLog { } ) ; // set up local variables let user = Address :: from ( [ 0x22 ; 20 ] ) ; let balance = U256 :: from ( 10_000_000 ) ; // declare up to 4 topics // topics must be of type FixedBytes<32> let topics = & [ user . into_word ( ) ] ; // store non-indexed data in a byte Vec let mut data : Vec < u8 > = vec! [ ] ; // to_be_bytes means 'to big endian bytes' data . extend_from_slice ( balance . to_be_bytes :: < 32 > ( ) . to_vec ( ) . as_slice ( ) ) ; // unwrap() here 'consumes' the Result evm :: raw_log ( topics . as_slice ( ) , data . as_ref ( ) ) . unwrap ( ) ; Ok ( Vec :: new ( ) ) } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus_events_example\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Events"
    }
  },
  {
    "text": "Inheritance\n\nThe Stylus Rust SDK replicates the composition pattern of Solidity. The #[public] macro provides the Router trait, which can be used to connect types via inheritance, via the #[inherit] macro.\n\nPlease note: Stylus doesn't support contract multi-inheritance yet.\n\nLet's see an example:\n\nThis code has yet to be audited. Please use at your own risk.\n\n#[public] #[inherit(Erc20)] impl Token { pub fn mint ( & mut self , amount : U256 ) -> Result < ( ) , Vec < u8 >> { ... } } #[public] impl Erc20 { pub fn balance_of ( ) -> Result < U256 > { ... } }\n\nIn the above code, we can see how Token inherits from Erc20 , meaning that it will inherit the public methods available in Erc20 . If someone called the Token contract on the function balanceOf , the function Erc20.balance_of() would be executed.\n\nAdditionally, the inheriting type must implement the Borrow trait for borrowing data from the inherited type. In the case above, Token should implement Borrow<Erc20> . For simplicity, #[storage] and sol_storage! provide a #[borrow] annotation that can be used instead of manually implementing the trait:\n\nsol_storage! { #[entrypoint] pub struct Token { #[borrow] Erc20 erc20 ; ... } pub struct Erc20 { ... } }\n\nMethods search order ​\n\nA type can inherit multiple other types (as long as they use the #[public] macro). Since execution begins in the type that uses the #[entrypoint] macro, that type will be first checked when searching a specific method. If the method is not found in that type, the search will continue in the inherited types, in order of inheritance. If the method is not found in any of the inherited methods, the call will revert.\n\nLet's see an example:\n\n#[public] #[inherit(B, C)] impl A { pub fn foo ( ) -> Result < ( ) , Vec < u8 >> { ... } } #[public] impl B { pub fn bar ( ) -> Result < ( ) , Vec < u8 >> { ... } } #[public] impl C { pub fn bar ( ) -> Result < ( ) , Vec < u8 >> { ... } pub fn baz ( ) -> Result < ( ) , Vec < u8 >> { ... } }\n\nIn the code above:\n\ncalling foo() will search the method in A , find it, and execute A.foo() calling bar() will search the method in A first, then in B , find it, and execute B.bar() calling baz() will search the method in A , B and finally C , so it will execute C.baz()\n\nNotice that C.bar() won't ever be reached, since the inheritance goes through B first, which has a method named bar() too.\n\nFinally, since the inherited types can also inherit other types themselves, keep in mind that method resolution finds the first matching method by Depth First Search .\n\nOverriding methods ​\n\nBecause methods are checked in the inherited order, if two types implement the same method, the one in the higher level in the hierarchy will override the one in the lower levels, which won’t be callable. This allows for patterns where the developer imports a crate implementing a standard, like ERC-20, and then adds or overrides just the methods they want to without modifying the imported ERC-20 type.\n\nImportant warning : The Stylus Rust SDK does not currently contain explicit override or virtual keywords for explicitly marking override functions. It is important, therefore, to carefully ensure that contracts are only overriding the functions.\n\nLet's see an example:\n\n#[public] #[inherit(B, C)] impl A { pub fn foo ( ) -> Result < ( ) , Vec < u8 >> { ... } } #[public] impl B { pub fn foo ( ) -> Result < ( ) , Vec < u8 >> { ... } pub fn bar ( ) -> Result < ( ) , Vec < u8 >> { ... } }\n\nIn the example above, even though B has an implementation for foo() , calling foo() will execute A.foo() since the method is searched first in A .\n\nLearn more ​\n\nArbitrum documentation inheritance, #[inherit] and #[borrow] Router trait Borrow trait BorrowMut trait",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Inheritance"
    }
  },
  {
    "text": "VM affordances\n\nThe Stylus Rust SDK contains several modules for interacting with the Virtual Machine (VM), which can be imported from stylus_sdk .\n\nLet's see an example:\n\nThis code has yet to be audited. Please use at your own risk.\n\nuse stylus_sdk :: { msg } ; let callvalue = msg :: value ( ) ;\n\nThis page lists the modules that are available, as well as the methods within those modules.\n\nblock ​\n\nAllows you to inspect the current block:\n\nbasefee : gets the basefee of the current block chainid : gets the unique chain identifier of the Arbitrum chain coinbase : gets the coinbase of the current block, which on Arbitrum chains is the L1 batch poster's address gas_limit : gets the gas limit of the current block number : gets a bounded estimate of the L1 block number at which the sequencer sequenced the transaction. See Block gas limit, numbers and time for more information on how this value is determined timestamp : gets a bounded estimate of the Unix timestamp at which the sequencer sequenced the transaction. See Block gas limit, numbers and time for more information on how this value is determined\n\nuse stylus_sdk :: { block } ; let basefee = block :: basefee ( ) ; let chainid = block :: chainid ( ) ; let coinbase = block :: coinbase ( ) ; let gas_limit = block :: gas_limit ( ) ; let number = block :: number ( ) ; let timestamp = block :: timestamp ( ) ;\n\ncontract ​\n\nAllows you to inspect the contract itself:\n\naddress : gets the address of the current program args : reads the invocation's calldata. The entrypoint macro uses this under the hood balance : gets the balance of the current program output : writes the contract's return data. The entrypoint macro uses this under the hood read_return_data : copies the bytes of the last EVM call or deployment return result. Note: this function does not revert if out of bounds, but rather will copy the overlapping portion return_data_len : returns the length of the last EVM call or deployment return result, or 0 if neither have happened during the program's execution\n\nuse stylus_sdk :: { contract } ; let address = contract :: address ( ) ; contract :: args ( ) ; let balance = contract :: balance ( ) ; contract :: output ( ) ; contract :: read_return_data ( ) ; contract :: return_data_len ( ) ;\n\ncrypto ​\n\nAllows you to access VM-accelerated cryptographic functions:\n\nkeccak : efficiently computes the keccak256 hash of the given preimage\n\nuse stylus_sdk :: { crypto } ; use stylus_sdk :: alloy_primitives :: address ; let preimage = address! ( \"361594F5429D23ECE0A88E4fBE529E1c49D524d8\" ) ; let hash = crypto :: keccak ( & preimage ) ;\n\nevm ​\n\nAllows you to access affordances for the Ethereum Virtual Machine:\n\ngas_left : gets the amount of gas remaining. See Ink and Gas for more information on Stylus's compute pricing ink_left : gets the amount of ink remaining. See Ink and Gas for more information on Stylus's compute pricing log : emits a typed alloy log pay_for_memory_grow : this function exists to force the compiler to import this symbol. Calling it will unproductively consume gas raw_log : emits an EVM log from its raw topics and data. Most users should prefer the alloy-typed raw_log\n\nuse stylus_sdk :: { evm } ; let gas_left = evm :: gas_left ( ) ; let ink_left = evm :: ink_left ( ) ; evm :: log ( ... ) ; evm :: pay_for_memory_grow ( ) ; evm :: raw_log ( ... ) ;\n\nHere's an example of how to emit a Transfer log:\n\nsol! { event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } fn foo ( ) { ... evm :: log ( Transfer { from : Address :: ZERO , to : address , value , } ) ; }\n\nmsg ​\n\nAllows you to inspect the current call\n\nreentrant : whether the current call is reentrant sender : gets the address of the account that called the program. For normal L2-to-L2 transactions the semantics are equivalent to that of the EVM's CALLER opcode, including in cases arising from DELEGATE_CALL value : gets the ETH value in wei sent to the program\n\nuse stylus_sdk :: { msg } ; let reentrant = msg :: reentrant ( ) ; let sender = msg :: sender ( ) ; let value = msg :: value ( ) ;\n\ntx ​\n\nAllows you to inspect the current transaction\n\ngas_price : gets the gas price in wei per gas, which on Arbitrum chains equals the basefee gas_to_ink : converts evm gas to ink. See Ink and Gas for more information on Stylus's compute-pricing model ink_price : gets the price of ink in evm gas basis points. See Ink and Gas for more information on Stylus's compute-pricing model ink_to_gas : converts ink to evm gas. See Ink and Gas for more information on Stylus's compute-pricing model origin : gets the top-level sender of the transaction. The semantics are equivalent to that of the EVM's ORIGIN opcode\n\nuse stylus_sdk :: { tx } ; let gas_price = tx :: gas_price ( ) ; let gas_to_ink = tx :: gas_to_ink ( ) ; let ink_price = tx :: ink_price ( ) ; let ink_to_gas = tx :: ink_to_gas ( ) ; let origin = tx :: origin ( ) ;\n\nLearn More ​\n\nArbitrum documentation Stylus SDK modules",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Vm Affordances"
    }
  },
  {
    "text": "Sending Ether\n\nWe have three main ways to send Ether in Rust Stylus: using the transfer_eth method, using low level call method, and sending value while calling an external contract.\n\nIt's important to note that the transfer_eth method in Rust Stylus invokes the recipient contract, which may subsequently call other contracts. All the gas is supplied to the recipient, which it may burn. Conversely, the transfer method in Solidity is capped at 2300 gas. In Rust Stylus, you can cap the gas by using the low-level call method with a specified gas. An example of this is provided in the code on bottom of the page.\n\nThese two methods are exactly equivalent under the hood:\n\nThis code has yet to be audited. Please use at your own risk.\n\ntransfer_eth ( recipient , value ) ? ; call ( Call :: new_in ( self ) . value ( value ) , recipient , & [ ] ) ? ;\n\nWhere to Send Ether ​\n\nExternally Owned Account (EOA) Addresses : Directly send Ether to an EOA address. Solidity Smart Contracts with Receive Function (No Calldata) : Send Ether to a Solidity smart contract that has a receive function without providing any calldata. Solidity Smart Contracts with Fallback Function (With Calldata) : Send Ether to a Solidity smart contract that has a fallback function by providing the necessary calldata. Smart Contracts with Payable Methods (both Solidity and Stylus) : Send Ether to smart contracts that have defined payable methods. Payable methods are identified by the payable modifier in Solidity, and the #[payable] macro in Rust.\n\nExternally Owned Account (EOA) Addresses : Directly send Ether to an EOA address.\n\nSolidity Smart Contracts with Receive Function (No Calldata) : Send Ether to a Solidity smart contract that has a receive function without providing any calldata.\n\nSolidity Smart Contracts with Fallback Function (With Calldata) : Send Ether to a Solidity smart contract that has a fallback function by providing the necessary calldata.\n\nSmart Contracts with Payable Methods (both Solidity and Stylus) : Send Ether to smart contracts that have defined payable methods. Payable methods are identified by the payable modifier in Solidity, and the #[payable] macro in Rust.\n\nBelow you can find examples for each of these methods and how to define them in a Rust Stylus smart contract using the Stylus SDK:\n\nsrc/lib.rs ​\n\n// Only run this as a WASM if the export-abi feature is not set. #![cfg_attr(not(any(feature = \"export-abi\" , test)), no_main)] extern crate alloc ; use alloy_primitives :: Address ; use stylus_sdk :: { abi :: Bytes , call :: { call , transfer_eth , Call } , msg :: { self } , prelude :: * , } ; sol_interface! { interface ITarget { function receiveEther ( ) external payable ; } } #[storage] #[entrypoint] pub struct SendEther { } #[public] impl SendEther { // Transfer Ether using the transfer_eth method // This can be used to send Ether to an EOA or a Solidity smart contract that has a receive() function implemented #[payable] pub fn send_via_transfer ( to : Address ) -> Result < ( ) , Vec < u8 >> { transfer_eth ( to , msg :: value ( ) ) ? ; Ok ( ( ) ) } // Transfer Ether using a low-level call // This can be used to send Ether to an EOA or a Solidity smart contract that has a receive() function implemented #[payable] pub fn send_via_call ( & mut self , to : Address ) -> Result < ( ) , Vec < u8 >> { call ( Call :: new_in ( self ) . value ( msg :: value ( ) ) , to , & [ ] ) ? ; Ok ( ( ) ) } // Transfer Ether using a low-level call with a specified gas limit // This can be used to send Ether to an EOA or a Solidity smart contract that has a receive() function implemented #[payable] pub fn send_via_call_gas_limit ( & mut self , to : Address , gas_amount : u64 ) -> Result < ( ) , Vec < u8 >> { call ( Call :: new_in ( self ) . value ( msg :: value ( ) ) . gas ( gas_amount ) , to , & [ ] , ) ? ; Ok ( ( ) ) } // Transfer Ether using a low-level call with calldata // This can be used to call a Solidity smart contract's fallback function and send Ether along with calldata #[payable] pub fn send_via_call_with_call_data ( & mut self , to : Address , data : Bytes , ) -> Result < ( ) , Vec < u8 >> { call ( Call :: new_in ( self ) . value ( msg :: value ( ) ) , to , data . as_slice ( ) ) ? ; Ok ( ( ) ) } // Transfer Ether to another smart contract via a payable method on the target contract // The target contract can be either a Solidity smart contract or a Stylus contract that has a receiveEther function, which is a payable function #[payable] pub fn send_to_stylus_contract ( & mut self , to : Address ) -> Result < ( ) , Vec < u8 >> { let target = ITarget :: new ( to ) ; let config = Call :: new_in ( self ) . value ( msg :: value ( ) ) ; target . receive_ether ( config ) ? ; Ok ( ( ) ) } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus_sending_ether_example\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Sending Ether"
    }
  },
  {
    "text": "Function selector\n\nWhen a smart contract is called, the first 4 bytes of the calldata sent as part of the request are called the \"function selector\", and identify which function of the smart contract to call.\n\nYou can compute a specific function selector by using the function_selector! macro.\n\nHere's an example that computes the selector of a function named foo :\n\nThis code has yet to be audited. Please use at your own risk.\n\nfunction_selector! ( \"foo\" ) // returns 0xc2985578\n\nFunctions usually take a number of arguments that you need to pass in order for the call to be successful. For example, here's the signature of a function that takes 2 arguments, an address and a uint256:\n\nfunction transfer ( address recipient , uint256 amount ) external returns ( bool ) ;\n\nTo compute the selector for this function, pass the types of the arguments to the function_selector macro:\n\nfunction_selector! ( \"transfer\" , Address , U256 ) // returns 0xa9059cbb\n\nfunction_selector will return a byte array containing the encoded function selector.\n\nLearn More ​\n\nstylus_sdk::function_selector",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Function Selector"
    }
  },
  {
    "text": "ABI Encode\n\nThe ABI Encode has 2 types which are encode and encode_packed .\n\nencode will concatenate all values and add padding to fit into 32 bytes for each values. encode_packed will concatenate all values in the exact byte representations without padding. (For example, encode_packed(\"a\", \"bc\") == encode_packed(\"ab\", \"c\") )\n\nSuppose we have a tuple of values: (target, value, func, data, timestamp) to encode, and their alloy primitives type are (Address, U256, String, Bytes, U256) .\n\nFirstly we need to import those types we need from alloy_primitives , stylus_sdk::abi and alloc::string :\n\nThis code has yet to be audited. Please use at your own risk.\n\n// Import items from the SDK. The prelude contains common traits and macros. use stylus_sdk :: { alloy_primitives :: { U256 , Address , FixedBytes } , abi :: Bytes , prelude :: * } ; // Import String from alloc use alloc :: string :: String ;\n\nSecondly because we will use the method abi_encode_sequence and abi_encode_packed under alloy_sol_types to encode data, we also need to import the types from alloy_sol_types :\n\n// Becauce the naming of alloy_primitives and alloy_sol_types is the same, so we need to re-name the types in alloy_sol_types use alloy_sol_types :: { sol_data :: { Address as SOLAddress , String as SOLString , Bytes as SOLBytes , * } , SolType } ;\n\nencode ​\n\nThen encode them:\n\n// define sol types tuple type TxIdHashType = ( SOLAddress , Uint < 256 > , SOLString , SOLBytes , Uint < 256 > ) ; // set the tuple let tx_hash_data = ( target , value , func , data , timestamp ) ; // encode the tuple let tx_hash_bytes = TxIdHashType :: abi_encode_sequence ( & tx_hash_data ) ;\n\nencode_packed ​\n\nThere are 2 methods to encode_packed data:\n\nencode_packed them:\n\n// define sol types tuple type TxIdHashType = ( SOLAddress , Uint < 256 > , SOLString , SOLBytes , Uint < 256 > ) ; // set the tuple let tx_hash_data = ( target , value , func , data , timestamp ) ; // encode the tuple let tx_hash_data_encode_packed = TxIdHashType :: abi_encode_packed ( & tx_hash_data ) ;\n\nWe can also use the following method to encode_packed them:\n\nlet tx_hash_data_encode_packed = [ & target . to_vec ( ) , & value . to_be_bytes_vec ( ) , func . as_bytes ( ) , & data . to_vec ( ) , & timestamp . to_be_bytes_vec ( ) ] . concat ( ) ;\n\nFull Example code:\n\nsrc/main.rs ​\n\n// Allow `cargo stylus export-abi` to generate a main function. #![cfg_attr(not(feature = \"export-abi\" ), no_main)] extern crate alloc ; /// Import items from the SDK. The prelude contains common traits and macros. use stylus_sdk :: { alloy_primitives :: { U256 , Address , FixedBytes } , abi :: Bytes , prelude :: * } ; use alloc :: string :: String ; // Becauce the naming of alloy_primitives and alloy_sol_types is the same, so we need to re-name the types in alloy_sol_types use alloy_sol_types :: { sol_data :: { Address as SOLAddress , String as SOLString , Bytes as SOLBytes , * } , SolType } ; use sha3 :: { Digest , Keccak256 } ; // Define some persistent storage using the Solidity ABI. // `Encoder` will be the entrypoint. #[storage] #[entrypoint] pub struct Encoder ; impl Encoder { fn keccak256 ( & self , data : Bytes ) -> FixedBytes < 32 > { // prepare hasher let mut hasher = Keccak256 :: new ( ) ; // populate the data hasher . update ( data ) ; // hashing with keccack256 let result = hasher . finalize ( ) ; // convert the result hash to FixedBytes<32> let result_vec = result . to_vec ( ) ; FixedBytes :: < 32 > :: from_slice ( & result_vec ) } } /// Declare that `Encoder` is a contract with the following external methods. #[public] impl Encoder { // Encode the data and hash it pub fn encode ( & self , target : Address , value : U256 , func : String , data : Bytes , timestamp : U256 ) -> Vec < u8 > { // define sol types tuple type TxIdHashType = ( SOLAddress , Uint < 256 > , SOLString , SOLBytes , Uint < 256 > ) ; // set the tuple let tx_hash_data = ( target , value , func , data , timestamp ) ; // encode the tuple let tx_hash_data_encode = TxIdHashType :: abi_encode_params ( & tx_hash_data ) ; tx_hash_data_encode } // Packed encode the data and hash it, the same result with the following one pub fn packed_encode ( & self , target : Address , value : U256 , func : String , data : Bytes , timestamp : U256 ) -> Vec < u8 > { // define sol types tuple type TxIdHashType = ( SOLAddress , Uint < 256 > , SOLString , SOLBytes , Uint < 256 > ) ; // set the tuple let tx_hash_data = ( target , value , func , data , timestamp ) ; // encode the tuple let tx_hash_data_encode_packed = TxIdHashType :: abi_encode_packed ( & tx_hash_data ) ; tx_hash_data_encode_packed } // Packed encode the data and hash it, the same result with the above one pub fn packed_encode_2 ( & self , target : Address , value : U256 , func : String , data : Bytes , timestamp : U256 ) -> Vec < u8 > { // set the data to arrary and concat it directly let tx_hash_data_encode_packed = [ & target . to_vec ( ) , & value . to_be_bytes_vec ( ) , func . as_bytes ( ) , & data . to_vec ( ) , & timestamp . to_be_bytes_vec ( ) ] . concat ( ) ; tx_hash_data_encode_packed } // The func example: \"transfer(address,uint256)\" pub fn encode_with_signature ( & self , func : String , address : Address , amount : U256 ) -> Vec < u8 > { type TransferType = ( SOLAddress , Uint < 256 > ) ; let tx_data = ( address , amount ) ; let data = TransferType :: abi_encode_params ( & tx_data ) ; // Get function selector let hashed_function_selector = self . keccak256 ( func . as_bytes ( ) . to_vec ( ) . into ( ) ) ; // Combine function selector and input data (use abi_packed way) let calldata = [ & hashed_function_selector [ .. 4 ] , & data ] . concat ( ) ; calldata } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus-encode-hashing\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" sha3 = \"0.10\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Abi Encode"
    }
  },
  {
    "text": "ABI Decode\n\nThe decode can not be used for encode_packed data because it ignores padding when encode. (For more information you can refer to ABI Encode )\n\nSo here we show an example for using decode on data encoded with abi_encode_sequence :\n\nThis code has yet to be audited. Please use at your own risk.\n\n// This should always return true pub fn encode_and_decode ( & self , target : Address , value : U256 , func : String , data : Bytes , timestamp : U256 ) -> Result < bool , HasherError > { // define sol types tuple type TxIdHashType = ( SOLAddress , Uint < 256 > , SOLString , SOLBytes , Uint < 256 > ) ; // because the abi_encode_sequence will return alloy_primitives::Bytes rather than stylus_sdk::bytes, so we need to make sure the input and return types are the same let primative_data = alloy_primitives :: Bytes :: copy_from_slice ( & data ) ; // set the tuple let tx_hash_data = ( target , value , func , primative_data , timestamp ) ; // encode the tuple let tx_hash_data_encode = TxIdHashType :: abi_encode_sequence ( & tx_hash_data ) ; let validate = true ; // Check the result match TxIdHashType :: abi_decode_sequence ( & tx_hash_data_encode , validate ) { Ok ( res ) => Ok ( res == tx_hash_data ) , Err ( _ ) => { return Err ( HasherError :: DecodedFailed ( DecodedFailed { } ) ) ; } , } }\n\nFull Example code:\n\nsrc/lib.rs ​\n\n#![cfg_attr(not(any(feature = \"export-abi\" , test)), no_main)] extern crate alloc ; /// Import items from the SDK. The prelude contains common traits and macros. use stylus_sdk :: { alloy_primitives :: { U256 , Address } , prelude :: * } ; // Because the naming of `alloy_primitives` and `alloy_sol_types` is the same, we need to rename the types in `alloy_sol_types`. use alloy_sol_types :: { sol_data :: { Address as SOLAddress , * } , SolType , sol } ; // Define error sol! { error DecodedFailed ( ) ; } // Error types for the MultiSig contract #[derive(SolidityError)] pub enum DecoderError { DecodedFailed ( DecodedFailed ) } #[storage] #[entrypoint] pub struct Decoder ; /// Declare that `Decoder` is a contract with the following external methods. #[public] impl Decoder { // This should always return true pub fn encode_and_decode ( & self , address : Address , amount : U256 ) -> Result < bool , DecoderError > { // define sol types tuple type TxIdHashType = ( SOLAddress , Uint < 256 > ) ; // set the tuple let tx_hash_data = ( address , amount ) ; // encode the tuple let tx_hash_data_encode = TxIdHashType :: abi_encode_params ( & tx_hash_data ) ; let validate = true ; // Check the result match TxIdHashType :: abi_decode_params ( & tx_hash_data_encode , validate ) { Ok ( res ) => Ok ( res == tx_hash_data ) , Err ( _ ) => { return Err ( DecoderError :: DecodedFailed ( DecodedFailed { } ) ) ; } , } } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus-decode-hashing\" version = \"0.1.0\" edition = \"2021\" [ dependencies ] alloy - primitives = \"=0.7.6\" alloy - sol - types = \"=0.7.6\" mini - alloc = \"0.4.2\" stylus - sdk = \"0.5.1\" [ features ] export - abi = [ \"stylus-sdk/export-abi\" ] debug = [ \"stylus-sdk/debug\" ] [ lib ] crate - type = [ \"lib\" , \"cdylib\" ] [ profile . release ] codegen - units = 1 strip = true lto = true panic = \"abort\" opt - level = \"s\"",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Abi Decode"
    }
  },
  {
    "text": "Hasing with keccak256 • Stylus by Example\n\nHashing with keccak256 ​\n\nKeccak256 is a cryptographic hash function that takes an input of an arbitrary length and produces a fixed-length output of 256 bits.\n\nKeccak256 is a member of the SHA-3 family of hash functions.\n\nkeccak256 computes the Keccak-256 hash of the input.\n\nSome use cases are:\n\nCreating a deterministic unique ID from a input Commit-Reveal scheme Compact cryptographic signature (by signing the hash instead of a larger input)\n\nHere we will use stylus-sdk::crypto::keccak to calculate the keccak256 hash of the input data:\n\nThis code has yet to be audited. Please use at your own risk.\n\npub fn keccak < T : AsRef < [ u8 ] >> ( bytes : T ) -> B256\n\nFull Example code:\n\nsrc/main.rs ​\n\n// Only run this as a WASM if the export-abi feature is not set. #![cfg_attr(not(any(feature = \"export-abi\" , test)), no_main)] extern crate alloc ; /// Import items from the SDK. The prelude contains common traits and macros. use stylus_sdk :: { alloy_primitives :: { U256 , Address , FixedBytes } , abi :: Bytes , prelude :: * , crypto :: keccak } ; use alloc :: string :: String ; use alloc :: vec :: Vec ; // Becauce the naming of alloy_primitives and alloy_sol_types is the same, so we need to re-name the types in alloy_sol_types use alloy_sol_types :: { sol_data :: { Address as SOLAddress , String as SOLString , Bytes as SOLBytes , * } , SolType } ; use alloy_sol_types :: sol ; // Define error sol! { error DecodedFailed ( ) ; } // Error types for the MultiSig contract #[derive(SolidityError)] pub enum HasherError { DecodedFailed ( DecodedFailed ) } #[solidity_storage] #[entrypoint] pub struct Hasher { } /// Declare that `Hasher` is a contract with the following external methods. #[public] impl Hasher { // Encode the data and hash it pub fn encode_and_hash ( & self , target : Address , value : U256 , func : String , data : Bytes , timestamp : U256 ) -> FixedBytes < 32 > { // define sol types tuple type TxIdHashType = ( SOLAddress , Uint < 256 > , SOLString , SOLBytes , Uint < 256 > ) ; // set the tuple let tx_hash_data = ( target , value , func , data , timestamp ) ; // encode the tuple let tx_hash_data_encode = TxIdHashType :: abi_encode_sequence ( & tx_hash_data ) ; // hash the encoded data keccak ( tx_hash_data_encode ) . into ( ) } // This should always return true pub fn encode_and_decode ( & self , address : Address , amount : U256 ) -> Result < bool , HasherError > { // define sol types tuple type TxIdHashType = ( SOLAddress , Uint < 256 > ) ; // set the tuple let tx_hash_data = ( address , amount ) ; // encode the tuple let tx_hash_data_encode = TxIdHashType :: abi_encode_sequence ( & tx_hash_data ) ; let validate = true ; // Check the result match TxIdHashType :: abi_decode_sequence ( & tx_hash_data_encode , validate ) { Ok ( res ) => Ok ( res == tx_hash_data ) , Err ( _ ) => { return Err ( HasherError :: DecodedFailed ( DecodedFailed { } ) ) ; } , } } // Packed encode the data and hash it, the same result with the following one pub fn packed_encode_and_hash_1 ( & self , target : Address , value : U256 , func : String , data : Bytes , timestamp : U256 ) -> FixedBytes < 32 > { // define sol types tuple type TxIdHashType = ( SOLAddress , Uint < 256 > , SOLString , SOLBytes , Uint < 256 > ) ; // set the tuple let tx_hash_data = ( target , value , func , data , timestamp ) ; // encode the tuple let tx_hash_data_encode_packed = TxIdHashType :: abi_encode_packed ( & tx_hash_data ) ; // hash the encoded data keccak ( tx_hash_data_encode_packed ) . into ( ) } // Packed encode the data and hash it, the same result with the above one pub fn packed_encode_and_hash_2 ( & self , target : Address , value : U256 , func : String , data : Bytes , timestamp : U256 ) -> FixedBytes < 32 > { // set the data to arrary and concat it directly let tx_hash_data_encode_packed = [ & target . to_vec ( ) , & value . to_be_bytes_vec ( ) , func . as_bytes ( ) , & data . to_vec ( ) , & timestamp . to_be_bytes_vec ( ) ] . concat ( ) ; // hash the encoded data keccak ( tx_hash_data_encode_packed ) . into ( ) } // The func example: \"transfer(address,uint256)\" pub fn encode_with_signature ( & self , func : String , address : Address , amount : U256 ) -> Vec < u8 > { type TransferType = ( SOLAddress , Uint < 256 > ) ; let tx_data = ( address , amount ) ; let data = TransferType :: abi_encode_sequence ( & tx_data ) ; // Get function selector let hashed_function_selector : FixedBytes < 32 > = keccak ( func . as_bytes ( ) . to_vec ( ) ) . into ( ) ; // Combine function selector and input data (use abi_packed way) let calldata = [ & hashed_function_selector [ .. 4 ] , & data ] . concat ( ) ; calldata } // The func example: \"transfer(address,uint256)\" pub fn encode_with_signature_and_hash ( & self , func : String , address : Address , amount : U256 ) -> FixedBytes < 32 > { type TransferType = ( SOLAddress , Uint < 256 > ) ; let tx_data = ( address , amount ) ; let data = TransferType :: abi_encode_sequence ( & tx_data ) ; // Get function selector let hashed_function_selector : FixedBytes < 32 > = keccak ( func . as_bytes ( ) . to_vec ( ) ) . into ( ) ; // Combine function selector and input data (use abi_packed way) let calldata = [ & hashed_function_selector [ .. 4 ] , & data ] . concat ( ) ; keccak ( calldata ) . into ( ) } }\n\nCargo.toml \u0000\u0000​\n\n[ package ] name = \"stylus-encode-hashing\" version = \"0.1.0\" edition = \"2021\" [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" sha3 = \"0.10.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] debug = [ \"stylus-sdk/debug\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Hashing"
    }
  },
  {
    "text": "Bytes In, Bytes Out\n\nThis is a simple bytes in, bytes out contract that shows a minimal entrypoint function (denoted by the #[entrypoint] proc macro). If your smart contract just has one primary function, like computing a cryptographic hash, this can be a great model because it strips out the SDK and acts like a pure function or Unix-style app.\n\nsrc/main.rs ​\n\nThis code has yet to be audited. Please use at your own risk.\n\n#![cfg_attr(not(feature = \"export-abi\" ), no_main)] extern crate alloc ; use alloc :: vec :: Vec ; use stylus_sdk :: stylus_proc :: entrypoint ; #[entrypoint] fn user_main ( input : Vec < u8 > ) -> Result < Vec < u8 > , Vec < u8 >> { Ok ( input ) }\n\nCargo.toml ​\n\n[ package ] name = \"bytes_in_bytes_out\" version = \"0.1.7\" edition = \"2021\" [ dependencies ] stylus-sdk = \"0.6.0\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\" [ workspace ]",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Bytes In Bytes Out"
    }
  },
  {
    "text": "Stylus Rust SDK advanced features\n\nThis document provides information about advanced features included in the Stylus Rust SDK , that are not described in the previous pages. For information about deploying Rust smart contracts, see the cargo stylus CLI Tool . For a conceptual introduction to Stylus, see Stylus: A Gentle Introduction . To deploy your first Stylus smart contract using Rust, refer to the Quickstart .\n\nMany of the affordances use macros. Though this section details what each does, it may be helpful to use cargo expand to see what they expand into if you’re doing advanced work in Rust.\n\nStorage ​\n\nThis section provides extra information about how the Stylus Rust SDK handles storage. You can find more information and basic examples in Variables .\n\nRust smart contracts may use state that persists across transactions. There’s two primary ways to define storage, depending on if you want to use Rust or Solidity definitions. Both are equivalent, and are up to the developer depending on their needs.\n\n#[storage] ​\n\nThe #[storage] macro allows a Rust struct to be used in persistent storage.\n\n#[storage] pub struct Contract { owner : StorageAddress , active : StorageBool , sub_struct : SubStruct , } #[storage] pub struct SubStruct { // types implementing the `StorageType` trait. }\n\nAny type implementing the StorageType trait may be used as a field, including other structs, which will implement the trait automatically when #[storage] is applied. You can even implement StorageType yourself to define custom storage types. However, we’ve gone ahead and implemented the common ones.\n\n| StorageBool | Stores a bool |\n| StorageAddress | Stores an Alloy Address |\n| StorageUint | Stores an Alloy Uint |\n| StorageSigned | Stores an Alloy Signed |\n| StorageFixedBytes | Stores an Alloy FixedBytes |\n| StorageBytes | Stores a Solidity bytes |\n| StorageString | Stores a Solidity string |\n| StorageVec | Stores a vector of StorageType |\n| StorageMap | Stores a mapping of StorageKey to StorageType |\n| StorageArray | Stores a fixed-sized array of StorageType |\n\nEvery Alloy primitive has a corresponding StorageType implementation with the word Storage before it. This includes aliases, like StorageU256 and StorageB64 .\n\nsol_storage! ​\n\nThe types in #[storage] are laid out in the EVM state trie exactly as they are in Solidity . This means that the fields of a struct definition will map to the same storage slots as they would in EVM programming languages.\n\nBecause of this, it is often nice to define your types using Solidity syntax, which makes that guarantee easier to see. For example, the earlier Rust struct can re-written to:\n\nsol_storage! { pub struct Contract { address owner ; // becomes a StorageAddress bool active ; // becomes a StorageBool SubStruct sub_struct , } pub struct SubStruct { // other solidity fields, such as mapping ( address => uint ) balances ; // becomes a StorageMap Delegate delegates [ ] ; // becomes a StorageVec } }\n\nThe above will expand to the equivalent definitions in Rust, each structure implementing the StorageType trait. Many contracts, like our example ERC-20 , do exactly this.\n\nBecause the layout is identical to Solidity’s , existing Solidity smart contracts can upgrade to Rust without fear of storage slots not lining up. You simply copy-paste your type definitions.\n\nOne exception to this storage layout guarantee is contracts which utilize inheritance. The current solution in Stylus using #[borrow] and #[inherits(...)] packs nested (inherited) structs into their own slots. This is consistent with regular struct nesting in solidity, but not inherited structs. We plan to revisit this behavior in an upcoming release.\n\nExisting Solidity smart contracts can upgrade to Rust if they use proxy patterns.\n\nConsequently, the order of fields will affect the JSON ABIs produced that explorers and tooling might use. Most developers won’t need to worry about this though and can freely order their types when working on a Rust contract from scratch.\n\nReading and writing storage ​\n\nYou can access storage types via getters and setters. For example, the Contract struct from earlier might access its owner address as follows.\n\nimpl Contract { /// Gets the owner from storage. pub fn owner ( & self ) -> Address { self . owner . get ( ) } /// Updates the owner in storage pub fn set_owner ( & mut self , new_owner : Address ) { if msg :: sender ( ) == self . owner . get ( ) { // we'll discuss msg::sender later self . owner . set ( new_owner ) ; } } /// Unlike other storage type, stringStorage needs to /// use `.set_str()` and `.get_string()` to set and get. pub fn set_base_uri ( & mut self , base_uri : String ) { self . base_uri . set_str ( base_uri ) ; } pub fn get_base_uri ( & self ) -> String { self . base_uri . get_string ( ) } }\n\nIn Solidity, one has to be very careful about storage access patterns. Getting or setting the same value twice doubles costs, leading developers to avoid storage access at all costs. By contrast, the Stylus SDK employs an optimal storage-caching policy that avoids the underlying SLOAD or SSTORE operations.\n\nStylus uses storage caching, so multiple accesses of the same variable is virtually free.\n\nHowever it must be said that storage is ultimately more expensive than memory. So if a value doesn’t need to be stored in state, you probably shouldn’t do it.\n\nCollections ​\n\nCollections like StorageVec and StorageMap are dynamic and have methods like push , insert , replace , and similar.\n\nimpl SubStruct { pub fn add_delegate ( & mut self , delegate : Address ) { self . delegates . push ( delegate ) ; } pub fn track_balance ( & mut self , address : Address ) { self . balances . insert ( address , address . balance ( ) ) ; } }\n\nYou may notice that some methods return types like StorageGuard and StorageGuardMut . This allows us to leverage the Rust borrow checker for storage mistakes, just like it does for memory. Here’s an example that will fail to compile.\n\nfn mistake ( vec : & mut StorageVec < StorageU64 > ) -> U64 { let value = vec . setter ( 0 ) ; let alias = vec . setter ( 0 ) ; value . set ( 32 . into ( ) ) ; alias . set ( 48 . into ( ) ) ; value . get ( ) // uh, oh. what value should be returned? }\n\nUnder the hood, vec.setter() returns a StorageGuardMut instead of a &mut StorageU64 . Because the guard is bound to a &mut StorageVec lifetime, value and alias cannot be alive simultaneously. This causes the Rust compiler to reject the above code, saving you from entire classes of storage aliasing errors.\n\nIn this way the Stylus SDK safeguards storage access the same way Rust ensures memory safety. It should never be possible to alias Storage without unsafe Rust.\n\nSimpleStorageType ​\n\nYou may run into scenarios where a collection’s methods like push and insert aren’t available. This is because only primitives, which implement a special trait called SimpleStorageType , can be added to a collection by value. For nested collections, one instead uses the equivalent grow and setter .\n\nfn nested_vec ( vec : & mut StorageVec < StorageVec < StorageU8 >> ) { let mut inner = vec . grow ( ) ; // adds a new element accessible via `inner` inner . push ( 0 . into ( ) ) ; // inner is a guard to a StorageVec<StorageU8> } fn nested_map ( map : & mut StorageMap < u32 , StorageVec < U8 >> ) { let mut slot = map . setter ( 0 ) ; slot . push ( 0 ) ; }\n\nErase and #[derive(Erase)] ​\n\nSome StorageType values implement Erase , which provides an erase() method for clearing state. We’ve implemented Erase for all primitives, and for vectors of primitives, but not maps. This is because a solidity mapping does not provide iteration, and so it’s generally impossible to know which slots to set to zero.\n\nStructs may also be Erase if all of the fields are. #[derive(Erase)] lets you do this automatically.\n\nsol_storage! { #[derive(Erase)] pub struct Contract { address owner ; // can erase primitive uint256 [ ] hashes ; // can erase vector of primitive } pub struct NotErase { mapping ( address => uint ) balances ; // can't erase a map mapping ( uint => uint ) [ ] roots ; // can't erase vector of maps } }\n\nYou can also implement Erase manually if desired. Note that the reason we care about Erase at all is that you get storage refunds when clearing state, lowering fees. There’s also minor implications for patterns using unsafe Rust.\n\nThe storage cache ​\n\nThe Stylus SDK employs an optimal storage-caching policy that avoids the underlying SLOAD or SSTORE operations needed to get and set state. For the vast majority of use cases, this happens in the background and requires no input from the user.\n\nHowever, developers working with unsafe Rust implementing their own custom StorageType collections, the StorageCache type enables direct control over this data structure. Included are unsafe methods for manipulating the cache directly, as well as for bypassing it altogether.\n\nImmutables and PhantomData ​\n\nSo that generics are possible in sol_interface! , core::marker::PhantomData implements StorageType and takes up zero space, ensuring that it won’t cause storage slots to change. This can be useful when writing libraries.\n\npub trait Erc20Params { const NAME : & 'static str ; const SYMBOL : & 'static str ; const DECIMALS : u8 ; } sol_storage! { pub struct Erc20 < T > { mapping ( address => uint256 ) balances ; PhantomData < T > phantom ; } }\n\nThe above allows consumers of Erc20 to choose immutable constants via specialization. See our WETH sample contract for a full example of this feature.\n\nFunctions ​\n\nThis section provides extra information about how the Stylus Rust SDK handles functions. You can find more information and basic examples in Functions , Bytes in, bytes out programming , Inheritance and Sending ether .\n\nPure, View, and Write functions ​\n\nFor non-payable methods the #[public] macro can figure state mutability out for you based on the types of the arguments. Functions with &self will be considered view , those with &mut self will be considered write , and those with neither will be considered pure . Please note that pure and view functions may change the state of other contracts by calling into them, or even this one if the reentrant feature is enabled.\n\n#[entrypoint] ​\n\nThis macro allows you to define the entrypoint, which is where Stylus execution begins. Without it, the contract will fail to pass cargo stylus check . Most commonly, the macro is used to annotate the top level storage struct.\n\nsol_storage! { #[entrypoint] pub struct Contract { ... } // only one entrypoint is allowed pub struct SubStruct { ... } }\n\nThe above will make the public methods of Contract the first to consider during invocation.\n\nReentrancy ​\n\nIf a contract calls another that then calls the first, it is said to be reentrant. By default, all Stylus contracts revert when this happens. However, you can opt out of this behavior by enabling the reentrant feature flag.\n\nstylus - sdk = { version = \"0.6.0\" , features = [ \"reentrant\" ] }\n\nThis is dangerous, and should be done only after careful review––ideally by third-party auditors. Numerous exploits and hacks have in Web3 are attributable to developers misusing or not fully understanding reentrant patterns.\n\nIf enabled, the Stylus SDK will flush the storage cache in between reentrant calls, persisting values to state that might be used by inner calls. Note that preventing storage invalidation is only part of the battle in the fight against exploits. You can tell if a call is reentrant via msg::reentrant , and condition your business logic accordingly.\n\nTopLevelStorage ​\n\nThe #[entrypoint] macro will automatically implement the TopLevelStorage trait for the annotated struct . The single type implementing TopLevelStorage is special in that mutable access to it represents mutable access to the entire program’s state. This idea will become important when discussing calls to other programs in later sections.\n\nInheritance, #[inherit] , and #[borrow] . ​\n\nStylus doesn't support contract multi-inheritance yet.\n\nComposition in Rust follows that of Solidity. Types that implement Router , the trait that #[public] provides, can be connected via inheritance.\n\n#[public] #[inherit(Erc20)] impl Token { pub fn mint ( & mut self , amount : U256 ) -> Result < ( ) , Vec < u8 >> { ... } } #[public] impl Erc20 { pub fn balance_of ( ) -> Result < U256 > { ... } }\n\nBecause Token inherits Erc20 in the above, if Token has the #[entrypoint] , calls to the contract will first check if the requested method exists within Token . If a matching function is not found, it will then try the Erc20 . Only after trying everything Token inherits will the call revert.\n\nNote that because methods are checked in that order, if both implement the same method, the one in Token will override the one in Erc20 , which won’t be callable. This allows for patterns where the developer imports a crate implementing a standard, like the ERC-20 , and then adds or overrides just the methods they want to without modifying the imported Erc20 type.\n\nStylus does not currently contain explicit override or virtual keywords for explicitly marking override functions. It is important, therefore, to carefully ensure that contracts are only overriding the functions.\n\nInheritance can also be chained. #[inherit(Erc20, Erc721)] will inherit both Erc20 and Erc721 , checking for methods in that order. Erc20 and Erc721 may also inherit other types themselves. Method resolution finds the first matching method by Depth First Search .\n\nFor the above to work, Token must implement Borrow<Erc20> . You can implement this yourself, but for simplicity, #[storage] and sol_storage! provide a #[borrow] annotation.\n\nsol_storage! { #[entrypoint] pub struct Token { #[borrow] Erc20 erc20 ; ... } pub struct Erc20 { ... } }\n\nCalls ​\n\nJust as with storage and functions, Stylus SDK calls are Solidity ABI equivalent. This means you never have to know the implementation details of other contracts to invoke them. You simply import the Solidity interface of the target contract, which can be auto-generated via the cargo stylus CLI tool .\n\nYou can call contracts in any programming language with the Stylus SDK.\n\nsol_interface! ​\n\nThis macro defines a struct for each of the Solidity interfaces provided.\n\nsol_interface! { interface IService { function makePayment ( address user ) payable returns ( string ) ; function getConstant ( ) pure returns ( bytes32 ) } interface ITree { // other interface methods } }\n\nThe above will define IService and ITree for calling the methods of the two contracts.\n\nCurrently only functions are supported, and any other items in the interface will cause an error.\n\nFor example, IService will have a make_payment method that accepts an Address and returns a B256 .\n\npub fn do_call ( & mut self , account : IService , user : Address ) -> Result < String , Error > { account . make_payment ( self , user ) // note the snake case }\n\nObserve the casing change. sol_interface! computes the selector based on the exact name passed in, which should almost always be CamelCase . For aesthetics, the rust functions will instead use snake_case .\n\nConfiguring gas and value with Call ​\n\nCall lets you configure a call via optional configuration methods. This is similar to how one would configure opening a File in Rust.\n\npub fn do_call ( account : IService , user : Address ) -> Result < String , Error > { let config = Call :: new_in ( ) . gas ( evm :: gas_left ( ) / 2 ) // limit to half the gas left . value ( msg :: value ( ) ) ; // set the callvalue account . make_payment ( config , user ) }\n\nBy default Call supplies all gas remaining and zero value, which often means Call::new_in() may be passed to the method directly. Additional configuration options are available in cases of reentrancy.\n\nReentrant calls ​\n\nContracts that opt into reentrancy via the reentrant feature flag require extra care. When the storage-cache feature is enabled, cross-contract calls must flush or clear the StorageCache to safeguard state. This happens automatically via the type system.\n\nsol_interface! { interface IMethods { function pureFoo ( ) external pure ; function viewFoo ( ) external view ; function writeFoo ( ) external ; function payableFoo ( ) external payable ; } } #[public] impl Contract { pub fn call_pure ( & self , methods : IMethods ) -> Result < ( ) , Vec < u8 >> { Ok ( methods . pure_foo ( self ) ? ) // `pure` methods might lie about not being `view` } pub fn call_view ( & self , methods : IMethods ) -> Result < ( ) , Vec < u8 >> { Ok ( methods . view_foo ( self ) ? ) } pub fn call_write ( & mut self , methods : IMethods ) -> Result < ( ) , Vec < u8 >> { methods . view_foo ( self ) ? ; // allows `pure` and `view` methods too Ok ( methods . write_foo ( self ) ? ) } #[payable] pub fn call_payable ( & mut self , methods : IMethods ) -> Result < ( ) , Vec < u8 >> { methods . write_foo ( Call :: new_in ( self ) ) ? ; // these are the same Ok ( methods . payable_foo ( self ) ? ) // ------------------ } }\n\nIn the above, we’re able to pass &self and &mut self because Contract implements TopLevelStorage , which means that a reference to it entails access to the entirety of the contract’s state. This is the reason it is sound to make a call, since it ensures all cached values are invalidated and/or persisted to state at the right time.\n\nWhen writing Stylus libraries, a type might not be TopLevelStorage and therefore &self or &mut self won’t work. Building a Call from a generic parameter via new_in is the usual solution.\n\npub fn do_call ( storage : & mut impl TopLevelStorage , // can be generic, but often just &mut self account : IService , // serializes as an Address user : Address , ) -> Result < String , Error > { let config = Call :: new_in ( storage ) // take exclusive access to all contract storage . gas ( evm :: gas_left ( ) / 2 ) // limit to half the gas left . value ( msg :: value ( ) ) ; // set the callvalue account . make_payment ( config , user ) // note the snake case }\n\nIn the context of a #[public] call, the &mut impl argument will correctly distinguish the method as being write or payable . This means you can write library code that will work regardless of whether the reentrant feature flag is enabled.\n\nAlso, that code that previously compiled with reentrancy disabled may require modification in order to type-check. This is done to ensure storage changes are persisted and that the storage cache is properly managed before calls.\n\ncall , static_call , and delegate_call ​\n\nThough sol_interface! and Call form the most common idiom to invoke other contracts, their underlying call and static_call are exposed for direct access.\n\nlet return_data = call ( Call :: new_in ( self ) , contract , call_data ) ? ;\n\nIn each case the calldata is supplied as a Vec<u8> . The return result is either the raw return data on success, or a call Error on failure.\n\ndelegate_call is also available, though it's unsafe and doesn't have a richly-typed equivalent. This is because a delegate call must trust the other contract to uphold safety requirements. Though this function clears any cached values, the other contract may arbitrarily change storage, spend ether, and do other things one should never blindly allow other contracts to do.\n\ntransfer_eth ​\n\nThis method provides a convenient shorthand for transferring ether.\n\nThis method invokes the other contract, which may in turn call others. All gas is supplied, which the recipient may burn. If this is not desired, the call function may be used instead.\n\ntransfer_eth ( recipient , value ) ? ; // these two are equivalent call ( Call :: new_in ( ) . value ( value ) , recipient , & [ ] ) ? ; // these two are equivalent\n\nRawCall and unsafe calls ​\n\nOccasionally, an untyped call to another contract is necessary. RawCall lets you configure an unsafe call by calling optional configuration methods. This is similar to how one would configure opening a File in Rust.\n\nlet data = RawCall :: new_delegate ( ) // configure a delegate call . gas ( 2100 ) // supply 2100 gas . limit_return_data ( 0 , 32 ) // only read the first 32 bytes back . flush_storage_cache ( ) // flush the storage cache before the call . call ( contract , calldata ) ? ; // do the call\n\nThe call method is unsafe when reentrancy is enabled. See flush_storage_cache and clear_storage_cache for more information.\n\nRawDeploy and unsafe deployments ​\n\nRight now the only way to deploy a contract from inside Rust is to use RawDeploy , similar to RawCall . As with RawCall , this mechanism is inherently unsafe due to reentrancy concerns, and requires manual management of the StorageCache .\n\nThat the EVM allows init code to make calls to other contracts, which provides a vector for reentrancy. This means that this technique may enable storage aliasing if used in the middle of a storage reference's lifetime and if reentrancy is allowed.\n\nWhen configured with a salt , RawDeploy will use CREATE2 instead of the default CREATE , facilitating address determinism.",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Advanced features"
    }
  },
  {
    "text": "Recommended libraries\n\nUsing public Rust crates ​\n\nRust provides a package registry at crates.io , which lets developers conveniently access a plethora of open source libraries to utilize as dependencies in their code. Stylus Rust contracts can take advantage of these crates to simplify their development workflow.\n\nWhile crates.io is a fantastic resource, many of these libraries were not designed with the constraints of a blockchain environment in mind. Some produce large binaries that exceed the 24KB compressed size limit of WASM smart contracts on Arbitrum. Many also take advantage of unsupported features such as:\n\nRandom numbers Multi threading Floating point numbers and operations\n\nUsing the standard Rust library often bloats contract sizes beyond the maximum size. For this reason, libraries designated as no_std are typically much stronger candidates for usage as a smart contract dependency. crates.io has a special tag for marking crates as no_std ; however, it's not universally used. Still, it can be a good starting point for locating supported libraries. See \"No standard library\" crates for more details.\n\nCurated crates ​\n\nTo save developers time on smart contract development for common dependencies, we've curated a list of crates and utilities that we found helpful. Keep in mind that we have not audited this code, and you should always be mindful about pulling dependencies into your codebase, whether they've been audited or not. We provide this list for you to use at your discretion and risk.\n\nrust_decimal : Decimal number implementation written in pure Rust. Suitable for financial and fixed-precision calculations special : The package provides special functions, which are mathematical functions with special names due to their common usage, such as sin , ln , tan , etc. hashbrown : Rust port of Google's SwissTable hash map time : Date and time library hex : Encoding and decoding data into/from hexadecimal representation\n\nWe'll be adding more libraries to this list as we find them. Feel free to suggest an edit if you know of any great crates that would be generally useful here.",
    "metadata": {
      "category": "Rust SDK",
      "subsection": "Use Rust Crates"
    }
  },
  {
    "text": "Using Stylus CLI\n\nThis guide will get you started using cargo stylus , a CLI toolkit to help developers manage, compile, deploy, and optimize their Stylus contracts efficiently.\n\nThis overview will help you discover and learn how to uses cargo stylus tools.\n\nInstalling cargo stylus ​\n\nCargo stylus is a plugin to the standard cargo tool for developing Rust programs.\n\nRust toolchain\n\nFollow the instructions on Rust Lang's installation page to install a complete Rust toolchain (v1.81 or newer) on your system. After installation, ensure you can access the programs rustup , rustc , and cargo from your preferred terminal application.\n\nDocker\n\nWe will use the testnet, and some cargo stylus commands will require Docker to operate.\n\nYou can download Docker from Docker's website .\n\nFoundry's Cast\n\nFoundry's Cast is a command-line tool for interacting with your EVM contracts.\n\nNitro devnode\n\nStylus is available on Arbitrum Sepolia, but we'll use Nitro devnode, which has a pre-funded wallet, saving us the effort of wallet provisioning or running out of tokens to send transactions.\n\ngit clone https://github.com/OffchainLabs/nitro-devnode.git cd nitro-devnode\n\n./run-dev-node.sh\n\nIn your terminal, run:\n\ncargo install --force cargo-stylus\n\nAdd WASM ( WebAssembly ) as a build target for the specific Rust toolchain you are using. The below example sets your default Rust toolchain to 1.80 as well as adding the WASM build target:\n\nrustup default 1.80 rustup target add wasm32-unknown-unknown --toolchain 1.80\n\nYou can verify the cargo stylus installation by running cargo stylus -V in your terminal, returning something like: stylus 0.5.6\n\nUsing cargo stylus ​\n\nThese options are available across multiple commands:\n\nAvailable for commands involving transactions:",
    "metadata": {
      "category": "Rust CLI",
      "subsection": "Overview"
    }
  },
  {
    "text": "How to debug Stylus transactions using Cargo Stylus Replay\n\nDebugging smart contracts can be challenging, especially when dealing with complex transactions. The cargo-stylus crate simplifies the debugging process by allowing developers to replay Stylus transactions. This tool leverages GDB to provide an interactive debugging experience, enabling developers to set breakpoints, inspect state changes, and trace the execution flow step-by-step. This capability is crucial for identifying and resolving issues, ensuring that smart contracts function correctly and efficiently.\n\nOverview ​\n\nCargo Stylus is a tool designed to simplify the development and debugging process for smart contracts written in Rust for the Stylus execution environment. One of its powerful features is the cargo stylus subcommand, which provides essential functionalities for developers:\n\nTrace transactions : Perform trace calls against Stylus transactions using Ethereum nodes' debug_traceTransaction RPC. This feature enables developers to analyze the execution flow and state changes of their transactions in a detailed manner. Debugging with GDB or LLDB : Replay and debug the execution of a Stylus transaction using a debugger. This allows developers to set breakpoints, inspect variables, and step through the transaction execution line by line, providing an in-depth understanding of the transaction's behavior.\n\nReplaying transactions ​\n\nRust (version 1.77 or higher) Crate : cargo-stylus GNU Debugger (GDB) (Linux) or LLDB (MacOS) Cast (an Ethereum CLI tool) Arbitrum RPC Provider with tracing endpoints enabled or a local Stylus dev node\n\ncargo stylus replay allows users to debug the execution of a Stylus transaction using GDB or LLDB against the Rust source code.\n\nInstallation and setup ​\n\nInstall the required crates and debugger : First, let's ensure that the following crates are installed:\n\ncargo install cargo-stylus\n\nIf on Linux, install GDB if it's not already installed:\n\nsudo apt-get install gdb\n\nIf on MacOS, install LLDB if it's not already installed:\n\nxcode-select --install\n\nDeploy your Stylus contract : For this guide, we demonstrate how to debug the execution of the increment() method in the stylus-hello-world smart contract. In Rust, it looks something like this, within src/lib.rs :\n\n#[external] impl Counter { .. . /// Increments number and updates its value in storage. pub fn increment ( & mut self ) { let number = self.number.get ( ) ; self.set_number ( number + U256::from ( 1 )) ; } .. . }\n\nSet your RPC endpoint to a node with tracing enabled and your private key:\n\nexport RPC_URL = .. . export PRIV_KEY = .. .\n\nand deploy your contract:\n\ncargo stylus deploy --private-key = $PRIV_KEY --endpoint = $RPC_URL\n\nYou should see an output similar to:\n\ncontract size: 4.0 KB wasm size: 12.1 KB contract size: 4.0 KB deployed code at address: 0x2c8d8a1229252b07e73b35774ad91c0b973ecf71 wasm already activated !\n\nSend a transaction : First, set the address of the deployed contract as an environment variable:\n\nexport ADDR = 0x2c8d8a1229252b07e73b35774ad91c0b973ecf71\n\nAnd send a transaction using Cast :\n\ncast send --rpc-url = $RPC_URL --private-key = $PRIV_KEY $ADDR \"increment()\"\n\nReplay the transaction with the debugger : Now, we can replay the transaction with cargo stylus and the debugger to inspect each step of it against our source code. Make sure GDB is installed and that you are on a Linux, x86 system.\nAlso, you should set the transaction hash as an environment variable:\n\nexport TX_HASH = 0x18b241841fa0a59e02d3c6d693750ff0080ad792204aac7e5d4ce9e20c466835\n\nAnd replay the transaction:\n\ncargo stylus replay --tx = $TX_HASH --endpoint = $RPC_URL --use-native-tracer\n\nOptions:\n\n--tx: Specifies the transaction hash to replay. --endpoint: Specifies the RPC endpoint for fetching transaction data. --use-native-tracer: Uses the native Stylus tracer instead of the default JS tracer. The native tracer has broader support from RPC providers.\n\nThe --use-native-tracer flag uses stylusTracer instead of jsTracer , which is required for tracing Stylus transactions on most RPC providers. See more details below .\n\nThe debugger will load and set a breakpoint automatically at the user_entrypoint internal Stylus function. While the examples below showcase GDB commands, you can find the LLDB equivalents here .\n\n[ Detaching after vfork from child process 370003 ] Thread 1 \"cargo-stylus\" hit Breakpoint 1 , stylus_hello_world::user_entrypoint ( len = 4 ) at src/lib.rs:38 38 #[entrypoint] ( gdb )\n\nDebugging : Now, set a breakpoint at the increment() method:\n\n( gdb ) b stylus_hello_world::Counter::increment Breakpoint 2 at 0x7ffff7e4ee33: file src/lib.rs, line 69 .\n\nThen, type c to continue the execution and you will reach that line where increment is called:\n\n( gdb ) c\n\nOnce you reach the increment method, inspect the state:\n\nThread 1 \"cargo-stylus\" hit Breakpoint 2 , stylus_hello_world::Counter::increment ( self = 0x7fffffff9ae8 ) at src/lib.rs:69 69 let number = self.number.get ( ) ; ( gdb ) p number\n\nTrace a transaction ​\n\nFor traditional tracing, cargo stylus supports calls to debug_traceTransaction . To trace a transaction, you can use the following command:\n\ncargo stylus trace [ OPTIONS ] --tx < TX > --use-native-tracer\n\nOptions:\n\n-e, --endpoint < ENDPOINT > RPC endpoint [ default: http://localhost:8547 ] -t, --tx < TX > Tx ( transaction ) to replay -p, --project < PROJECT > Project path [ default: . ] -h, --help Print help -V, --version Print version --use-native-tracer    Uses the native Stylus tracer instead of the default JS tracer. The native tracer has broader support from RPC providers.\n\nRun the following command to obtain a trace output:\n\ncargo stylus trace --tx = $TX_HASH --endpoint = $RPC_URL --use-native-tracer\n\nThis will produce a trace of the functions called and ink left along each method:\n\n[ { \"args\" : [ 0,0 ,0,4 ] , \"endInk\" :846200000, \"name\" : \"user_entrypoint\" , \"outs\" : [ ] , \"startInk\" :846200000 } , { \"args\" : [ ] , \"endInk\" :846167558, \"name\" : \"msg_reentrant\" , \"outs\" : [ 0,0 ,0,0 ] , \"startInk\" :846175958 } , { \"args\" : [ ] , \"endInk\" :846047922, \"name\" : \"read_args\" , \"outs\" : [ 208,157 ,224,138 ] , \"startInk\" :846061362 } , { \"args\" : [ ] , \"endInk\" :845914924, \"name\" : \"msg_value\" , \"outs\" : [ 0,0 ,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] , \"startInk\" :845928364 } , { \"args\" : [ 0,0 ,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] , \"endInk\" :227196069, \"name\" : \"storage_load_bytes32\" , \"outs\" : [ 0,0 ,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] , \"startInk\" :844944549 } , { \"args\" : [ 0,0 ,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 ] , \"endInk\" :226716083, \"name\" : \"storage_cache_bytes32\" , \"outs\" : [ ] , \"startInk\" :226734563 } , { \"args\" : [ 0 ] , \"endInk\" :226418732, \"name\" : \"storage_flush_cache\" , \"outs\" : [ ] , \"startInk\" :226486805 } , { \"args\" : [ ] , \"endInk\" :226362319, \"name\" : \"write_result\" , \"outs\" : [ ] , \"startInk\" :226403481 } , { \"args\" : [ ] , \"endInk\" :846200000, \"name\" : \"user_returned\" , \"outs\" : [ 0,0 ,0,0 ] , \"startInk\" :846200000 } ]\n\nRPC endpoint compatibility ​\n\nBoth cargo stylus trace and cargo stylus replay require an RPC endpoint that supports debug_traceTransaction .\nBy default, the jsTracer type is used, which is not supported by most RPC providers. If the --use-native-tracer flag is used, the stylusTracer type is used, which is supported by many RPC providers.\nBoth jsTracer and stylusTracer are available on local nodes, but stylusTracer is more efficient.\nSee this list of RPC providers for tracing support.",
    "metadata": {
      "category": "Rust CLI",
      "subsection": "Debug transactions"
    }
  },
  {
    "text": "Testing Smart Contracts with Stylus\n\nIntroduction ​\n\nThe Stylus SDK provides a robust testing framework that allows developers to write and run tests for their contracts directly in Rust without deploying to a blockchain. This guide will walk you through the process of writing and running tests for Stylus contracts using the built-in testing framework.\n\nThe Stylus testing framework allows you to:\n\nSimulate a complete Ethereum environment for your tests without the need for running a test node Test contract storage operations and state transitions Mock transaction context and block information Test contract-to-contract interactions with mocked calls Verify contract logic without deployment costs or delays Simulate various user scenarios and edge cases\n\nPrerequisites ​\n\nBefore you begin, make sure you have:\n\nBasic familiarity with Rust and smart contract development Understanding of unit testing concepts Rust toolchain: follow the instructions on Rust Lang's installation page to install a complete Rust toolchain (v1.81 or newer) on your system. After installation, ensure you can access the programs rustup , rustc , and cargo from your preferred terminal application.\n\nThe Stylus Testing Framework ​\n\nThe Stylus SDK includes testing , a module that provides all the tools you need to test your contracts. This module includes:\n\nTestVM : A mock implementation of the Stylus VM that can simulate all host functions TestVMBuilder : A builder pattern to conveniently configure the test VM Built-in utilities for mocking calls, storage, and other EVM operations\n\nKey Components ​\n\nHere are the components you'll use when testing your Stylus contracts:\n\nTestVM : The core component that simulates the Stylus execution environment Storage accessors : For testing contract state changes Call mocking : For simulating interactions with other contracts Block context : For testing time-dependent logic\n\nExample Smart Contract: Cupcake Vending Machine ​\n\nLet's look at a Rust-based cupcake vending machine smart contract. This contract follows two simple rules:\n\nThe vending machine will distribute a cupcake to anyone who hasn't received one in the last 5 seconds The vending machine tracks each user's cupcake balance\n\nCupcake Vending Machine Contract\n\n#![cfg_attr(not(any(test, feature = \"export-abi\" )), no_main)] extern crate alloc ; /// Import items from the SDK. The prelude contains common traits and macros. use stylus_sdk :: alloy_primitives :: { Address , U256 } ; use stylus_sdk :: console ; use stylus_sdk :: prelude :: \\ * ; sol_storage! { #[entrypoint] pub struct VendingMachine { mapping ( address => uint256 ) cupcake_balances ; mapping ( address => uint256 ) cupcake_distribution_times ; } } #[public] impl VendingMachine { pub fn give_cupcake_to ( & mut self , user_address : Address ) -> Result < bool , Vec < u8 >> { // Get the last distribution time for the user. let last_distribution = self . cupcake_distribution_times . get ( user_address ) ; // Calculate the earliest next time the user can receive a cupcake. let five_seconds_from_last_distribution = last_distribution + U256 :: from ( 5 ) ; // Get the current block timestamp using the VM pattern let current_time = self . vm ( ) . block_timestamp ( ) ; // Check if the user can receive a cupcake. let user_can_receive_cupcake = five_seconds_from_last_distribution <= U256 :: from ( current_time ) ; if user_can_receive_cupcake { // Increment the user's cupcake balance. let mut balance_accessor = self . cupcake_balances . setter ( user_address ) ; let balance = balance_accessor . get ( ) + U256 :: from ( 1 ) ; balance_accessor . set ( balance ) ; // Get current timestamp using the VM pattern BEFORE creating the mutable borrow let new_distribution_time = self . vm ( ) . block_timestamp ( ) ; // Update the distribution time to the current time. let mut time_accessor = self . cupcake_distribution_times . setter ( user_address ) ; time_accessor . set ( U256 :: from ( new_distribution_time ) ) ; return Ok ( true ) ; } else { // User must wait before receiving another cupcake. console! ( \"HTTP 429: Too Many Cupcakes (you must wait at least 5 seconds between cupcakes)\" ) ; return Ok ( false ) ; } } pub fn get_cupcake_balance_for ( & self , user_address : Address ) -> Result < U256 , Vec < u8 >> { Ok ( self . cupcake_balances . get ( user_address ) ) } }\n\nWriting Tests for the Vending Machine ​\n\nNow, let's write comprehensive tests for our vending machine contract using the Stylus testing framework. We'll create tests that verify:\n\nUsers can get an initial cupcake Users must wait 5 seconds between cupcakes Cupcake balances are tracked correctly The contract state updates properly\n\nBasic Test Structure ​\n\nCreate a test file using standard Rust test patterns. Here's the basic structure:\n\n// Import necessary dependencies #[cfg(test)] mod test { use super :: * ; use alloy_primitives :: address ; use stylus_sdk :: testing :: * ; #[test] fn test_give_cupcake_to ( ) { // Set up test environment let vm = TestVM :: default ( ) ; // Initialize your contract let mut contract = VendingMachine :: from ( & vm ) ; // Test logic goes here... }\n\nUsing the TestVM ​\n\nThe TestVM simulates the execution environment for your Stylus contract, removing the need to run your tests against a test node.\nThe TestVM allows you to control aspects like:\n\nBlock timestamp and number Account balances Transaction value and sender Storage state\n\nLet's create a comprehensive test suite that covers all aspects of our contract.\n\nBelow is a more advanced example test file, we'll go over the code features one by one:\n\nComprehensive Test Vending Machine Contract\n\n#[cfg(test)] mod test { use super :: * ; use alloy_primitives :: address ; use ethers :: contract :: multicall_contract :: GetCurrentBlockTimestampCall ; use stylus_sdk :: testing :: * ; #[test] fn test_give_cupcake_to ( ) { let vm = TestVM :: default ( ) ; let mut contract = VendingMachine :: from ( & vm ) ; let user = address! ( \"0xCDC41bff86a62716f050622325CC17a317f99404\" ) ; assert_eq! ( contract . get_cupcake_balance_for ( user ) . unwrap ( ) , U256 :: ZERO ) ; vm . set_block_timestamp ( vm . block_timestamp ( ) + 6 ) ; // Give a cupcake and verify it succeeds assert! ( contract . give_cupcake_to ( user ) . unwrap ( ) ) ; // Check balance is now 1 assert_eq! ( contract . get_cupcake_balance_for ( user ) . unwrap ( ) , U256 :: from ( 1 ) ) ; // Try to give another cupcake immediately - should fail due to time restriction assert! ( ! contract . give_cupcake_to ( user ) . unwrap ( ) ) ; // Balance should still be 1 assert_eq! ( contract . get_cupcake_balance_for ( user ) . unwrap ( ) , U256 :: from ( 1 ) ) ; // Advance block timestamp by 6 seconds vm . set_block_timestamp ( vm . block_timestamp ( ) + 6 ) ; // Now giving a cupcake should succeed assert! ( contract . give_cupcake_to ( user ) . unwrap ( ) ) ; // Balance should now be 2 assert_eq! ( contract . get_cupcake_balance_for ( user ) . unwrap ( ) , U256 :: from ( 2 ) ) ; } /// This test demonstrates advanced configuration and usage of the TestVM for /// comprehensive smart contract testing. /// /// It covers: /// - Creating and configuring a TestVM with custom parameters /// - Setting blockchain state (timestamps, block numbers) /// - Interacting with contract methods /// - Taking and inspecting VM state snapshots /// - Mocking external contract calls /// - Testing time-dependent contract behavior #[test] fn test_advanced_testvm_configuration ( ) { // SECTION 1: TestVM Setup and Configuration // ----------------------------------------- // Create a TestVM with custom configuration using the builder pattern // This approach allows for fluent, readable test setup let vm : TestVM = TestVMBuilder :: new ( ) // Set the transaction sender address (msg.sender in Solidity) . sender ( address! ( \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\" ) ) // Set the address where our contract is deployed . contract_address ( address! ( \"0x5FbDB2315678afecb367f032d93F642f64180aa3\" ) ) // Set the ETH value sent with the transaction (msg.value in Solidity) . value ( U256 :: from ( 1 ) ) . build ( ) ; // Configure additional blockchain state parameters directly on the VM instance // This demonstrates how to set parameters after VM creation vm . set_block_number ( 12345678 ) ; // Note: The chain ID is set to 42161 (Arbitrum One) by default in the TestVM // We don't need to set it explicitly as it's already configured in the VM state // SECTION 2: Contract Initialization and User Setup // ------------------------------------------------ // Initialize our VendingMachine contract with the configured VM // The `from` method connects our contract to the test environment let mut contract = VendingMachine :: from ( & vm ) ; // Define a user address that will interact with our contract // This represents an external user's Ethereum address let user = address! ( \"0xCDC41bff86a62716f050622325CC17a317f99404\" ) ; // SECTION 3: Initial State Verification // ------------------------------------ // Verify the user starts with zero cupcakes // This confirms our contract's initial state is as expected assert_eq! ( contract . get_cupcake_balance_for ( user ) . unwrap ( ) , U256 :: ZERO ) ; // Set the initial block timestamp by advancing it by 10 seconds // This ensures we're past any time-based restrictions vm . set_block_timestamp ( vm . block_timestamp ( ) + 10 ) ; // SECTION 4: Contract Interaction // ------------------------------ // Give a cupcake to the user and verify the operation succeeds // The contract should return true when a cupcake is successfully given assert! ( contract . give_cupcake_to ( user ) . unwrap ( ) ) ; // Verify the user now has exactly one cupcake // This confirms our contract correctly updated its storage assert_eq! ( contract . get_cupcake_balance_for ( user ) . unwrap ( ) , U256 :: from ( 1 ) ) ; // SECTION 5: VM State Inspection // ----------------------------- // Take a snapshot of the current VM state for inspection // This captures all storage, balances, and blockchain parameters let snapshot = vm . snapshot ( ) ; // Inspect various aspects of the VM state to verify configuration // Chain ID should be Arbitrum One (42161) which is the default assert_eq! ( snapshot . chain_id , 42161 ) ; // Message value should match what we configured (1 wei) assert_eq! ( snapshot . msg_value , U256 :: from ( 1 ) ) ; // SECTION 6: Mocking External Contract Calls // ----------------------------------------- // Define an external contract we might want to interact with let external_contract = address! ( \"0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199\" ) ; // Define example call data we would send to that contract let call_data = vec! [ 0xab , 0xcd , 0xef ] ; // Define the expected response from that contract let expected_response = vec! [ 0x12 , 0x34 , 0x56 ] ; // Mock the external call so it returns our expected response // This allows testing contract interactions without deploying external contracts vm . mock_call ( external_contract , call_data , Ok ( expected_response ) ) ; // SECTION 7: Time-Dependent Behavior Testing // ----------------------------------------- // Set a specific block timestamp // This simulates the passage of time on the blockchain vm . set_block_timestamp ( 1006 ) ; // Try giving another cupcake after the time restriction has passed // The contract should allow this since enough time has elapsed assert! ( contract . give_cupcake_to ( user ) . unwrap ( ) ) ; // Verify the user now has two cupcakes // This confirms our contract correctly handles time-based restrictions assert_eq! ( contract . get_cupcake_balance_for ( user ) . unwrap ( ) , U256 :: from ( 2 ) ) ; } }\n\nHere is a cargo.toml file to add the required dependencies:\n\ncargo.toml\n\n[ package ] name = \"stylus-cupcake-example\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy - primitives = \"=0.8.20\" alloy - sol - types = \"=0.8.20\" mini - alloc = \"0.8.4\" stylus - sdk = \"0.8.4\" hex = \"0.4.3\" dotenv = \"0.15.0\" [ dev - dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" stylus - sdk = { version = \"0.8.4\" , features = [ \"stylus-test\" ] } alloy - primitives = { version = \"=0.8.20\" , features = [ \"sha3-keccak\" ] } [ features ] export - abi = [ \"stylus-sdk/export-abi\" ] debug = [ \"stylus-sdk/debug\" ] [ [ bin ] ] name = \"stylus-cupcake-example\" path = \"src/main.rs\" [ lib ] crate - type = [ \"lib\" , \"cdylib\" ] [ profile . release ] codegen - units = 1 strip = true lto = true panic = \"abort\" # If you need to reduce the binary size , it is advisable to try other # optimization levels , such as \"s\" and \"z\" opt - level = 3\n\nYou can find the example above in the stylus-quickstart-vending-machine git repository .\n\nRunning Tests ​\n\nTo run your tests, you can use the standard Rust test command:\n\ncargo test\n\nOr with the cargo-stylus CLI tool:\n\nTo run a specific test:\n\ncargo test test_give_cupcake\n\nTesting Best Practices ​\n\nTest Isolation Create a new TestVM instance for each test Avoid relying on state from previous tests Comprehensive Coverage Test both success and error conditions Test edge cases and boundary conditions Verify all public functions and important state transitions Clear Assertions Use descriptive error messages in assertions Make assertions that verify the actual behavior you care about Realistic Scenarios Test real-world usage patterns Include tests for authorization and access control Gas and Resource Efficiency For complex contracts, consider testing gas usage patterns Look for storage optimization opportunities\n\nTest Isolation\n\nCreate a new TestVM instance for each test Avoid relying on state from previous tests\n\nComprehensive Coverage\n\nTest both success and error conditions Test edge cases and boundary conditions Verify all public functions and important state transitions\n\nClear Assertions\n\nUse descriptive error messages in assertions Make assertions that verify the actual behavior you care about\n\nRealistic Scenarios\n\nTest real-world usage patterns Include tests for authorization and access control\n\nGas and Resource Efficiency\n\nFor complex contracts, consider testing gas usage patterns Look for storage optimization opportunities\n\nMigrating from Global Accessors to VM Accessors ​\n\nAs of Stylus SDK 0.8.0, there's a shift away from global host function invocations to using the .vm() method. This is a safer approach that makes testing easier. For example:\n\n// Old style (deprecated) let timestamp = block :: timestamp ( ) ; // New style (preferred) let timestamp = self . vm ( ) . block_timestamp ( ) ;\n\nTo make your contracts more testable, make sure they access host methods through the HostAccess trait with the .vm() method.",
    "metadata": {
      "category": "Rust CLI",
      "subsection": "Testing contracts"
    }
  },
  {
    "text": "How to verify contracts for Stylus contracts\n\nThis page will walk you through how to verify your Stylus contracts locally. Stylus contract verification is also available on Arbiscan . Please note, however, that Stylus contract verification on Arbiscan is only supported for Stylus contracts deployed using cargo-stylus 0.5.0 or higher.\n\nBackground ​\n\nStylus contracts written in Rust and deployed onchain can be verified against a local codebase by using the cargo stylus tool.\n\nGoals ​\n\nTo ensure Stylus contract deployments are reproducible by anyone who is running the same architecture as the deployed item To sandbox the reproducible environment and standardize it as much as possible to prevent foot guns To guarantee that programs reproducibly deployed with a cargo stylus version >= 0.4.2 are verifiable\n\nOpting out ​\n\nBy default, cargo stylus deploy is reproducible as it runs in a Docker container. Users can opt-out by specifying --no-verify as a flag.\n\nReproducible deployments ​\n\nRequired knowledge and setup:\n\nSystem architecture of your host computer (x86 / ARM) The git commit of your project used for deployment A Rust stylus project, such as OffchainLabs/stylus-hello-world which contains a rust-toolchain.toml file Your cargo stylus version (run cargo stylus --version to obtain this value) Docker installed and running on your machine\n\nYour project's toolchain file must contain the Rust version you wish to use for your deployment, such as major.minor.patch\n\n[toolchain] channel = \"1.79.0\"\n\nIt cannot be stable , nightly , or beta by itself, as a specific version must be added. For instance, you can specify nightly-YYYY-MM-DD or major.minor.patch for your channel. This is so that deployments have a very specific version to prevent potential mismatches from being more generic.\n\n# Replace {PRIV_KEY} with your actual private key or set it as a local variable cargo stylus deploy --private-key={PRIV_KEY} --verbose\n\nUpon completion, you will obtain the deployment transaction hash:\n\ndeployment tx hash: 0x1d8ae97e245e1db21dd188e5b64ad9025c1fb4e5f82a8d38bc8ae2b7a387600b\n\nSave this transaction hash, as verifiers will need it.\n\nReproducible verification ​\n\nTo verify a program, the verifier will need Docker installed and also know:\n\nSystem architecture the deployer used (x86 / ARM). Note: ARM devices that can emulate x86, such as Mac M series via Rosetta, can verify x86 Stylus deployments The git commit of the project the deployer used Your cargo stylus version the deployer used The deployment transaction hash\n\nNavigate to the project's directory and check out the git commit that was used at deployment. Ensure your cargo stylus --version matches what the deployer used.\n\n# Replace {DEPLOYMENT_TX_HASH} with the actual DEPLOYMENT_TX_HASH or set it as a local variable cargo stylus verify --deployment-tx={DEPLOYMENT_TX_HASH}\n\nThis command will run the verification pipeline through a Docker environment, recreate the project metadata hash, and verify that the deployed program matches what the command reconstructed locally.\n\nHow it works ​\n\nOn deployment, a keccak256 hash is created from the contents of all Rust source files in the project, sorted by file path, along with a rust-toolchain.toml, Cargo.toml and Cargo.lock files by default. This hash is injected in as a custom section of the user WASM's code. This means all data in the source files will be used for reproducible verification of a Stylus contract, including code comments.\n\nThis means the codehash onchain of the program will change due to this deployment metadata hash.\n\nThe verification routine fetches the deployment transaction by hash via RPC, then attempts to build the local project to reconstruct the deployment init code and WASM using cargo build. It then checks that the deployment transaction data matches the created init code.\n\nImportant details ​\n\nDocker image The docker container used for reproducibility standardizes all builds to x86, and it looks like this:\n\nFROM --platform = linux/amd64 rust:1.79 as builder RUN rustup toolchain install $VERSION -x86_64-unknown-linux-gnu RUN rustup default $VERSION -x86_64-unknown-linux-gnu RUN rustup target add wasm32-unknown-unknown RUN rustup target add wasm32-wasi RUN rustup target add x86_64-unknown-linux-gnu RUN cargo install cargo-stylus\n\nThe docker container uses the rust:1.79 version as a base for all projects. This will install cargo tooling and rust targets, but the toolchain actually used for compilation will be specified by the project being deployed in its rust-toolchain.toml file.\n\nFor instance, a future toolchain can be used despite the base image being 1.79, as when cargo stylus is installed, it will use that particular toolchain. Future cargo stylus updates could update this base image but may not impact the compiled WASM as the image will be using the specified toolchain. However, this is why knowing the specific cargo stylus version used for the reproducible verification from the deployer is important.\n\nThe build toolchain\n\nAll verifiable Stylus contracts in Rust must have a standard rust-toolchain.toml file which specifies the channel for their deployment. It cannot be stable , nightly , or beta by itself, as a specific version must be added. For instance, you can specify nightly-YYYY-MM-DD or major.minor.patch for your channel. This is so that deployments have a very specific version to prevent potential mismatches from being more generic.",
    "metadata": {
      "category": "Rust CLI",
      "subsection": "Verify contracts"
    }
  },
  {
    "text": "Caching contracts with Stylus\n\nStylus is designed for fast computation and efficiency. However,\nthe initialization process when entering a contract can be resource-intensive and time-consuming.\n\nThis initialization process, if repeated frequently, may lead to inefficiencies. To address this, we have implemented a caching strategy. By storing frequently accessed contracts in memory, we can avoid repeated initializations. This approach saves resources and time, significantly enhancing the speed and efficiency of contract execution.\n\nNote that Stylus smart contracts will need to be re-activated once per year (365 days) or\nwhenever a upgrade to Stylus (which will always involve an ArbOS upgrade), even if they are in the\ncache. This re-activation can be done using cargo-stylus , a cargo subcommand for building,\nverifying, and deploying Arbitrum Stylus WASM contracts in Rust.\n\nCacheManager contract ​\n\nThe core component of our caching strategy is the CacheManager contract . This smart contract manages the cache, interacts with precompiles, and determines which contracts should be cached. The CacheManager can hold approximately 4,000 contracts in memory.\n\nThe CacheManager defines how contracts remain in the cache and how they compete with other contracts for cache space. Its primary purpose is to reduce high initialization costs, ensuring efficient contract activation and usage. The contract includes methods for adding and removing cache entries, querying the status of cached contracts, and managing the lifecycle of cached data.\n\nKey features ​\n\nThe CacheManager plays a crucial role in our caching strategy by keeping a specific set of contracts in memory rather than retrieving them from disk. This significantly reduces the activation time for frequently accessed contracts. The CacheManager contract is an onchain contract that accepts bids for inserting contract code into the cache. It then calls a precompile that loads or unloads the contracts in the ArbOS cache, which follows the onchain cache but operates locally in the client and marks the contract as in or out of the cache in the ArbOS state.\n\nThe cache operates through an auction system where dApp developers submit bids to insert their contracts into the cache. If the cache is at capacity, lower bids are evicted to make space for higher bids. The cache maintains a minimum heap of bids for codeHashes , with bids encoded as bid << 64 + index , where index represents the position in the list of all bids. When an insertion exceeds the cache's maximum size, items are popped off the minimum heap and deleted until there is enough space to insert the new item. Contracts with equal bids will be popped in a random order, while the smallest bid is evicted first.\n\nTo ensure that developers periodically pay to maintain their position in the cache, we use a global decay parameter computed by decay = block.timestamp * _decay . This inflates the value of bids over time, making newer bids more valuable.\n\nCache access and costs ​\n\nDuring activation, we compute the contract's initialization costs for both non-cached and cached initialization. These costs take into account factors such as the number of functions, types, code size, data length, and memory usage. It's important to note that accessing an uncached contract does not automatically add it to the CacheManager 's cache. Only explicit calls to the CacheManager contract will add a contract to the cache. If a contract is removed from the cache, calling the contract becomes more expensive unless it is re-added.\n\nTo see how much gas contract initialization would cost, you need to call programInitGas(address) from the ArbWasm precompile . This function returns both the initialization cost when the contract is cached and when it is not.\n\nHow to use the CacheManager API ​\n\nThis section provides a practical guide for interacting with the CacheManager contract API, either directly or through the cargo stylus command-line tool.\n\nStep 1: Determine the minimum bid ​\n\nBefore placing a bid, it's important to know the minimum bid required to cache the Stylys contract. This can be done using the getMinBid function, or using the cargo stylus cache suggest-bid command.\n\nMethod 1: Direct smart contract call ​\n\nuint192 minBid = cacheManager . getMinBid ( contractAddress ) ;\n\nMethod 2: Cargo stylus command ​\n\nHere, the [ contractAddress ] is the address of the Stylus contract you want to cache.\n\ncargo stylus cache suggest-bid [ contractAddress ]\n\nStep 2: Place a bid ​\n\nYou can place a bid using either of the following methods:\n\nMethod 1: Direct smart contract call ​\n\nHere, bidAmount is the amount you want to bid, and contractAddress is the address of the Stylus contract you're bidding for.\n\ncacheManager . placeBid { value : bidAmount } ( contractAddress ) ;\n\nMethod 2: Cargo stylus command ​\n\nYou can place a bid using the cargo stylus cache bid command:\n\ncargo stylus cache bid < --private-key-path < PRIVATE_KEY_PATH >| --private-key < PRIVATE_KEY >| --keystore-path < KEYSTORE_PATH >> [ contractAddress ] [ bidAmount ]\n\n[contractAddress] : The address of the Stylus contract you want to cache. [bidAmount] : The amount you want to bid. If not specified, the default bid is 0.\n\nIf you specify a bid amount using cargo stylus , it will automatically validate that the bid is greater than or equal to the result of the getMinBid function. If the bid is insufficient, the command will fail, ensuring that only valid bids are placed.\n\nStep 3: Check cache status ​\n\nTo check if a specific address is cached, you can use the cargo stylus status command:\n\ncargo stylus cache status --address = [ contractAddress ]\n\nAdditional information ​\n\nPausing Bids : The CacheManager contract has an isPaused state that can be toggled by the owner to prevent or allow new bids. Checking Cache Size : You can monitor the current cache size and decay rate using the getCacheSize and getDecayRate functions respectively.\n\nBy following these steps, you can effectively interact with the CacheManager contract, either directly through smart contract calls or using the cargo stylus command-line tool. This ensures that your bids meet the necessary requirements for caching programs on the network, optimizing your contracts for faster and more efficient execution.",
    "metadata": {
      "category": "Rust CLI",
      "subsection": "Cache contracts"
    }
  },
  {
    "text": "How to verify Stylus contracts on Arbiscan\n\nThis how-to will show you how to verify deployed contracts using Arbiscan, Arbitrum's block explorer.\n\nHere's an example of a verified contract: the English Auction Stylus contract , which has been verified on Arbitrum Sepolia. You can view the verified contract here .\n\nYou can also see a list of all Stylus contracts verified on Arbiscan by visiting:\n\nVerified Stylus Contracts on Arbitrum One . Verified Stylus Contracts on Arbitrum Sepolia .\n\nHere are the steps to take to verify a contract on Arbiscan:\n\nStep 1: Navigate to the verification page ​\n\nYou have two options to access the contract verification page on Arbiscan:\n\nDirect link: Visit Arbiscan Verify Contract to go directly to the verification form. This option is ideal if you already have the contract address and details ready. From the contract page: If you're viewing the contract's page on Arbiscan: Go to the Contract tab. Click on Verify and Publish .\n\nGo to the Contract tab. Click on Verify and Publish .\n\nBoth methods will take you to the contract verification form, where you can proceed to the next step.\n\nStep 2: Enter the contract's details ​\n\nYou will need to fill in the following fields on the contract verification page:\n\nContract address : Enter the contract address you want to verify. Compiler type : Select Stylus for Stylus contracts. Compiler version : Choose the cargo stylus version that was used to deploy the contract. Open source license type : Select the appropriate license for your contract.\n\nStep 3: Submit source code ​\n\nAfter entering the contract details, you’ll need to provide the contract's source code:\n\nManual submission : Copy and paste the source code into the provided text box. Fetch from GitHub (Recommended) : It's recommended to use the Fetch from Git option, as it's easier and helps automate the process. However, note that contracts located in subdirectories of the repository cannot be verified. Ensure that the contract's code is placed directly in the repository's root for verification to succeed.\n\nStep 4: Set EVM version ​\n\nThe EVM Version to Target can be left as default unless specific requirements dictate otherwise.\n\nStep 5: Verify and publish ​\n\nClick Verify and Publish . The verification process will take a few seconds. Refresh the contract page, and if successful, the contract will be marked as verified.\n\nBehavior when deploying a verified contract ​\n\nWhen deploying another instance of a previously verified contract, if the bytecode matches, Arbiscan will automatically link the new instance to the verified source code, displaying a message like:\n\n\"This contract matches the deployed Bytecode of the Source Code for Contract [verified contract address].\"\n\nHowever, the new contract will still appear as \"Not Verified\" until you explicitly verify it.",
    "metadata": {
      "category": "Rust CLI",
      "subsection": "Verify on Arbiscan"
    }
  },
  {
    "text": "How to optimize Stylus WASM binaries\n\nTo be deployed onchain, the size of your uncompressed WebAssembly (WASM) file must not exceed 128Kb, while the compressed binary must not exceed 24KB. Stylus conforms with the same contract size limit as the EVM to remain fully interoperable with all smart contracts on Arbitrum chains.\n\ncargo-stylus , the Stylus CLI tool, automatically compresses your WASM programs, but there are additional steps that you can take to further reduce the size of your binaries.\n\nYour options fall into two categories: Rust compiler flags, and third-party optimization tools.\n\nRust compiler flags ​\n\nThe Rust compiler supports various config options for shrinking binary sizes.\n\nCargo.toml ​\n\n[ profile.release ] codegen-units = 1 # prefer efficiency to compile time panic = \"abort\" # use simple panics opt-level = \"z\" # optimize for size (\"s\" may also work) strip = true # remove debug info lto = true # link time optimization debug = false # no debug data rpath = false # no run-time search path debug-assertions = false # prune debug assertions incremental = false # no incremental builds\n\nThird-party optimization tooling ​\n\nAdditional WASM-specific tooling exists to shrink binaries. Due to being third party, users should use these at their own risk.\n\nwasm-opt ​\n\nwasm-opt applies techniques to further reduce binary size, usually netting around 10%.\n\ntwiggy ​\n\ntwiggy is a code size profiler for WASM, it can help you estimate the impact of each added component on your binaries' size.\n\nOur team has also curated a list of recommended libraries that are helpful to Stylus development and optimally sized.\n\nFrequently asked questions ​\n\nYes! We're actively working on improving WASM sizes generated by Rust code with the Stylus SDK.\n\nOn modern platforms, tools like cargo don’t have to worry about the size of the binaries they produce. This is because there’s many orders of magnitude more storage available than even the largest of binaries, and for most applications it’s media like images and videos that constitutes the majority of the footprint.\n\nResource constraints when building on blockchains are extremely strict. Hence, while not the default option, tooling often provides mechanisms for reducing binary bloat, such as the options outlined in this document.",
    "metadata": {
      "category": "Rust CLI",
      "subsection": "Optimize WASM binaries"
    }
  },
  {
    "text": "Architecture overview\n\nThere are four main steps for bringing a Stylus program to life: coding, activation, execution, and proving .\n\nCoding ​\n\nDevelopers can now write smart contracts in any programming language that compiles to WASM.\n\nSome high-level languages generate far more performant WASMs than others.\n\nCurrently, there is support for Rust, C, and C++. However, the levels of support vary. Rust has rich language support from day one, with an open-source SDK that makes writing smart contracts in Rust as easy as possible. C and C++ are supported off the bat, enabling the deployment of existing contracts in those languages onchain with minimal modifications.\n\nThe Stylus SDK for Rust contains the smart contract development framework and language features most developers will need to use in Stylus. The SDK also makes it possible to perform all EVM-specific functionalities that smart contract developers use. Check out the Rust SDK Guide and the Crate Docs .\n\nActivation ​\n\nStarting from a high-level language (such as Rust, C, or C++), the first compilation stage happens using the CLI provided in the Stylus SDK for Rust or any other compiler, such as Clang for C and C++. Once compiled, the WASM is posted onchain. Then, in an activation process, WASM gets lowered to a node's native machine code (such as ARM or x86).\n\nActivating a Stylus program requires a new precompile, ArbWasm. This precompile produces efficient binary code tailored to a node's native assembly. During this step, a series of middlewares ensure that user programs execute safely and are deterministically fraud-proven. Instrumentation includes gas metering, depth-checking, memory charging, and more to guarantee all WASM programs are safe for the chain to execute. Stylus contracts can be called only after activation.\n\nGas metering is essential for certifying that computational resources are paid for. In Stylus, the unit for measuring cost is called ink , which is similar to Ethereum's gas but thousands of times smaller. There are two reasons why a new measurement is used: First, WASM execution is so much faster than the EVM that executing thousands of WASM opcodes could be done in the same amount of time it takes the EVM to execute one. Second, the conversion rate of ink to gas can change based on future hardware or VM improvements. For a conceptual introduction to Stylus gas and ink, see gas and ink (Stylus) .\n\nExecution ​\n\nStylus programs execute in a fork of Wasmer , the leading WebAssembly runtime, with minimal changes to optimize their codebase for blockchain-specific use cases. Wasmer executes native code much faster than Geth executes EVM bytecode, contributing to the significant gas savings that Stylus provides.\n\nEVM contracts continue to execute the same way they were before Stylus. When calling a contract, the difference between an EVM contract and a WASM program is visible via an EOF -inspired contract header. From there, the contract executes using its corresponding runtime. Contracts written in Solidity and WASM languages can make cross-contract calls to each other, meaning a developer never has to consider which language the contract is in. Everything is interoperable.\n\nProving ​\n\nNitro operates in two modes: a \"happy case\" where it compiles execution history to native code, and a \"sad case\" during validator disputes, where it compiles execution history to WASM for interactive fraud proofs on Ethereum. Stylus builds on Nitro's fraud-proving technology, allowing it to verify both execution history and WASM programs deployed by developers.\n\nStylus is made possible by Nitro’s ability to replay and verify disputes using WASM. Validators bisect disputes until an invalid step is identified and proven onchain through a “one-step proof.” . This deterministic fraud-proving capability ensures the correctness of any arbitrary program compiled to WASM. The combination of WASM's and Nitro's properties enables this technological leap we call Stylus.\n\nFor more details on Nitro’s architecture, refer to the documentation or the Nitro whitepaper .\n\nWhy does this matter? ​\n\nStylus innovates on many levels, with the key ones described here:\n\nOne chain, many languages ​\n\nThere are roughly 20k Solidity developers, compared to three million Rust developers or 12 million C developers [ 1 ]. Developers can now use their preferred programming language, which is interoperable on any Arbitrum chain with Stylus. By onboarding the next million developers, scaling to the next billion users becomes possible.\n\nA better EVM ​\n\nStylus' MultiVM brings the best of both worlds. Developers still get all of the benefits of the EVM, including the ecosystem and liquidity, while getting efficiency improvements and access to existing libraries in Rust, C, and C++, all without changing anything about how the EVM works. EVM equivalence is no longer the ceiling; it's the floor.\n\nCheaper execution ​\n\nStylus is a more efficient execution environment than the EVM, leading directly to gas savings for complex smart contracts. Computation and memory can be significantly cheaper. Deploying cryptography libraries can be done permissionlessly as custom application layer precompiles. Use cases that are impractical in the EVM are now possible in Stylus.\n\nOpt-in reentrancy ​\n\nStylus doesn't just improve on cost and speed. WASM programs are also safer. Reentrancy is a common vulnerability developers can only attempt to mitigate in Solidity. Stylus provides cheap reentrancy detection, and using the Rust SDK, reentrancy is disabled by default unless intentionally overridden.\n\nFully interoperable ​\n\nSolidity programs and WASM programs are completely composable. If working in Solidity, a developer can call a Rust program or rely on another dependency in a different language. If working in Rust, all Solidity functionalities are accessible out of the box.",
    "metadata": {
      "category": "Concepts",
      "subsection": "Architecture overview"
    }
  },
  {
    "text": "Gas metering\n\nGas and ink are the pricing primitives that are used to determine the cost of handling specific opcodes and host I/Os on Stylus. For an overview of specific opcode and host I/O costs, see Gas and ink costs .\n\nStylus gas costs ​\n\nStylus introduces new pricing models for WASM programs. Intended for high-compute applications, Stylus makes the following more affordable:\n\nCompute, which is generally 10-100x cheaper depending on the program. This is primarily due to the efficiency of the WASM runtime relative to the EVM, and the quality of the code produced by Rust, C, and C++ compilers. Another factor that matters is the quality of the code itself. For example, highly optimized and audited C libraries that implement a particular cryptographic operation are usually deployable without modification and perform exceptionally well. The fee reduction may be smaller for highly optimized Solidity that makes heavy use of native precompiles vs. an unoptimized Stylus equivalent that doesn't do the same. Memory, which is 100-500x cheaper due to Stylus's novel exponential pricing mechanism intended to address Vitalik's concerns with the EVM's per-call, quadratic memory pricing policy . For the first time ever, high-memory applications are possible on an EVM-equivalent chain. Storage, for which the Rust SDK promotes better access patterns and type choices. Note that while the underlying SLOAD and SSTORE operations cost as they do in the EVM, the Rust SDK implements an optimal caching policy that minimizes their use. Exact savings depends on the program. VM affordances, including common operations like keccak and reentrancy detection. No longer is it expensive to make safety the default.\n\nThere are, however, minor overheads to using Stylus that may matter to your application:\n\nThe first time a WASM is deployed, it must be activated . This is generally a few million gas, though to avoid testnet DoS, we've set it to a fixed 14 million. Note that you do not have to activate future copies of the same program. For example, the same NFT template can be deployed many times without paying this cost more than once. We will soon make the fees paid depend on the program, so that the gas used is based on the complexity of the WASM instead of this very conservative, worst-case estimate. Calling a Stylus contract costs 128-2048 gas. We're working with Wasmer to improve setup costs, but there will likely always be some amount of gas one pays to jump into WASM execution. This means that if a contract does next to nothing, it may be cheaper in Solidity. However if a contract starts doing interesting work, the dynamic fees will quickly make up for this fixed-cost overhead.\n\nThough conservative bounds have been chosen for testnet, all of this is subject to change as pricing models mature and further optimizations are made. Since gas numbers will vary across updates, it may make more sense to clock the time it takes to perform an operation rather than going solely by the numbers reported in receipts.\n\nInk and gas ​\n\nBecause WASM opcodes are orders of magnitude faster than their EVM counterparts, almost every operation that Stylus does costs less than 1 gas . “Fractional gas” isn’t an EVM concept, so the Stylus VM introduces a new unit of payment known as ink that’s orders of magnitude smaller.\n\n1 gas = 10 , 000 ink\n\nIntuition ​\n\nTo build intuition for why this is the case, consider the ADD instruction.\n\nPay for gas, requiring multiple look-ups of an in-memory table Consider tracing, even if disabled Pop two items of the simulated stack Add them together Push the result\n\nExecute a single x86 or ARM ADD instruction\n\nNote that unlike the EVM, which charges for gas before running each opcode, the Stylus VM strategically charges for many opcodes all at once. This cuts fees considerably, since the VM only rarely needs to execute gas charging logic. Additionally, gas charging happens inside the program , removing the need for an in-memory table.\n\nThe ink price ​\n\nThe ink price, which measures the amount of ink a single EVM gas buys, is configurable by the chain owner. By default, the exchange rate is 1:10000 , but this may be adjusted as the EVM and Stylus VM improve over time.\n\nFor example, if the Stylus VM becomes 2x faster, instead of cutting the nominal cost of each operation, the ink price may instead be halved, allowing 1 EVM gas to buy twice as much ink. This provides an elegant mechanism for smoothly repricing resources between the two VMs as each makes independent progress.\n\nUser experience ​\n\nIt is important to note that users never need to worry about this notion of ink. Receipts will always be measured in gas, with the exchange rate applied automatically under the hood as the VMs pass execution back and forth.\n\nHowever, developers optimizing contracts may choose to measure performance in ink to pin down the exact cost of executing various routines. The ink_left function exposes this value, and various methods throughout the Rust SDK optionally accept ink amounts too.\n\nSee also ​\n\nGas and ink costs : Detailed costs per opcode and host I/O Caching strategy : Description of the Stylus caching strategy and the CacheManager contract",
    "metadata": {
      "category": "Concepts",
      "subsection": "Gas metering"
    }
  },
  {
    "text": "ERC-20\n\nAny contract that follows the ERC-20 standard is an ERC-20 token.\n\nERC-20 tokens provide functionalities to\n\ntransfer tokens allow others to transfer tokens on behalf of the token holder\n\nHere is the interface for ERC-20.\n\ninterface IERC20 { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address account ) external view returns ( uint256 ) ; function transfer ( address recipient , uint256 amount ) external returns ( bool ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function approve ( address spender , uint256 amount ) external returns ( bool ) ; function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) ; }\n\nExample implementation of an ERC-20 token contract written in Rust.\n\nsrc/erc20.rs ​\n\nThis code has yet to be audited. Please use at your own risk.\n\n//! Implementation of the ERC-20 standard //! //! The eponymous [`Erc20`] type provides all the standard methods, //! and is intended to be inherited by other contract types. //! //! You can configure the behavior of [`Erc20`] via the [`Erc20Params`] trait, //! which allows specifying the name, symbol, and decimals of the token. //! //! Note that this code is unaudited and not fit for production use. // Imported packages use alloc :: string :: String ; use alloy_primitives :: { Address , U256 } ; use alloy_sol_types :: sol ; use core :: marker :: PhantomData ; use stylus_sdk :: { evm , msg , prelude :: * , } ; pub trait Erc20Params { /// Immutable token name const NAME : & 'static str ; /// Immutable token symbol const SYMBOL : & 'static str ; /// Immutable token decimals const DECIMALS : u8 ; } sol_storage! { /// Erc20 implements all ERC-20 methods. pub struct Erc20 < T > { /// Maps users to balances mapping ( address => uint256 ) balances ; /// Maps users to a mapping of each spender's allowance mapping ( address => mapping ( address => uint256 ) ) allowances ; /// The total supply of the token uint256 total_supply ; /// Used to allow [`Erc20Params`] PhantomData < T > phantom ; } } // Declare events and Solidity error types sol! { event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; error InsufficientBalance ( address from , uint256 have , uint256 want ) ; error InsufficientAllowance ( address owner , address spender , uint256 have , uint256 want ) ; } /// Represents the ways methods may fail. #[derive(SolidityError)] pub enum Erc20Error { InsufficientBalance ( InsufficientBalance ) , InsufficientAllowance ( InsufficientAllowance ) , } // These methods aren't exposed to other contracts // Methods marked as \"pub\" here are usable outside of the erc20 module (i.e. they're callable from lib.rs) // Note: modifying storage will become much prettier soon impl < T : Erc20Params > Erc20 < T > { /// Movement of funds between 2 accounts /// (invoked by the external transfer() and transfer_from() functions ) pub fn _transfer ( & mut self , from : Address , to : Address , value : U256 , ) -> Result < ( ) , Erc20Error > { // Decreasing sender balance let mut sender_balance = self . balances . setter ( from ) ; let old_sender_balance = sender_balance . get ( ) ; if old_sender_balance < value { return Err ( Erc20Error :: InsufficientBalance ( InsufficientBalance { from , have : old_sender_balance , want : value , } ) ) ; } sender_balance . set ( old_sender_balance - value ) ; // Increasing receiver balance let mut to_balance = self . balances . setter ( to ) ; let new_to_balance = to_balance . get ( ) + value ; to_balance . set ( new_to_balance ) ; // Emitting the transfer event evm :: log ( Transfer { from , to , value } ) ; Ok ( ( ) ) } /// Mints `value` tokens to `address` pub fn mint ( & mut self , address : Address , value : U256 ) -> Result < ( ) , Erc20Error > { // Increasing balance let mut balance = self . balances . setter ( address ) ; let new_balance = balance . get ( ) + value ; balance . set ( new_balance ) ; // Increasing total supply self . total_supply . set ( self . total_supply . get ( ) + value ) ; // Emitting the transfer event evm :: log ( Transfer { from : Address :: ZERO , to : address , value , } ) ; Ok ( ( ) ) } /// Burns `value` tokens from `address` pub fn burn ( & mut self , address : Address , value : U256 ) -> Result < ( ) , Erc20Error > { // Decreasing balance let mut balance = self . balances . setter ( address ) ; let old_balance = balance . get ( ) ; if old_balance < value { return Err ( Erc20Error :: InsufficientBalance ( InsufficientBalance { from : address , have : old_balance , want : value , } ) ) ; } balance . set ( old_balance - value ) ; // Decreasing the total supply self . total_supply . set ( self . total_supply . get ( ) - value ) ; // Emitting the transfer event evm :: log ( Transfer { from : address , to : Address :: ZERO , value , } ) ; Ok ( ( ) ) } } // These methods are external to other contracts // Note: modifying storage will become much prettier soon #[public] impl < T : Erc20Params > Erc20 < T > { /// Immutable token name pub fn name ( ) -> String { T :: NAME . into ( ) } /// Immutable token symbol pub fn symbol ( ) -> String { T :: SYMBOL . into ( ) } /// Immutable token decimals pub fn decimals ( ) -> u8 { T :: DECIMALS } /// Total supply of tokens pub fn total_supply ( & self ) -> U256 { self . total_supply . get ( ) } /// Balance of `address` pub fn balance_of ( & self , owner : Address ) -> U256 { self . balances . get ( owner ) } /// Transfers `value` tokens from msg::sender() to `to` pub fn transfer ( & mut self , to : Address , value : U256 ) -> Result < bool , Erc20Error > { self . _transfer ( msg :: sender ( ) , to , value ) ? ; Ok ( true ) } /// Transfers `value` tokens from `from` to `to` /// (msg::sender() must be able to spend at least `value` tokens from `from`) pub fn transfer_from ( & mut self , from : Address , to : Address , value : U256 , ) -> Result < bool , Erc20Error > { // Check msg::sender() allowance let mut sender_allowances = self . allowances . setter ( from ) ; let mut allowance = sender_allowances . setter ( msg :: sender ( ) ) ; let old_allowance = allowance . get ( ) ; if old_allowance < value { return Err ( Erc20Error :: InsufficientAllowance ( InsufficientAllowance { owner : from , spender : msg :: sender ( ) , have : old_allowance , want : value , } ) ) ; } // Decreases allowance allowance . set ( old_allowance - value ) ; // Calls the internal transfer function self . _transfer ( from , to , value ) ? ; Ok ( true ) } /// Approves the spenditure of `value` tokens of msg::sender() to `spender` pub fn approve ( & mut self , spender : Address , value : U256 ) -> bool { self . allowances . setter ( msg :: sender ( ) ) . insert ( spender , value ) ; evm :: log ( Approval { owner : msg :: sender ( ) , spender , value , } ) ; true } /// Returns the allowance of `spender` on `owner`'s tokens pub fn allowance ( & self , owner : Address , spender : Address ) -> U256 { self . allowances . getter ( owner ) . get ( spender ) } }\n\nlib.rs ​\n\n// Only run this as a WASM if the export-abi feature is not set. #![cfg_attr(not(any(feature = \"export-abi\" , test)), no_main)] extern crate alloc ; // Modules and imports mod erc20 ; use alloy_primitives :: { Address , U256 } ; use stylus_sdk :: { msg , prelude :: * } ; use crate :: erc20 :: { Erc20 , Erc20Params , Erc20Error } ; /// Immutable definitions struct StylusTokenParams ; impl Erc20Params for StylusTokenParams { const NAME : & 'static str = \"StylusToken\" ; const SYMBOL : & 'static str = \"STK\" ; const DECIMALS : u8 = 18 ; } // Define the entrypoint as a Solidity storage object. The sol_storage! macro // will generate Rust-equivalent structs with all fields mapped to Solidity-equivalent // storage slots and types. sol_storage! { #[entrypoint] struct StylusToken { // Allows erc20 to access StylusToken's storage and make calls #[borrow] Erc20 < StylusTokenParams > erc20 ; } } #[public] #[inherit(Erc20<StylusTokenParams>)] impl StylusToken { /// Mints tokens pub fn mint ( & mut self , value : U256 ) -> Result < ( ) , Erc20Error > { self . erc20 . mint ( msg :: sender ( ) , value ) ? ; Ok ( ( ) ) } /// Mints tokens to another address pub fn mint_to ( & mut self , to : Address , value : U256 ) -> Result < ( ) , Erc20Error > { self . erc20 . mint ( to , value ) ? ; Ok ( ( ) ) } /// Burns tokens pub fn burn ( & mut self , value : U256 ) -> Result < ( ) , Erc20Error > { self . erc20 . burn ( msg :: sender ( ) , value ) ? ; Ok ( ( ) ) } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus_erc20_example\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Examples",
      "subsection": "Erc20"
    }
  },
  {
    "text": "ERC-721\n\nAny contract that follows the ERC-721 standard is an ERC-721 token.\n\nHere is the interface for ERC-721.\n\ninterface ERC721 { event Transfer ( address indexed _from , address indexed _to , uint256 indexed _tokenId ) ; event Approval ( address indexed _owner , address indexed _approved , uint256 indexed _tokenId ) ; event ApprovalForAll ( address indexed _owner , address indexed _operator , bool _approved ) ; function balanceOf ( address _owner ) external view returns ( uint256 ) ; function ownerOf ( uint256 _tokenId ) external view returns ( address ) ; function safeTransferFrom ( address _from , address _to , uint256 _tokenId , bytes data ) external payable ; function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable ; function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable ; function approve ( address _approved , uint256 _tokenId ) external payable ; function setApprovalForAll ( address _operator , bool _approved ) external ; function getApproved ( uint256 _tokenId ) external view returns ( address ) ; function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) ; }\n\nExample implementation of an ERC-721 token contract written in Rust.\n\nsrc/erc721.rs ​\n\nThis code has yet to be audited. Please use at your own risk.\n\n//! Implementation of the ERC-721 standard //! //! The eponymous [`Erc721`] type provides all the standard methods, //! and is intended to be inherited by other contract types. //! //! You can configure the behavior of [`Erc721`] via the [`Erc721Params`] trait, //! which allows specifying the name, symbol, and token uri. //! //! Note that this code is unaudited and not fit for production use. use alloc :: { string :: String , vec , vec :: Vec } ; use alloy_primitives :: { Address , U256 , FixedBytes } ; use alloy_sol_types :: sol ; use core :: { borrow :: BorrowMut , marker :: PhantomData } ; use stylus_sdk :: { abi :: Bytes , evm , msg , prelude :: * } ; pub trait Erc721Params { /// Immutable NFT name. const NAME : & 'static str ; /// Immutable NFT symbol. const SYMBOL : & 'static str ; /// The NFT's Uniform Resource Identifier. fn token_uri ( token_id : U256 ) -> String ; } sol_storage! { /// Erc721 implements all ERC-721 methods pub struct Erc721 < T : Erc721Params > { /// Token id to owner map mapping ( uint256 => address ) owners ; /// User to balance map mapping ( address => uint256 ) balances ; /// Token id to approved user map mapping ( uint256 => address ) token_approvals ; /// User to operator map (the operator can manage all NFTs of the owner) mapping ( address => mapping ( address => bool ) ) operator_approvals ; /// Total supply uint256 total_supply ; /// Used to allow [`Erc721Params`] PhantomData < T > phantom ; } } // Declare events and Solidity error types sol! { event Transfer ( address indexed from , address indexed to , uint256 indexed token_id ) ; event Approval ( address indexed owner , address indexed approved , uint256 indexed token_id ) ; event ApprovalForAll ( address indexed owner , address indexed operator , bool approved ) ; // Token id has not been minted, or it has been burned error InvalidTokenId ( uint256 token_id ) ; // The specified address is not the owner of the specified token id error NotOwner ( address from , uint256 token_id , address real_owner ) ; // The specified address does not have allowance to spend the specified token id error NotApproved ( address owner , address spender , uint256 token_id ) ; // Attempt to transfer token id to the Zero address error TransferToZero ( uint256 token_id ) ; // The receiver address refused to receive the specified token id error ReceiverRefused ( address receiver , uint256 token_id , bytes4 returned ) ; } /// Represents the ways methods may fail. #[derive(SolidityError)] pub enum Erc721Error { InvalidTokenId ( InvalidTokenId ) , NotOwner ( NotOwner ) , NotApproved ( NotApproved ) , TransferToZero ( TransferToZero ) , ReceiverRefused ( ReceiverRefused ) , } // External interfaces sol_interface! { /// Allows calls to the `onERC721Received` method of other contracts implementing `IERC721TokenReceiver`. interface IERC721TokenReceiver { function onERC721Received ( address operator , address from , uint256 token_id , bytes data ) external returns ( bytes4 ) ; } } /// Selector for `onERC721Received`, which is returned by contracts implementing `IERC721TokenReceiver`. const ERC721_TOKEN_RECEIVER_ID : u32 = 0x150b7a02 ; // These methods aren't external, but are helpers used by external methods. // Methods marked as \"pub\" here are usable outside of the erc721 module (i.e. they're callable from lib.rs). impl < T : Erc721Params > Erc721 < T > { /// Requires that msg::sender() is authorized to spend a given token fn require_authorized_to_spend ( & self , from : Address , token_id : U256 ) -> Result < ( ) , Erc721Error > { // `from` must be the owner of the token_id let owner = self . owner_of ( token_id ) ? ; if from != owner { return Err ( Erc721Error :: NotOwner ( NotOwner { from , token_id , real_owner : owner , } ) ) ; } // caller is the owner if msg :: sender ( ) == owner { return Ok ( ( ) ) ; } // caller is an operator for the owner (can manage their tokens) if self . operator_approvals . getter ( owner ) . get ( msg :: sender ( ) ) { return Ok ( ( ) ) ; } // caller is approved to manage this token_id if msg :: sender ( ) == self . token_approvals . get ( token_id ) { return Ok ( ( ) ) ; } // otherwise, caller is not allowed to manage this token_id Err ( Erc721Error :: NotApproved ( NotApproved { owner , spender : msg :: sender ( ) , token_id , } ) ) } /// Transfers `token_id` from `from` to `to`. /// This function does check that `from` is the owner of the token, but it does not check /// that `to` is not the zero address, as this function is usable for burning. pub fn transfer ( & mut self , token_id : U256 , from : Address , to : Address ) -> Result < ( ) , Erc721Error > { let mut owner = self . owners . setter ( token_id ) ; let previous_owner = owner . get ( ) ; if previous_owner != from { return Err ( Erc721Error :: NotOwner ( NotOwner { from , token_id , real_owner : previous_owner , } ) ) ; } owner . set ( to ) ; // right now working with storage can be verbose, but this will change upcoming version of the Stylus SDK let mut from_balance = self . balances . setter ( from ) ; let balance = from_balance . get ( ) - U256 :: from ( 1 ) ; from_balance . set ( balance ) ; let mut to_balance = self . balances . setter ( to ) ; let balance = to_balance . get ( ) + U256 :: from ( 1 ) ; to_balance . set ( balance ) ; // cleaning app the approved mapping for this token self . token_approvals . delete ( token_id ) ; evm :: log ( Transfer { from , to , token_id } ) ; Ok ( ( ) ) } /// Calls `onERC721Received` on the `to` address if it is a contract. /// Otherwise it does nothing fn call_receiver < S : TopLevelStorage > ( storage : & mut S , token_id : U256 , from : Address , to : Address , data : Vec < u8 > , ) -> Result < ( ) , Erc721Error > { if to . has_code ( ) { let receiver = IERC721TokenReceiver :: new ( to ) ; let received = receiver . on_erc_721_received ( & mut * storage , msg :: sender ( ) , from , token_id , data . into ( ) ) . map_err ( | _e | Erc721Error :: ReceiverRefused ( ReceiverRefused { receiver : receiver . address , token_id , returned : alloy_primitives :: FixedBytes ( 0_u32 . to_be_bytes ( ) ) , } ) ) ? . 0 ; if u32 :: from_be_bytes ( received ) != ERC721_TOKEN_RECEIVER_ID { return Err ( Erc721Error :: ReceiverRefused ( ReceiverRefused { receiver : receiver . address , token_id , returned : alloy_primitives :: FixedBytes ( received ) , } ) ) ; } } Ok ( ( ) ) } /// Transfers and calls `onERC721Received` pub fn safe_transfer < S : TopLevelStorage + BorrowMut < Self >> ( storage : & mut S , token_id : U256 , from : Address , to : Address , data : Vec < u8 > , ) -> Result < ( ) , Erc721Error > { storage . borrow_mut ( ) . transfer ( token_id , from , to ) ? ; Self :: call_receiver ( storage , token_id , from , to , data ) } /// Mints a new token and transfers it to `to` pub fn mint ( & mut self , to : Address ) -> Result < ( ) , Erc721Error > { let new_token_id = self . total_supply . get ( ) ; self . total_supply . set ( new_token_id + U256 :: from ( 1u8 ) ) ; self . transfer ( new_token_id , Address :: default ( ) , to ) ? ; Ok ( ( ) ) } /// Burns the token `token_id` from `from` /// Note that total_supply is not reduced since it's used to calculate the next token_id to mint pub fn burn ( & mut self , from : Address , token_id : U256 ) -> Result < ( ) , Erc721Error > { self . transfer ( token_id , from , Address :: default ( ) ) ? ; Ok ( ( ) ) } } // these methods are external to other contracts #[public] impl < T : Erc721Params > Erc721 < T > { /// Immutable NFT name. pub fn name ( ) -> Result < String , Erc721Error > { Ok ( T :: NAME . into ( ) ) } /// Immutable NFT symbol. pub fn symbol ( ) -> Result < String , Erc721Error > { Ok ( T :: SYMBOL . into ( ) ) } /// The NFT's Uniform Resource Identifier. #[selector(name = \"tokenURI\" )] pub fn token_uri ( & self , token_id : U256 ) -> Result < String , Erc721Error > { self . owner_of ( token_id ) ? ; // require NFT exist Ok ( T :: token_uri ( token_id ) ) } /// Gets the number of NFTs owned by an account. pub fn balance_of ( & self , owner : Address ) -> Result < U256 , Erc721Error > { Ok ( self . balances . get ( owner ) ) } /// Gets the owner of the NFT, if it exists. pub fn owner_of ( & self , token_id : U256 ) -> Result < Address , Erc721Error > { let owner = self . owners . get ( token_id ) ; if owner . is_zero ( ) { return Err ( Erc721Error :: InvalidTokenId ( InvalidTokenId { token_id } ) ) ; } Ok ( owner ) } /// Transfers an NFT, but only after checking the `to` address can receive the NFT. /// It includes additional data for the receiver. #[selector(name = \"safeTransferFrom\" )] pub fn safe_transfer_from_with_data < S : TopLevelStorage + BorrowMut < Self >> ( storage : & mut S , from : Address , to : Address , token_id : U256 , data : Bytes , ) -> Result < ( ) , Erc721Error > { if to . is_zero ( ) { return Err ( Erc721Error :: TransferToZero ( TransferToZero { token_id } ) ) ; } storage . borrow_mut ( ) . require_authorized_to_spend ( from , token_id ) ? ; Self :: safe_transfer ( storage , token_id , from , to , data .0 ) } /// Equivalent to [`safe_transfer_from_with_data`], but without the additional data. /// /// Note: because Rust doesn't allow multiple methods with the same name, /// we use the `#[selector]` macro attribute to simulate solidity overloading. #[selector(name = \"safeTransferFrom\" )] pub fn safe_transfer_from < S : TopLevelStorage + BorrowMut < Self >> ( storage : & mut S , from : Address , to : Address , token_id : U256 , ) -> Result < ( ) , Erc721Error > { Self :: safe_transfer_from_with_data ( storage , from , to , token_id , Bytes ( vec! [ ] ) ) } /// Transfers the NFT. pub fn transfer_from ( & mut self , from : Address , to : Address , token_id : U256 ) -> Result < ( ) , Erc721Error > { if to . is_zero ( ) { return Err ( Erc721Error :: TransferToZero ( TransferToZero { token_id } ) ) ; } self . require_authorized_to_spend ( from , token_id ) ? ; self . transfer ( token_id , from , to ) ? ; Ok ( ( ) ) } /// Grants an account the ability to manage the sender's NFT. pub fn approve ( & mut self , approved : Address , token_id : U256 ) -> Result < ( ) , Erc721Error > { let owner = self . owner_of ( token_id ) ? ; // require authorization if msg :: sender ( ) != owner && ! self . operator_approvals . getter ( owner ) . get ( msg :: sender ( ) ) { return Err ( Erc721Error :: NotApproved ( NotApproved { owner , spender : msg :: sender ( ) , token_id , } ) ) ; } self . token_approvals . insert ( token_id , approved ) ; evm :: log ( Approval { approved , owner , token_id , } ) ; Ok ( ( ) ) } /// Grants an account the ability to manage all of the sender's NFTs. pub fn set_approval_for_all ( & mut self , operator : Address , approved : bool ) -> Result < ( ) , Erc721Error > { let owner = msg :: sender ( ) ; self . operator_approvals . setter ( owner ) . insert ( operator , approved ) ; evm :: log ( ApprovalForAll { owner , operator , approved , } ) ; Ok ( ( ) ) } /// Gets the account managing an NFT, or zero if unmanaged. pub fn get_approved ( & mut self , token_id : U256 ) -> Result < Address , Erc721Error > { Ok ( self . token_approvals . get ( token_id ) ) } /// Determines if an account has been authorized to managing all of a user's NFTs. pub fn is_approved_for_all ( & mut self , owner : Address , operator : Address ) -> Result < bool , Erc721Error > { Ok ( self . operator_approvals . getter ( owner ) . get ( operator ) ) } /// Whether the NFT supports a given standard. pub fn supports_interface ( interface : FixedBytes < 4 > ) -> Result < bool , Erc721Error > { let interface_slice_array : [ u8 ; 4 ] = interface . as_slice ( ) . try_into ( ) . unwrap ( ) ; if u32 :: from_be_bytes ( interface_slice_array ) == 0xffffffff { // special cased in the ERC165 standard return Ok ( false ) ; } const IERC165 : u32 = 0x01ffc9a7 ; const IERC721 : u32 = 0x80ac58cd ; const IERC721_METADATA : u32 = 0x5b5e139f ; Ok ( matches! ( u32 :: from_be_bytes ( interface_slice_array ) , IERC165 | IERC721 | IERC721_METADATA ) ) } }\n\nlib.rs ​\n\n// Only run this as a WASM if the export-abi feature is not set. #![cfg_attr(not(any(feature = \"export-abi\" , test)), no_main)] extern crate alloc ; // Modules and imports mod erc721 ; use alloy_primitives :: { U256 , Address } ; /// Import the Stylus SDK along with alloy primitive types for use in our program. use stylus_sdk :: { msg , prelude :: * } ; use crate :: erc721 :: { Erc721 , Erc721Params , Erc721Error } ; /// Immutable definitions struct StylusNFTParams ; impl Erc721Params for StylusNFTParams { const NAME : & 'static str = \"StylusNFT\" ; const SYMBOL : & 'static str = \"SNFT\" ; fn token_uri ( token_id : U256 ) -> String { format! ( \"{}{}{}\" , \"https://my-nft-metadata.com/\" , token_id , \".json\" ) } } // Define the entrypoint as a Solidity storage object. The sol_storage! macro // will generate Rust-equivalent structs with all fields mapped to Solidity-equivalent // storage slots and types. sol_storage! { #[entrypoint] struct StylusNFT { #[borrow] // Allows erc721 to access StylusNFT's storage and make calls Erc721 < StylusNFTParams > erc721 ; } } #[public] #[inherit(Erc721<StylusNFTParams>)] impl StylusNFT { /// Mints an NFT pub fn mint ( & mut self ) -> Result < ( ) , Erc721Error > { let minter = msg :: sender ( ) ; self . erc721 . mint ( minter ) ? ; Ok ( ( ) ) } /// Mints an NFT to another address pub fn mint_to ( & mut self , to : Address ) -> Result < ( ) , Erc721Error > { self . erc721 . mint ( to ) ? ; Ok ( ( ) ) } /// Burns an NFT pub fn burn ( & mut self , token_id : U256 ) -> Result < ( ) , Erc721Error > { // This function checks that msg::sender() owns the specified token_id self . erc721 . burn ( msg :: sender ( ) , token_id ) ? ; Ok ( ( ) ) } /// Total supply pub fn total_supply ( & mut self ) -> Result < U256 , Erc721Error > { Ok ( self . erc721 . total_supply . get ( ) ) } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus_erc721_example\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Examples",
      "subsection": "Erc721"
    }
  },
  {
    "text": "Multicall\n\nAn Arbitrum Stylus version implementation of Solidity Multi Call contract that aggregates multiple queries using a for loop and RawCall.\n\nExample implementation of a Multi Call contract written in Rust:\nHere is the interface for TimeLock.\n\n/** * This file was automatically generated by Stylus and represents a Rust program. * For more information, please see [The Stylus SDK](https://github.com/OffchainLabs/stylus-sdk-rs). */ // SPDX-License-Identifier: MIT-OR-APACHE-2.0 pragma solidity ^ 0.8.23 ; interface IMultiCall { function multicall ( address [ ] memory addresses , bytes [ ] memory data ) external view returns ( bytes [ ] memory ) ; error ArraySizeNotMatch ( ) ; error CallFailed ( uint256 ) ; }\n\nsrc/lib.rs ​\n\nThis code has yet to be audited. Please use at your own risk.\n\n#![cfg_attr(not(feature = \"export-abi\" ), no_main)] extern crate alloc ; #[global_allocator] static ALLOC : mini_alloc :: MiniAlloc = mini_alloc :: MiniAlloc :: INIT ; use alloy_primitives :: U256 ; use alloy_sol_types :: sol ; use stylus_sdk :: { abi :: Bytes , alloy_primitives :: Address , call :: RawCall , prelude :: * } ; #[solidity_storage] #[entrypoint] pub struct MultiCall ; // Declare events and Solidity error types sol! { error ArraySizeNotMatch ( ) ; error CallFailed ( uint256 call_index ) ; } #[derive(SolidityError)] pub enum MultiCallErrors { ArraySizeNotMatch ( ArraySizeNotMatch ) , CallFailed ( CallFailed ) , } #[external] impl MultiCall { pub fn multicall ( & self , addresses : Vec < Address > , data : Vec < Bytes > , ) -> Result < Vec < Bytes > , MultiCallErrors > { let addr_len = addresses . len ( ) ; let data_len = data . len ( ) ; let mut results : Vec < Bytes > = Vec :: new ( ) ; if addr_len != data_len { return Err ( MultiCallErrors :: ArraySizeNotMatch ( ArraySizeNotMatch { } ) ) ; } for i in 0 .. addr_len { let result = RawCall :: new ( ) . call ( addresses [ i ] , data [ i ] . to_vec ( ) . as_slice ( ) ) . map_err ( | _ | MultiCallErrors :: CallFailed ( CallFailed { call_index : U256 :: from ( i ) } ) ) ? ; results . push ( result . into ( ) ) ; } Ok ( results ) } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus-multi-call-contract\" version = \"0.1.5\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] description = \"Stylus multi call example\" [ dependencies ] alloy-primitives = \"0.3.1\" alloy-sol-types = \"0.3.1\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.5.0\" hex = \"0.4.3\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ [ bin ] ] name = \"stylus-multi-call\" path = \"src/main.rs\" [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Examples",
      "subsection": "Multi Call"
    }
  },
  {
    "text": "Vending Machine\n\nAn example project for writing Arbitrum Stylus programs in Rust using the stylus-sdk . It includes a Rust implementation of a vending machine Ethereum smart contract.\n\ndistribute Cupcakes to any given address count Cupcakes balance of any given address\n\nHere is the interface for Vending Machine.\n\ninterface IVendingMachine { // Function to distribute a cupcake to a user function giveCupcakeTo ( address userAddress ) external returns ( bool ) ; // Getter function for the cupcake balance of a user function getCupcakeBalanceFor ( address userAddress ) external view returns ( uint ) ; }\n\nExample implementation of the Vending Machine contract written in Rust.\n\nsrc/lib.rs ​\n\nThis code has yet to be audited. Please use at your own risk.\n\n//! //! Stylus Cupcake Example //! //! The program is ABI-equivalent with Solidity, which means you can call it from both Solidity and Rust. //! To do this, run `cargo stylus export-abi`. //! //! Note: this code is a template-only and has not been audited. //! // Allow `cargo stylus export-abi` to generate a main function if the \"export-abi\" feature is enabled. #![cfg_attr(not(feature = \"export-abi\" ), no_main)] extern crate alloc ; use alloy_primitives :: { Address , Uint } ; // Import items from the SDK. The prelude contains common traits and macros. use stylus_sdk :: alloy_primitives :: U256 ; use stylus_sdk :: prelude :: * ; use stylus_sdk :: { block , console } ; // Define persistent storage using the Solidity ABI. // `VendingMachine` will be the entrypoint for the contract. sol_storage! { #[entrypoint] pub struct VendingMachine { // Mapping from user addresses to their cupcake balances. mapping ( address => uint256 ) cupcake_balances ; // Mapping from user addresses to the last time they received a cupcake. mapping ( address => uint256 ) cupcake_distribution_times ; } } // Declare that `VendingMachine` is a contract with the following external methods. #[public] impl VendingMachine { // Give a cupcake to the specified user if they are eligible (i.e., if at least 5 seconds have passed since their last cupcake). pub fn give_cupcake_to ( & mut self , user_address : Address ) -> bool { // Get the last distribution time for the user. let last_distribution = self . cupcake_distribution_times . get ( user_address ) ; // Calculate the earliest next time the user can receive a cupcake. let five_seconds_from_last_distribution = last_distribution + U256 :: from ( 5 ) ; // Get the current block timestamp. let current_time = block :: timestamp ( ) ; // Check if the user can receive a cupcake. let user_can_receive_cupcake = five_seconds_from_last_distribution <= Uint :: < 256 , 4 > :: from ( current_time ) ; if user_can_receive_cupcake { // Increment the user's cupcake balance. let mut balance_accessor = self . cupcake_balances . setter ( user_address ) ; let balance = balance_accessor . get ( ) + U256 :: from ( 1 ) ; balance_accessor . set ( balance ) ; // Update the distribution time to the current time. let mut time_accessor = self . cupcake_distribution_times . setter ( user_address ) ; let new_distribution_time = block :: timestamp ( ) ; time_accessor . set ( Uint :: < 256 , 4 > :: from ( new_distribution_time ) ) ; return true ; } else { // User must wait before receiving another cupcake. console! ( \"HTTP 429: Too Many Cupcakes (you must wait at least 5 seconds between cupcakes)\" ) ; return false ; } } // Get the cupcake balance for the specified user. pub fn get_cupcake_balance_for ( & self , user_address : Address ) -> Uint < 256 , 4 > { // Return the user's cupcake balance from storage. return self . cupcake_balances . get ( user_address ) ; } }\n\nCargo.toml ​\n\n[ package ] name = \"stylus_cupcake_example\" version = \"0.1.7\" edition = \"2021\" license = \"MIT OR Apache-2.0\" keywords = [ \"arbitrum\" , \"ethereum\" , \"stylus\" , \"alloy\" ] [ dependencies ] alloy-primitives = \"=0.7.6\" alloy-sol-types = \"=0.7.6\" mini-alloc = \"0.4.2\" stylus-sdk = \"0.6.0\" hex = \"0.4.3\" [ dev-dependencies ] tokio = { version = \"1.12.0\" , features = [ \"full\" ] } ethers = \"2.0\" eyre = \"0.6.8\" [ features ] export-abi = [ \"stylus-sdk/export-abi\" ] [ lib ] crate-type = [ \"lib\" , \"cdylib\" ] [ profile.release ] codegen-units = 1 strip = true lto = true panic = \"abort\" opt-level = \"s\"",
    "metadata": {
      "category": "Examples",
      "subsection": "Vending Machine"
    }
  },
  {
    "text": "How to add a new programming language to Stylus\n\nArbitrum Stylus is a new technology developed for Arbitrum chains which gives smart contract developers superpowers. With Stylus, developers can write EVM-compatible smart contracts in many different programming languages, and reap massive performance gains. Stylus slashes fees, with performance gains ranging from 10-70x, and memory efficiency gains as high as 100-500x.\n\nThis is possible thanks to WebAssembly technology, which all Stylus contracts compile to. Stylus smart contracts live under the same Ethereum state trie in Arbitrum nodes, and can fully interoperate with Solidity or Vyper EVM smart contracts. With Stylus, developers can write smart contracts in Rust that talk to Solidity and vice versa without any limitations.\n\nToday, the Stylus testnet also comes with two officially supported SDKs for developers to write contracts in the Rust or C programming languages.\n\nHowever, anyone can add support for new languages in Stylus. As long as a programming language can compile to WebAssembly , Stylus will let you use it to write EVM-compatible smart contracts. Note that in order to be deployed onchain, your compiled program must fit under the 24Kb brotli-compressed limit, and should meet Stylus gas metering requirements.\n\nIn this document, we go over how we added support for the up-and-coming Zig programming language, which is meant to be a spiritual successor to C that comes with great performance and memory safety within 20 lines of code .\n\nWhy Zig?\n\nZig contains memory safety guardrails , requiring developers to think hard about manual memory allocation in a prudent manner Zig is a C equivalent language, and its tooling is also a C compiler. This means C projects can incrementally adopt Zig when refactoring Zig is lightning fast and produces small binaries , making it suitable for blockchain applications\n\nPrograms written in Zig and deployed to Stylus have a tiny footprint and will have gas costs comparable, if not equal to, C programs.\n\nRequirements ​\n\nDownload and install Zig 0.11.0 Install Rust , which we'll need for the Stylus CLI tool to deploy our program to the Stylus testnet\n\nWe'll also be using Rust to run an example script that can call our Zig contract on the Stylus testnet using the popular ethers-rs library.\n\nOnce Rust is installed, also install the Stylus CLI tool with\n\nRUSTFLAGS = \"-C link-args=-rdynamic\" cargo install --force cargo-stylus\n\nUsing Zig with Stylus ​\n\nFirst, let's clone the repository:\n\ngit clone https://github.com/offchainlabs/zig-on-stylus && cd zig-on-stylus\n\nthen delete everything inside of main.zig . We'll be filling it out ourselves in this tutorial.\n\nTo support Stylus, your Zig programs need to define a special entrypoint function, which takes in the length of its input args, len , and returns a status code i32 , which is either 0 or 1. We won't need the Zig standard library for this.\n\nOne more thing it needs is to use a special function, called memory_grow which can allocate memory for your program. This function is injected into all Stylus contracts as an external import. Internally, we call these vm_hooks , and also refer to them as host-io's , because they give you access to the host, EVM environment.\n\nGo ahead and replace everything in your main.zig function with:\n\npub extern \"vm_hooks\" fn memory_grow ( len : u32 ) void ; export fn mark_unused ( ) void { memory_grow ( 0 ) ; @ panic ( \"\" ) ; } // The main entrypoint to use for execution of the Stylus WASM program. export fn user_entrypoint ( len : usize ) i32 { _ = len ; return 0 ; }\n\nAt the top, we declare the memory_grow external function for use.\n\nNext, we can build our Zig library to a freestanding WASM file for our onchain deployment:\n\nzig build-lib ./src/main.zig -target wasm32-freestanding -dynamic --export = user_entrypoint -OReleaseSmall --export = mark_unused\n\nThis is enough for us to deploy on the Stylus testnet! We'll use the Stylus CLI tool , which you installed earlier using cargo install :\n\ncargo stylus deploy --private-key=<YOUR_TESTNET_PRIVKEY> --wasm-file=main.wasm\n\nThe tool will send two transactions: one to deploy your Zig contract's code onchain, and the other to activate it for usage.\n\nUncompressed WASM size: 112 B Compressed WASM size to be deployed onchain: 103 B\n\nYou can see that our Zig program is tiny when compiled to WASM. Next, we can call our contract to make sure it works using any of your favorite Ethereum tooling. In this example below, we use the cast CLI tool provided by foundry . The contract above has been deployed to the Stylus testnet at address 0xe0CD04EA8c148C9a5A58Fee1C895bc2cf6896799 .\n\nexport ADDR=0xe0CD04EA8c148C9a5A58Fee1C895bc2cf6896799 cast call --rpc-url 'https://stylus-testnet.arbitrum.io/rpc' $ADDR '0x'\n\nCalling the contract via RPC should simply return the value 0 as we programmed it to.\n\n0x\n\nReading input and writing output data ​\n\nSmart contracts on Ethereum, at the bare minimum, can take in data and output data as bytes. Stylus contracts are no different, and to do anything useful, we need to be able to read from user input also write our output to the caller. To do this, the Stylus runtime provides all Stylus contracts with two additional, useful host-ios:\n\npub extern \"vm_hooks\" fn read_args ( dest : * u8 ) void ; pub extern \"vm_hooks\" fn write_result ( data : * const u8 , len : usize ) void ;\n\nAdd these near the top of your main.zig file.\n\nThe first, read_args takes in a pointer to a byte slice where the input arguments will be written to. The length of this byte slice must equal the length of the program args received in the user_entrypoint . We can write a helper function that uses this vm hook and gives us a byte slice in Zig we can then operate on.\n\n// Allocates a Zig byte slice of length=`len` reads a Stylus contract's calldata // using the read_args hostio function. pub fn input ( len : usize ) ! [ ] u8 { var input = try allocator . alloc ( u8 , len ) ; read_args ( @ ptrCast ( * u8 , input ) ) ; return input ; }\n\nNext, we implement a helper function that outputs the data bytes to the Stylus contract's caller:\n\n// Outputs data as bytes via the write_result hostio to the Stylus contract's caller. pub fn output ( data : [ ] u8 ) void { write_result ( @ ptrCast ( * u8 , data ) , data . len ) ; }\n\nLet's put these together:\n\n// The main entrypoint to use for execution of the Stylus WASM program. // It echoes the input arguments to the caller. export fn user_entrypoint ( len : usize ) i32 { var in = input ( len ) catch return 1 ; output ( in ) ; return 0 ; }\n\nWe're almost good to go, let's try to compile to WASM and deploy to the Stylus testnet. Let's run our build command again:\n\nsrc/main.zig:21:20: error: use of undeclared identifier 'allocator' var data = try allocator.alloc(u8, len); ^~~~~~~~~\n\nOops! Looks like we need an allocator to do our job here. Zig, as a language, requires programmers to think carefully about memory allocation and it's a typical pattern to require them to manually provide an allocator. There are many to choose from, but the Zig standard library already has one built specifically for WASM programs. Memory in WASM programs grows in increments of 64Kb, and the allocator from the stdlib has us covered here.\n\nLet's try to use it by adding the following to the top of our main.zig\n\nconst std = @ import ( \"std\" ) ; const allocator = std . heap . WasmAllocator ;\n\nOur code compiles, but will it deploy onchain? Run cargo stylus check --wasm-file=main.wasm and see:\n\nCaused by: missing import memory_grow\n\nWhat's wrong? This means that the WasmAllocator from the Zig standard library should actually be using our special memory_grow hostio function underneath the hood. We can fix this by copying over the WasmAllocator.zig file from the standard library, and modifying a single line to use memory_grow .\n\nYou can find this file under WasmAllocator.zig in the OffchainLabs/zig-on-stylus repository. We can now use it:\n\nconst std = @ import ( \"std\" ) ; const WasmAllocator = @ import ( \"WasmAllocator.zig\" ) ; // Uses our custom WasmAllocator which is a simple modification over the wasm allocator // from the Zig standard library as of Zig 0.11.0. pub const allocator = std . mem . Allocator { . ptr = undefined , . vtable = & WasmAllocator . vtable , } ;\n\nBuilding again and running cargo stylus check should now succeed:\n\nUncompressed WASM size: 514 B Compressed WASM size to be deployed onchain: 341 B Connecting to Stylus RPC endpoint: https://stylus-testnet.arbitrum.io/rpc Stylus program with same WASM code is already activated onchain\n\nLet's deploy it:\n\ncargo stylus deploy --private-key=<YOUR_TESTNET_PRIVKEY> --wasm-file=main.wasm\n\nNow if we try to call it, it will output whatever input we send it, like an echo. Let's send it the input 0x123456:\n\nexport ADDR=0x20Aa65a9D3F077293993150C0345f62B50CCb549 cast call --rpc-url 'https://stylus-testnet.arbitrum.io/rpc' $ADDR '0x123456' 0x123456\n\nWorks!\n\nPrime number checker implementation ​\n\nLet's build something a little bit fancier: this time we'll implement a primality checker in Zig using an ancient algorithm called the sieve of erathosthenes . Given a number, our contract will output 1 if it is prime, or 0 otherwise. We'll implement in a pretty naive way, but leverage one of Zig's awesome features: comptime .\n\nThe comptime keyword tells the Zig compiler to evaluate the code involved at compile time, allowing you to define computation that would normally make runtime more expensive and do it while your binary is being compiled! Comptime in Zig is extremely flexible. In this example, we use it to define a slice of booleans up to a certain limit at compile time, which we'll use to mark which numbers are prime or not.\n\nfn sieve_of_erathosthenes ( comptime limit : usize , nth : u16 ) bool { var prime = [ _ ] bool { true } * * limit ; prime [ 0 ] = false ; prime [ 1 ] = false ; var i : usize = 2 ; while ( i * i < limit ) : ( i += 1 ) { if ( prime [ i ] ) { var j = i * i ; while ( j < limit ) : ( j += i ) prime [ j ] = false ; } } return prime [ nth ] ; }\n\nChecking if a number N is prime would involve just checking if the value at index N in this prime boolean slice is true . We can then integrate this function into our user_entrypoint :\n\n// The main entrypoint to use for execution of the Stylus WASM program. export fn user_entrypoint ( len : usize ) i32 { // Expects the input is a u16 encoded as little endian bytes. var input = args ( len ) catch return 1 ; var check_nth_prime = std . mem . readIntSliceLittle ( u16 , input ) ; const limit : u16 = 10 _000 ; if ( check_nth_prime > limit ) { @ panic ( \"input is greater than limit of 10,000 primes\" ) ; } // Checks if the number is prime and returns a boolean using the output function. var is_prime = sieve_of_erathosthenes ( limit , check_nth_prime ) ; var out = input [ 0. .1 ] ; if ( is_prime ) { out [ 0 ] = 1 ; } else { out [ 0 ] = 0 ; } output ( out ) ; return 0 ; }\n\nLet's check and deploy it:\n\nUncompressed WASM size: 10.8 KB Compressed WASM size to be deployed onchain: 525 B\n\nOur uncompressed size is big because of that giant array of booleans, but the program is highly compressible because all of them are zeros!\n\nAn instance of this program has been deployed to the Stylus testnet at address 0x0c503Bb757b1CaaD0140e8a2700333C0C9962FE4\n\nInteracting With Stylus contracts Using Ethers-rs ​\n\nAn example is included in this repo under rust-example which uses the popular ethers-rs library to interact with our prime sieve contract on the Stylus testnet. To run it, do:\n\nexport STYLUS_PROGRAM_ADDRESS=0x0c503Bb757b1CaaD0140e8a2700333C0C9962FE4 cargo run\n\n...and see:\n\nChecking if 2 is_prime = true, took: 404.146917ms Checking if 3 is_prime = true, took: 154.802083ms Checking if 4 is_prime = false, took: 123.239583ms Checking if 5 is_prime = true, took: 109.248709ms Checking if 6 is_prime = false, took: 113.086625ms Checking if 32 is_prime = false, took: 280.19975ms Checking if 53 is_prime = true, took: 123.667958ms\n\nNext steps ​\n\nThe hostios defined in this walkthrough are not the only ones! Check out our stylus-sdk-c to see all the hostios you can use under hostio.h . These include affordances for the EVM, utilities to access storage, and utilities to call other Arbitrum smart contracts.",
    "metadata": {
      "category": "Using other languages"
    }
  },
  {
    "text": "Troubleshooting Stylus\n\nHow does Stylus manage security issues in smart contracts when interacting with so many different languages? ​\n\nAll languages are compiled to WASM for them to be able to work with Stylus. So it just needs to verify that the produced WASM programs behave as they should inside the new virtual machine.\n\nIs there any analogue of the fallback function from Solidity in the Rust Stylus SDK? ​\n\nCurrently there isn't any analogue. However, you can use a minimal entrypoint and perform raw delegate calls, forwarding your calldata. You can find more information in Bytes-in, bytes-out programming and call, static_call and delegate_call .\n\nIs it possible to verify Stylus contracts on the block explorer? ​\n\nCurrently it is not possible to verify contracts compiled to WASM on the block explorer, but we are actively working with providers to have the verification process ready for when Stylus reaches mainnet-ready status.\n\nDo Stylus contracts compile down to EVM bytecode like prior other attempts? ​\n\nNo. Stylus contracts are compiled down to WASM. The user writes a program in Rust / C / C++ which is then compiled down to WebAssembly.\n\nHow is a Stylus contract deployed? ​\n\nStylus contracts are deployed on chain as a blob of bytes, just like EVM ones. The only difference is that when the contract is executed, instead of invoking the EVM, we invoke a separate WASM runtime. Note that a special EOF-inspired prefix distinguishes Stylus contracts from traditional EVM contracts: when a contract's bytecode starts with the magic 0xEFF00000 prefix, it's a Stylus WASM contract.\n\nIs there a new transaction type to deploy Stylus contracts? ​\n\nYou deploy a Stylus contract the same way that Solidity contracts are deployed. There are no special transaction types. As a UX note: a WASM will revert until a special instrumentation operation is performed by a call to the new ArbWasm precompile, which readies the program for calls on-chain.\n\nYou can find instructions for deploying a Stylus contract in our Quickstart .\n\nDo Stylus contracts use a different type of ABI? ​\n\nStylus contracts use solidity ABIs. Methods, signatures, logs, calls, etc. work exactly as in the EVM. From a user's / explorer's perspective, it all just looks and behaves like solidity.\n\nDoes the Stylus SDK for Rust support custom data structures? ​\n\nFor in-memory usage, you should be able to use any implementation of custom data structures without problems.\n\nFor storage usage, it might be a bit more complicated. Stylus uses the EVM storage system, so you'll need to define the data structure on top of it. However, in the SDK there's a storage trait that custom types can implement to back their collections with the EVM state trie. The SDK macros are compatible with them too, although fundamentally it's still a global key-value system.\n\nYou can read more about it in the Stylus Rust SDK page .\n\nAs an alternative solution, you can use entrypoint-style contracts for your custom data structures.\n\nWhy do I get an error \"no library targets found in package\" when trying to compile and old example? ​\n\nSome of the first Stylus examples were built and deployed using a previous version of cargo-stylus ( 0.1.x ). In that version, Stylus projects were structured as regular Rust binaries.\n\nSince cargo-stylus v0.2.1 , Stylus projects are structured as libraries, so when trying to compile old projects you might get an error no library targets found in package .\n\nTo solve this, it's usually enough to rename the main.rs file to a lib.rs file.\n\nHow can I generate the ABI of my Stylus contract? ​\n\nThe cargo-stylus tool has a command that allows you to export the ABI of your Stylus contract: cargo stylus export-abi .\n\nIf you're using the Stylus Rust SDK, you'll need to enable the export-abi feature in your Cargo.toml file like so:\n\n[ features ] export - abi = [ \"stylus-sdk/export-abi\" ]\n\nYou'll also need to have a main.rs file that selects that feature.\n\nThis is an example of a main.rs file that allows you to export the abi of the stylus-hello-world example project:\n\n#![cfg_attr(not(feature = \"export-abi\" ), no_main)] #[cfg(feature = \"export-abi\" )] fn main ( ) { stylus_hello_world :: main ( ) ; }",
    "metadata": {
      "category": "Troubleshooting"
    }
  }
]