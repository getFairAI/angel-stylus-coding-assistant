[
  {
    "stylusVersion": "0.4.2",
    "project": "stylus-chess",
    "link": "https://github.com/OffchainLabs/stylus-chess",
    "files": {
      "Cargo.toml": "[package]\nname = \"stylus-chess\"\nversion = \"0.1.5\"\nedition = \"2021\"\nlicense = \"MIT OR Apache-2.0\"\nhomepage = \"https://github.com/OffchainLabs/stylus-hello-world\"\nrepository = \"https://github.com/OffchainLabs/stylus-hello-world\"\nkeywords = [\"arbitrum\", \"ethereum\", \"stylus\", \"alloy\"]\ndescription = \"Stylus hello world example\"\n\n[dependencies]\nalloy-primitives = \"0.3.1\"\nalloy-sol-types = \"0.3.1\"\nmini-alloc = \"0.4.2\"\nstylus-sdk = { version = \"0.4.2\", features = [\"debug\"]}\nhex = \"0.4.3\"\nchess-engine = \"0.1.2\"\n\n[dev-dependencies]\ntokio = { version = \"1.12.0\", features = [\"full\"] }\nethers = \"2.0\"\neyre = \"0.6.8\"\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\ndebug = [\"stylus-sdk/debug\"]\n\n[[bin]]\nname = \"stylus-hello-world\"\npath = \"src/main.rs\"\n\n[lib]\ncrate-type = [\"lib\", \"cdylib\"]\n\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"\n",
      "examples/counter.rs": "//! Example on how to interact with a deployed `stylus-hello-world` program using defaults.\n//! This example uses ethers-rs to instantiate the program using a Solidity ABI.\n//! Then, it attempts to check the current counter value, increment it via a tx,\n//! and check the value again. The deployed program is fully written in Rust and compiled to WASM\n//! but with Stylus, it is accessible just as a normal Solidity smart contract is via an ABI.\n\nuse ethers::{\n    middleware::SignerMiddleware,\n    prelude::abigen,\n    providers::{Http, Middleware, Provider},\n    signers::{LocalWallet, Signer},\n    types::Address,\n};\nuse eyre::eyre;\nuse std::io::{BufRead, BufReader};\nuse std::str::FromStr;\nuse std::sync::Arc;\n\n/// Your private key file path.\nconst PRIV_KEY_PATH: &str = \"PRIV_KEY_PATH\";\n\n/// Stylus RPC endpoint url.\nconst RPC_URL: &str = \"RPC_URL\";\n\n/// Deployed pragram address.\nconst STYLUS_PROGRAM_ADDRESS: &str = \"STYLUS_PROGRAM_ADDRESS\";\n\n#[tokio::main]\nasync fn main() -> eyre::Result<()> {\n    let priv_key_path = std::env::var(PRIV_KEY_PATH)\n        .map_err(|_| eyre!(\"No {} env var set\", PRIV_KEY_PATH))?;\n    let rpc_url =\n        std::env::var(RPC_URL).map_err(|_| eyre!(\"No {} env var set\", RPC_URL))?;\n    let program_address = std::env::var(STYLUS_PROGRAM_ADDRESS)\n        .map_err(|_| eyre!(\"No {} env var set\", STYLUS_PROGRAM_ADDRESS))?;\n    abigen!(\n        Counter,\n        r#\"[\n            function number() external view returns (uint256)\n            function setNumber(uint256 number) external\n            function increment() external\n        ]\"#\n    );\n\n    let provider = Provider::<Http>::try_from(rpc_url)?;\n    let address: Address = program_address.parse()?;\n\n    let privkey = read_secret_from_file(&priv_key_path)?;\n    let wallet = LocalWallet::from_str(&privkey)?;\n    let chain_id = provider.get_chainid().await?.as_u64();\n    let client = Arc::new(SignerMiddleware::new(\n        provider,\n        wallet.clone().with_chain_id(chain_id),\n    ));\n\n    let counter = Counter::new(address, client);\n    let num = counter.number().call().await;\n    println!(\"Counter number value = {:?}\", num);\n\n    let _ = counter.increment().send().await?.await?;\n    println!(\"Successfully incremented counter via a tx\");\n\n    let num = counter.number().call().await;\n    println!(\"New counter number value = {:?}\", num);\n    Ok(())\n}\n\nfn read_secret_from_file(fpath: &str) -> eyre::Result<String> {\n    let f = std::fs::File::open(fpath)?;\n    let mut buf_reader = BufReader::new(f);\n    let mut secret = String::new();\n    buf_reader.read_line(&mut secret)?;\n    Ok(secret.trim().to_string())\n}\n",
      "src/lib.rs": "// Only run this as a WASM if the export-abi feature is not set.\n#![cfg_attr(not(feature = \"export-abi\"), no_main)]\nextern crate alloc;\n\n/// Initializes a custom, global allocator for Rust programs compiled to WASM.\n#[global_allocator]\nstatic ALLOC: mini_alloc::MiniAlloc = mini_alloc::MiniAlloc::INIT;\n\nuse alloy_primitives::{Address, U8};\nuse chess_engine::{Board, BoardBuilder, Color, GameResult, Move, Piece, Position};\n\n/// Import the Stylus SDK along with alloy primitive types for use in our program.\nuse stylus_sdk::{alloy_primitives::U256, console, msg, prelude::*};\n\n/// Game Status\n// const PENDING: u8 = 0;\nconst CONTINUING: u8 = 1;\nconst ILLEGAL_MOVE: u8 = 2;\nconst STALEMATE: u8 = 3;\nconst VICTORY: u8 = 4;\n\n/// Colors\nconst WHITE: u8 = 0;\nconst BLACK: u8 = 1;\n\n/// Piece types\nconst PAWN: u8 = 1;\nconst KNIGHT: u8 = 2;\nconst BISHOP: u8 = 3;\nconst ROOK: u8 = 4;\nconst QUEEN: u8 = 5;\nconst KING: u8 = 6;\n\n/// Bit masks\nconst COLOR_MASK: u8 = 1;\nconst PIECE_TYPE_MASK: u8 = 7;\n\nsol_storage! {\n  #[entrypoint]\n  pub struct StylusChess {\n    /// Total games of chess started\n    uint256 total_games;\n    /// Used to store a single pending game while waiting for a player two to join.\n    uint256 pending_game;\n    /// Stores info for each chess game\n    mapping(uint256 => GameInfo) games;\n  }\n\n  pub struct GameInfo {\n    /// Player 1 is WHITE\n    address player_one;\n    /// Player 2 is BLACK\n    address player_two;\n    /// PENDING (waiting second player) = 0, CONTINUING = 1, STALEMATE = 3, or VICTORY = 4\n    uint8 game_status;\n    /// Player turn 0 = WHITE; 1 = BLACK\n    uint8 turn_color;\n    /// 0 = WHITE; 1 = BLACK\n    uint8 victor;\n    /// All the info needed to rebuild the board\n    uint256 board_state;\n  }\n}\n\n#[external]\nimpl StylusChess {\n    /// Gets the game number from storage.\n    pub fn total_games(&self) -> Result<U256, Vec<u8>> {\n        Ok(U256::from(self.total_games.get()))\n    }\n\n    /// Get the color of the current player\n    pub fn get_turn_color(&self, game_number: U256) -> Result<U256, Vec<u8>> {\n        let game_info = self.games.get(game_number);\n        let turn_color = game_info.turn_color.get();\n\n        Ok(U256::from(turn_color))\n    }\n\n    /// Get the address of the current player\n    pub fn get_current_player(&self, game_number: U256) -> Result<Address, Vec<u8>> {\n        let game_info = self.games.get(game_number);\n        let turn_color = game_info.turn_color.get();\n\n        let player_address = match turn_color == U8::from(WHITE) {\n            true => game_info.player_one.get(),\n            false => game_info.player_two.get(),\n        };\n\n        Ok(player_address)\n    }\n\n    /// Play a Move\n    pub fn play_move(\n        &mut self,\n        game_number: U256,\n        from_row: U256,\n        from_col: U256,\n        to_row: U256,\n        to_col: U256,\n    ) -> Result<U256, Vec<u8>> {\n        let board = self.get_board_from_game_number(game_number);\n        let current_player = self.get_current_player_address(game_number, board);\n        let game_data = self.games.get(game_number);\n\n        // only allow the current player address to execute this call\n        if msg::sender() != current_player {\n            return Ok(U256::from(ILLEGAL_MOVE));\n        }\n\n        // don't continue if game is already over\n        if game_data.game_status.get() != U8::from(CONTINUING) {\n            return Ok(U256::from(ILLEGAL_MOVE));\n        }\n\n        let from_position = Position::new(from_row.to(), from_col.to());\n        let to_position = Position::new(to_row.to(), to_col.to());\n        let player_move = Move::Piece(from_position, to_position);\n        let move_result = board.play_move(player_move);\n\n        let response = match move_result {\n            GameResult::Continuing(new_board) => {\n                let new_board_state = self.serialize_board(new_board);\n                let mut game_setter = self.games.setter(game_number);\n                game_setter.board_state.set(new_board_state);\n\n                match new_board.get_turn_color() {\n                    Color::White => {\n                        game_setter.turn_color.set(U8::from(WHITE));\n                    }\n                    Color::Black => {\n                        game_setter.turn_color.set(U8::from(BLACK));\n                    }\n                }\n\n                U256::from(CONTINUING)\n            }\n            GameResult::Victory(_) => {\n                let current_color = match board.get_turn_color() {\n                    Color::White => U8::from(WHITE),\n                    Color::Black => U8::from(BLACK),\n                };\n                let mut game_setter = self.games.setter(game_number);\n                game_setter.victor.set(current_color);\n                game_setter.game_status.set(U8::from(VICTORY));\n\n                U256::from(VICTORY)\n            }\n            GameResult::Stalemate => {\n                let mut game_setter = self.games.setter(game_number);\n                game_setter.game_status.set(U8::from(STALEMATE));\n\n                U256::from(STALEMATE)\n            }\n            _ => U256::from(ILLEGAL_MOVE),\n        };\n\n        Ok(response)\n    }\n\n    pub fn print_game_state(&self, game_number: U256) -> Result<(), Vec<u8>> {\n        let game_info = self.games.get(U256::from(game_number));\n        let board_state = game_info.board_state.get();\n        let board: Board = self.deserialize_board(board_state);\n        self.print_board(&board);\n\n        Ok(())\n    }\n\n    /// The board layout for a particular game\n    pub fn board_state_by_game_number(&self, game_number: U256) -> Result<U256, Vec<u8>> {\n        let game_info = self.games.get(game_number);\n        Ok(game_info.board_state.get())\n    }\n\n    /// Either creates a new game or joins a pending game if it exists\n    /// Returns the game number\n    pub fn create_or_join(&mut self) -> Result<U256, Vec<u8>> {\n        let pending_game = self.pending_game.get();\n\n        // Sets pending_game number and initializes a new board\n        if pending_game == U256::from(0) {\n            let game_number = self.get_next_game_number();\n            self.pending_game.set(game_number);\n            self.create_game(game_number);\n            return Ok(U256::from(game_number));\n        }\n\n        self.join_game(pending_game);\n\n        Ok(U256::from(pending_game))\n    }\n}\n\nimpl StylusChess {\n    pub fn get_current_player_address(&self, game_number: U256, current_board: Board) -> Address {\n        let game_info = self.games.get(game_number);\n        match current_board.get_turn_color() {\n            Color::White => game_info.player_one.get(),\n            Color::Black => game_info.player_two.get(),\n        }\n    }\n\n    fn get_board_from_game_number(&self, game_number: U256) -> Board {\n        let game_info = self.games.get(game_number);\n        let color = game_info.turn_color.get();\n        let board_state = game_info.board_state.get();\n        let board = self.deserialize_board(board_state);\n\n        let color_enum = match color == U8::from(WHITE) {\n            true => Color::White,\n            false => Color::Black,\n        };\n\n        board.set_turn(color_enum)\n    }\n\n    fn get_next_game_number(&mut self) -> U256 {\n        let game_number = self.total_games.get() + U256::from(1);\n        self.total_games.set(game_number);\n        game_number\n    }\n\n    fn create_game(&mut self, game_number: U256) {\n        let board = Board::default();\n        // Set up pieces for serialization\n        let board_state = self.serialize_board(board);\n\n        let mut game_info = self.games.setter(game_number);\n        game_info.player_one.set(msg::sender());\n        game_info.board_state.set(board_state);\n    }\n\n    fn join_game(&mut self, game_number: U256) {\n        let mut game_info = self.games.setter(game_number);\n        // join as player two\n        game_info.player_two.set(msg::sender());\n        // change status to continuing\n        game_info.game_status.set(U8::from(CONTINUING));\n        // empty out pending_game\n        self.pending_game.set(U256::ZERO);\n    }\n\n    fn deserialize_board(&self, board_state: U256) -> Board {\n        let mut board_builder: BoardBuilder = BoardBuilder::default();\n        board_builder = board_builder.enable_castling();\n\n        for row in 0..8_u8 {\n            for col in 0..8_u8 {\n                let base_offset: usize = ((row * 8 + col) * 4).into();\n                let color_offset: usize = base_offset + 3;\n                let piece_type_offset: usize = base_offset;\n\n                let color = (board_state >> color_offset) & U256::from(COLOR_MASK);\n                let piece_type = (board_state >> piece_type_offset) & U256::from(PIECE_TYPE_MASK);\n\n                if piece_type != U256::ZERO {\n                    let position = Position::new(row.into(), col.into());\n                    let color_enum = match U8::from(color).to() {\n                        WHITE => Color::White,\n                        _ => Color::Black,\n                    };\n                    let piece = match U8::from(piece_type).to() {\n                        KNIGHT => Piece::Knight(color_enum, position),\n                        BISHOP => Piece::Bishop(color_enum, position),\n                        ROOK => Piece::Rook(color_enum, position),\n                        QUEEN => Piece::Queen(color_enum, position),\n                        KING => Piece::King(color_enum, position),\n                        _ => Piece::Pawn(color_enum, position),\n                    };\n\n                    board_builder = board_builder.piece(piece);\n                }\n            }\n        }\n\n        board_builder.build()\n    }\n\n    fn serialize_board(&self, board: Board) -> U256 {\n        let mut board_state = U256::from(0);\n\n        for row in 0..8_u8 {\n            for col in 0..8_u8 {\n                let position = Position::new(row.into(), col.into());\n                let base_offset: usize = ((row * 8 + col) * 4).into();\n                let color_offset: usize = base_offset + 3;\n                let piece_type_offset: usize = base_offset;\n\n                if let Some(board_piece) = board.get_piece(position) {\n                    let color = if board_piece.get_color() == Color::White {\n                        WHITE\n                    } else {\n                        BLACK\n                    };\n\n                    let piece_type = match board_piece {\n                        Piece::Pawn(_, _) => PAWN,\n                        Piece::Knight(_, _) => KNIGHT,\n                        Piece::Bishop(_, _) => BISHOP,\n                        Piece::Rook(_, _) => ROOK,\n                        Piece::Queen(_, _) => QUEEN,\n                        Piece::King(_, _) => KING,\n                    };\n\n                    board_state |= U256::from(color) << color_offset;\n                    board_state |= U256::from(piece_type) << piece_type_offset;\n                } else {\n                    board_state |= U256::from(0) << (base_offset + 4);\n                }\n            }\n        }\n\n        board_state\n    }\n\n    fn print_board(&self, board: &Board) {\n        let turn = board.get_turn_color();\n        let abc = if turn == Color::White {\n            \"abcdefgh\"\n        } else {\n            \"hgfedcba\"\n        };\n\n        console!(\"   {}\", abc);\n        console!(\"  ╔════════╗\");\n        let mut square_color = !turn;\n        let height = 8;\n        let width = 8;\n\n        for row in 0..height {\n            let print_row = match turn {\n                Color::White => height - row - 1,\n                Color::Black => row,\n            };\n            let mut row_text = String::new();\n            let row_label = format!(\"{} ║\", print_row + 1);\n            row_text.push_str(row_label.as_str());\n\n            for col in 0..width {\n                let print_col = match turn {\n                    Color::Black => width - col - 1,\n                    Color::White => col,\n                };\n\n                let pos = Position::new(print_row, print_col);\n\n                let s = if let Some(piece) = board.get_piece(pos) {\n                    piece.to_string()\n                } else {\n                    String::from(match square_color {\n                        Color::White => \"░\",\n                        Color::Black => \"▓\",\n                    })\n                };\n                if Some(pos) == board.get_en_passant() {\n                    row_text.push_str(format!(\"\\x1b[34m{}\\x1b[m\\x1b[0m\", s).as_str());\n                } else if board.is_threatened(pos, turn) {\n                    row_text.push_str(format!(\"\\x1b[31m{}\\x1b[m\\x1b[0m\", s).as_str());\n                } else if board.is_threatened(pos, !turn) {\n                    row_text.push_str(format!(\"\\x1b[32m{}\\x1b[m\\x1b[0m\", s).as_str());\n                } else {\n                    row_text.push_str(s.as_str());\n                }\n\n                square_color = !square_color;\n            }\n            row_text.push('║');\n            console!(\"{}\", row_text);\n\n            square_color = !square_color;\n        }\n\n        console!(\"  ╚════════╝\");\n        console!(\"   {}\", abc);\n    }\n}\n",
      "src/main.rs": "#![cfg_attr(not(feature = \"export-abi\"), no_main)]\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    stylus_chess::main();\n}\n"
    }
  },
  {
    "stylusVersion": "0.5.0",
    "project": "stylus-workshop-basic-nft",
    "link": "https://github.com/OffchainLabs/stylus-workshop-basic-nft",
    "files": {
      ".cargo/config.toml": "[build]\ntarget = \"wasm32-unknown-unknown\"\n\n[target.wasm32-unknown-unknown]\nrustflags = [\n  \"-C\", \"link-arg=-zstack-size=32768\",\n]",
      "Cargo.toml": "[package]\nname = \"stylus-workshop-basic-nft\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nstylus-sdk = { version = \"0.5.0\", features = [\"docs\"] }\nalloy-primitives = \"0.3.1\"\nalloy-sol-types = \"0.3.1\"\nwee_alloc = \"0.4.5\"\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n\n[lib]\ncrate-type = [\"lib\", \"cdylib\"]\n\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"\n\n[workspace]\n",
      "src/erc721.rs": "//! Implementation of the ERC-721 standard\n//! (Based on https://github.com/OffchainLabs/stylus-workshop-nft/ implementation)\n//!\n//! The eponymous [`Erc721`] type provides all the standard methods,\n//! and is intended to be inherited by other contract types.\n//!\n//! You can configure the behavior of [`Erc721`] via the [`Erc721Params`] trait,\n//! which allows specifying the name, symbol, and token uri.\n//!\n//! Note that this code is unaudited and not fit for production use.\n\nuse alloc::{string::String, vec, vec::Vec};\nuse alloy_primitives::{Address, U256};\nuse alloy_sol_types::sol;\nuse core::{borrow::BorrowMut, marker::PhantomData};\nuse stylus_sdk::{\n    abi::Bytes,\n    evm,\n    msg,\n    prelude::*,\n    call::Error\n};\n\npub trait Erc721Params {\n    /// Immutable NFT name.\n    const NAME: &'static str;\n\n    /// Immutable NFT symbol.\n    const SYMBOL: &'static str;\n\n    /// The NFT's Uniform Resource Identifier.\n    fn token_uri(token_id: U256) -> String;\n}\n\nsol_storage! {\n    /// Erc721 implements all ERC-721 methods\n    pub struct Erc721<T: Erc721Params> {\n        /// Token id to owner map\n        mapping(uint256 => address) owners;\n        /// User to balance map\n        mapping(address => uint256) balance;\n        /// Token id to approved user map\n        mapping(uint256 => address) approved;\n        /// User to operator map (the operator can manage all NFTs of the owner)\n        mapping(address => mapping(address => bool)) approved_for_all;\n        /// Total supply\n        uint256 total_supply;\n        /// Used to allow [`Erc721Params`]\n        PhantomData<T> phantom;\n    }\n}\n\n// Declare events and Solidity error types\nsol! {\n    event Transfer(address indexed from, address indexed to, uint256 indexed token_id);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed token_id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    // Token id has not been minted, or it has been burned\n    error InvalidTokenId(uint256 token_id);\n    // The specified address is not the owner of the specified token id\n    error NotOwner(address from, uint256 token_id, address real_owner);\n    // The specified address does not have allowance to spend the specified token id\n    error NotApproved(address owner, address spender, uint256 token_id);\n    // Attempt to transfer token id to the Zero address\n    error TransferToZero(uint256 token_id);\n    // The receiver address refused to receive the specified token id\n    error ReceiverRefused(address receiver, uint256 token_id, bytes4 returned);\n    // Error thrown when call receiver address by onERC721Received\n    error CallReceiverFailed(bytes revert);\n}\n\n/// Represents the ways methods may fail.\n#[derive(SolidityError)]\npub enum Erc721Error {\n    InvalidTokenId(InvalidTokenId),\n    NotOwner(NotOwner),\n    NotApproved(NotApproved),\n    TransferToZero(TransferToZero),\n    ReceiverRefused(ReceiverRefused),\n    CallReceiverFailed(CallReceiverFailed),\n}\n\n// These methods aren't external, but are helpers used by external methods.\n// Methods marked as \"pub\" here are usable outside of the erc721 module (i.e. they're callable from lib.rs).\nimpl<T: Erc721Params> Erc721<T> {\n    /// Requires that msg::sender() is authorized to spend a given token\n    fn require_authorized_to_spend(&self, from: Address, token_id: U256) -> Result<(), Erc721Error> {\n        // `from` must be the owner of the token_id\n        let owner = self.owner_of(token_id)?;\n        if from != owner {\n            return Err(Erc721Error::NotOwner(NotOwner {\n                from,\n                token_id,\n                real_owner: owner,\n            }));\n        }\n\n        // caller is the owner\n        if msg::sender() == owner {\n            return Ok(());\n        }\n\n        // caller is an operator for the owner (can manage their tokens)\n        if self.approved_for_all.getter(owner).get(msg::sender()) {\n            return Ok(());\n        }\n\n        // caller is approved to manage this token_id\n        if msg::sender() == self.approved.get(token_id) {\n            return Ok(());\n        }\n\n        // otherwise, caller is not allowed to manage this token_id\n        Err(Erc721Error::NotApproved(NotApproved {\n            owner,\n            spender: msg::sender(),\n            token_id,\n        }))\n    }\n\n    /// Transfers `token_id` from `from` to `to`.\n    /// This function does check that `from` is the owner of the token, but it does not check\n    /// that `to` is not the zero address, as this function is usable for burning.\n    pub fn transfer(&mut self, token_id: U256, from: Address, to: Address) -> Result<(), Erc721Error> {\n        let mut owner = self.owners.setter(token_id);\n        let previous_owner = owner.get();\n        if previous_owner != from {\n            return Err(Erc721Error::NotOwner(NotOwner {\n                from,\n                token_id,\n                real_owner: previous_owner,\n            }));\n        }\n        owner.set(to);\n\n        // right now working with storage can be verbose, but this will change upcoming version of the Stylus SDK\n        let mut from_balance = self.balance.setter(from);\n        let balance = from_balance.get() - U256::from(1);\n        from_balance.set(balance);\n\n        let mut to_balance = self.balance.setter(to);\n        let balance = to_balance.get() + U256::from(1);\n        to_balance.set(balance);\n\n        self.approved.delete(token_id);\n        evm::log(Transfer { from, to, token_id });\n        Ok(())\n    }\n\n    /// Calls `onERC721Received` on the `to` address if it is a contract.\n    /// Otherwise it does nothing\n    fn call_receiver<S: TopLevelStorage>(\n        storage: &mut S,\n        token_id: U256,\n        from: Address,\n        to: Address,\n        data: Vec<u8>,\n    ) -> Result<(), Erc721Error> {\n        if to.has_code() {\n            let receiver = IERC721TokenReceiver::new(to);\n            // call onERC721Received\n            let result = receiver.on_erc_721_received(&mut *storage, msg::sender(), from, token_id, data);\n            // check the return value\n            let received = match result {\n                Ok(received) => received.0,\n                Err(Error::Revert(revert)) => return Err(Erc721Error::CallReceiverFailed(CallReceiverFailed { revert })),\n                Err(err) => return Err(Erc721Error::CallReceiverFailed(CallReceiverFailed { revert: err.into() })),\n            };\n            if u32::from_be_bytes(received) != ERC721_TOKEN_RECEIVER_ID {\n                return Err(Erc721Error::ReceiverRefused(ReceiverRefused {\n                    receiver: receiver.address,\n                    token_id,\n                    returned: received,\n                }));\n            }\n        }\n        Ok(())\n    }\n\n    /// Transfers and calls `onERC721Received`\n    pub fn safe_transfer<S: TopLevelStorage + BorrowMut<Self>>(\n        storage: &mut S,\n        token_id: U256,\n        from: Address,\n        to: Address,\n        data: Vec<u8>,\n    ) -> Result<(), Erc721Error> {\n        storage.borrow_mut().transfer(token_id, from, to)?;\n        Self::call_receiver(storage, token_id, from, to, data)\n    }\n\n    /// Mints a new token and transfers it to `to`\n    pub fn mint(&mut self, to: Address) -> Result<(), Erc721Error> {\n        let new_token_id = self.total_supply.get();\n        self.total_supply.set(new_token_id + U256::from(1u8));\n        self.transfer(new_token_id, Address::default(), to)?;\n        Ok(())\n    }\n\n    /// Burns the token `token_id` from `from`\n    pub fn burn(&mut self, from: Address, token_id: U256) -> Result<(), Erc721Error> {\n        self.transfer(token_id, from, Address::default())?;\n        Ok(())\n    }\n}\n\nsol_interface! {\n    /// Allows calls to the `onERC721Received` method of other contracts implementing `IERC721TokenReceiver`.\n    interface IERC721TokenReceiver {\n        function onERC721Received(address operator, address from, uint256 token_id, bytes data) external returns(bytes4);\n    }\n}\n\n/// Selector for `onERC721Received`, which is returned by contracts implementing `IERC721TokenReceiver`.\nconst ERC721_TOKEN_RECEIVER_ID: u32 = 0x150b7a02;\n\n// these methods are external to other contracts\n#[external]\nimpl<T: Erc721Params> Erc721<T> {\n    /// Immutable NFT name.\n    pub fn name() -> Result<String, Erc721Error> {\n        Ok(T::NAME.into())\n    }\n\n    /// Immutable NFT symbol.\n    pub fn symbol() -> Result<String, Erc721Error> {\n        Ok(T::SYMBOL.into())\n    }\n\n    /// The NFT's Uniform Resource Identifier.\n    pub fn token_uri(&self, token_id: U256) -> Result<String, Erc721Error> {\n        self.owner_of(token_id)?; // require NFT exist\n        Ok(T::token_uri(token_id))\n    }\n\n    /// Whether the NFT supports a given standard.\n    pub fn supports_interface(interface: [u8; 4]) -> Result<bool, Erc721Error> {\n        if interface == [0xff; 4] {\n            // special cased in the ERC165 standard\n            return Ok(false);\n        }\n\n        const IERC165: u32 = 0x01ffc9a7;\n        const IERC721: u32 = 0x80ac58cd;\n        const _IERC721_ENUMERABLE: u32 = 0x780e9d63; // TODO: implement standard\n\n        Ok(matches!(u32::from_be_bytes(interface), IERC165 | IERC721))\n    }\n\n    /// Gets the number of NFTs owned by an account.\n    pub fn balance_of(&self, owner: Address) -> Result<U256, Erc721Error> {\n        Ok(self.balance.get(owner))\n    }\n\n    /// Gets the owner of the NFT, if it exists.\n    pub fn owner_of(&self, token_id: U256) -> Result<Address, Erc721Error> {\n        let owner = self.owners.get(token_id);\n        if owner.is_zero() {\n            return Err(Erc721Error::InvalidTokenId(InvalidTokenId { token_id }));\n        }\n        Ok(owner)\n    }\n\n    /// Transfers an NFT, but only after checking the `to` address can receive the NFT.\n    #[selector(name = \"safeTransferFrom\")]\n    pub fn safe_transfer_from<S: TopLevelStorage + BorrowMut<Self>>(\n        storage: &mut S,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -> Result<(), Erc721Error> {\n        Self::safe_transfer_from_with_data(storage, from, to, token_id, Bytes(vec![]))\n    }\n\n    /// Equivalent to [`safe_transfer_from`], but with additional data for the receiver.\n    ///\n    /// Note: because Rust doesn't allow multiple methods with the same name,\n    /// we use the `#[selector]` macro attribute to simulate solidity overloading.\n    #[selector(name = \"safeTransferFrom\")]\n    pub fn safe_transfer_from_with_data<S: TopLevelStorage + BorrowMut<Self>>(\n        storage: &mut S,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -> Result<(), Erc721Error> {\n        if to.is_zero() {\n            return Err(Erc721Error::TransferToZero(TransferToZero { token_id }));\n        }\n        storage\n            .borrow_mut()\n            .require_authorized_to_spend(from, token_id)?;\n\n        Self::safe_transfer(storage, token_id, from, to, data.0)\n    }\n\n    /// Transfers the NFT.\n    pub fn transfer_from(&mut self, from: Address, to: Address, token_id: U256) -> Result<(), Erc721Error> {\n        if to.is_zero() {\n            return Err(Erc721Error::TransferToZero(TransferToZero { token_id }));\n        }\n        self.require_authorized_to_spend(from, token_id)?;\n        self.transfer(token_id, from, to)?;\n        Ok(())\n    }\n\n    /// Grants an account the ability to manage the sender's NFT.\n    pub fn approve(&mut self, approved: Address, token_id: U256) -> Result<(), Erc721Error> {\n        let owner = self.owner_of(token_id)?;\n\n        // require authorization\n        if msg::sender() != owner && !self.approved_for_all.getter(owner).get(msg::sender()) {\n            return Err(Erc721Error::NotApproved(NotApproved {\n                owner,\n                spender: msg::sender(),\n                token_id,\n            }));\n        }\n        self.approved.insert(token_id, approved);\n\n        evm::log(Approval {\n            approved,\n            owner,\n            token_id,\n        });\n        Ok(())\n    }\n\n    /// Grants an account the ability to manage all of the sender's NFTs.\n    pub fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<(), Erc721Error> {\n        let owner = msg::sender();\n        self.approved_for_all\n            .setter(owner)\n            .insert(operator, approved);\n\n        evm::log(ApprovalForAll {\n            owner,\n            operator,\n            approved,\n        });\n        Ok(())\n    }\n\n    /// Gets the account managing an NFT, or zero if unmanaged.\n    pub fn get_approved(&mut self, token_id: U256) -> Result<Address, Erc721Error> {\n        Ok(self.approved.get(token_id))\n    }\n\n    /// Determines if an account has been authorized to managing all of a user's NFTs.\n    pub fn is_approved_for_all(&mut self, owner: Address, operator: Address) -> Result<bool, Erc721Error> {\n        Ok(self.approved_for_all.getter(owner).get(operator))\n    }\n}",
      "src/lib.rs": "// Only run this as a WASM if the export-abi feature is not set.\n#![cfg_attr(not(any(feature = \"export-abi\", test)), no_main)]\nextern crate alloc;\n\n// Modules and imports\nmod erc721;\n\nuse alloy_primitives::{U256};\n/// Import the Stylus SDK along with alloy primitive types for use in our program.\nuse stylus_sdk::{\n    msg, prelude::*\n};\nuse crate::erc721::{Erc721, Erc721Params, Erc721Error};\n\n/// Initializes a custom, global allocator for Rust programs compiled to WASM.\n#[global_allocator]\nstatic ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;\n\nstruct StylusNFTParams;\n\n/// Immutable definitions\nimpl Erc721Params for StylusNFTParams {\n    const NAME: &'static str = \"StylusNFT\";\n    const SYMBOL: &'static str = \"SNFT\";\n\n    fn token_uri(token_id: U256) -> String {\n        format!(\"{}{}{}\", \"https://my-nft-metadata.com/\", token_id, \".json\")\n    }\n}\n\n// Define the entrypoint as a Solidity storage object. The sol_storage! macro\n// will generate Rust-equivalent structs with all fields mapped to Solidity-equivalent\n// storage slots and types.\nsol_storage! {\n    #[entrypoint]\n    struct StylusNFT {\n        #[borrow] // Allows erc721 to access MyToken's storage and make calls\n        Erc721<StylusNFTParams> erc721;\n    }\n}\n\n#[external]\n#[inherit(Erc721<StylusNFTParams>)]\nimpl StylusNFT {\n    /// Mints an NFT\n    pub fn mint(&mut self) -> Result<(), Erc721Error> {\n        let minter = msg::sender();\n        self.erc721.mint(minter)?;\n        Ok(())\n    }\n\n    /// Burns an NFT\n    pub fn burn(&mut self, token_id: U256) -> Result<(), Erc721Error> {\n        // This function checks that msg::sender() owns the specified token_id\n        self.erc721.burn(msg::sender(), token_id)?;\n        Ok(())\n    }\n}\n",
      "src/main.rs": "#[cfg(feature = \"export-abi\")]\nfn main() {\n    stylus_workshop_basic_nft::print_abi(\"MIT-OR-APACHE-2.0\", \"pragma solidity ^0.8.23;\");\n}"
    }
  },
  {
    "stylusVersion": "0.6.0",
    "project": "stylus_cupcake_example",
    "link": "https://github.com/OffchainLabs/stylus-vending-machine",
    "files": {
      "Cargo.toml": "[package]\nname = \"stylus_cupcake_example\"\nversion = \"0.1.7\"\nedition = \"2021\"\nlicense = \"MIT OR Apache-2.0\"\nkeywords = [\"arbitrum\", \"ethereum\", \"stylus\", \"alloy\"]\n\n[dependencies]\nalloy-primitives = \"=0.7.6\"\nalloy-sol-types = \"=0.7.6\"\nmini-alloc = \"0.4.2\"\nstylus-sdk = \"0.6.0\"\nhex = \"0.4.3\"\n\n[dev-dependencies]\ntokio = { version = \"1.12.0\", features = [\"full\"] }\nethers = \"2.0\"\neyre = \"0.6.8\"\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n\n[lib]\ncrate-type = [\"lib\", \"cdylib\"]\n\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"\n",
      "rust-toolchain.toml": "[toolchain]\nchannel = \"1.80.0\"",
      "src/lib.rs": "//!\n//! Stylus Cupcake Example\n//!\n//! The program is ABI-equivalent with Solidity, which means you can call it from both Solidity and Rust.\n//! To do this, run `cargo stylus export-abi`.\n//!\n//! Note: this code is a template-only and has not been audited.\n//!\n\n// Allow `cargo stylus export-abi` to generate a main function if the \"export-abi\" feature is enabled.\n#![cfg_attr(not(feature = \"export-abi\"), no_main)]\nextern crate alloc;\n\nuse alloy_primitives::{Address, Uint};\n// Import items from the SDK. The prelude contains common traits and macros.\nuse stylus_sdk::alloy_primitives::U256;\nuse stylus_sdk::prelude::*;\nuse stylus_sdk::{block, console};\n\n// Define persistent storage using the Solidity ABI.\n// `VendingMachine` will be the entrypoint for the contract.\nsol_storage! {\n    #[entrypoint]\n    pub struct VendingMachine {\n        // Mapping from user addresses to their cupcake balances.\n        mapping(address => uint256) cupcake_balances;\n        // Mapping from user addresses to the last time they received a cupcake.\n        mapping(address => uint256) cupcake_distribution_times;\n    }\n}\n\n// Declare that `VendingMachine` is a contract with the following external methods.\n#[public]\nimpl VendingMachine {\n    // Give a cupcake to the specified user if they are eligible (i.e., if at least 5 seconds have passed since their last cupcake).\n    pub fn give_cupcake_to(&mut self, user_address: Address) -> bool {\n        // Get the last distribution time for the user.\n        let last_distribution = self.cupcake_distribution_times.get(user_address);\n        // Calculate the earliest next time the user can receive a cupcake.\n        let five_seconds_from_last_distribution = last_distribution + U256::from(5);\n\n        // Get the current block timestamp.\n        let current_time = block::timestamp();\n        // Check if the user can receive a cupcake.\n        let user_can_receive_cupcake =\n            five_seconds_from_last_distribution <= Uint::<256, 4>::from(current_time);\n\n        if user_can_receive_cupcake {\n            // Increment the user's cupcake balance.\n            let mut balance_accessor = self.cupcake_balances.setter(user_address);\n            let balance = balance_accessor.get() + U256::from(1);\n            balance_accessor.set(balance);\n\n            // Update the distribution time to the current time.\n            let mut time_accessor = self.cupcake_distribution_times.setter(user_address);\n            let new_distribution_time = block::timestamp();\n            time_accessor.set(Uint::<256, 4>::from(new_distribution_time));\n            return true;\n        } else {\n            // User must wait before receiving another cupcake.\n            console!(\n                \"HTTP 429: Too Many Cupcakes (you must wait at least 5 seconds between cupcakes)\"\n            );\n            return false;\n        }\n    }\n\n    // Get the cupcake balance for the specified user.\n    pub fn get_cupcake_balance_for(&self, user_address: Address) -> Uint<256, 4> {\n        // Return the user's cupcake balance from storage.\n        return self.cupcake_balances.get(user_address);\n    }\n}\n",
      "src/main.rs": "#![cfg_attr(not(feature = \"export-abi\"), no_main)]\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    stylus_cupcake_example::print_abi(\"MIT-OR-APACHE-2.0\", \"pragma solidity ^0.8.23;\");\n}\n"
    }
  },
  {
    "stylusVersion": "0.6.0",
    "project": "stylus-counter",
    "link": "https://github.com/OffchainLabs/stylus-workshop-counter",
    "files": {
      "Cargo.toml": "[package]\nname = \"stylus-counter\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nstylus-sdk = { version = \"0.6.0\", default-features = false }\n\n[dev-dependencies]\nmotsu = \"0.1.0-rc\"\ne2e = { git = \"https://github.com/TucksonDev/e2e-lib.git\" }\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n\n[lib]\ncrate-type = [\"lib\", \"cdylib\"]\n\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"\n\n[workspace]\n",
      "rust-toolchain.toml": "[toolchain]\nchannel = \"1.80.0\"\n",
      "src/lib.rs": "// Allow `cargo stylus export-abi` to generate a main function.\nextern crate alloc;\n\n/// Import items from the SDK. The prelude contains common traits and macros.\nuse stylus_sdk::{\n  alloy_primitives::U256,\n  prelude::*,\n  storage::StorageU256,\n};\n\n/// The storage macro allows this struct to be used in persistent\n/// storage. It accepts fields that implement the StorageType trait. Built-in\n/// storage types for Solidity ABI primitives are found under\n/// stylus_sdk::storage.\n#[storage]\n/// The entrypoint macro defines where Stylus execution begins. External methods\n/// are exposed by annotating an impl for this struct with #[external] as seen\n/// below.\n#[entrypoint]\npub struct Counter {\n    number: StorageU256,\n}\n\n/// Declare that `Counter` is a contract with the following external methods.\n#[public]\nimpl Counter {\n    /// Gets the number from storage.\n    pub fn number(&self) -> U256 {\n        self.number.get()\n    }\n\n    /// Sets a number in storage to a user-specified value.\n    pub fn set_number(&mut self, new_number: U256) {\n        self.number.set(new_number);\n    }\n\n    /// Sets a number in storage to a user-specified value.\n    pub fn mul_number(&mut self, new_number: U256) {\n        self.number.set(new_number * self.number.get());\n    }\n\n    /// Sets a number in storage to a user-specified value.\n    pub fn add_number(&mut self, new_number: U256) {\n        self.number.set(new_number + self.number.get());\n    }\n\n    /// Increments `number` and updates its value in storage.\n    pub fn increment(&mut self) {\n        let number = self.number.get();\n        self.set_number(number + U256::from(1));\n    }\n}\n\n/// Unit tests\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[motsu::test]\n    fn it_gets_number(contract: Counter) {\n        let number = contract.number();\n        assert_eq!(U256::ZERO, number);\n    }\n\n    #[motsu::test]\n    fn it_sets_number(contract: Counter) {\n        contract.set_number(U256::from(5));\n        let number = contract.number();\n        assert_eq!(U256::from(5), number);\n    }\n\n    #[motsu::test]\n    fn it_multiplies(contract: Counter) {\n        contract.set_number(U256::from(5));\n        contract.mul_number(U256::from(2));\n        let number = contract.number();\n        assert_eq!(U256::from(10), number);\n    }\n\n    #[motsu::test]\n    fn it_adds(contract: Counter) {\n        contract.set_number(U256::from(5));\n        contract.add_number(U256::from(2));\n        let number = contract.number();\n        assert_eq!(U256::from(7), number);\n    }\n\n    #[motsu::test]\n    fn it_increments(contract: Counter) {\n        contract.set_number(U256::from(5));\n        contract.increment();\n        let number = contract.number();\n        assert_eq!(U256::from(6), number);\n    }\n}",
      "src/main.rs": "#![cfg_attr(not(feature = \"export-abi\"), no_main)]\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    stylus_counter::print_abi(\"MIT-OR-APACHE-2.0\", \"pragma solidity ^0.8.23;\");\n}",
      "tests/abi/mod.rs": "#![allow(dead_code)]\nuse e2e::alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract Counter {\n        function number() external view returns (uint256 number);\n        function setNumber(uint256 new_number) external;\n        function mulNumber(uint256 new_number) external;\n        function addNumber(uint256 new_number) external;\n        function increment() external;\n    }\n);\n",
      "tests/integration_tests.rs": "// e2e module\nuse e2e::{\n    Account,\n    ReceiptExt,\n    send,\n    alloy::{\n        primitives::{U256, utils::parse_ether},\n        providers::Provider,\n    },\n    eyre::Result,\n    tokio,\n};\n\n// Counter ABI\nuse abi::Counter;\nmod abi;\n\n// Test 1: Accounts are correctly funded\n#[e2e::test]\nasync fn accounts_are_funded(alice: Account) -> Result<()> {\n    let balance = alice.wallet.get_balance(alice.address()).await?;\n    let expected = parse_ether(\"100\")?;\n    assert_eq!(expected, balance);\n    Ok(())\n}\n\n// Test 2: Contract deploys correctly\n#[e2e::test]\nasync fn deploys(alice: Account) -> Result<()> {\n    let contract_addr = alice\n        .as_deployer()\n        .deploy()\n        .await?\n        .address()?;\n    let contract = Counter::new(contract_addr, &alice.wallet);\n    let Counter::numberReturn { number } = contract.number().call().await?;\n\n    assert_eq!(U256::ZERO, number);\n    Ok(())\n}\n\n// Test 3: Performs all operations\n#[e2e::test]\nasync fn performs_all_operations(alice: Account) -> Result<()> {\n    let contract_addr = alice\n        .as_deployer()\n        .deploy()\n        .await?\n        .address()?;\n    let contract = Counter::new(contract_addr, &alice.wallet);\n\n    // Number should be 0 on initialization\n    let Counter::numberReturn { number } = contract.number().call().await?;\n    assert_eq!(U256::ZERO, number);\n\n    // Incrementing\n    let _ = send!(contract.increment());\n    let Counter::numberReturn { number } = contract.number().call().await?;\n    assert_eq!(U256::from(1), number);\n\n    // Adding\n    let number_to_add = U256::from(5);\n    let _ = send!(contract.addNumber(number_to_add));\n    let Counter::numberReturn { number } = contract.number().call().await?;\n    assert_eq!(U256::from(6), number);\n\n    // Multiplying\n    let number_to_multiply = U256::from(2);\n    let _ = send!(contract.mulNumber(number_to_multiply));\n    let Counter::numberReturn { number } = contract.number().call().await?;\n    assert_eq!(U256::from(12), number);\n\n    // Setting new number\n    let number_to_set = U256::from(2);\n    let _ = send!(contract.setNumber(number_to_set));\n    let Counter::numberReturn { number } = contract.number().call().await?;\n    assert_eq!(number_to_set, number);\n\n    Ok(())\n}"
    }
  },
  {
    "stylusVersion": "0.6.0",
    "project": "stylus_cupcake_example",
    "link": "https://github.com/OffchainLabs/stylus-quickstart-vending-machine",
    "files": {
      "Cargo.toml": "[package]\nname = \"stylus_cupcake_example\"\nversion = \"0.1.7\"\nedition = \"2021\"\nlicense = \"MIT OR Apache-2.0\"\nkeywords = [\"arbitrum\", \"ethereum\", \"stylus\", \"alloy\"]\n\n[dependencies]\nalloy-primitives = \"=0.7.6\"\nalloy-sol-types = \"=0.7.6\"\nmini-alloc = \"0.4.2\"\nstylus-sdk = \"0.6.0\"\nhex = \"0.4.3\"\ndotenv = \"0.15\"\n\n[dev-dependencies]\ntokio = { version = \"1.12.0\", features = [\"full\"] }\nethers = \"2.0\"\neyre = \"0.6.8\"\nstylus-sdk = { version = \"0.6.0\", features = [\"export-abi\"] }\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n\n[lib]\ncrate-type = [\"lib\", \"cdylib\"]\n\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"",
      "examples/vending_machine.rs": "use ethers::{\n    middleware::SignerMiddleware,\n    prelude::abigen,\n    providers::{Http, Middleware, Provider},\n    signers::{LocalWallet, Signer},\n    types::Address,\n};\nuse eyre::eyre;\nuse std::io::{BufRead, BufReader};\nuse std::str::FromStr;\nuse std::sync::Arc;\nuse dotenv::dotenv;\nuse std::env;\n\n/// Your private key file path.\nconst PRIV_KEY_PATH: &str = \"PRIV_KEY_PATH\";\n\n/// Stylus RPC endpoint url.\nconst RPC_URL: &str = \"RPC_URL\";\n\n/// Deployed contract address.\nconst STYLUS_CONTRACT_ADDRESS: &str = \"STYLUS_CONTRACT_ADDRESS\";\nconst USER_ADDRESS: &str = \"USER_ADDRESS\";\n\n#[tokio::main]\nasync fn main() -> eyre::Result<()> {\n    // Load environment variables from .env file\n    dotenv().ok();\n\n    // Debugging: Print environment variables\n    println!(\"PRIV_KEY_PATH: {:?}\", env::var(PRIV_KEY_PATH));\n    println!(\"RPC_URL: {:?}\", env::var(RPC_URL));\n    println!(\"STYLUS_CONTRACT_ADDRESS: {:?}\", env::var(STYLUS_CONTRACT_ADDRESS));\n    println!(\"USER_ADDRESS: {:?}\", env::var(USER_ADDRESS));\n\n    let priv_key_path = env::var(PRIV_KEY_PATH).map_err(|_| eyre!(\"No {} env var set\", PRIV_KEY_PATH))?;\n    let rpc_url = env::var(RPC_URL).map_err(|_| eyre!(\"No {} env var set\", RPC_URL))?;\n    let contract_address = env::var(STYLUS_CONTRACT_ADDRESS)\n        .map_err(|_| eyre!(\"No {} env var set\", STYLUS_CONTRACT_ADDRESS))?;\n    let user_address_str = env::var(USER_ADDRESS).map_err(|_| eyre!(\"No {} env var set\", USER_ADDRESS))?;\n    let user_address: Address = user_address_str.parse().map_err(|e| eyre!(\"Failed to parse user address: {}\", e))?;\n\n    abigen!( //abigen! macro is used to generate type-safe bindings to the VendingMachine contract based on its ABI\n        VendingMachine,\n        r#\"[\n            function giveCupcakeTo(address user_address) external returns (bool)\n            function getCupcakeBalanceFor(address user_address) external view returns (uint256)\n        ]\"#\n    );\n\n    let provider = Provider::<Http>::try_from(rpc_url)?;\n    let address: Address = contract_address.parse()?;\n\n    let privkey = read_secret_from_file(&priv_key_path)?;\n    println!(\"Private key read from file: {}\", privkey); // Debugging line\n\n    let wallet = LocalWallet::from_str(&privkey)?;\n    let chain_id = provider.get_chainid().await?.as_u64();\n    let client = Arc::new(SignerMiddleware::new(\n        provider,\n        wallet.clone().with_chain_id(chain_id),\n    ));\n\n    let vending_machine = VendingMachine::new(address, client);\n\n    let balance = vending_machine.get_cupcake_balance_for(user_address).call().await?;\n    println!(\"User cupcake balance = {:?}\", balance);\n\n    let tx_receipt = vending_machine.give_cupcake_to(user_address).send().await?.await?;\n    match tx_receipt {\n        Some(receipt) => {\n            if receipt.status == Some(1.into()) {\n                println!(\"Successfully gave cupcake to user via a tx\");\n            } else {\n                println!(\"Failed to give cupcake to user, tx failed\");\n            }\n        }\n        None => {\n            println!(\"Failed to get transaction receipt\");\n        }\n    }\n\n    let balance = vending_machine.get_cupcake_balance_for(user_address).call().await?;\n    println!(\"New user cupcake balance = {:?}\", balance);\n\n    Ok(())\n}\n\nfn read_secret_from_file(fpath: &str) -> eyre::Result<String> {\n    let f = std::fs::File::open(fpath)?;\n    let mut buf_reader = BufReader::new(f);\n    let mut secret = String::new();\n    buf_reader.read_line(&mut secret)?;\n    Ok(secret.trim().to_string())\n}\n",
      "rust-toolchain.toml": "[toolchain]\nchannel = \"1.80.0\"",
      "src/lib.rs": "//!\n//! Stylus Cupcake Example\n//!\n//! The contract is ABI-equivalent with Solidity, which means you can call it from both Solidity and Rust.\n//! To do this, run `cargo stylus export-abi`.\n//!\n//! Note: this code is a template-only and has not been audited.\n//!\n\n// Allow `cargo stylus export-abi` to generate a main function if the \"export-abi\" feature is enabled.\n#![cfg_attr(not(feature = \"export-abi\"), no_main)]\nextern crate alloc;\n\nuse alloy_primitives::{Address, Uint};\n// Import items from the SDK. The prelude contains common traits and macros.\nuse stylus_sdk::alloy_primitives::U256;\nuse stylus_sdk::prelude::*;\nuse stylus_sdk::{block, console};\n\n// Define persistent storage using the Solidity ABI.\n// `VendingMachine` will be the entrypoint for the contract.\nsol_storage! {\n    #[entrypoint]\n    pub struct VendingMachine {\n        // Mapping from user addresses to their cupcake balances.\n        mapping(address => uint256) cupcake_balances;\n        // Mapping from user addresses to the last time they received a cupcake.\n        mapping(address => uint256) cupcake_distribution_times;\n    }\n}\n\n// Declare that `VendingMachine` is a contract with the following external methods.\n#[public]\nimpl VendingMachine {\n    // Give a cupcake to the specified user if they are eligible (i.e., if at least 5 seconds have passed since their last cupcake).\n    pub fn give_cupcake_to(&mut self, user_address: Address) -> bool {\n        // Get the last distribution time for the user.\n        let last_distribution = self.cupcake_distribution_times.get(user_address);\n        // Calculate the earliest next time the user can receive a cupcake.\n        let five_seconds_from_last_distribution = last_distribution + U256::from(5);\n\n        // Get the current block timestamp.\n        let current_time = block::timestamp();\n        // Check if the user can receive a cupcake.\n        let user_can_receive_cupcake =\n            five_seconds_from_last_distribution <= Uint::<256, 4>::from(current_time);\n\n        if user_can_receive_cupcake {\n            // Increment the user's cupcake balance.\n            let mut balance_accessor = self.cupcake_balances.setter(user_address);\n            let balance = balance_accessor.get() + U256::from(1);\n            balance_accessor.set(balance);\n\n            // Update the distribution time to the current time.\n            let mut time_accessor = self.cupcake_distribution_times.setter(user_address);\n            let new_distribution_time = block::timestamp();\n            time_accessor.set(Uint::<256, 4>::from(new_distribution_time));\n            return true;\n        } else {\n            // User must wait before receiving another cupcake.\n            console!(\n                \"HTTP 429: Too Many Cupcakes (you must wait at least 5 seconds between cupcakes)\"\n            );\n            return false;\n        }\n    }\n\n    // Get the cupcake balance for the specified user.\n    pub fn get_cupcake_balance_for(&self, user_address: Address) -> Uint<256, 4> {\n        // Return the user's cupcake balance from storage.\n        return self.cupcake_balances.get(user_address);\n    }\n}",
      "src/main.rs": "#![cfg_attr(not(feature = \"export-abi\"), no_main)]\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    stylus_cupcake_example::print_abi(\"MIT-OR-APACHE-2.0\", \"pragma solidity ^0.8.23;\");\n}"
    }
  },
  {
    "stylusVersion": "0.6.0",
    "project": "stylus-erc20",
    "link": "https://github.com/OffchainLabs/stylus-erc20",
    "files": {
      ".cargo/config.toml": "[target.wasm32-unknown-unknown]\nrustflags = [\n  \"-C\", \"link-arg=-zstack-size=32768\",\n]\n\n[target.aarch64-apple-darwin]\nrustflags = [\n\"-C\", \"link-arg=-undefined\",\n\"-C\", \"link-arg=dynamic_lookup\",\n]\n\n[target.x86_64-apple-darwin]\nrustflags = [\n\"-C\", \"link-arg=-undefined\",\n\"-C\", \"link-arg=dynamic_lookup\",\n]\n",
      "Cargo.toml": "[package]\nname = \"stylus-erc20\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nstylus-sdk = \"0.6.0\"\nmini-alloc = \"0.6.0\"\nalloy-primitives = \"=0.7.6\"\nalloy-sol-types = \"=0.7.6\"\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n\n[lib]\ncrate-type = [\"lib\", \"cdylib\"]\n\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"\n",
      "proxy/foundry.toml": "[profile.default]\nsrc = \"src\"\nout = \"out\"\nlibs = [\"lib\"]\nremappings = ['@openzeppelin/=lib/openzeppelin-contracts/']\n",
      "proxy/lib/forge-std/foundry.toml": "[profile.default]\nfs_permissions = [{ access = \"read-write\", path = \"./\"}]\n\n[rpc_endpoints]\n# The RPC URLs are modified versions of the default for testing initialization.\nmainnet = \"https://eth-mainnet.alchemyapi.io/v2/WV407BEiBmjNJfKo9Uo_55u0z0ITyCOX\" # Different API key.\noptimism_sepolia = \"https://sepolia.optimism.io/\" # Adds a trailing slash.\narbitrum_one_sepolia = \"https://sepolia-rollup.arbitrum.io/rpc/\" # Adds a trailing slash.\nneeds_undefined_env_var = \"${UNDEFINED_RPC_URL_PLACEHOLDER}\"\n\n[fmt]\n# These are all the `forge fmt` defaults.\nline_length = 120\ntab_width = 4\nbracket_spacing = false\nint_types = 'long'\nmultiline_func_header = 'attributes_first'\nquote_style = 'double'\nnumber_underscore = 'preserve'\nsingle_line_statement_blocks = 'preserve'\nignore = [\"src/console.sol\", \"src/console2.sol\"]",
      "proxy/lib/forge-std/test/fixtures/test.toml": "a = 123\nb = \"test\"\n\n[c]\na = 123\nb = \"test\"\n",
      "proxy/lib/openzeppelin-contracts/foundry.toml": "[profile.default]\nsrc = 'contracts'\nout = 'out'\nlibs = ['node_modules', 'lib']\ntest = 'test'\ncache_path  = 'cache_forge'\n\n[fuzz]\nruns = 10000\nmax_test_rejects = 150000\n",
      "proxy/lib/openzeppelin-contracts/lib/forge-std/foundry.toml": "[profile.default]\nfs_permissions = [{ access = \"read-write\", path = \"./\"}]\n\n[rpc_endpoints]\n# The RPC URLs are modified versions of the default for testing initialization.\nmainnet = \"https://mainnet.infura.io/v3/7a8769b798b642f6933f2ed52042bd70\" # Different API key.\noptimism_goerli = \"https://goerli.optimism.io/\" # Adds a trailing slash.\narbitrum_one_goerli = \"https://goerli-rollup.arbitrum.io/rpc/\" # Adds a trailing slash.\nneeds_undefined_env_var = \"${UNDEFINED_RPC_URL_PLACEHOLDER}\"\n\n[fmt]\n# These are all the `forge fmt` defaults.\nline_length = 120\ntab_width = 4\nbracket_spacing = false\nint_types = 'long'\nmultiline_func_header = 'attributes_first'\nquote_style = 'double'\nnumber_underscore = 'preserve'\nsingle_line_statement_blocks = 'preserve'\nignore = [\"src/console.sol\", \"src/console2.sol\"]",
      "proxy/lib/openzeppelin-contracts/netlify.toml": "[build]\ncommand = \"npm run docs\"\npublish = \"build/site\"\n",
      "rust-toolchain.toml": "[toolchain]\nchannel = \"1.80.0\"\n",
      "src/erc20.rs": "//! Implementation of the ERC-20 standard\n//!\n//! The eponymous [`Erc20`] type provides all the standard methods,\n//! and is intended to be inherited by other contract types.\n//!\n//! You can configure the behavior of [`Erc20`] via the [`Erc20Params`] trait,\n//! which allows specifying the name, symbol, and decimals of the token.\n//!\n//! Note that this code is unaudited and not fit for production use.\n\n// Imported packages\nuse alloy_primitives::{Address, U256};\nuse alloy_sol_types::sol;\nuse core::marker::PhantomData;\nuse stylus_sdk::{evm, msg, prelude::*};\n\npub trait Erc20Params {\n    /// Immutable token name\n    const NAME: &'static str;\n\n    /// Immutable token symbol\n    const SYMBOL: &'static str;\n\n    /// Immutable token decimals\n    const DECIMALS: u8;\n}\n\nsol_storage! {\n    /// Erc20 implements all ERC-20 methods.\n    pub struct Erc20<T> {\n        /// Maps users to balances\n        mapping(address => uint256) balances;\n        /// Maps users to a mapping of each spender's allowance\n        mapping(address => mapping(address => uint256)) allowances;\n        /// The total supply of the token\n        uint256 total_supply;\n        /// Used to allow [`Erc20Params`]\n        PhantomData<T> phantom;\n    }\n}\n\n// Declare events and Solidity error types\nsol! {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    error InsufficientBalance(address from, uint256 have, uint256 want);\n    error InsufficientAllowance(address owner, address spender, uint256 have, uint256 want);\n}\n\n/// Represents the ways methods may fail.\n#[derive(SolidityError)]\npub enum Erc20Error {\n    InsufficientBalance(InsufficientBalance),\n    InsufficientAllowance(InsufficientAllowance),\n}\n\n// These methods aren't exposed to other contracts\n// Methods marked as \"pub\" here are usable outside of the erc20 module (i.e. they're callable from lib.rs)\n// Note: modifying storage will become much prettier soon\nimpl<T: Erc20Params> Erc20<T> {\n    /// Movement of funds between 2 accounts\n    /// (invoked by the public transfer() and transfer_from() functions )\n    pub fn _transfer(&mut self, from: Address, to: Address, value: U256) -> Result<(), Erc20Error> {\n        // Decreasing sender balance\n        let mut sender_balance = self.balances.setter(from);\n        let old_sender_balance = sender_balance.get();\n        if old_sender_balance < value {\n            return Err(Erc20Error::InsufficientBalance(InsufficientBalance {\n                from,\n                have: old_sender_balance,\n                want: value,\n            }));\n        }\n        sender_balance.set(old_sender_balance - value);\n\n        // Increasing receiver balance\n        let mut to_balance = self.balances.setter(to);\n        let new_to_balance = to_balance.get() + value;\n        to_balance.set(new_to_balance);\n\n        // Emitting the transfer event\n        evm::log(Transfer { from, to, value });\n        Ok(())\n    }\n\n    /// Mints `value` tokens to `address`\n    pub fn mint(&mut self, address: Address, value: U256) -> Result<(), Erc20Error> {\n        // Increasing balance\n        let mut balance = self.balances.setter(address);\n        let new_balance = balance.get() + value;\n        balance.set(new_balance);\n\n        // Increasing total supply\n        self.total_supply.set(self.total_supply.get() + value);\n\n        // Emitting the transfer event\n        evm::log(Transfer {\n            from: Address::ZERO,\n            to: address,\n            value,\n        });\n\n        Ok(())\n    }\n\n    /// Burns `value` tokens from `address`\n    pub fn burn(&mut self, address: Address, value: U256) -> Result<(), Erc20Error> {\n        // Decreasing balance\n        let mut balance = self.balances.setter(address);\n        let old_balance = balance.get();\n        if old_balance < value {\n            return Err(Erc20Error::InsufficientBalance(InsufficientBalance {\n                from: address,\n                have: old_balance,\n                want: value,\n            }));\n        }\n        balance.set(old_balance - value);\n\n        // Decreasing the total supply\n        self.total_supply.set(self.total_supply.get() - value);\n\n        // Emitting the transfer event\n        evm::log(Transfer {\n            from: address,\n            to: Address::ZERO,\n            value,\n        });\n\n        Ok(())\n    }\n}\n\n// These methods are public to other contracts\n// Note: modifying storage will become much prettier soon\n#[public]\nimpl<T: Erc20Params> Erc20<T> {\n    /// Immutable token name\n    pub fn name() -> String {\n        T::NAME.into()\n    }\n\n    /// Immutable token symbol\n    pub fn symbol() -> String {\n        T::SYMBOL.into()\n    }\n\n    /// Immutable token decimals\n    pub fn decimals() -> u8 {\n        T::DECIMALS\n    }\n\n    /// Total supply of tokens\n    pub fn total_supply(&self) -> U256 {\n        self.total_supply.get()\n    }\n\n    /// Balance of `address`\n    pub fn balance_of(&self, owner: Address) -> U256 {\n        self.balances.get(owner)\n    }\n\n    /// Transfers `value` tokens from msg::sender() to `to`\n    pub fn transfer(&mut self, to: Address, value: U256) -> Result<bool, Erc20Error> {\n        self._transfer(msg::sender(), to, value)?;\n        Ok(true)\n    }\n\n    /// Transfers `value` tokens from `from` to `to`\n    /// (msg::sender() must be able to spend at least `value` tokens from `from`)\n    pub fn transfer_from(\n        &mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -> Result<bool, Erc20Error> {\n        // Check msg::sender() allowance\n        let mut sender_allowances = self.allowances.setter(from);\n        let mut allowance = sender_allowances.setter(msg::sender());\n        let old_allowance = allowance.get();\n        if old_allowance < value {\n            return Err(Erc20Error::InsufficientAllowance(InsufficientAllowance {\n                owner: from,\n                spender: msg::sender(),\n                have: old_allowance,\n                want: value,\n            }));\n        }\n\n        // Decreases allowance\n        allowance.set(old_allowance - value);\n\n        // Calls the internal transfer function\n        self._transfer(from, to, value)?;\n\n        Ok(true)\n    }\n\n    /// Approves the spenditure of `value` tokens of msg::sender() to `spender`\n    pub fn approve(&mut self, spender: Address, value: U256) -> bool {\n        self.allowances.setter(msg::sender()).insert(spender, value);\n        evm::log(Approval {\n            owner: msg::sender(),\n            spender,\n            value,\n        });\n        true\n    }\n\n    /// Returns the allowance of `spender` on `owner`'s tokens\n    pub fn allowance(&self, owner: Address, spender: Address) -> U256 {\n        self.allowances.getter(owner).get(spender)\n    }\n}",
      "src/lib.rs": "// Only run this as a WASM if the export-abi feature is not set.\n#![cfg_attr(not(any(feature = \"export-abi\", test)), no_main)]\nextern crate alloc;\n\n// Modules and imports\nmod erc20;\n\nuse crate::erc20::{Erc20, Erc20Error, Erc20Params};\nuse alloy_primitives::{Address, U256};\nuse stylus_sdk::{msg, prelude::*};\n\n/// Immutable definitions\nstruct StylusTestTokenParams;\nimpl Erc20Params for StylusTestTokenParams {\n    const NAME: &'static str = \"StylusTestToken\";\n    const SYMBOL: &'static str = \"STTK\";\n    const DECIMALS: u8 = 18;\n}\n\n// Define the entrypoint as a Solidity storage object. The sol_storage! macro\n// will generate Rust-equivalent structs with all fields mapped to Solidity-equivalent\n// storage slots and types.\nsol_storage! {\n    #[entrypoint]\n    struct StylusTestToken {\n        // Allows erc20 to access StylusTestToken's storage and make calls\n        #[borrow]\n        Erc20<StylusTestTokenParams> erc20;\n    }\n}\n\n#[public]\n#[inherit(Erc20<StylusTestTokenParams>)]\nimpl StylusTestToken {\n    /// Mints tokens\n    pub fn mint(&mut self, value: U256) -> Result<(), Erc20Error> {\n        self.erc20.mint(msg::sender(), value)?;\n        Ok(())\n    }\n\n    /// Mints tokens to another address\n    pub fn mint_to(&mut self, to: Address, value: U256) -> Result<(), Erc20Error> {\n        self.erc20.mint(to, value)?;\n        Ok(())\n    }\n\n    /// Burns tokens\n    pub fn burn(&mut self, value: U256) -> Result<(), Erc20Error> {\n        self.erc20.burn(msg::sender(), value)?;\n        Ok(())\n    }\n}\n",
      "src/main.rs": "#[cfg(feature = \"export-abi\")]\nfn main() {\n    stylus_erc20::print_abi(\"MIT-OR-APACHE-2.0\", \"pragma solidity ^0.8.23;\");\n}"
    }
  },
  {
    "stylusVersion": "0.5.0",
    "project": "stylus-erc721",
    "link": "https://github.com/OffchainLabs/stylus-erc721",
    "files": {
      ".cargo/config.toml": "[target.wasm32-unknown-unknown]\nrustflags = [\n  \"-C\", \"link-arg=-zstack-size=32768\",\n]\n\n[target.aarch64-apple-darwin]\nrustflags = [\n\"-C\", \"link-arg=-undefined\",\n\"-C\", \"link-arg=dynamic_lookup\",\n]\n\n[target.x86_64-apple-darwin]\nrustflags = [\n\"-C\", \"link-arg=-undefined\",\n\"-C\", \"link-arg=dynamic_lookup\",\n]\n",
      "Cargo.toml": "[package]\nname = \"stylus-erc721\"\nversion = \"0.1.0\"\nedition = \"2021\"\nlicense = \"MIT OR Apache-2.0\"\n\n[dependencies]\nstylus-sdk = \"0.5.0\"\nmini-alloc = \"0.4.2\"\nalloy-primitives = \"0.3.1\"\nalloy-sol-types = \"0.3.1\"\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n\n[lib]\ncrate-type = [\"lib\", \"cdylib\"]\n\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"\n",
      "proxy/foundry.toml": "[profile.default]\nsrc = \"src\"\nout = \"out\"\nlibs = [\"lib\"]\nremappings = ['@openzeppelin/=lib/openzeppelin-contracts/']\n",
      "proxy/lib/forge-std/foundry.toml": "[profile.default]\nfs_permissions = [{ access = \"read-write\", path = \"./\"}]\n\n[rpc_endpoints]\n# The RPC URLs are modified versions of the default for testing initialization.\nmainnet = \"https://eth-mainnet.alchemyapi.io/v2/WV407BEiBmjNJfKo9Uo_55u0z0ITyCOX\" # Different API key.\noptimism_sepolia = \"https://sepolia.optimism.io/\" # Adds a trailing slash.\narbitrum_one_sepolia = \"https://sepolia-rollup.arbitrum.io/rpc/\" # Adds a trailing slash.\nneeds_undefined_env_var = \"${UNDEFINED_RPC_URL_PLACEHOLDER}\"\n\n[fmt]\n# These are all the `forge fmt` defaults.\nline_length = 120\ntab_width = 4\nbracket_spacing = false\nint_types = 'long'\nmultiline_func_header = 'attributes_first'\nquote_style = 'double'\nnumber_underscore = 'preserve'\nsingle_line_statement_blocks = 'preserve'\nignore = [\"src/console.sol\", \"src/console2.sol\"]",
      "proxy/lib/forge-std/test/fixtures/test.toml": "a = 123\nb = \"test\"\n\n[c]\na = 123\nb = \"test\"\n",
      "proxy/lib/openzeppelin-contracts/foundry.toml": "[profile.default]\nsrc = 'contracts'\nout = 'out'\nlibs = ['node_modules', 'lib']\ntest = 'test'\ncache_path  = 'cache_forge'\n\n[fuzz]\nruns = 10000\nmax_test_rejects = 150000\n",
      "proxy/lib/openzeppelin-contracts/lib/forge-std/foundry.toml": "[profile.default]\nfs_permissions = [{ access = \"read-write\", path = \"./\"}]\n\n[rpc_endpoints]\n# The RPC URLs are modified versions of the default for testing initialization.\nmainnet = \"https://mainnet.infura.io/v3/7a8769b798b642f6933f2ed52042bd70\" # Different API key.\noptimism_goerli = \"https://goerli.optimism.io/\" # Adds a trailing slash.\narbitrum_one_goerli = \"https://goerli-rollup.arbitrum.io/rpc/\" # Adds a trailing slash.\nneeds_undefined_env_var = \"${UNDEFINED_RPC_URL_PLACEHOLDER}\"\n\n[fmt]\n# These are all the `forge fmt` defaults.\nline_length = 120\ntab_width = 4\nbracket_spacing = false\nint_types = 'long'\nmultiline_func_header = 'attributes_first'\nquote_style = 'double'\nnumber_underscore = 'preserve'\nsingle_line_statement_blocks = 'preserve'\nignore = [\"src/console.sol\", \"src/console2.sol\"]",
      "proxy/lib/openzeppelin-contracts/netlify.toml": "[build]\ncommand = \"npm run docs\"\npublish = \"build/site\"\n",
      "src/erc721.rs": "//! Implementation of the ERC-721 standard\n//!\n//! The eponymous [`Erc721`] type provides all the standard methods,\n//! and is intended to be inherited by other contract types.\n//!\n//! You can configure the behavior of [`Erc721`] via the [`Erc721Params`] trait,\n//! which allows specifying the name, symbol, and token uri.\n//!\n//! Note that this code is unaudited and not fit for production use.\n\nuse alloc::{string::String, vec, vec::Vec};\nuse alloy_primitives::{Address, U256, FixedBytes};\nuse alloy_sol_types::sol;\nuse core::{borrow::BorrowMut, marker::PhantomData};\nuse stylus_sdk::{\n    abi::Bytes,\n    evm,\n    msg,\n    prelude::*\n};\n\npub trait Erc721Params {\n    /// Immutable NFT name.\n    const NAME: &'static str;\n\n    /// Immutable NFT symbol.\n    const SYMBOL: &'static str;\n\n    /// The NFT's Uniform Resource Identifier.\n    fn token_uri(token_id: U256) -> String;\n}\n\nsol_storage! {\n    /// Erc721 implements all ERC-721 methods\n    pub struct Erc721<T: Erc721Params> {\n        /// Token id to owner map\n        mapping(uint256 => address) owners;\n        /// User to balance map\n        mapping(address => uint256) balances;\n        /// Token id to approved user map\n        mapping(uint256 => address) token_approvals;\n        /// User to operator map (the operator can manage all NFTs of the owner)\n        mapping(address => mapping(address => bool)) operator_approvals;\n        /// Total supply\n        uint256 total_supply;\n        /// Used to allow [`Erc721Params`]\n        PhantomData<T> phantom;\n    }\n}\n\n// Declare events and Solidity error types\nsol! {\n    event Transfer(address indexed from, address indexed to, uint256 indexed token_id);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed token_id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    // Token id has not been minted, or it has been burned\n    error InvalidTokenId(uint256 token_id);\n    // The specified address is not the owner of the specified token id\n    error NotOwner(address from, uint256 token_id, address real_owner);\n    // The specified address does not have allowance to spend the specified token id\n    error NotApproved(address owner, address spender, uint256 token_id);\n    // Attempt to transfer token id to the Zero address\n    error TransferToZero(uint256 token_id);\n    // The receiver address refused to receive the specified token id\n    error ReceiverRefused(address receiver, uint256 token_id, bytes4 returned);\n}\n\n/// Represents the ways methods may fail.\n#[derive(SolidityError)]\npub enum Erc721Error {\n    InvalidTokenId(InvalidTokenId),\n    NotOwner(NotOwner),\n    NotApproved(NotApproved),\n    TransferToZero(TransferToZero),\n    ReceiverRefused(ReceiverRefused),\n}\n\n// External interfaces\nsol_interface! {\n    /// Allows calls to the `onERC721Received` method of other contracts implementing `IERC721TokenReceiver`.\n    interface IERC721TokenReceiver {\n        function onERC721Received(address operator, address from, uint256 token_id, bytes data) external returns(bytes4);\n    }\n}\n\n/// Selector for `onERC721Received`, which is returned by contracts implementing `IERC721TokenReceiver`.\nconst ERC721_TOKEN_RECEIVER_ID: u32 = 0x150b7a02;\n\n// These methods aren't external, but are helpers used by external methods.\n// Methods marked as \"pub\" here are usable outside of the erc721 module (i.e. they're callable from lib.rs).\nimpl<T: Erc721Params> Erc721<T> {\n    /// Requires that msg::sender() is authorized to spend a given token\n    fn require_authorized_to_spend(&self, from: Address, token_id: U256) -> Result<(), Erc721Error> {\n        // `from` must be the owner of the token_id\n        let owner = self.owner_of(token_id)?;\n        if from != owner {\n            return Err(Erc721Error::NotOwner(NotOwner {\n                from,\n                token_id,\n                real_owner: owner,\n            }));\n        }\n\n        // caller is the owner\n        if msg::sender() == owner {\n            return Ok(());\n        }\n\n        // caller is an operator for the owner (can manage their tokens)\n        if self.operator_approvals.getter(owner).get(msg::sender()) {\n            return Ok(());\n        }\n\n        // caller is approved to manage this token_id\n        if msg::sender() == self.token_approvals.get(token_id) {\n            return Ok(());\n        }\n\n        // otherwise, caller is not allowed to manage this token_id\n        Err(Erc721Error::NotApproved(NotApproved {\n            owner,\n            spender: msg::sender(),\n            token_id,\n        }))\n    }\n\n    /// Transfers `token_id` from `from` to `to`.\n    /// This function does check that `from` is the owner of the token, but it does not check\n    /// that `to` is not the zero address, as this function is usable for burning.\n    pub fn transfer(&mut self, token_id: U256, from: Address, to: Address) -> Result<(), Erc721Error> {\n        let mut owner = self.owners.setter(token_id);\n        let previous_owner = owner.get();\n        if previous_owner != from {\n            return Err(Erc721Error::NotOwner(NotOwner {\n                from,\n                token_id,\n                real_owner: previous_owner,\n            }));\n        }\n        owner.set(to);\n\n        // right now working with storage can be verbose, but this will change upcoming version of the Stylus SDK\n        let mut from_balance = self.balances.setter(from);\n        let balance = from_balance.get() - U256::from(1);\n        from_balance.set(balance);\n\n        let mut to_balance = self.balances.setter(to);\n        let balance = to_balance.get() + U256::from(1);\n        to_balance.set(balance);\n\n        // cleaning app the approved mapping for this token\n        self.token_approvals.delete(token_id);\n        \n        evm::log(Transfer { from, to, token_id });\n        Ok(())\n    }\n\n    /// Calls `onERC721Received` on the `to` address if it is a contract.\n    /// Otherwise it does nothing\n    fn call_receiver<S: TopLevelStorage>(\n        storage: &mut S,\n        token_id: U256,\n        from: Address,\n        to: Address,\n        data: Vec<u8>,\n    ) -> Result<(), Erc721Error> {\n        if to.has_code() {\n            let receiver = IERC721TokenReceiver::new(to);\n            let received = receiver\n                .on_erc_721_received(&mut *storage, msg::sender(), from, token_id, data)\n                .map_err(|_e| Erc721Error::ReceiverRefused(ReceiverRefused {\n                    receiver: receiver.address,\n                    token_id,\n                    returned: 0_u32.to_be_bytes(),\n                }))?\n                .0;\n\n            if u32::from_be_bytes(received) != ERC721_TOKEN_RECEIVER_ID {\n                return Err(Erc721Error::ReceiverRefused(ReceiverRefused {\n                    receiver: receiver.address,\n                    token_id,\n                    returned: received,\n                }));\n            }\n        }\n        Ok(())\n    }\n\n    /// Transfers and calls `onERC721Received`\n    pub fn safe_transfer<S: TopLevelStorage + BorrowMut<Self>>(\n        storage: &mut S,\n        token_id: U256,\n        from: Address,\n        to: Address,\n        data: Vec<u8>,\n    ) -> Result<(), Erc721Error> {\n        storage.borrow_mut().transfer(token_id, from, to)?;\n        Self::call_receiver(storage, token_id, from, to, data)\n    }\n\n    /// Mints a new token and transfers it to `to`\n    pub fn mint(&mut self, to: Address) -> Result<(), Erc721Error> {\n        let new_token_id = self.total_supply.get();\n        self.total_supply.set(new_token_id + U256::from(1u8));\n        self.transfer(new_token_id, Address::default(), to)?;\n        Ok(())\n    }\n\n    /// Burns the token `token_id` from `from`\n    /// Note that total_supply is not reduced since it's used to calculate the next token_id to mint\n    pub fn burn(&mut self, from: Address, token_id: U256) -> Result<(), Erc721Error> {\n        self.transfer(token_id, from, Address::default())?;\n        Ok(())\n    }\n}\n\n// these methods are external to other contracts\n#[external]\nimpl<T: Erc721Params> Erc721<T> {\n    /// Immutable NFT name.\n    pub fn name() -> Result<String, Erc721Error> {\n        Ok(T::NAME.into())\n    }\n\n    /// Immutable NFT symbol.\n    pub fn symbol() -> Result<String, Erc721Error> {\n        Ok(T::SYMBOL.into())\n    }\n\n    /// The NFT's Uniform Resource Identifier.\n    #[selector(name = \"tokenURI\")]\n    pub fn token_uri(&self, token_id: U256) -> Result<String, Erc721Error> {\n        self.owner_of(token_id)?; // require NFT exist\n        Ok(T::token_uri(token_id))\n    }\n\n    /// Gets the number of NFTs owned by an account.\n    pub fn balance_of(&self, owner: Address) -> Result<U256, Erc721Error> {\n        Ok(self.balances.get(owner))\n    }\n\n    /// Gets the owner of the NFT, if it exists.\n    pub fn owner_of(&self, token_id: U256) -> Result<Address, Erc721Error> {\n        let owner = self.owners.get(token_id);\n        if owner.is_zero() {\n            return Err(Erc721Error::InvalidTokenId(InvalidTokenId { token_id }));\n        }\n        Ok(owner)\n    }\n\n    /// Transfers an NFT, but only after checking the `to` address can receive the NFT.\n    /// It includes additional data for the receiver.\n    #[selector(name = \"safeTransferFrom\")]\n    pub fn safe_transfer_from_with_data<S: TopLevelStorage + BorrowMut<Self>>(\n        storage: &mut S,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -> Result<(), Erc721Error> {\n        if to.is_zero() {\n            return Err(Erc721Error::TransferToZero(TransferToZero { token_id }));\n        }\n        storage\n            .borrow_mut()\n            .require_authorized_to_spend(from, token_id)?;\n\n        Self::safe_transfer(storage, token_id, from, to, data.0)\n    }\n\n    /// Equivalent to [`safe_transfer_from_with_data`], but without the additional data.\n    ///\n    /// Note: because Rust doesn't allow multiple methods with the same name,\n    /// we use the `#[selector]` macro attribute to simulate solidity overloading.\n    #[selector(name = \"safeTransferFrom\")]\n    pub fn safe_transfer_from<S: TopLevelStorage + BorrowMut<Self>>(\n        storage: &mut S,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -> Result<(), Erc721Error> {\n        Self::safe_transfer_from_with_data(storage, from, to, token_id, Bytes(vec![]))\n    }\n\n    /// Transfers the NFT.\n    pub fn transfer_from(&mut self, from: Address, to: Address, token_id: U256) -> Result<(), Erc721Error> {\n        if to.is_zero() {\n            return Err(Erc721Error::TransferToZero(TransferToZero { token_id }));\n        }\n        self.require_authorized_to_spend(from, token_id)?;\n        self.transfer(token_id, from, to)?;\n        Ok(())\n    }\n\n    /// Grants an account the ability to manage the sender's NFT.\n    pub fn approve(&mut self, approved: Address, token_id: U256) -> Result<(), Erc721Error> {\n        let owner = self.owner_of(token_id)?;\n\n        // require authorization\n        if msg::sender() != owner && !self.operator_approvals.getter(owner).get(msg::sender()) {\n            return Err(Erc721Error::NotApproved(NotApproved {\n                owner,\n                spender: msg::sender(),\n                token_id,\n            }));\n        }\n        self.token_approvals.insert(token_id, approved);\n\n        evm::log(Approval {\n            approved,\n            owner,\n            token_id,\n        });\n        Ok(())\n    }\n\n    /// Grants an account the ability to manage all of the sender's NFTs.\n    pub fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<(), Erc721Error> {\n        let owner = msg::sender();\n        self.operator_approvals\n            .setter(owner)\n            .insert(operator, approved);\n\n        evm::log(ApprovalForAll {\n            owner,\n            operator,\n            approved,\n        });\n        Ok(())\n    }\n\n    /// Gets the account managing an NFT, or zero if unmanaged.\n    pub fn get_approved(&mut self, token_id: U256) -> Result<Address, Erc721Error> {\n        Ok(self.token_approvals.get(token_id))\n    }\n\n    /// Determines if an account has been authorized to managing all of a user's NFTs.\n    pub fn is_approved_for_all(&mut self, owner: Address, operator: Address) -> Result<bool, Erc721Error> {\n        Ok(self.operator_approvals.getter(owner).get(operator))\n    }\n\n    /// Whether the NFT supports a given standard.\n    pub fn supports_interface(interface: FixedBytes<4>) -> Result<bool, Erc721Error> {\n        let interface_slice_array: [u8; 4] = interface.as_slice().try_into().unwrap();\n\n        if u32::from_be_bytes(interface_slice_array) == 0xffffffff {\n            // special cased in the ERC165 standard\n            return Ok(false);\n        }\n\n        const IERC165: u32 = 0x01ffc9a7;\n        const IERC721: u32 = 0x80ac58cd;\n        const IERC721_METADATA: u32 = 0x5b5e139f;\n\n        Ok(matches!(u32::from_be_bytes(interface_slice_array), IERC165 | IERC721 | IERC721_METADATA))\n    }\n}",
      "src/lib.rs": "// Only run this as a WASM if the export-abi feature is not set.\n#![cfg_attr(not(any(feature = \"export-abi\", test)), no_main)]\nextern crate alloc;\n\n// Modules and imports\nmod erc721;\n\nuse alloy_primitives::{U256, Address};\n/// Import the Stylus SDK along with alloy primitive types for use in our program.\nuse stylus_sdk::{\n    msg, prelude::*\n};\nuse crate::erc721::{Erc721, Erc721Params, Erc721Error};\n\n/// Initializes a custom, global allocator for Rust programs compiled to WASM.\n#[global_allocator]\nstatic ALLOC: mini_alloc::MiniAlloc = mini_alloc::MiniAlloc::INIT;\n\n/// Immutable definitions\nstruct StylusNFTParams;\nimpl Erc721Params for StylusNFTParams {\n    const NAME: &'static str = \"StylusNFT\";\n    const SYMBOL: &'static str = \"SNFT\";\n\n    fn token_uri(token_id: U256) -> String {\n        format!(\"{}{}{}\", \"https://my-nft-metadata.com/\", token_id, \".json\")\n    }\n}\n\n// Define the entrypoint as a Solidity storage object. The sol_storage! macro\n// will generate Rust-equivalent structs with all fields mapped to Solidity-equivalent\n// storage slots and types.\nsol_storage! {\n    #[entrypoint]\n    struct StylusNFT {\n        #[borrow] // Allows erc721 to access StylusNFT's storage and make calls\n        Erc721<StylusNFTParams> erc721;\n    }\n}\n\n#[external]\n#[inherit(Erc721<StylusNFTParams>)]\nimpl StylusNFT {\n    /// Mints an NFT\n    pub fn mint(&mut self) -> Result<(), Erc721Error> {\n        let minter = msg::sender();\n        self.erc721.mint(minter)?;\n        Ok(())\n    }\n\n    /// Mints an NFT to another address\n    pub fn mint_to(&mut self, to: Address) -> Result<(), Erc721Error> {\n        self.erc721.mint(to)?;\n        Ok(())\n    }\n\n    /// Burns an NFT\n    pub fn burn(&mut self, token_id: U256) -> Result<(), Erc721Error> {\n        // This function checks that msg::sender() owns the specified token_id\n        self.erc721.burn(msg::sender(), token_id)?;\n        Ok(())\n    }\n\n    /// Total supply\n    pub fn total_supply(&mut self) -> Result<U256, Erc721Error> {\n        Ok(self.erc721.total_supply.get())\n    }\n}",
      "src/main.rs": "#[cfg(feature = \"export-abi\")]\nfn main() {\n    stylus_erc721::print_abi(\"MIT-OR-APACHE-2.0\", \"pragma solidity ^0.8.23;\");\n}"
    }
  },
  {
    "stylusVersion": "0.2.4",
    "project": "stylus-hello-world",
    "link": "https://github.com/ggonzalez94/stylus-pausable/",
    "files": {
      "Cargo.toml": "[package]\nname = \"stylus-hello-world\"\nversion = \"0.1.4\"\nedition = \"2021\"\nlicense = \"MIT OR Apache-2.0\"\nhomepage = \"https://github.com/OffchainLabs/stylus-hello-world\"\nrepository = \"https://github.com/OffchainLabs/stylus-hello-world\"\nkeywords = [\"arbitrum\", \"ethereum\", \"stylus\", \"alloy\"]\ndescription = \"Stylus hello world example\"\n\n[dependencies]\nalloy-primitives = \"0.3.1\"\nalloy-sol-types = \"0.3.1\"\nstylus-sdk = \"0.2.4\"\nhex = \"0.4.3\"\nwee_alloc = \"0.4.5\"\n\n[dev-dependencies]\ntokio = { version = \"1.12.0\", features = [\"full\"] } \nethers = \"2.0\"\neyre = \"0.6.8\"\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"\n",
      "src/lib.rs": "\n// Only run this as a WASM if the export-abi feature is not set.\n#![cfg_attr(not(feature = \"export-abi\"), no_main)]\nextern crate alloc;\n\n/// Initializes a custom, global allocator for Rust programs compiled to WASM.\n#[global_allocator]\nstatic ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;\n\n/// Import the Stylus SDK along with alloy primitive types for use in our program.\nuse stylus_sdk::{alloy_primitives::U256, prelude::*};\nuse crate::pausable::Pausable;\nuse crate::ownable::Ownable;\n\nmod pausable;\nmod ownable;\n\nsol_storage! {\n    #[entrypoint]\n    pub struct Counter {\n        #[borrow]\n        Pausable pausable;\n        #[borrow]\n        Ownable ownable;\n        uint256 number;\n    }\n}\n\n/// Implementation of the Counter struct. Inherits from Ownable and Pausable to allow ony the owner to pause the contract.\n#[external]\n#[inherit(Pausable, Ownable)]\nimpl Counter {\n    /// Gets the number from storage.\n    pub fn number(&self) -> Result<U256, Vec<u8>> {\n        Ok(self.number.get())\n    }\n\n    /// Sets a number in storage to a user-specified value.\n    pub fn set_number(&mut self, new_number: U256) -> Result<(), Vec<u8>> {\n        self.pausable.when_not_paused()?; //modifiers are nto available so we use functions\n        self.number.set(new_number);\n        Ok(())\n    }\n\n    /// Increments number and updates it values in storage.\n    pub fn increment(&mut self) -> Result<(), Vec<u8>> {\n        self.pausable.when_not_paused()?; //modifiers are nto available so we use functions\n        let number = self.number.get();\n        self.number.set(number + U256::from(1));\n        Ok(())\n    }\n\n    /// Pauses the contract.\n    pub fn pause(&mut self) -> Result<(), Vec<u8>> {\n        self.ownable.only_owner()?;\n        self.pausable.pause()?;\n        Ok(())\n    }\n\n    /// Unpauses the contract.\n    pub fn unpause(&mut self) -> Result<(), Vec<u8>> {\n        self.ownable.only_owner()?;\n        self.pausable.unpause()?;\n        Ok(())\n    }\n}\n",
      "src/ownable.rs": "use alloc::{vec::Vec};\nuse stylus_sdk::{\n    alloy_primitives::{Address},\n    alloy_sol_types::{sol, SolError},\n    evm, msg,\n    prelude::*,\n};\n\nconst ZERO_ADDRESS : Address = Address::ZERO;\n\nsol_storage! {\n    pub struct Ownable {\n        address owner;\n        bool initialized;\n    }\n}\n\n// Declare events and Solidity error types\nsol! {\n    event OwnershipTransferred(address indexed previous_owner, address indexed new_owner);\n\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    error OwnableAlreadyInitialized();\n}\n\npub enum OwnableError {\n    OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),\n    OwnableInvalidOwner(OwnableInvalidOwner),\n    OwnableAlreadyInitialized(OwnableAlreadyInitialized),\n}\n\nimpl From<OwnableError> for Vec<u8> {\n    fn from(err: OwnableError) -> Vec<u8> {\n        match err {\n            OwnableError::OwnableUnauthorizedAccount(e) => e.encode(),\n            OwnableError::OwnableInvalidOwner(e) => e.encode(),\n            OwnableError::OwnableAlreadyInitialized(e) => e.encode(),\n        }\n    }\n}\n\n// Internal methods\nimpl Ownable {\n    pub fn only_owner(\n        &mut self,\n    ) -> Result<(), OwnableError> {\n        if msg::sender() != self.owner.get() {\n            return Err(OwnableError::OwnableUnauthorizedAccount(OwnableUnauthorizedAccount {\n                account: msg::sender()\n            }))\n        }\n\n        Ok(())\n    }\n\n    pub fn transfer_ownership_impl(\n        &mut self,\n        new_owner: Address,\n    ) {\n        let old_owner  = self.owner.get();\n        self.owner.set(new_owner);\n        evm::log(OwnershipTransferred {\n            previous_owner: old_owner,\n            new_owner: new_owner\n        });\n    }\n}\n\n// External methods\n#[external]\nimpl Ownable {\n    pub fn renounce_ownership(&mut self) -> Result<(), OwnableError> {\n        self.only_owner()?;\n\n        self.transfer_ownership_impl(ZERO_ADDRESS);\n        Ok(())\n    }\n\n    pub fn transfer_ownership(&mut self, new_owner: Address) -> Result<(), OwnableError> {\n        self.only_owner()?;\n        self.transfer_ownership_impl(new_owner);\n        Ok(())\n    }\n\n    pub fn owner(&self) -> Result<Address, Vec<u8>>  {\n        Ok(self.owner.get())\n    }\n\n    pub fn initialize(&mut self, initial_owner: Address) -> Result<(), OwnableError> {\n        if (self.initialized.get()) {\n            return Err(OwnableError::OwnableAlreadyInitialized(OwnableAlreadyInitialized {}));\n        }\n        if (initial_owner == ZERO_ADDRESS) {\n            return Err(OwnableError::OwnableInvalidOwner(OwnableInvalidOwner {\n                owner: initial_owner\n            }));\n        }\n        self.transfer_ownership_impl(initial_owner);\n        self.initialized.set(true);\n        Ok(())\n    }\n}",
      "src/pausable.rs": "use stylus_sdk::{\n    evm, msg,\n    prelude::*,\n    alloy_sol_types::{sol, SolError},\n};\n\n// Declare events and error types\nsol! {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    error EnforcedPause();\n    error ExpectedPause();\n}\n\nsol_storage! {\n    pub struct Pausable {\n        /// Indicates whether the contract is paused\n        bool paused;\n    }\n}\n\npub enum PausableError {\n    EnforcedPause(EnforcedPause),\n    ExpectedPause(ExpectedPause),\n}\n\n// There will soon be a better way to deal with Custom errors, but for now this is the best way\nimpl From<PausableError> for Vec<u8> {\n    fn from(err: PausableError) -> Vec<u8> {\n        match err {\n            PausableError::EnforcedPause(e) => e.encode(),\n            PausableError::ExpectedPause(e) => e.encode(),\n        }\n    }\n}\n\n// Internal methods\nimpl Pausable {\n\n    pub fn when_not_paused(&self) -> Result<(), PausableError>{\n        if self.paused.get() {\n            return Err(PausableError::EnforcedPause(EnforcedPause {}));\n        }\n        Ok(())\n    }\n\n    pub fn when_paused(&self) -> Result<(), PausableError>{\n        if !self.paused.get() {\n            return Err(PausableError::ExpectedPause(ExpectedPause {}));\n        }\n        Ok(())\n    }\n\n    // Internal function to pause the contract\n    pub fn pause(&mut self) -> Result<(), PausableError> {\n        self.when_not_paused()?;\n        self.paused.set(true);\n        evm::log(Paused { account: msg::sender() });\n        Ok(())\n    }\n\n    // Internal function to unpause the contract\n    pub fn unpause(&mut self) -> Result<(), PausableError> {\n        self.when_paused()?;\n        self.paused.set(false);\n        evm::log(Unpaused { account: msg::sender() });\n        Ok(())\n    }\n\n}\n\n// External methods\n#[external]\nimpl Pausable {\n    // Check if the contract is paused; for external callers\n    pub fn paused(&self) -> Result<(bool), PausableError> {\n        Ok(self.paused.get())\n    }\n}"
    }
  },
  {
    "stylusVersion": "0.4.1",
    "project": "stylus-benchmark",
    "link": "https://github.com/LimeChain/stylus-benchmark-old",
    "files": {
      "Cargo.toml": "[package]\nname = \"stylus-benchmark\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nalloy-sol-types = \"0.3.1\"\nalloy-primitives = \"0.3.1\"\nstylus-sdk = \"0.4.1\"\nwee_alloc = \"0.4.5\"\nstylus-toolkit = { git = \"https://github.com/LimeChain/stylus-toolkit.git\", branch = \"main\" }\n\n# [[bin]]\n# name = \"erc20\"\n# path = \"src/erc20_benchmark.rs\"\n\n[[bin]]\nname = \"ed25519\"\npath = \"src/ed25519_verify_benchmark.rs\"\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"\n\n[workspace]\n",
      "src/ed25519_verify_benchmark.rs": "// Only run this as a WASM if the export-abi feature is not set.\n#![cfg_attr(not(feature = \"export-abi\"), no_main)]\nextern crate alloc;\nuse alloc::vec::Vec;\nuse alloy_primitives::FixedBytes;\nuse stylus_sdk::{\n    abi::Bytes,\n    alloy_sol_types::{sol, SolError},\n    evm,\n    prelude::*,\n    stylus_proc::entrypoint,\n};\nuse stylus_toolkit::crypto::ed25519::ed25519_verify;\n\nsol_storage! {\n    #[entrypoint]\n    struct Ed25519VerifyBenchmark { }\n}\n\nsol! {\n    event VerificationResult(bool success);\n}\n\n#[external]\nimpl Ed25519VerifyBenchmark {\n    pub fn verify(\n        &mut self,\n        msg: Bytes,\n        signature: Bytes,\n        public_key: FixedBytes<32>,\n    ) -> Result<(), Vec<u8>> {\n        let result = ed25519_verify(public_key, signature, msg);\n        evm::log(VerificationResult { success: result });\n        Ok(())\n    }\n}\n",
      "src/erc20_benchmark.rs": "// Only run this as a WASM if the export-abi feature is not set.\n#![cfg_attr(not(feature = \"export-abi\"), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\nuse stylus_toolkit::tokens::erc20::{Erc20, Erc20Params};\nuse alloy_primitives::U256;\nuse stylus_sdk::{\n    prelude::*,\n    stylus_proc::entrypoint,\n    msg,\n};\n\nstruct MyParams;\nimpl Erc20Params for MyParams {\n    const NAME: &'static str = \"Dummy ERC20 token\";\n    const SYMBOL: &'static str = \"DERC20\";\n    const DECIMALS: u8 = 18;\n}\n\nsol_storage! {\n    #[entrypoint] // Makes Weth the entrypoint\n    struct DummyErc20 {\n        #[borrow] // Allows erc20 to access Dummy Erc20's storage and make calls\n        Erc20<MyParams> erc20;\n    }\n}\n#[external]\n#[inherit(Erc20<MyParams>)]\nimpl DummyErc20 {\n\n    pub fn fund(&mut self, amount: U256) -> Result<(), Vec<u8>> {\n        self.erc20._mint(msg::sender(), amount);\n        Ok(())\n    }\n\n}",
      "src/lib.rs": "// mod erc20_benchmark;\nmod ed25519_verify_benchmark;"
    }
  },
  {
    "stylusVersion": "not found",
    "project": "stylus-create2",
    "link": "https://github.com/rollchad/stylus-create2",
    "files": {
      "Cargo.toml": "[workspace]\n\nresolver = \"2\"\n\nmembers = [\n    \"crates/counter\",\n    \"crates/factory\"\n]\n\n# This must be at the root level otherwise binaries will bloat\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"\n",
      "crates/counter/Cargo.toml": "[package]\nname = \"counter\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nstylus-sdk = \"0.4.3\"\nmini-alloc = \"0.4.2\"\n\n# important- lock to this version\nalloy-sol-types = \"0.3.1\"\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n#debug = [\"stylus-sdk/debug\"]\n\n[lib]\ncrate-type = [\"lib\", \"cdylib\"]\n",
      "crates/counter/src/lib.rs": "//! Implements a hello-world example for Arbitrum Stylus, providing a Solidity ABI-equivalent\n//! Rust implementation of the Counter contract example provided by Foundry.\n//! Warning: this code is a template only and has not been audited.\n//! ```\n//! contract Counter {\n//!     uint256 public number;\n//!     function setNumber(uint256 newNumber) public {\n//!         number = newNumber;\n//!     }\n//!     function increment() public {\n//!         number++;\n//!     }\n//! }\n//! ```\n\n// Only run this as a WASM if the export-abi feature is not set.\n#![cfg_attr(not(feature = \"export-abi\"), no_main)]\nextern crate alloc;\n\n/// Initializes a custom, global allocator for Rust programs compiled to WASM.\n#[global_allocator]\nstatic ALLOC: mini_alloc::MiniAlloc = mini_alloc::MiniAlloc::INIT;\n\n/// Import the Stylus SDK along with alloy primitive types for use in our program.\nuse stylus_sdk::{alloy_primitives::U256, prelude::*};\n\n// Define the entrypoint as a Solidity storage object, in this case a struct\n// called `Counter` with a single uint256 value called `number`. The sol_storage! macro\n// will generate Rust-equivalent structs with all fields mapped to Solidity-equivalent\n// storage slots and types.\nsol_storage! {\n    #[entrypoint]\n    pub struct Counter {\n        uint256 number;\n    }\n}\n\n/// Define an implementation of the generated Counter struct, defining a set_number\n/// and increment method using the features of the Stylus SDK.\n#[external]\nimpl Counter {\n    /// Gets the number from storage.\n    pub fn number(&self) -> Result<U256, Vec<u8>> {\n        Ok(self.number.get())\n    }\n\n    /// Sets a number in storage to a user-specified value.\n    pub fn set_number(&mut self, new_number: U256) -> Result<(), Vec<u8>> {\n        self.number.set(new_number);\n        Ok(())\n    }\n\n    /// Increments number and updates it values in storage.\n    pub fn increment(&mut self) -> Result<(), Vec<u8>> {\n        let number = self.number.get();\n        self.set_number(number + U256::from(1))\n    }\n}\n",
      "crates/factory/Cargo.toml": "[package]\nname = \"factory\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nstylus-sdk = \"0.4.3\"\nmini-alloc = \"0.4.2\"\n\n# important- lock to this version\nalloy-sol-types = \"0.3.1\"\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n#debug = [\"stylus-sdk/debug\"]\n\n[lib]\ncrate-type = [\"lib\", \"cdylib\"]\n",
      "crates/factory/src/lib.rs": "#![cfg_attr(not(feature = \"export-abi\"), no_main)]\nextern crate alloc;\n\n#[global_allocator]\nstatic ALLOC: mini_alloc::MiniAlloc = mini_alloc::MiniAlloc::INIT;\n\nuse stylus_sdk::{alloy_primitives::{tiny_keccak, Address, B256, U256}, contract, deploy::RawDeploy, msg, prelude::*};\n\nsol_storage! {\n    #[entrypoint]\n    pub struct Factory {\n\n    }\n}\n\n#[external]\nimpl Factory {\n    pub fn deploy_with_create2(&mut self) -> Result<(), Vec<u8>> {\n        let init_code = include_bytes!(\"./deployment_tx_data\");\n\n        let salt = B256::default();\n        let endowment = U256::ZERO;\n\n        let expected_address = get_create2_address(contract::address(), salt, init_code);\n        let actual_address = unsafe { RawDeploy::new().salt(salt).deploy(init_code, endowment)? };\n\n        assert_eq!(expected_address, actual_address);\n        Ok(())\n    }\n}\n\nfn keccak256(bytes: &[u8]) -> [u8; 32] {\n    use tiny_keccak::{Hasher, Keccak};\n\n    let mut output = [0u8; 32];\n    let mut hasher = Keccak::v256();\n    hasher.update(bytes);\n    hasher.finalize(&mut output);\n\n    output\n}\n\nfn get_create2_address(from: Address, salt: B256, init_code: &[u8]) -> Address {\n    let init_code_hash = keccak256(init_code);\n\n    let mut bytes = Vec::with_capacity(1 + 20 + salt.len() + init_code_hash.len());\n\n    bytes.push(0xff);\n    bytes.extend_from_slice(from.as_slice());\n    bytes.extend_from_slice(salt.as_slice());\n    bytes.extend_from_slice(init_code_hash.as_slice());\n\n    let hash = keccak256(bytes.as_slice());\n\n    let mut address_bytes = [0u8; 20];\n    address_bytes.copy_from_slice(&hash[12..]);\n\n    let address = Address::from_slice(&address_bytes);\n\n    address\n}\n"
    }
  },
  {
    "stylusVersion": "0.6.0",
    "project": "stylus-auction-example",
    "link": "https://github.com/OffchainLabs/stylus-english-auction",
    "files": {
      "Cargo.toml": "[package]\nname = \"stylus-auction-example\"\nversion = \"0.1.7\"\nedition = \"2021\"\nlicense = \"MIT OR Apache-2.0\"\nkeywords = [\"arbitrum\", \"ethereum\", \"stylus\", \"alloy\"]\n\n[dependencies]\nalloy-primitives = \"=0.7.6\"\nalloy-sol-types = \"=0.7.6\"\nmini-alloc = \"0.4.2\"\nstylus-sdk = \"0.6.0\"\nhex = \"0.4.3\"\n\n[dev-dependencies]\ntokio = { version = \"1.12.0\", features = [\"full\"] }\nethers = \"2.0\"\neyre = \"0.6.8\"\n\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n\n[lib]\ncrate-type = [\"lib\", \"cdylib\"]\n\n[profile.release]\ncodegen-units = 1\nstrip = true\nlto = true\npanic = \"abort\"\nopt-level = \"s\"\n",
      "rust-toolchain.toml": "[toolchain]\nchannel = \"1.80.0\"",
      "src/lib.rs": "// Allow `cargo stylus export-abi` to generate a main function.\n#![cfg_attr(not(feature = \"export-abi\"), no_main)]\nextern crate alloc;\n\nuse std::borrow::BorrowMut;\n\n/// Import items from the SDK. The prelude contains common traits and macros.\nuse stylus_sdk::{alloy_primitives::{Address, U256}, block, call::{transfer_eth, Call}, contract, evm, msg, prelude::*};\nuse alloy_sol_types::sol;\n\n// Import the IERC721 interface.\nsol_interface! {\n    interface IERC721 {\n        // Required methods.\n        function safeTransferFrom(address from, address to, uint256 token_id) external;\n        function transferFrom(address, address, uint256) external;\n    }\n}\n\n// Define the events and errors for the contract.\nsol!{\n    // Define the events for the contract.\n    event Start(); // Start the auction.\n    event Bid(address indexed sender, uint256 amount); // Bid on the auction.\n    event Withdraw(address indexed bidder, uint256 amount); // Withdraw a bid.\n    event End(address winner, uint256 amount); // End the auction.\n\n    // Define the errors for the contract.\n    error AlreadyInitialized(); // The contract has already been initialized.\n    error AlreadyStarted(); // The auction has already started.\n    error NotSeller(); // The sender is not the seller.\n    error AuctionEnded(); // The auction has ended.\n    error BidTooLow(); // The bid is too low.\n    error NotStarted(); // The auction has not started.\n    error NotEnded(); // The auction has not ended.\n}\n\n\n#[derive(SolidityError)]\npub enum EnglishAuctionError {\n    // Define the errors for the contract.\n    AlreadyInitialized(AlreadyInitialized),\n    AlreadyStarted(AlreadyStarted),\n    NotSeller(NotSeller),\n    AuctionEnded(AuctionEnded),\n    BidTooLow(BidTooLow),\n    NotStarted(NotStarted),\n    NotEnded(NotEnded),\n}\n\n// Define some persistent storage using the Solidity ABI.\n// `Counter` will be the entrypoint.\nsol_storage! {\n    #[entrypoint]\n    pub struct EnglishAuction {\n        address nft_address; // The address of the NFT contract.\n        uint256 nft_id; // The ID of the NFT.\n\n        address seller; // The address of the seller.\n        uint256 end_at; // The end time of the auction.\n        bool started; // The auction has started or not.\n        bool ended; // The auction has ended or not.\n\n        address highest_bidder; // The address of the highest bidder.\n        uint256 highest_bid; // The highest bid.\n        mapping(address => uint256) bids; // The bids of the bidders.\n    }\n}\n\n/// Declare that `Counter` is a contract with the following external methods.\n#[public]\nimpl EnglishAuction {\n    pub const ONE_DAY: u64 = 86400; // 1 day = 24 hours * 60 minutes * 60 seconds = 86400 seconds.\n    \n    // Get nft address\n    pub fn nft(&self) -> Result<Address, EnglishAuctionError> {\n        Ok(self.nft_address.get())\n    }\n\n    // Get nft id\n    pub fn nft_id(&self) -> Result<U256, EnglishAuctionError> {\n        Ok(self.nft_id.get())\n    }\n    // Get seller address\n    pub fn seller(&self) -> Result<Address, EnglishAuctionError> {\n        Ok(self.seller.get())\n    }\n\n    // Get end time\n    pub fn end_at(&self) -> Result<U256, EnglishAuctionError> {\n        Ok(self.end_at.get())\n    }\n\n    // Get started status\n    pub fn started(&self) -> Result<bool, EnglishAuctionError> {\n        Ok(self.started.get())\n    }\n\n    // Get ended status\n    pub fn ended(&self) -> Result<bool, EnglishAuctionError> {\n        Ok(self.ended.get())\n    }\n\n    // Get highest bidder address\n    pub fn highest_bidder(&self) -> Result<Address, EnglishAuctionError> {\n        Ok(self.highest_bidder.get())\n    }\n\n    // Get highest bid amount\n    pub fn highest_bid(&self) -> Result<U256, EnglishAuctionError> {\n        Ok(self.highest_bid.get())\n    }\n\n    // Get bid amount of a bidder\n    pub fn bids(&self, bidder: Address) -> Result<U256, EnglishAuctionError> {\n        Ok(self.bids.getter(bidder).get())\n    }\n\n    // Initialize program\n    pub fn initialize(&mut self, nft: Address, nft_id: U256, starting_bid: U256) -> Result<(), EnglishAuctionError> {\n        // Check if the contract has already been initialized.\n        if self.seller.get() != Address::default() {\n            // Return an error if the contract has already been initialized.\n            return Err(EnglishAuctionError::AlreadyInitialized(AlreadyInitialized{}));\n        }\n        \n        // Initialize the contract with the NFT address, the NFT ID, the seller, and the starting bid.\n        self.nft_address.set(nft);\n        self.nft_id.set(nft_id);\n        self.seller.set(msg::sender());\n        self.highest_bid.set(starting_bid);\n        Ok(())\n    }\n\n    pub fn start(&mut self) -> Result<(), EnglishAuctionError> {\n        // Check if the auction has already started.\n        if self.started.get() {\n            return Err(EnglishAuctionError::AlreadyStarted(AlreadyStarted{}));\n        }\n        \n        // Check if the sender is the seller.\n        if self.seller.get() != msg::sender() {\n            // Return an error if the sender is the seller.\n            return Err(EnglishAuctionError::NotSeller(NotSeller{}));\n        }\n        \n        // Create a new instance of the IERC721 interface.\n        let nft = IERC721::new(*self.nft_address);\n        // Get the NFT ID.\n        let nft_id = self.nft_id.get();\n\n        // Transfer the NFT to the contract.\n        let config = Call::new_in(self);\n        let result = nft.transfer_from(config, msg::sender(), contract::address(), nft_id);\n        \n        match result {\n            // If the transfer is successful, start the auction.\n            Ok(_) => {\n                self.started.set(true);\n                // Set the end time of the auction to 7 days from now.\n                self.end_at.set(U256::from(block::timestamp() + 7 * Self::ONE_DAY));\n                // Log the start event.\n                evm::log(Start {});\n                Ok(())\n            },\n            // If the transfer fails, return an error.\n            Err(_) => {\n                return Err(EnglishAuctionError::NotSeller(NotSeller{}));\n            }\n            \n        }\n    }\n\n    // The bid method allows bidders to place a bid on the auction.\n    #[payable]\n    pub fn bid(&mut self) -> Result<(), EnglishAuctionError> {\n        // Check if the auction has started.\n        if !self.started.get() {\n            // Return an error if the auction has not started.\n            return Err(EnglishAuctionError::NotSeller(NotSeller{}));\n        }\n        \n        // Check if the auction has ended.\n        if U256::from(block::timestamp()) >= self.end_at.get() {\n            // Return an error if the auction has ended.\n            return Err(EnglishAuctionError::AuctionEnded(AuctionEnded{}));\n        }\n        \n        // Check if the bid amount is higher than the current highest bid.\n        if msg::value() <= self.highest_bid.get() {\n            // Return an error if the bid amount is too low.\n            return Err(EnglishAuctionError::BidTooLow(BidTooLow{}));\n        }\n        \n        // Refund the previous highest bidder. (But will not transfer back at this call, needs bidders to call withdraw() to get back the fund.\n        if self.highest_bidder.get() != Address::default() {\n            let mut bid = self.bids.setter(self.highest_bidder.get());\n            let current_bid = bid.get();\n            bid.set(current_bid + self.highest_bid.get());\n        }\n        \n        // Update the highest bidder and the highest bid.\n        self.highest_bidder.set(msg::sender());\n        self.highest_bid.set(msg::value());\n\n        // Update the bid of the current bidder.\n        evm::log(Bid {\n            sender: msg::sender(),\n            amount: msg::value(),\n        });\n        Ok(())\n    }\n\n    // The withdraw method allows bidders to withdraw their bid.\n    pub fn withdraw(&mut self) -> Result<(), EnglishAuctionError> {\n        // Get the current bid of the bidder.\n        let mut current_bid = self.bids.setter(msg::sender());\n        let bal = current_bid.get();\n        // Set the record of this bidder to 0 and transfer back tokens.\n        current_bid.set(U256::from(0));\n        let _ = transfer_eth(msg::sender(), bal);\n\n        // Log the withdraw event.\n        evm::log(Withdraw {\n            bidder: msg::sender(),\n            amount: bal,\n        });\n        Ok(())\n    }\n\n    // The end method allows the seller to end the auction.\n    pub fn end<S: TopLevelStorage + BorrowMut<Self>>(storage: &mut S) -> Result<(), EnglishAuctionError> {\n        // Check if the auction has started.\n        if !storage.borrow_mut().started.get() {\n            // Return an error if the auction has not started.\n            return Err(EnglishAuctionError::NotStarted(NotStarted{}));\n        }\n        \n        // Check if the auction has ended.\n        if U256::from(block::timestamp()) < storage.borrow_mut().end_at.get() {\n            // Return an error if the auction has not ended.\n            return Err(EnglishAuctionError::NotEnded(NotEnded{}));\n        }\n        \n        // Check if the auction has already ended.\n        if storage.borrow_mut().ended.get() {\n            // Return an error if the auction has already ended.\n            return Err(EnglishAuctionError::AuctionEnded(AuctionEnded{}));\n        }\n        \n        // End the auction and transfer the NFT and the highest bid to the winner.\n        storage.borrow_mut().ended.set(true);\n        let nft_contract_address = *storage.borrow_mut().nft_address;\n        let seller_address = storage.borrow_mut().seller.get();\n        let highest_bid = storage.borrow_mut().highest_bid.get();\n        let highest_bidder = storage.borrow_mut().highest_bidder.get();\n        let nft_id = storage.borrow_mut().nft_id.get();\n        let config = Call::new_in(storage.borrow_mut());\n        \n        let nft = IERC721::new(nft_contract_address);\n        \n        // Check if there is highest bidder.\n        if highest_bidder != Address::default() {\n            // If there is a highest bidder, transfer the NFT to the highest bidder.\n            let _ = nft.safe_transfer_from(config, contract::address(), highest_bidder, nft_id);\n            // Transfer the highest bid to the seller.\n            let _ = transfer_eth(seller_address, highest_bid);\n        } else {\n            // If there is no highest bidder, transfer the NFT back to the seller.\n            let _ = nft.safe_transfer_from(config, contract::address(), seller_address, nft_id);\n        }\n\n        // Log the end event.\n        evm::log(End {\n            winner: highest_bidder,\n            amount: highest_bid,\n        });\n        Ok(())\n    }\n}",
      "src/main.rs": "#![cfg_attr(not(feature = \"export-abi\"), no_main)]\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    stylus_auction_example::print_abi(\"MIT-OR-APACHE-2.0\", \"pragma solidity ^0.8.23;\");\n}\n"
    }
  }
]